<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IO流之NIO</title>
    <url>/posts/47ee0103/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
</blockquote>
<a id="more"></a>

<h1 id="NIO-简介"><a href="#NIO-简介" class="headerlink" title="NIO 简介"></a>NIO 简介</h1><p>NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。</p>
<p>NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p>
<h1 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h1><h2 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h2><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型:</p>
<ul>
<li>FileChannel: 从文件中读写数据；</li>
<li>DatagramChannel: 通过 UDP 读写网络中数据；</li>
<li>SocketChannel: 通过 TCP 读写网络中数据；</li>
<li>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区包括以下类型:</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h3 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h3><ul>
<li>容量Capacity：<strong>缓冲区能够容纳的数据元素的最大数量</strong>。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)</li>
<li>位置Position: 当前已经读写的字节数；<strong>下一个要被读或写的元素的位置</strong>。Position会自动由相应的 <code>get( )</code>和 <code>put( )</code>函数更新。</li>
<li>上界Limit: 还可以读写的字节数；<strong>缓冲区里的数据的总数</strong>，代表了当前缓冲区中一共有多少数据。</li>
<li>标记Mark：一个备忘位置。<strong>用于记录上一次读写的位置</strong>。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib00xmyDOO5dgS04fnMtGicQx2PBicyCHBys3VYmichRh8SKX7DwOqs9UnhTbIfTT0a0e215shnr6m6uA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>状态变量的改变过程举例:</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p><img src="https://www.pdai.tech/_images/pics/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="image"></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。</p>
<p><img src="https://www.pdai.tech/_images/pics/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="image"></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p><img src="https://www.pdai.tech/_images/pics/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="image"></p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p><img src="https://www.pdai.tech/_images/pics/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="image"></p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p><img src="https://www.pdai.tech/_images/pics/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="image"></p>
<h2 id="文件-NIO-实例"><a href="#文件-NIO-实例" class="headerlink" title="文件 NIO 实例"></a>文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    FileInputStream fin = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    FileChannel fcin = fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的通道 */</span></span><br><span class="line">    FileChannel fcout = fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="keyword">int</span> r = fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。</p>
<p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<p><img src="https://www.pdai.tech/_images/pics/4d930e22-f493-49ae-8dff-ea21cd6895dc.png" alt="image"></p>
<h2 id="创建选择器"><a href="#创建选择器" class="headerlink" title="创建选择器"></a>创建选择器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<h2 id="将通道注册到选择器上"><a href="#将通道注册到选择器上" class="headerlink" title="将通道注册到选择器上"></a>将通道注册到选择器上</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类:</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure>
<p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h2 id="获取到达的事件"><a href="#获取到达的事件" class="headerlink" title="获取到达的事件"></a>获取到达的事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h1><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<h1 id="NIO的特性-NIO与IO区别"><a href="#NIO的特性-NIO与IO区别" class="headerlink" title="NIO的特性/NIO与IO区别"></a>NIO的特性/NIO与IO区别</h1><p>如果是在面试中回答这个问题，我觉得首先肯定要从 NIO 流是非阻塞 IO 而 IO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件/特性为 NIO 带来的一些改进来分析。如果，你把这些都回答上了我觉得你对于 NIO 就有了更为深入一点的认识，面试官问到你这个问题，你也能很轻松的回答上来了。</p>
<h3 id="1-Non-blocking-IO（非阻塞IO）"><a href="#1-Non-blocking-IO（非阻塞IO）" class="headerlink" title="1)Non-blocking IO（非阻塞IO）"></a>1)Non-blocking IO（非阻塞IO）</h3><p><strong>IO流是阻塞的，NIO流是不阻塞的。</strong></p>
<p>Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用 <code>read()</code> 或 <code>write()</code> 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了</p>
<h3 id="2-Buffer-缓冲区"><a href="#2-Buffer-缓冲区" class="headerlink" title="2)Buffer(缓冲区)"></a>2)Buffer(缓冲区)</h3><p><strong>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</strong></p>
<p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p>
<p>在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
<p>最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</p>
<h3 id="3-Channel-通道"><a href="#3-Channel-通道" class="headerlink" title="3)Channel (通道)"></a>3)Channel (通道)</h3><p>NIO 通过Channel（通道） 进行读写。</p>
<p>通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</p>
<h3 id="4-Selector-选择器"><a href="#4-Selector-选择器" class="headerlink" title="4)Selector (选择器)"></a>4)Selector (选择器)</h3><p>NIO有选择器，而IO没有。</p>
<p>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Slector.png" alt="一个单线程中Selector维护3个Channel的示意图"></p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流之IO模型</title>
    <url>/posts/fd7df785/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>本文主要简要介绍 Unix I/O 5种模型，并对5大模型比较</p>
</blockquote>
<a id="more"></a>

<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>UNIX系统将所有的外部设备都看作一个文件来看待，所有打开的文件都通过文件描述符来引用。文件描述符是一个非负整数，它指向内核中的一个结构体。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。而对于一个socket的读写也会有相应的文件描述符，称为socketfd（socket描述符）。<br>在UNIX系统中，I/O输入操作（例如标准输入或者套接字的输入）通常包含以下两个不同的阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>例如对于套接字的输入，第一步是等待数据从网络中到达，当所等待的数据到达时，数据被复制到内核中的缓冲区。第二步则是把数据从内核缓冲区复制到应用进程的缓冲区。<br>根据在这两个不同阶段处理的不同，可以将I/O模型划分为以下五种类型：</p>
<ul>
<li>阻塞式I/O模型</li>
<li>非阻塞式I/O模型</li>
<li>I/O复用</li>
<li>信号驱动式I/O</li>
<li>异步I/O</li>
</ul>
<h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><p>为简单起见，我们以UDP套接字中的recvfrom函数作为系统调用来说明I/O模型。recvfrom函数类似于标准的read函数，它的作用是从指定的套接字中读取数据报。recvfrom会从应用进程空间运行切换到内核空间中运行，一段时间后会再切换回来。</p>
<h2 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h2><p>阻塞式I/O模型可以说是最简单的I/O模型。</p>
<blockquote>
<p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20160609135646100" alt="阻塞式I/O模型"></p>
<p>上图是阻塞式I/O模型的示意图，阅读此图须注意箭头的方向，沿着剪头方向顺时针阅读。<br>在图中应用进程调用recvfrom，然后切换到内核空间中运行，直到数据报到达且被复制到应用进程缓冲区中才返回。我们说进程从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。</p>
<h2 id="非阻塞式I-O模型"><a href="#非阻塞式I-O模型" class="headerlink" title="非阻塞式I/O模型"></a>非阻塞式I/O模型</h2><p>进程把一个套接字设置为非阻塞是指，在等待I/O数据时，进程并不阻塞，如果数据还没准备好，则直接返回一个错误。</p>
<p><img src="https://img-blog.csdn.net/20160609135720523" alt="非阻塞式I/O模型"></p>
<p>非阻塞I/O模型的示图。<br>在前两次调用recvfrom时由于数据报没准备好，因此内核马上返回一个系统调用错误。第3次调用recvfrom时，数据报已准备好，数据报被复制到应用进程的缓冲区，接着recvfrom成功返回。<br>当一个应用进程像这样不断对一个非阻塞描述符循环调用recvfrom时，我们称之为轮询。应用进程会持续轮询内核，以确定某个操作是否就绪。轮询操作会消耗大量的CPU时间。</p>
<h2 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h2><p>我们常用的select和poll函数使用了I/O复用模型。我们以select为例说明I/O复用模型的特点。</p>
<p><img src="https://img-blog.csdn.net/20160609135743772" alt="I/O复用模型"><br>I/O复用模型<br>当我们调用select函数时，将会阻塞于此函数，等待数据报套接字变为可读。当等待的多个套接字中的其中一个或者多个变得可读时，我们调用recvfrom把数据报复制到应用进程缓冲区。</p>
<p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。    </p>
<h2 id="信号驱动式I-O模型"><a href="#信号驱动式I-O模型" class="headerlink" title="信号驱动式I/O模型"></a>信号驱动式I/O模型</h2><p>信号驱动I/O模型用得比较少</p>
<p><img src="https://img-blog.csdn.net/20160609135826601" alt="信号驱动式I/O模型"><br>信号驱动式I/O模型</p>
<p>为了使用该I/O模型，需要开启套接字的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。sigaction函数立即返回，我们的进程继续工作，即进程没有被阻塞。当数据报准备好时，内核会为该进程产生一个SIGIO信号，这样我们可以在信号处理函数中调用recvfrom读取数据报，也可以在主循环中读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间不被阻塞。</p>
<h2 id="2-5-异步I-O模型"><a href="#2-5-异步I-O模型" class="headerlink" title="2.5 异步I/O模型"></a>2.5 异步I/O模型</h2><p>异步I/O模型的工作机制是，启动某个操作，并让内核在整个操作（包括等待数据和将数据从内核复制到用户空间）完成后通知应用进程。</p>
<p><img src="https://img-blog.csdn.net/20160609135848507" alt="异步I/O模型"><br>异步I/O模型</p>
<p>我们调用aio_read函数，告诉内核，当整个I/O操作完成后通知我们。该系统调用立即返回，而在等待I/O完成期间，应用进程不会被阻塞。当I/O完成（包括数据从内样复制到用户进程）后，内核会产生一个信号通知应用进程，应用进程对数据报进行处理。<br>异步I/O模型与信号驱动式I/O的区别在于：信号驱动式I/O在数据报准备好时就通知应用进程，应用进程还需要将数据报从内核复制到用户进程缓冲区；而异步I/O模型则是整个操作完成才通知应用进程，应用进程在整个操作期间都不会被阻塞。</p>
<h2 id="各种I-O模型的比较"><a href="#各种I-O模型的比较" class="headerlink" title="各种I/O模型的比较"></a>各种I/O模型的比较</h2><p><img src="https://img-blog.csdn.net/20161021075133062" alt="这里写图片描述"><br>5种I/O模型的比较</p>
<p>从图中可以看到，前四种I/O模型的主要区别在于第一个阶段，它们的第二个阶段是一样的：在数据从内核复制到应用进程的缓冲区期间，进程会被阻塞于recvfrom系统调用。<br>而异步I/O模型则是整个操作完成内核才通知应用进程。</p>
<h1 id="同步I-O和异步I-O"><a href="#同步I-O和异步I-O" class="headerlink" title="同步I/O和异步I/O"></a>同步I/O和异步I/O</h1><p>POSIX标准将同步I/O和异步I/O定义为：</p>
<ul>
<li>同步I/O操作：导致请求进程阻塞，直到I/O操作完成。</li>
<li>异步I/O操作：不导致请求进程阻塞。</li>
</ul>
<p>根据上述两个定义，本文介绍的前面四种模型，包括阻塞式I/O，非阻塞式I/O，I/O复用和信号驱动式I/O模型都是同步I/O模型，因为其中真正的I/O操作（recvfrom）将阻塞进程。只有异步I/O模型才符合POSIX标准的异步I/O定义。</p>
<blockquote>
<p>When you execute something synchronously, you wait for it to finish before moving on to another task. When you execute something asynchronously, you can move on to another task before it finishes.</p>
<p>当你同步执行某项任务时，你需要等待其完成才能继续执行其他任务。当你异步执行某些操作时，你可以在完成另一个任务之前继续进行。</p>
</blockquote>
<ul>
<li><strong>同步</strong> ：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在<code>A-&gt;B</code>事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用中被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</li>
<li><strong>异步</strong>： 两个异步的任务是完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用中一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，</li>
</ul>
<p><strong>阻塞和非阻塞</strong></p>
<ul>
<li><strong>阻塞：</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li><strong>非阻塞：</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<p><strong>如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？</strong></p>
<p>同步/异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。</p>
<h1 id="生活中的类比例子"><a href="#生活中的类比例子" class="headerlink" title="生活中的类比例子"></a>生活中的类比例子</h1><p>以生活中钓鱼为例子（例子参考了参考资料2），来说明各种I/O模型的不同，例子中的等待鱼上钩对应于上文中的等待数据，拉竿操则作对应于上文的将数据从内核复制到用户空间。</p>
<p>有A，B，C，D，E五个人在钓鱼。<br>A使用了最古老的鱼竿，所以开始钓鱼后，就一直守着，直接鱼上钩了再拉竿；<br>B由于着急想知道有没鱼上钩，所以隔一会就看一次鱼竿看有没鱼上钩，直到看到鱼上钩后，再拉竿；<br>C同时使用了N支鱼竿来钩鱼，然后等着，只要有其中一支鱼竿有鱼上钩，就将对应的鱼竿拉起来；<br>D的鱼竿比较高级，当有鱼上钩后，会发出警报提示，所以D开始钓鱼后不用一直守着，一旦鱼竿发出警报，D再回来拉竿即可；<br>E为了更省事，直接雇个佣人给他钓鱼，当佣人钓起鱼后，再通知E去取鱼即可。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC锁之ReentrantLock</title>
    <url>/posts/2c2753cf/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>ReentrantLock锁的源码详解</p>
</blockquote>
<a id="more"></a>

<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><blockquote>
<p>ReentrantLock是一个可重用的互斥锁，又被称为独占锁，顾名思义，ReentrantLock在同一时间只能被一个线程拥有，单个线程可以多次获取。</p>
</blockquote>
<p>ReentrantLock实现了Lock接口，里面有三个静态内部类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该锁同步控制的一个基类.下边有两个子类：非公平机制和公平机制.使用了AbstractQueuedSynchronizer类的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//非公平锁同步器</span></span><br><span class="line"><span class="class"><span class="title">final</span> <span class="title">static</span> <span class="title">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//公平锁同步器</span></span><br><span class="line"><span class="class"><span class="title">final</span> <span class="title">static</span> <span class="title">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span>  </span></span><br></pre></td></tr></table></figure>
<p>ReentranLock与Sync是组合关系。ReentranLock中包含了Sync对象，Sync是AQS的子类，他下面有两个子类FairSync（公平锁）和NonFairSync（非公平锁）。ReentranLock是一个独占锁，然后是否公平是取决于sync对象是“FairSync的实例”还是“NonFairSync的实例”</p>
<h1 id="ReentranLock的构造方法："><a href="#ReentranLock的构造方法：" class="headerlink" title="ReentranLock的构造方法："></a>ReentranLock的构造方法：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 同步器：内部类Sync的一个引用 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair true--&gt;公平锁  false--&gt;非公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中创建写法</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<p>ReentranLock有公平锁和非公平锁两种构造方式，默认实现的是非公平锁</p>
<h1 id="ReentantLock的FairSync的lock方法："><a href="#ReentantLock的FairSync的lock方法：" class="headerlink" title="ReentantLock的FairSync的lock方法："></a>ReentantLock的FairSync的lock方法：</h1><p>ReetantLock调用的lock方法调用了他的组件Sync的lock方法，先看一下FairSync的lock方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lock()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//acquire() acquire是在AQS实现的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RenntrantLock公平锁的lock方法就是调用了一下AQS的acquire方法，因为acquireQueued、addWaiter方法以及流程子啊AQS原理里已经详细介绍过了，这里只需要研究一下ReentrantLock重写的tryAcquire方法就行了</p>
<h2 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取“当前线程”</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取“独占锁”的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// c=0意味着“锁没有被任何线程锁拥有”，</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若“锁没有被任何线程锁拥有”，</span></span><br><span class="line">        <span class="comment">// 则判断“当前线程”是不是CLH队列中的第一个线程线程，</span></span><br><span class="line">        <span class="comment">// 若是的话，则获取该锁，设置锁的状态，并切设置锁的拥有者为“当前线程”。</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 如果“独占锁”的拥有者已经为“当前线程”，</span></span><br><span class="line">        <span class="comment">// 则将更新锁的状态。</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下流程：</p>
<ol>
<li>首先获取当先线程，然后获取独占锁的状态；</li>
<li>如果独占锁没有被占用（Stat=0），判断当前线程是否是等待队列里的第一个<ol>
<li>若是，获取锁，更新锁的状态，并设置锁的拥有者为当前线程，返回true</li>
<li>若不是，返回false</li>
</ol>
</li>
<li>如果独占锁已被占用，则观察独占锁的拥有者是否是当前线程<ol>
<li>若是，更新独占锁的状态</li>
<li>若不是，返回false</li>
</ol>
</li>
</ol>
<h1 id="ReentantLock的NonfairSync的lock方法："><a href="#ReentantLock的NonfairSync的lock方法：" class="headerlink" title="ReentantLock的NonfairSync的lock方法："></a>ReentantLock的NonfairSync的lock方法：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="释放锁Unlock"><a href="#释放锁Unlock" class="headerlink" title="释放锁Unlock"></a>释放锁Unlock</h1><p>unlock()在ReentrantLock.java中实现的，而公平锁和非公平锁没有重写unlock方法，这说明释放锁的方法一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c是本次释放锁之后的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果“当前线程”不是“锁的持有者”，则抛出异常！</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果“锁”已经被当前线程彻底释放，则设置“锁”的持有者为null，即锁是可获取状态。</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前线程的锁的状态。</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryRelease()的作用是尝试释放锁。(01) 如果“当前线程”不是“锁的持有者”，则抛出异常。(02) 如果“当前线程”在本次释放锁操作之后，对锁的拥有状态是0(即，当前线程彻底释放该“锁”)，则设置“锁”的持有者为null，即锁是可获取状态。同时，更新当前线程的锁的状态为0。</p>
<p><strong>unparkSuccessor()：</strong>在release()中“当前线程”释放锁成功的话，会唤醒当前线程的后继线程。根据CLH队列的FIFO规则，“当前线程”(即已经获取锁的线程)肯定是head；如果CLH队列非空的话，则唤醒锁的下一个等待线程。unparkSuccessor()的作用是“唤醒当前线程的后继线程”。后继线程被唤醒之后，就可以获取该锁并恢复运行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果状态&lt;0，则设置状态=0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前节点的“有效的后继节点”，无效的话，则通过for循环进行获取。</span></span><br><span class="line">    <span class="comment">// 这里的有效，是指“后继节点对应的线程状态&lt;=0”</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒“后继节点对应的线程”</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结：公平锁和非公平锁只有两处不同："><a href="#总结：公平锁和非公平锁只有两处不同：" class="headerlink" title="总结：公平锁和非公平锁只有两处不同："></a>总结：公平锁和非公平锁只有两处不同：</h1><ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
]]></content>
      <categories>
        <category>并发</category>
        <category>Lock</category>
      </categories>
      <tags>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之BigDecimal</title>
    <url>/posts/5c7898df/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p>
<p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p>
</blockquote>
<a id="more"></a>

<h1 id="BigDecimal-的用处"><a href="#BigDecimal-的用处" class="headerlink" title="BigDecimal 的用处"></a>BigDecimal 的用处</h1><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// falseCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>
<p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b); </span><br><span class="line">BigDecimal y = b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<h2 id="BigDecimal-的大小比较"><a href="#BigDecimal-的大小比较" class="headerlink" title="BigDecimal 的大小比较"></a>BigDecimal 的大小比较</h2><p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1表示 <code>a</code> 大于 <code>b</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>
<h2 id="BigDecimal-保留几位小数"><a href="#BigDecimal-保留几位小数" class="headerlink" title="BigDecimal 保留几位小数"></a>BigDecimal 保留几位小数</h2><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line">BigDecimal n = m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.255Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>
<h2 id="BigDecimal-的使用注意事项"><a href="#BigDecimal-的使用注意事项" class="headerlink" title="BigDecimal 的使用注意事项"></a>BigDecimal 的使用注意事项</h2><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/BigDecimal.png" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p>
<p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p>
<h1 id="基本数据类型与包装数据类型的使用标准"><a href="#基本数据类型与包装数据类型的使用标准" class="headerlink" title="基本数据类型与包装数据类型的使用标准"></a>基本数据类型与包装数据类型的使用标准</h1><p>Reference:《阿里巴巴Java开发手册》</p>
<ul>
<li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li>
<li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li>
<li>【推荐】所有的局部变量使用基本数据类型。</li>
</ul>
<p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.</p>
<p><strong>说明</strong> :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p>
<p><strong>正例</strong> : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p>
<p><strong>反例</strong> : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>BigDecimal</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发之锁</title>
    <url>/posts/4b9d9636/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>锁的一些理论基础知识</p>
</blockquote>
<a id="more"></a>

<h1 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h1><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度，在java和数据库中都有此概念的应用。</p>
<p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，<strong>java中，synchronized关键字和Lock的实现类都是悲观锁</strong>。</p>
<p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<strong>乐观锁在java中是通过使用无锁编程来实现，最常采用的是CAS算法，java原子类中的递增操作就是通过CAS自旋实现的</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1588698615668-9d2636ab-2263-4b34-8407-764e42485ce9.png" alt="20181122101819836.png"></p>
<p>根据上面的概念描述我们可以发现：</p>
<p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确；</p>
<p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升；</p>
<p>调用示例：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1588698801224-08c2febe-0738-41ab-adf9-d1cb8d119734.png" alt="image.png"></p>
<h2 id="自旋锁与适应性自旋锁"><a href="#自旋锁与适应性自旋锁" class="headerlink" title="自旋锁与适应性自旋锁"></a>自旋锁与适应性自旋锁</h2><p>阻塞或唤醒一个java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复线程的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程会不会很快释放。</p>
<p>为了让当前线程“稍等一下”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1588753264244-cb217682-f03b-486c-9bf6-e89f8517f700.png" alt="image.png"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p><strong>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功**</strong>。**</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1588767466949-c19662f6-63a2-4b57-89cc-84830edbb380.png" alt="image.png"></p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>在自旋锁中，另有三种常见的锁形式：TicketLock、CLHlock和MCSlock，这里就不具体介绍了。</p>
<h2 id="无锁、偏向锁、轻量级锁、重量级锁"><a href="#无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁、重量级锁"></a>无锁、偏向锁、轻量级锁、重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的，在synchronized原理里已经详细介绍了，这里不再赘述</p>
<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>根据锁的获取机制，可以将锁分成公平锁和非公平锁。</p>
<p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<h2 id="可重入锁与非可重入锁"><a href="#可重入锁与非可重入锁" class="headerlink" title="可重入锁与非可重入锁"></a>可重入锁与非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>
<p>​    <img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1588779746666-9121acb9-6fdf-4e83-89ee-e0ae56d00f91.png" alt="image.png"></p>
<p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p>
<p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<h2 id="独享锁与共享锁"><a href="#独享锁与共享锁" class="headerlink" title="独享锁与共享锁"></a>独享锁与共享锁</h2><p>独享锁和共享锁同样是一种概念。独享锁也叫排他锁或者互斥锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><p>Java在java.util.concurrent.locks包中提供了一系列的显示锁类，其中最基础的就是Lock接口，该接口提供了几个常见的锁相关的操作。</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果当前线程未被中断，则获取锁。如果锁可用，则获取锁，并立即返回。与lock（）接口唯一的区别是可以被中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//试图获取锁，若锁可用，则获取锁，并立即返回值true。若锁不可用，则此方法将立即返回值false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//与上个方法不同的就是给定了超时时间，若锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回绑定到此 Lock 实例的新 Condition 实例</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><p>通常使用显示锁Lock时，会采用下面的操作流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...需要保证线程安全的代码。</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lock的lock()方法保证了只有一个线程能够执有此锁。对于任何一个lock()方法，都需要一个unlock()方法与之对应，通常情况下为了保证unlock()方法总是能够执行，unlock()方法被置于finally中。</p>
<h2 id="Synchroynized和Lock的区别"><a href="#Synchroynized和Lock的区别" class="headerlink" title="Synchroynized和Lock的区别"></a>Synchroynized和Lock的区别</h2><p>Synchronized是Java的关键字，当它用来修饰一个方法或一个代码块时，能够保证在同一时刻最多只有一个线程执行该代码。因为当调用Synchronized修饰的代码时，并不需要显示的加锁和解锁的过程，代码简洁，一般称之为隐式锁。</p>
<p>Lock是一个接口，提供了无条件的、可轮询的、定时的、可中断的锁获取操作，所有的加锁和解锁操作方法都是显示的，因而称为显示锁。</p>
<h1 id="Condition实现"><a href="#Condition实现" class="headerlink" title="Condition实现"></a>Condition实现</h1><blockquote>
<p>JDK的Object对象提供了wait/notify的机制，也能实现消息的等待与通知，Condition与之的差别主要体现在以下几点：</p>
<ul>
<li>调用wait方法的线程首先必须是已经进入了同步代码块，即已经获取了监视器锁；与之类似，调用await方法的线程首先必须获得lock锁。</li>
<li>调用wait方法的线程会释放已经获得的监视器锁，进入当前监视器锁的等待队列（wait set）中；与之类似，调用await方法的线程会释放已经获得的lock锁，进入到当前Condtion对应的条件队列中。</li>
<li>调用监视器锁的notify方法会唤醒等待在该监视器锁上的线程，这些线程将开始参与锁竞争，并在获得锁后，从wait方法处恢复执行；与之类似，调用Condtion的signal方法会唤醒对应的条件队列中的线程，这些线程将开始参与锁竞争，并在获得锁后，从await方法处开始恢复执行。</li>
</ul>
</blockquote>
<p>在AQS的Condition实现中，和独占锁的争夺类似的是，每创建一个Condtion对象就会对应一个Condtion队列，每一个调用了Condtion对象的await方法的线程都会被包装成Node扔进一个条件队列中，就像这样：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/13/16efec71b11f89ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Picture2.png"></p>
<p>同样的，在Condition中也会用到之前介绍的同步队列，当等待队列中的节点获得信号通知时，会将等待队列的节点移到同步队列。</p>
<p>以下是await时节点的变化，</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/13/16efec72514288d9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="await.png"></p>
<p>以下是signal信号发出时节点的变化，</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/13/16efec725324221d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="signal.png"></p>
<p>Condition的整个await/signal流程如下：</p>
<p>1、Condition提供了await()方法将当前线程阻塞，并提供signal()方法支持另外一个线程将已经阻塞的线程唤醒。 2、Condition需要结合Lock使用 3、线程调用await()方法前必须获取锁，调用await()方法时，将线程构造成节点加入等待队列，同时释放锁，并挂起当前线程 4、其他线程调用signal()方法前也必须获取锁，当执行signal()方法时将等待队列的节点移入到同步队列，当线程退出临界区释放锁的时候，唤醒同步队列的首个节点</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/13/16efec72516ee019?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="5507455-37635d0723174712.png"></p>
<p>下面结合源代码进行分析：</p>
<p><strong>await实现</strong></p>
<p>调用await阻塞当前线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">//将当前线程封装成Node加入到等待队列尾部</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//判断当前节点是否已经在同步队列中，如果是则退出循环，如果不是就阻塞当前线程</span></span><br><span class="line">        <span class="comment">//其他线程如果发出了signal信号之后，会把等待队列的线程移入同步队列，此时就会退出循环，进入下面的重新获取锁的acquireQueued</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他发出signal信号的线程释放锁之后，该线程被唤醒并重新竞争锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程加入等待队列尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = lastWaiter;</span><br><span class="line">        <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">		<span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<span class="comment">//清除cancell态的节点</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">			t = lastWaiter;<span class="comment">//t指向最后一个状态正确的节点</span></span><br><span class="line">	&#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)<span class="comment">//列表为空，初始化为第一个节点</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>signal/signalAll实现</strong></p>
<p>将等待队列的节点移入同步队列(signalAll只是循环执行signal而已)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;<span class="comment">//得到firstWaiter</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将节点从等待队列移入同步队列</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//cas节点状态错误，说明已经cancell了，直接返回false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">         * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">	Node p = enq(node);<span class="comment">//加入同步队列</span></span><br><span class="line">	<span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">	<span class="comment">//设置前置节点状态为signal，可重入锁那篇文章分析过，为了唤醒线程而设置</span></span><br><span class="line">	<span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">		LockSupport.unpark(node.thread);<span class="comment">//特殊情况下唤醒线程并重新同步，一般情况下这里不会执行</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
        <category>Lock</category>
      </categories>
      <tags>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>并发关键字之final</title>
    <url>/posts/c001bbc9/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>final关键字的深入理解</p>
</blockquote>
<a id="more"></a>

<h1 id="final基础使用"><a href="#final基础使用" class="headerlink" title="final基础使用"></a>final基础使用</h1><h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p>
<p>注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。</p>
<blockquote>
<p>这里顺道说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做? @pdai</p>
</blockquote>
<p>设计模式中最重要的两种关系，一种是继承/实现；另外一种是组合关系。所以当遇到不能用继承的(final修饰的类),应该考虑用组合, 如下代码大概写个组合实现的意思：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...init &amp; other methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持老的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString.length(); <span class="comment">// 通过innerString调用老的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toMyString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><blockquote>
<p>常规的使用就不说了，这里说下:</p>
</blockquote>
<ul>
<li>private 方法是隐式的final</li>
<li>final方法是可以被重载的</li>
</ul>
<h3 id="private-final"><a href="#private-final" class="headerlink" title="private final"></a>private final</h3><p>类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处。看下下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        Base father = son;</span><br><span class="line">        <span class="comment">//father.test();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Base和Son都有方法test(),但是这并不是一种覆盖，因为private所修饰的方法是隐式的final，也就是无法被继承，所以更不用说是覆盖了，在Son中的test()方法不过是属于Son的新成员罢了，Son进行向上转型得到father，但是father.test()是不可执行的，因为Base中的test方法是private的，无法被访问到。</p>
<h3 id="final方法是可以被重载的"><a href="#final方法是可以被重载的" class="headerlink" title="final方法是可以被重载的"></a>final方法是可以被重载的</h3><p>我们知道父类的final方法是不能够被子类重写的，那么final方法可以被重载吗? 答案是可以的，下面代码是正确的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExampleParent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h2><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p>
<h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><blockquote>
<p>常规的用法比较简单，这里通过下面三个问题进一步说明。</p>
</blockquote>
<h3 id="所有的final修饰的字段都是编译期常量吗"><a href="#所有的final修饰的字段都是编译期常量吗" class="headerlink" title="所有的final修饰的字段都是编译期常量吗?"></a>所有的final修饰的字段都是编译期常量吗?</h3><p>现在来看编译期常量和非编译期常量, 如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> J = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//非编译期常量</span></span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> k = r.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。</p>
<h3 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h3><p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> k = r.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> k2 = r.nextInt(<span class="number">10</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t1.k+<span class="string">&quot; k2=&quot;</span>+t1.k2);</span><br><span class="line">        Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t2.k+<span class="string">&quot; k2=&quot;</span>+t2.k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码某次输出结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">k=2 k2=7</span><br><span class="line">k=8 k2=7</span><br></pre></td></tr></table></figure>
<p>我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢? 因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。</p>
<h3 id="blank-final"><a href="#blank-final" class="headerlink" title="blank final"></a>blank final</h3><p>Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p>
<ul>
<li>在定义处进行赋值(这不叫空白final)</li>
<li>在构造器中进行赋值，保证了该值在被使用前赋值。</li>
</ul>
<p>这增强了final的灵活性。</p>
<p>看下面代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i2;<span class="comment">//空白final</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i2 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到i2的赋值更为灵活。但是请注意，如果字段由static和final修饰，仅能在定义处赋值，因为该字段不属于对象，属于这个类。</p>
<h1 id="final域重排序规则"><a href="#final域重排序规则" class="headerlink" title="final域重排序规则"></a>final域重排序规则</h1><p>上面我们聊的final使用，应该属于Java基础层面的，当理解这些后我们就真的算是掌握了final吗? 有考虑过final在多线程并发的情况吗? 在java内存模型中我们知道java内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说针对底层来说java内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下,final会进行怎样的重排序? 会导致线程安全的问题吗? 下面，就来看看final的重排序。</p>
<h2 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h2><p>先看一段示例性的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;  <span class="comment">//普通域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b; <span class="comment">//final域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FinalDemo finalDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1. 写普通域</span></span><br><span class="line">        b = <span class="number">2</span>; <span class="comment">// 2. 写final域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finalDemo = <span class="keyword">new</span> FinalDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FinalDemo demo = finalDemo; <span class="comment">// 3.读对象引用</span></span><br><span class="line">        <span class="keyword">int</span> a = demo.a;    <span class="comment">//4.读普通域</span></span><br><span class="line">        <span class="keyword">int</span> b = demo.b;    <span class="comment">//5.读final域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>假设线程A在执行writer()方法，线程B执行reader()方法。</p>
<h3 id="写final域重排序规则"><a href="#写final域重排序规则" class="headerlink" title="写final域重排序规则"></a>写final域重排序规则</h3><p>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外；</li>
<li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障(关于内存屏障可以看这篇文章)。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
<p>我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：</p>
<ul>
<li>构造了一个FinalDemo对象；</li>
<li>把这个对象赋值给成员变量finalDemo。</li>
</ul>
<p>我们来画下存在的一种可能执行时序图，如下：</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-key-final-1.png" alt="img"></p>
<p>由于a,b之间没有数据依赖性，普通域(普通变量)a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值(零值)，这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。</p>
<p>因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo。</p>
<h3 id="读final域重排序规则"><a href="#读final域重排序规则" class="headerlink" title="读final域重排序规则"></a>读final域重排序规则</h3><p>读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p>
<p>read()方法主要包含了三个操作：</p>
<ul>
<li>初次读引用变量finalDemo;</li>
<li>初次读引用变量finalDemo的普通域a;</li>
<li>初次读引用变量finalDemo的final与b;</li>
</ul>
<p>假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图：</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-key-final-2.png" alt="img"></p>
<p>读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。</p>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。</p>
<h2 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h2><p>我们已经知道了final域是基本数据类型的时候重排序规则是怎么的了? 如果是引用数据类型了? 我们接着继续来探讨。</p>
<h3 id="对final修饰的对象的成员域写操作"><a href="#对final修饰的对象的成员域写操作" class="headerlink" title="对final修饰的对象的成员域写操作"></a>对final修饰的对象的成员域写操作</h3><p>针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] arrays;</span><br><span class="line">    <span class="keyword">private</span> FinalReferenceDemo finalReferenceDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrays = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];  <span class="comment">//1</span></span><br><span class="line">        arrays[<span class="number">0</span>] = <span class="number">1</span>;        <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finalReferenceDemo = <span class="keyword">new</span> FinalReferenceDemo(); <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrays[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (finalReferenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//5</span></span><br><span class="line">            <span class="keyword">int</span> temp = finalReferenceDemo.arrays[<span class="number">0</span>];  <span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论(耐心看完才有收获)。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-key-final-3.png" alt="img"></p>
<p>由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。</p>
<h3 id="对final修饰的对象的成员域读操作"><a href="#对final修饰的对象的成员域读操作" class="headerlink" title="对final修饰的对象的成员域读操作"></a>对final修饰的对象的成员域读操作</h3><p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p>
<h2 id="关于final重排序的总结"><a href="#关于final重排序的总结" class="headerlink" title="关于final重排序的总结"></a>关于final重排序的总结</h2><p>按照final修饰的数据类型分类：</p>
<ul>
<li>基本数据类型:<ul>
<li><code>final域写</code>：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li>
<li>final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。</li>
</ul>
</li>
<li>引用数据类型：<ul>
<li>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li>
</ul>
</li>
</ul>
<h1 id="final再深入理解"><a href="#final再深入理解" class="headerlink" title="final再深入理解"></a>final再深入理解</h1><h2 id="final的实现原理"><a href="#final的实现原理" class="headerlink" title="final的实现原理"></a>final的实现原理</h2><p>上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p>
<p>很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，以X86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器</p>
<h2 id="为什么final引用不能从构造函数中“溢出”"><a href="#为什么final引用不能从构造函数中“溢出”" class="headerlink" title="为什么final引用不能从构造函数中“溢出”"></a>为什么final引用不能从构造函数中“溢出”</h2><p>这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“逸出”。以下面的例子来说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> FinalReferenceEscapeDemo referenceDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;  <span class="comment">//1</span></span><br><span class="line">        referenceDemo = <span class="keyword">this</span>; <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (referenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> temp = referenceDemo.a; <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>可能的执行时序如图所示：</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-key-final-4.png" alt="img"></p>
<p>假设一个线程A执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referenceDemo是个没有完全初始化的对象，而当线程B去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。</p>
<h2 id="使用-final-的限制条件和局限性"><a href="#使用-final-的限制条件和局限性" class="headerlink" title="使用 final 的限制条件和局限性"></a>使用 final 的限制条件和局限性</h2><p>当声明一个 final 成员时，必须在构造函数退出前设置它的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> myField = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> myField;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    myField = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将指向对象的成员声明为 final 只能将该引用设为不可变的，而非所指的对象。</p>
<p>下面的方法仍然可以修改该 list。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List myList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">myList.add(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>声明为 final 可以保证如下操作不合法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">myList = someOtherList;    </span><br></pre></td></tr></table></figure>
<p>如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 final，则必须提供其他方式保证线程安全。</p>
<p>“ 其他方式 “ 可以包括声明成员为 volatile，使用 synchronized 或者显式 Lock 控制所有该成员的访问。</p>
<h2 id="再思考一个有趣的现象："><a href="#再思考一个有趣的现象：" class="headerlink" title="再思考一个有趣的现象："></a>再思考一个有趣的现象：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b2=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b3=b1+b2;<span class="comment">//当程序执行到这一行的时候会出错，因为b1、b2可以自动转换成int类型的变量，运算时java虚拟机对它进行了转换，结果导致把一个int赋值给byte-----出错 </span></span><br></pre></td></tr></table></figure>
<p>如果对b1 b2加上final就不会出错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b2=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b3=b1+b2;<span class="comment">//不会出错，相信你看了上面的解释就知道原因了。  </span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器之BlockingQueue</title>
    <url>/posts/e2b34733/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>JUC里的 BlockingQueue 接口表示一个线程安放入和提取实例的队列</p>
</blockquote>
<a id="more"></a>

<h1 id="BlockingQueue和BlockingDeque"><a href="#BlockingQueue和BlockingDeque" class="headerlink" title="BlockingQueue和BlockingDeque"></a>BlockingQueue和BlockingDeque</h1><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>BlockingQueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述:</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-blocking-queue-1.png" alt="img"></p>
<p>一个线程往里边放，另外一个线程从里边取的一个 BlockingQueue。</p>
<p>一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</p>
<h2 id="BlockingQueue-的方法"><a href="#BlockingQueue-的方法" class="headerlink" title="BlockingQueue 的方法"></a>BlockingQueue 的方法</h2><p>BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o, timeout, timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove(o)</td>
<td>poll(o)</td>
<td>take(o)</td>
<td>poll(timeout, timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>element(o)</td>
<td>peek(o)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>四组不同的行为方式解释:</p>
<ul>
<li>抛异常: 如果试图的操作无法立即执行，抛一个异常。</li>
<li>特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li>
<li>阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li>
<li>超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</li>
</ul>
<p>无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。 可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注: 基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。</p>
<h2 id="BlockingDeque"><a href="#BlockingDeque" class="headerlink" title="BlockingDeque"></a>BlockingDeque</h2><p>java.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。</p>
<p>BlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。 deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。</p>
<p>在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。BlockingDeque 图解:</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-blocking-deque-1.png" alt="img"></p>
<h2 id="BlockingDeque-的方法"><a href="#BlockingDeque-的方法" class="headerlink" title="BlockingDeque 的方法"></a>BlockingDeque 的方法</h2><p>一个 BlockingDeque - 线程在双端队列的两端都可以插入和提取元素。 一个线程生产元素，并把它们插入到队列的任意一端。如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。</p>
<p>BlockingDeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>addFirst(o)</td>
<td>offerFirst(o)</td>
<td>putFirst(o)</td>
<td>offerFirst(o, timeout, timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>removeFirst(o)</td>
<td>pollFirst(o)</td>
<td>takeFirst(o)</td>
<td>pollFirst(timeout, timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>getFirst(o)</td>
<td>peekFirst(o)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>addLast(o)</td>
<td>offerLast(o)</td>
<td>putLast(o)</td>
<td>offerLast(o, timeout, timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>removeLast(o)</td>
<td>pollLast(o)</td>
<td>takeLast(o)</td>
<td>pollLast(timeout, timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>getLast(o)</td>
<td>peekLast(o)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>四组不同的行为方式解释:</p>
<ul>
<li>抛异常: 如果试图的操作无法立即执行，抛一个异常。</li>
<li>特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li>
<li>阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li>
<li>超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</li>
</ul>
<h2 id="BlockingDeque-与BlockingQueue关系"><a href="#BlockingDeque-与BlockingQueue关系" class="headerlink" title="BlockingDeque 与BlockingQueue关系"></a>BlockingDeque 与BlockingQueue关系</h2><p>BlockingDeque 接口继承自 BlockingQueue 接口。这就意味着你可以像使用一个 BlockingQueue 那样使用 BlockingDeque。如果你这么干的话，各种插入方法将会把新元素添加到双端队列的尾端，而移除方法将会把双端队列的首端的元素移除。正如 BlockingQueue 接口的插入和移除方法一样。</p>
<p>以下是 BlockingDeque 对 BlockingQueue 接口的方法的具体内部实现:</p>
<table>
<thead>
<tr>
<th>BlockingQueue</th>
<th>BlockingDeque</th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td>addLast()</td>
</tr>
<tr>
<td>offer() x 2</td>
<td>offerLast() x 2</td>
</tr>
<tr>
<td>put()</td>
<td>putLast()</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>poll() x 2</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>take()</td>
<td>takeFirst()</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<h1 id="BlockingQueue-的例子"><a href="#BlockingQueue-的例子" class="headerlink" title="BlockingQueue 的例子"></a>BlockingQueue 的例子</h1><p>这里是一个 Java 中使用 BlockingQueue 的示例。本示例使用的是 BlockingQueue 接口的 ArrayBlockingQueue 实现。 首先，BlockingQueueExample 类分别在两个独立的线程中启动了一个 Producer 和 一个 Consumer。Producer 向一个共享的 BlockingQueue 中注入字符串，而 Consumer 则会从中把它们拿出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是 Producer 类。注意它在每次 put() 调用时是如何休眠一秒钟的。这将导致 Consumer 在等待队列中对象的时候发生阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是 Consumer 类。它只是把对象从队列中抽取出来，然后将它们打印到 System.out。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组阻塞队列-ArrayBlockingQueue"><a href="#数组阻塞队列-ArrayBlockingQueue" class="headerlink" title="数组阻塞队列 ArrayBlockingQueue"></a>数组阻塞队列 ArrayBlockingQueue</h2><p>ArrayBlockingQueue 类实现了 BlockingQueue 接口。</p>
<p>ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注: 因为它是基于数组实现的，也就具有数组的特性: 一旦初始化，大小就无法修改)。 ArrayBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是在使用 ArrayBlockingQueue 的时候对其初始化的一个示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);</span><br><span class="line">queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Object object = queue.take();   </span><br></pre></td></tr></table></figure>
<p>以下是使用了 Java 泛型的一个 BlockingQueue 示例。注意其中是如何对 String 元素放入和提取的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">1024</span>);</span><br><span class="line">queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">String string = queue.take();</span><br></pre></td></tr></table></figure>
<h2 id="延迟队列-DelayQueue"><a href="#延迟队列-DelayQueue" class="headerlink" title="延迟队列 DelayQueue"></a>延迟队列 DelayQueue</h2><p>DelayQueue 实现了 BlockingQueue 接口。</p>
<p>DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口，该接口定义:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&lt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit timeUnit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take 被调用的时候被释放掉。</p>
<p>传递给 getDelay 方法的 getDelay 实例是一个枚举类型，它表明了将要延迟的时间段。TimeUnit 枚举将会取以下值:</p>
<ul>
<li>DAYS</li>
<li>HOURS</li>
<li>INUTES</li>
<li>SECONDS</li>
<li>MILLISECONDS</li>
<li>MICROSECONDS</li>
<li>NANOSECONDS</li>
</ul>
<p>正如你所看到的，Delayed 接口也继承了 java.lang.Comparable 接口，这也就意味着 Delayed 对象之间可以进行对比。这个可能在对 DelayQueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。 以下是使用 DelayQueue 的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueExample</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DelayQueue queue = <span class="keyword">new</span> DelayQueue();</span><br><span class="line">        Delayed element1 = <span class="keyword">new</span> DelayedElement();</span><br><span class="line">        queue.put(element1);</span><br><span class="line">        Delayed element2 = queue.take();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>DelayedElement 是我所创建的一个 DelayedElement 接口的实现类，它不在 java.util.concurrent 包里。你需要自行创建你自己的 Delayed 接口的实现以使用 DelayQueue 类。</p>
<h2 id="链阻塞队列-LinkedBlockingQueue"><a href="#链阻塞队列-LinkedBlockingQueue" class="headerlink" title="链阻塞队列 LinkedBlockingQueue"></a>链阻塞队列 LinkedBlockingQueue</h2><p>LinkedBlockingQueue 类实现了 BlockingQueue 接口。</p>
<p>LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。</p>
<p>LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是 LinkedBlockingQueue 的初始化和使用示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; unbounded = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">BlockingQueue&lt;String&gt; bounded   = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">1024</span>);</span><br><span class="line">bounded.put(<span class="string">&quot;Value&quot;</span>);</span><br><span class="line">String value = bounded.take();</span><br></pre></td></tr></table></figure>
<h2 id="具有优先级的阻塞队列-PriorityBlockingQueue"><a href="#具有优先级的阻塞队列-PriorityBlockingQueue" class="headerlink" title="具有优先级的阻塞队列 PriorityBlockingQueue"></a>具有优先级的阻塞队列 PriorityBlockingQueue</h2><p>PriorityBlockingQueue 类实现了 BlockingQueue 接口。</p>
<p>PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。 所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。 注意 PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。</p>
<p>同时注意，如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。 以下是使用 PriorityBlockingQueue 的示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue queue   = <span class="keyword">new</span> PriorityBlockingQueue();</span><br><span class="line"><span class="comment">//String implements java.lang.Comparable</span></span><br><span class="line">queue.put(<span class="string">&quot;Value&quot;</span>);</span><br><span class="line">String value = queue.take();</span><br></pre></td></tr></table></figure>
<h2 id="同步队列-SynchronousQueue"><a href="#同步队列-SynchronousQueue" class="headerlink" title="同步队列 SynchronousQueue"></a>同步队列 SynchronousQueue</h2><p>SynchronousQueue 类实现了 BlockingQueue 接口。</p>
<p>SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p>
<h1 id="BlockingDeque-的例子"><a href="#BlockingDeque-的例子" class="headerlink" title="BlockingDeque 的例子"></a>BlockingDeque 的例子</h1><p>既然 BlockingDeque 是一个接口，那么你想要使用它的话就得使用它的众多的实现类的其中一个。java.util.concurrent 包提供了以下 BlockingDeque 接口的实现类: LinkedBlockingDeque。</p>
<p>以下是如何使用 BlockingDeque 方法的一个简短代码示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingDeque&lt;String&gt; deque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">deque.addFirst(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">deque.addLast(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">String two = deque.takeLast();</span><br><span class="line">String one = deque.takeFirst();</span><br></pre></td></tr></table></figure>
<h2 id="链阻塞双端队列-LinkedBlockingDeque"><a href="#链阻塞双端队列-LinkedBlockingDeque" class="headerlink" title="链阻塞双端队列 LinkedBlockingDeque"></a>链阻塞双端队列 LinkedBlockingDeque</h2><p>LinkedBlockingDeque 类实现了 BlockingDeque 接口。</p>
<p>deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。(译者注: 唐僧啊，受不了。) LinkedBlockingDeque 是一个双端队列，在它为空的时候，一个试图从中抽取数据的线程将会阻塞，无论该线程是试图从哪一端抽取数据。 以下是 LinkedBlockingDeque 实例化以及使用的示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingDeque&lt;String&gt; deque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">deque.addFirst(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">deque.addLast(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">String two = deque.takeLast();</span><br><span class="line">String one = deque.takeFirst();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>容器</category>
        <category>并发容器</category>
      </categories>
      <tags>
        <tag>BlockingQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>并发工具类之CountDownLatch</title>
    <url>/posts/ac1e355a/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>底层由AQS支持，CountDownLatch典型的用法是将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch。当每一个任务完成时，都会在这个锁存器上调用countDown，等待问题被解决的任务调用这个锁存器的await，将他们自己拦住，直至锁存器计数结束。</p>
</blockquote>
<a id="more"></a>

<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前计数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图在共享模式下获取对象状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图设置状态来反映共享模式下的一个释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 没有被线程占有</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 下一个状态</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 比较并且设置成功</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化状态数</span></span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h1><h2 id="await函数"><a href="#await函数" class="headerlink" title="await函数"></a>await函数</h2><p>此函数将会使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 转发到sync对象上</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acquireSharedInterruptibly"><a href="#acquireSharedInterruptibly" class="headerlink" title="acquireSharedInterruptibly"></a>acquireSharedInterruptibly</h3><p>acquireSharedInterruptibly又调用了CountDownLatch的内部类Sync的tryAcquireShared和AQS的doAcquireSharedInterruptibly函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h3><p>该函数只是简单的判断AQS的state是否为0，为0则返回1，不为0则返回-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doAcquireSharedInterruptibly"><a href="#doAcquireSharedInterruptibly" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加节点至等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取node的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 前驱节点为头结点</span></span><br><span class="line">                <span class="comment">// 试图在共享模式下获取对象状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 获取成功</span></span><br><span class="line">                    <span class="comment">// 设置头结点并进行繁殖</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">// 设置节点next域</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 在获取失败后是否需要禁止线程并且进行中断检查</span></span><br><span class="line">                <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            canceAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h3><p>该方法设置头结点并且释放头结点后面的满足条件的结点，该方法中可能会调用到AQS的doReleaseShared方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取头结点</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 设置头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">        *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">        *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">        *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">        *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">        *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">        * and</span></span><br><span class="line"><span class="comment">        *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">        *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">        * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">        * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">        * anyway.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取节点的后继</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) <span class="comment">// 后继为空或者为共享模式</span></span><br><span class="line">            <span class="comment">// 以共享模式进行释放</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 保存头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; <span class="comment">// 头结点不为空并且头结点不为尾结点</span></span><br><span class="line">            <span class="comment">// 获取头结点的等待状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus; </span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 状态为SIGNAL</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// 不成功就继续</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 释放后继结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// 状态为0并且不成功，继续</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// 若头结点改变，继续循环  </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountDownLatch的await调用大致会有如下的调用链。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-countdownlatch-1.png" alt="img"></p>
<p>说明: 上图给出了可能会调用到的主要方法，并非一定会调用到</p>
<h2 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h2><p>此函数将递减锁存器的计数，如果计数到达零，则释放所有等待的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><p> 此函数会试图设置状态来反映共享模式下的一个释放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS的doReleaseShared"><a href="#AQS的doReleaseShared" class="headerlink" title="AQS的doReleaseShared"></a>AQS的doReleaseShared</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 保存头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; <span class="comment">// 头结点不为空并且头结点不为尾结点</span></span><br><span class="line">            <span class="comment">// 获取头结点的等待状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus; </span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 状态为SIGNAL</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// 不成功就继续</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 释放后继结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// 状态为0并且不成功，继续</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// 若头结点改变，继续循环  </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 此函数在共享模式下释放资源。</p>
<p>所以，对CountDownLatch的countDown调用大致会有如下的调用链。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-countdownlatch-2.png" alt="img"></p>
<h1 id="CountDownLatch示例"><a href="#CountDownLatch示例" class="headerlink" title="CountDownLatch示例"></a>CountDownLatch示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; doing something&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finish&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, countDownLatch);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, countDownLatch);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for t1 thread and t2 thread to finish&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;            </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continue&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果(某一次):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> t1 thread and t2 thread to finish</span><br><span class="line">t1 doing something</span><br><span class="line">t2 doing something</span><br><span class="line">t1 finish</span><br><span class="line">t2 finish</span><br><span class="line">main <span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>说明: 本程序首先计数器初始化为2。根据结果，可能会存在如下的一种时序图。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-countdownlatch-3.png" alt="img"></p>
<p>说明: 首先main线程会调用await操作，此时main线程会被阻塞，等待被唤醒，之后t1线程执行了countDown操作，最后，t2线程执行了countDown操作，此时main线程就被唤醒了，可以继续运行。下面，进行详细分析。</p>
<ul>
<li>main线程执行countDownLatch.await操作，主要调用的函数如下。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-countdownlatch-4.png" alt="img"></p>
<p>说明: 在最后，main线程就被park了，即禁止运行了。此时Sync queue(同步队列)中有两个节点，AQS的state为2，包含main线程的结点的nextWaiter指向SHARED结点。</p>
<ul>
<li>t1线程执行countDownLatch.countDown操作，主要调用的函数如下。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-countdownlatch-5.png" alt="img"></p>
<p>说明: 此时，Sync queue队列里的结点个数未发生变化，但是此时，AQS的state已经变为1了。</p>
<ul>
<li>t2线程执行countDownLatch.countDown操作，主要调用的函数如下。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-countdownlatch-6.png" alt="img"></p>
<p>说明: 经过调用后，AQS的state为0，并且此时，main线程会被unpark，可以继续运行。当main线程获取cpu资源后，继续运行。</p>
<ul>
<li>main线程获取cpu资源，继续运行，由于main线程是在parkAndCheckInterrupt函数中被禁止的，所以此时，继续在parkAndCheckInterrupt函数运行。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-countdownlatch-7.png" alt="img"></p>
<p>说明: main线程恢复，继续在parkAndCheckInterrupt函数中运行，之后又会回到最终达到的状态为AQS的state为0，并且head与tail指向同一个结点，该节点的额nextWaiter域还是指向SHARED结点</p>
<h1 id="写道面试题"><a href="#写道面试题" class="headerlink" title="写道面试题"></a>写道面试题</h1><blockquote>
<p>实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束.</p>
</blockquote>
<h2 id="使用wait和notify实现"><a href="#使用wait和notify实现" class="headerlink" title="使用wait和notify实现"></a>使用wait和notify实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  必须先让t2先进行启动 使用wait 和 notify 进行相互通讯，wait会释放锁，notify不会释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">volatile</span>   List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        T2 t2 = <span class="keyword">new</span> T2();</span><br><span class="line"></span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 启动&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(t2.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">/**会释放锁*/</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2 结束&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t1 启动&quot;</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                   t2.add(i);</span><br><span class="line">                   System.out.println(<span class="string">&quot;add&quot;</span>+i);</span><br><span class="line">                   <span class="keyword">if</span>(t2.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                       <span class="comment">/**不会释放锁*/</span></span><br><span class="line">                       lock.notify();</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           lock.wait();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">t2 启动</span><br><span class="line">t1 启动</span><br><span class="line">add0</span><br><span class="line">add1</span><br><span class="line">add2</span><br><span class="line">add3</span><br><span class="line">add4</span><br><span class="line">t2 结束</span><br><span class="line">add5</span><br><span class="line">add6</span><br><span class="line">add7</span><br><span class="line">add8</span><br></pre></td></tr></table></figure>
<h2 id="CountDownLatch实现"><a href="#CountDownLatch实现" class="headerlink" title="CountDownLatch实现"></a>CountDownLatch实现</h2><p>说出使用CountDownLatch 代替wait notify 好处?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用CountDownLatch 代替wait notify 好处是通讯方式简单，不涉及锁定  Count 值为0时当前线程继续执行，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">volatile</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T3 t = <span class="keyword">new</span> T3();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 start&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(t.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   countDownLatch.await();</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2 end&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">               t.add(i);</span><br><span class="line">               System.out.println(<span class="string">&quot;add&quot;</span>+ i);</span><br><span class="line">               <span class="keyword">if</span>(t.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;countdown is open&quot;</span>);</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 end&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>并发</category>
        <category>JUC工具类</category>
      </categories>
      <tags>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title>并发工具类之CyclicBarrier</title>
    <url>/posts/5b722c34/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="CyclicBarrier理解"><a href="#CyclicBarrier理解" class="headerlink" title="CyclicBarrier理解"></a>CyclicBarrier理解</h1><p>对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。</p>
<p>对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。</p>
<a id="more"></a>

<h1 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h1><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>CyclicBarrier类存在一个内部类Generation，每一次使用的CycBarrier可以当成Generation的实例，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>说明: Generation类有一个属性broken，用来表示当前屏障是否被损坏。</p>
<h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="comment">// 条件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** The number of parties */</span></span><br><span class="line">    <span class="comment">// 参与的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="comment">// 由最后一个进入 barrier 的线程执行的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="comment">// 当前代</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    <span class="comment">// 正在等待进入屏障的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 该属性有一个为ReentrantLock对象，有一个为Condition对象，而Condition对象又是基于AQS的，所以，归根到底，底层还是由AQS提供支持。</p>
<h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><h3 id="CyclicBarrier-int-Runnable-型构造函数"><a href="#CyclicBarrier-int-Runnable-型构造函数" class="headerlink" title="CyclicBarrier(int, Runnable)型构造函数"></a>CyclicBarrier(int, Runnable)型构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参与的线程数量小于等于0，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 设置parties</span></span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="comment">// 设置count</span></span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="comment">// 设置barrierCommand</span></span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 该构造函数可以指定关联该CyclicBarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。</p>
<h3 id="CyclicBarrier-int-型构造函数"><a href="#CyclicBarrier-int-型构造函数" class="headerlink" title="CyclicBarrier(int)型构造函数"></a>CyclicBarrier(int)型构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用含有两个参数的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 该构造函数仅仅执行了关联该CyclicBarrier的线程数量，没有设置执行动作。</p>
<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h3 id="dowait函数"><a href="#dowait函数" class="headerlink" title="dowait函数"></a>dowait函数</h3><p>此函数为CyclicBarrier类的核心函数，CyclicBarrier类对外提供的await函数在底层都是调用该了doawait函数，其源代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">// 保存当前锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 锁定</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存当前代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (g.broken) <span class="comment">// 屏障被破坏，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">// 线程被中断</span></span><br><span class="line">            <span class="comment">// 损坏当前屏障，并且唤醒所有的线程，只有拥有锁的时候才会调用</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减少正在等待进入屏障的线程数量</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 正在等待进入屏障的线程数量为0，所有线程都已经进入</span></span><br><span class="line">            <span class="comment">// 运行的动作标识</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 保存运行动作</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>) <span class="comment">// 动作不为空</span></span><br><span class="line">                    <span class="comment">// 运行</span></span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 设置ranAction状态</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 进入下一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction) <span class="comment">// 没有运行的动作</span></span><br><span class="line">                    <span class="comment">// 损坏当前屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed) <span class="comment">// 没有设置等待时间</span></span><br><span class="line">                    <span class="comment">// 等待</span></span><br><span class="line">                    trip.await(); </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) <span class="comment">// 设置了等待时间，并且等待时间大于0</span></span><br><span class="line">                    <span class="comment">// 等待指定时长</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; </span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123; <span class="comment">// 等于当前代并且屏障没有被损坏</span></span><br><span class="line">                    <span class="comment">// 损坏当前屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// 抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不等于当前带后者是屏障被损坏</span></span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    <span class="comment">// 中断当前线程</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken) <span class="comment">// 屏障被损坏，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation) <span class="comment">// 不等于当前代</span></span><br><span class="line">                <span class="comment">// 返回索引</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123; <span class="comment">// 设置了等待时间，并且等待时间小于0</span></span><br><span class="line">                <span class="comment">// 损坏屏障</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>说明: dowait方法的逻辑会进行一系列的判断，大致流程如下:</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-cyclicbarrier-1.png" alt="img"></p>
<h3 id="nextGeneration函数"><a href="#nextGeneration函数" class="headerlink" title="nextGeneration函数"></a>nextGeneration函数</h3><p>此函数在所有线程进入屏障后会被调用，即生成下一个版本，所有线程又可以重新进入到屏障中，其源代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    <span class="comment">// 恢复正在等待进入屏障的线程数量</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 新生一代</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此函数中会调用AQS的signalAll方法，即唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。其源代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 不被当前线程独占，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 保存condition队列头结点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 头结点不为空</span></span><br><span class="line">        <span class="comment">// 唤醒所有等待线程</span></span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>说明: 此函数判断头结点是否为空，即条件队列是否为空，然后会调用doSignalAll函数，doSignalAll函数源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition队列的头结点尾结点都设置为空</span></span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取first结点的nextWaiter域结点</span></span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        <span class="comment">// 设置first结点的nextWaiter域为空</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将first结点从condition队列转移到sync队列</span></span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        <span class="comment">// 重新设置first</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>说明: 此函数会依次将条件队列中的节点转移到同步队列中，会调用到transferForSignal函数，其源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">        * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">        * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">        * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>说明: 此函数的作用就是将处于条件队列中的节点转移到同步队列中，并设置结点的状态信息，其中会调用到enq函数，其源代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，确保结点能够成功入队列</span></span><br><span class="line">        <span class="comment">// 保存尾结点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点为空，即还没被初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 头结点为空，并设置头结点为新生成的结点</span></span><br><span class="line">                tail = head; <span class="comment">// 头结点与尾结点都指向同一个新生结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 尾结点不为空，即已经被初始化过</span></span><br><span class="line">            <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">            node.prev = t; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 比较结点t是否为尾结点，若是则将尾结点设置为node</span></span><br><span class="line">                <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">                t.next = node; </span><br><span class="line">                <span class="keyword">return</span> t; <span class="comment">// 返回尾结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>说明: 此函数完成了结点插入同步队列的过程，也很好理解。</p>
<p>综合上面的分析可知，newGeneration函数的主要方法的调用如下，之后会通过一个例子详细讲解:</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-cyclicbarrier-2.png" alt="img"></p>
<h2 id="breakBarrier函数"><a href="#breakBarrier函数" class="headerlink" title="breakBarrier函数"></a>breakBarrier函数</h2><p>此函数的作用是损坏当前屏障，会唤醒所有在屏障中的线程。源代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 恢复正在等待进入屏障的线程数量</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>说明: 可以看到，此函数也调用了AQS的signalAll函数，由signal函数提供支持。</p>
<h1 id="CyclicBarrier示例"><a href="#CyclicBarrier示例" class="headerlink" title="CyclicBarrier示例"></a>CyclicBarrier示例</h1><p>下面通过一个例子来详解CyclicBarrier的使用和内部工作机制，源代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, CyclicBarrier cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; going to await&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cb.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continue&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Thread(<span class="string">&quot;barrierAction&quot;</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; barrier action&quot;</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, cb);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, cb);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; going to await&quot;</span>);</span><br><span class="line">        cb.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>运行结果(某一次):</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">t1 going to await</span><br><span class="line">main going to await</span><br><span class="line">t2 going to await</span><br><span class="line">t2 barrier action</span><br><span class="line">t2 continue</span><br><span class="line">t1 continue</span><br><span class="line">main continue   </span><br></pre></td></tr></table></figure>
<p>说明: 根据结果可知，可能会存在如下的调用时序。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-cyclicbarrier-3.png" alt="img"></p>
<p>说明: 由上图可知，假设t1线程的cb.await是在main线程的cb.barrierAction动作是由最后一个进入屏障的线程执行的。根据时序图，进一步分析出其内部工作流程。</p>
<ul>
<li>main(主)线程执行cb.await操作，主要调用的函数如下。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-cyclicbarrier-4.png" alt="img"></p>
<p>说明: 由于ReentrantLock的默认采用非公平策略，所以在dowait函数中调用的是ReentrantLock.NonfairSync的lock函数，由于此时AQS的状态是0，表示还没有被任何线程占用，故main线程可以占用，之后在dowait中会调用trip.await函数，最终的结果是条件队列中存放了一个包含main线程的结点，并且被禁止运行了，同时，main线程所拥有的资源也被释放了，可以供其他线程获取。</p>
<ul>
<li>t1线程执行cb.await操作，其中假设t1线程的lock.lock操作在main线程释放了资源之后，则其主要调用的函数如下。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-cyclicbarrier-5.png" alt="img"></p>
<p>说明: 可以看到，之后condition queue(条件队列)里面有两个节点，包含t1线程的结点插入在队列的尾部，并且t1线程也被禁止了，因为执行了park操作，此时两个线程都被禁止了。</p>
<ul>
<li>t2线程执行cb.await操作，其中假设t2线程的lock.lock操作在t1线程释放了资源之后，则其主要调用的函数如下。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-cyclicbarrier-6.png" alt="img"></p>
<p>说明: 由上图可知，在t2线程执行await操作后，会直接执行command.run方法，不是重新开启一个线程，而是最后进入屏障的线程执行。同时，会将Condition queue中的所有节点都转移到Sync queue中，并且最后main线程会被unpark，可以继续运行。main线程获取cpu资源，继续运行。</p>
<ul>
<li>main线程获取cpu资源，继续运行，下图给出了主要的方法调用:</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-cyclicbarrier-7.png" alt="img"></p>
<p>说明: 其中，由于main线程是在AQS.CO的wait中被park的，所以恢复时，会继续在该方法中运行。运行过后，t1线程被unpark，它获得cpu资源可以继续运行。</p>
<ul>
<li>t1线程获取cpu资源，继续运行，下图给出了主要的方法调用。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-cyclicbarrier-8.png" alt="img"></p>
<p>说明: 其中，由于t1线程是在AQS.CO的wait方法中被park，所以恢复时，会继续在该方法中运行。运行过后，Sync queue中保持着一个空节点。头结点与尾节点均指向它。</p>
<p>注意: 在线程await过程中中断线程会抛出异常，所有进入屏障的线程都将被释放。至于CyclicBarrier的其他用法，读者可以自行查阅API，不再累赘。</p>
<h1 id="和CountDonwLatch再对比"><a href="#和CountDonwLatch再对比" class="headerlink" title="和CountDonwLatch再对比"></a>和CountDonwLatch再对比</h1><ul>
<li><p>CountDownLatch减计数，CyclicBarrier加计数。</p>
</li>
<li><p>CountDownLatch是一次性的，CyclicBarrier可以重用。</p>
</li>
<li><p>CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
        <category>JUC工具类</category>
      </categories>
      <tags>
        <tag>CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title>并发工具类之Semaphore</title>
    <url>/posts/9f71f91f/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>工具类Semaphore的源码详解</p>
</blockquote>
<a id="more"></a>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>说明: Semaphore实现了Serializable接口，即可以进行序列化。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>Semaphore总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-1.png" alt="img"></p>
<p>说明: Semaphore与ReentrantLock的内部类的结构相同，类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。下面逐个进行分析。</p>
<h3 id="Sync类"><a href="#Sync类" class="headerlink" title="Sync类"></a>Sync类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部类，继承自AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="comment">// 设置状态数</span></span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享模式下非公平策略获取</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可数</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">// 剩余的许可</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining)) <span class="comment">// 许可小于0或者比较并且设置状态成功</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共享模式下进行释放</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的缩减量减小可用许可的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="comment">// 可用的许可</span></span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Permit count underflow&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 比较并进行设置成功</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并返回立即可用的所有许可</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取许可</span></span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>)) <span class="comment">// 许可为0或者比较并设置成功</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: Sync类的属性相对简单，只有一个版本号，Sync类存在如下方法和作用如下。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-2.png" alt="img"></p>
<h3 id="NonfairSync类"><a href="#NonfairSync类" class="headerlink" title="NonfairSync类"></a>NonfairSync类</h3><p>NonfairSync类继承了Sync类，表示采用非公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共享模式下获取</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>说明: 从tryAcquireShared方法的源码可知，其会调用父类Sync的nonfairTryAcquireShared方法，表示按照非公平策略进行资源的获取。</p>
<h3 id="FairSync类"><a href="#FairSync类" class="headerlink" title="FairSync类"></a>FairSync类</h3><p>FairSync类继承了Sync类，表示采用公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">// 同步队列中存在其他节点</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">// 剩余的许可</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 剩余的许可小于0或者比较设置成功</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>说明: 从tryAcquireShared方法的源码可知，它使用公平策略来获取资源，它会判断同步队列中是否存在其他的等待节点。</p>
<h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>说明: Semaphore自身只有两个属性，最重要的是sync属性，基于Semaphore对象的操作绝大多数都转移到了对sync的操作。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="Semaphore-int-型构造函数"><a href="#Semaphore-int-型构造函数" class="headerlink" title="Semaphore(int)型构造函数"></a>Semaphore(int)型构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>说明: 该构造函数会创建具有给定的许可数和非公平的公平设置的Semaphore。</p>
<h3 id="Semaphore-int-boolean-型构造函数"><a href="#Semaphore-int-boolean-型构造函数" class="headerlink" title="Semaphore(int, boolean)型构造函数"></a>Semaphore(int, boolean)型构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>说明: 该构造函数会创建具有给定的许可数和给定的公平设置的Semaphore。</p>
<h2 id="核心函数分析"><a href="#核心函数分析" class="headerlink" title="核心函数分析"></a>核心函数分析</h2><h3 id="acquire函数"><a href="#acquire函数" class="headerlink" title="acquire函数"></a>acquire函数</h3><p>此方法从信号量获取一个(多个)许可，在提供一个许可前一直将线程阻塞，或者线程被中断，其源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>说明: 该方法中将会调用Sync对象的acquireSharedInterruptibly(从AQS继承而来的方法)方法，而acquireSharedInterruptibly方法在上一篇CountDownLatch中已经进行了分析，在此不再累赘。</p>
<p>最终可以获取大致的方法调用序列(假设使用非公平策略)。如下图所示。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-3.png" alt="img"></p>
<p>说明: 上图只是给出了大体会调用到的方法，和具体的示例可能会有些差别，之后会根据具体的示例进行分析。</p>
<h3 id="release函数"><a href="#release函数" class="headerlink" title="release函数"></a>release函数</h3><p>此方法释放一个(多个)许可，将其返回给信号量，源码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>说明: 该方法中将会调用Sync对象的releaseShared(从AQS继承而来的方法)方法，而releaseShared方法在上一篇CountDownLatch中已经进行了分析，在此不再累赘。</p>
<p>最终可以获取大致的方法调用序列(假设使用非公平策略)。如下图所示:</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-4.png" alt="img"></p>
<p>说明: 上图只是给出了大体会调用到的方法，和具体的示例可能会有些差别，之后会根据具体的示例进行分析。</p>
<h1 id="Semaphore示例"><a href="#Semaphore示例" class="headerlink" title="Semaphore示例"></a>Semaphore示例</h1><p>下面给出了一个使用Semaphore的示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to acquire&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire successfully&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release successfully&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SEM_SIZE = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(SEM_SIZE);</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, semaphore);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, semaphore);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">int</span> permits = <span class="number">5</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to acquire&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(permits);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire successfully&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release successfully&quot;</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>运行结果(某一次):</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">main trying to acquire</span><br><span class="line">main acquire successfully</span><br><span class="line">t1 trying to acquire</span><br><span class="line">t1 acquire successfully</span><br><span class="line">t2 trying to acquire</span><br><span class="line">t1 release successfully</span><br><span class="line">main release successfully</span><br><span class="line">t2 acquire successfully</span><br><span class="line">t2 release successfully    </span><br></pre></td></tr></table></figure>
<p>说明: 首先，生成一个信号量，信号量有10个许可，然后，main，t1，t2三个线程获取许可运行，根据结果，可能存在如下的一种时序。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-5.png" alt="img"></p>
<p>说明: 如上图所示，首先，main线程执行acquire操作，并且成功获得许可，之后t1线程执行acquire操作，成功获得许可，之后t2执行acquire操作，由于此时许可数量不够，t2线程将会阻塞，直到许可可用。之后t1线程释放许可，main线程释放许可，此时的许可数量可以满足t2线程的要求，所以，此时t2线程会成功获得许可运行，t2运行完成后释放许可。下面进行详细分析。</p>
<ul>
<li>main线程执行semaphore.acquire操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-6.png" alt="img"></p>
<p>说明: 此时，可以看到只是AQS的state变为了5，main线程并没有被阻塞，可以继续运行。</p>
<ul>
<li>t1线程执行semaphore.acquire操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-7.png" alt="img"></p>
<p>说明: 此时，可以看到只是AQS的state变为了2，t1线程并没有被阻塞，可以继续运行。</p>
<ul>
<li>t2线程执行semaphore.acquire操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-8.png" alt="img"></p>
<p>说明: 此时，t2线程获取许可不会成功，之后会导致其被禁止运行，值得注意的是，AQS的state还是为2。</p>
<ul>
<li>t1执行semaphore.release操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-9.png" alt="img"></p>
<p>说明: 此时，t2线程将会被unpark，并且AQS的state为5，t2获取cpu资源后可以继续运行。</p>
<ul>
<li>main线程执行semaphore.release操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-10.png" alt="img"></p>
<p>说明: 此时，t2线程还会被unpark，但是不会产生影响，此时，只要t2线程获得CPU资源就可以运行了。此时，AQS的state为10。</p>
<ul>
<li>t2获取CPU资源，继续运行，此时t2需要恢复现场，回到parkAndCheckInterrupt函数中，也是在should继续运行。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-11.png" alt="img"></p>
<p>说明: 此时，可以看到，Sync queue中只有一个结点，头结点与尾节点都指向该结点，在setHeadAndPropagate的函数中会设置头结点并且会unpark队列中的其他结点。</p>
<ul>
<li>t2线程执行semaphore.release操作。主要的函数调用如下图所示。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-semaphore-12.png" alt="img"></p>
<p>说明: t2线程经过release后，此时信号量的许可又变为10个了，此时Sync queue中的结点还是没有变化。</p>
<h1 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h1><h2 id="单独使用Semaphore是不会使用到AQS的条件队列的"><a href="#单独使用Semaphore是不会使用到AQS的条件队列的" class="headerlink" title="单独使用Semaphore是不会使用到AQS的条件队列的"></a>单独使用Semaphore是不会使用到AQS的条件队列的</h2><p>不同于CyclicBarrier和ReentrantLock，单独使用Semaphore是不会使用到AQS的条件队列的，其实，只有进行await操作才会进入条件队列，其他的都是在同步队列中，只是当前线程会被park。</p>
<h2 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h2><h3 id="semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么"><a href="#semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么" class="headerlink" title="semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?"></a>semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?</h3><p>答案：拿不到令牌的线程阻塞，不会继续往下运行。</p>
<h3 id="semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么"><a href="#semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么" class="headerlink" title="semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?"></a>semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?</h3><p>答案：线程阻塞，不会继续往下运行。可能你会考虑类似于锁的重入的问题，很好，但是，令牌没有重入的概念。你只要调用一次acquire方法，就需要有一个令牌才能继续运行。</p>
<h3 id="semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗"><a href="#semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗" class="headerlink" title="semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?"></a>semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?</h3><p>答案：能，原因是release方法会添加令牌，并不会以初始化的大小为准。</p>
<h3 id="semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗"><a href="#semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗" class="headerlink" title="semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?"></a>semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?</h3><p>答案：能，原因是release会添加令牌，并不会以初始化的大小为准。Semaphore中release方法的调用并没有限制要在acquire后调用。</p>
<p>具体示例如下，如果不相信的话，可以运行一下下面的demo，在做实验之前，笔者也认为应该是不允许的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> permitsNum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(permitsNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
        <category>JUC工具类</category>
      </categories>
      <tags>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流之AIO</title>
    <url>/posts/4cb2463e/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><p>阻塞式同步IO、非阻塞式同步IO、多路复用IO 这三种IO模型，说明了IO模型是由操作系统提供支持，且这三种IO模型都是同步IO，都是采用的“应用程序不询问我，我绝不会主动通知”的方式。</p>
<p>异步IO则是采用“订阅-通知”模式: 即应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，在主动通知应用程序，触发相应的函数:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-aio-1.png" alt="img"></p>
<p>和同步IO一样，异步IO也是由操作系统进行支持的。微软的windows系统提供了一种异步IO技术: IOCP(I/O Completion Port，I/O完成端口)；</p>
<p>Linux下由于没有这种异步IO技术，所以使用的是epoll(上文介绍过的一种多路复用IO技术的实现)对异步IO进行模拟。</p>
<h1 id="JAVA对AIO的支持"><a href="#JAVA对AIO的支持" class="headerlink" title="JAVA对AIO的支持"></a>JAVA对AIO的支持</h1><h2 id="JAVA-AIO框架简析"><a href="#JAVA-AIO框架简析" class="headerlink" title="JAVA AIO框架简析"></a>JAVA AIO框架简析</h2><p><img src="https://www.pdai.tech/_images/io/java-io-aio-2.png" alt="img"></p>
<p>这里通过这个结构分析要告诉各位读者JAVA AIO中类设计和操作系统的相关性</p>
<p>在文中我们一再说明JAVA AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO，这个从JAVA AIO框架的部分类设计上就可以看出来。例如框架中，在Windows下负责实现套接字通道的具体类是“sun.nio.ch.WindowsAsynchronousSocketChannelImpl”，其引用的IOCP类型文档注释如是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* Windows implementation of AsynchronousChannelGroup encapsulating an I/O </span></span><br><span class="line"><span class="comment">* completion port. </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如果您感兴趣，当然可以去看看全部完整代码(建议从“java.nio.channels.spi.AsynchronousChannelProvider”这个类看起)。</p>
<p>特别说明一下，请注意图中的“java.nio.channels.NetworkChannel”接口，这个接口同样被JAVA NIO框架实现了，如下图所示:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-aio-3.png" alt="img"></p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>下面，我们通过一个代码示例，来讲解JAVA AIO框架的具体使用，先上代码，在针对代码编写和运行中的要点进行讲解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testASocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.BasicConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinwenjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        BasicConfigurator.configure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object waitObject = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 对于使用的线程池技术，我一定要多说几句</span></span><br><span class="line"><span class="comment">         * 1、Executors是线程池生成工具，通过这个工具我们可以很轻松的生成“固定大小的线程池”、“调度池”、“可伸缩线程数量的池”。具体请看API Doc</span></span><br><span class="line"><span class="comment">         * 2、当然您也可以通过ThreadPoolExecutor直接生成池。</span></span><br><span class="line"><span class="comment">         * 3、这个线程池是用来得到操作系统的“IO事件通知”的，不是用来进行“得到IO数据后的业务处理的”。要进行后者的操作，您可以再使用一个池(最好不要混用)</span></span><br><span class="line"><span class="comment">         * 4、您也可以不使用线程池(不推荐)，如果决定不使用线程池，直接AsynchronousServerSocketChannel.open()就行了。</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        AsynchronousChannelGroup group = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="keyword">final</span> AsynchronousServerSocketChannel serverSocket = AsynchronousServerSocketChannel.open(group);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置要监听的端口“0.0.0.0”代表本机所有IP设备</span></span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">83</span>));</span><br><span class="line">        <span class="comment">//为AsynchronousServerSocketChannel注册监听，注意只是为AsynchronousServerSocketChannel通道注册监听</span></span><br><span class="line">        <span class="comment">//并不包括为 随后客户端和服务器 socketchannel通道注册的监听</span></span><br><span class="line">        serverSocket.accept(<span class="keyword">null</span>, <span class="keyword">new</span> ServerSocketChannelHandle(serverSocket));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待，以便观察现象(这个和要讲解的原理本身没有任何关系，只是为了保证守护线程不会退出)</span></span><br><span class="line">        <span class="keyword">synchronized</span>(waitObject) &#123;</span><br><span class="line">            waitObject.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个处理器类，专门用来响应 ServerSocketChannel 的事件。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinwenjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannelHandle</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(ServerSocketChannelHandle.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverSocketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverSocketChannel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerSocketChannelHandle</span><span class="params">(AsynchronousServerSocketChannel serverSocketChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverSocketChannel = serverSocketChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意，我们分别观察 this、socketChannel、attachment三个对象的id。</span></span><br><span class="line"><span class="comment">     * 来观察不同客户端连接到达时，这三个对象的变化，以说明ServerSocketChannelHandle的监听模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Void attachment)</span> </span>&#123;</span><br><span class="line">        ServerSocketChannelHandle.LOGGER.info(<span class="string">&quot;completed(AsynchronousSocketChannel result, ByteBuffer attachment)&quot;</span>);</span><br><span class="line">        <span class="comment">//每次都要重新注册监听(一次注册，一次响应)，但是由于“文件状态标示符”是独享的，所以不需要担心有“漏掉的”事件</span></span><br><span class="line">        <span class="keyword">this</span>.serverSocketChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为这个新的socketChannel注册“read”事件，以便操作系统在收到数据并准备好后，主动通知应用程序</span></span><br><span class="line">        <span class="comment">//在这里，由于我们要将这个客户端多次传输的数据累加起来一起处理，所以我们将一个stringbuffer对象作为一个“附件”依附在这个channel上</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        socketChannel.read(readBuffer, <span class="keyword">new</span> StringBuffer(), <span class="keyword">new</span> SocketChannelReadHandle(socketChannel , readBuffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (non-Javadoc)</span></span><br><span class="line"><span class="comment">     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">        ServerSocketChannelHandle.LOGGER.info(<span class="string">&quot;failed(Throwable exc, ByteBuffer attachment)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责对每一个socketChannel的数据获取事件进行监听。&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 重要的说明: 一个socketchannel都会有一个独立工作的SocketChannelReadHandle对象(CompletionHandler接口的实现)，</span></span><br><span class="line"><span class="comment"> * 其中又都将独享一个“文件状态标示”对象FileDescriptor、</span></span><br><span class="line"><span class="comment"> * 一个独立的由程序员定义的Buffer缓存(这里我们使用的是ByteBuffer)、</span></span><br><span class="line"><span class="comment"> * 所以不用担心在服务器端会出现“窜对象”这种情况，因为JAVA AIO框架已经帮您组织好了。&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 但是最重要的，用于生成channel的对象: AsynchronousChannelProvider是单例模式，无论在哪组socketchannel，</span></span><br><span class="line"><span class="comment"> * 对是一个对象引用(但这没关系，因为您不会直接操作这个AsynchronousChannelProvider对象)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinwenjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketChannelReadHandle</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">StringBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(SocketChannelReadHandle.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 专门用于进行这个通道数据缓存操作的ByteBuffer&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 当然，您也可以作为CompletionHandler的attachment形式传入。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 这是，在这段示例代码中，attachment被我们用来记录所有传送过来的Stringbuffer了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer byteBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketChannelReadHandle</span><span class="params">(AsynchronousSocketChannel socketChannel , ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socketChannel = socketChannel;</span><br><span class="line">        <span class="keyword">this</span>.byteBuffer = byteBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (non-Javadoc)</span></span><br><span class="line"><span class="comment">     * @see java.nio.channels.CompletionHandler#completed(java.lang.Object, java.lang.Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, StringBuffer historyContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果条件成立，说明客户端主动终止了TCP套接字，这时服务端终止就可以了</span></span><br><span class="line">        <span class="keyword">if</span>(result == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.socketChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                SocketChannelReadHandle.LOGGER.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SocketChannelReadHandle.LOGGER.info(<span class="string">&quot;completed(Integer result, Void attachment) : 然后我们来取出通道中准备好的值&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 实际上，由于我们从Integer result知道了本次channel从操作系统获取数据总长度</span></span><br><span class="line"><span class="comment">         * 所以实际上，我们不需要切换成“读模式”的，但是为了保证编码的规范性，还是建议进行切换。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 另外，无论是JAVA AIO框架还是JAVA NIO框架，都会出现“buffer的总容量”小于“当前从操作系统获取到的总数据量”，</span></span><br><span class="line"><span class="comment">         * 但区别是，JAVA AIO框架中，我们不需要专门考虑处理这样的情况，因为JAVA AIO框架已经帮我们做了处理(做成了多次通知)</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">this</span>.byteBuffer.flip();</span><br><span class="line">        <span class="keyword">byte</span>[] contexts = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">this</span>.byteBuffer.get(contexts, <span class="number">0</span>, result);</span><br><span class="line">        <span class="keyword">this</span>.byteBuffer.clear();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String nowContent = <span class="keyword">new</span> String(contexts , <span class="number">0</span> , result , <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            historyContext.append(nowContent);</span><br><span class="line">            SocketChannelReadHandle.LOGGER.info(<span class="string">&quot;================目前的传输结果: &quot;</span> + historyContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            SocketChannelReadHandle.LOGGER.error(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果条件成立，说明还没有接收到“结束标记”</span></span><br><span class="line">        <span class="keyword">if</span>(historyContext.indexOf(<span class="string">&quot;over&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=========================================================================</span></span><br><span class="line">        <span class="comment">//          和上篇文章的代码相同，我们以“over”符号作为客户端完整信息的标记</span></span><br><span class="line">        <span class="comment">//=========================================================================</span></span><br><span class="line">        SocketChannelReadHandle.LOGGER.info(<span class="string">&quot;=======收到完整信息，开始处理业务=========&quot;</span>);</span><br><span class="line">        historyContext = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还要继续监听(一次监听一次通知)</span></span><br><span class="line">        <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBuffer, historyContext, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (non-Javadoc)</span></span><br><span class="line"><span class="comment">     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, StringBuffer historyContext)</span> </span>&#123;</span><br><span class="line">        SocketChannelReadHandle.LOGGER.info(<span class="string">&quot;=====发现客户端异常关闭，服务器将关闭TCP通道&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.socketChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            SocketChannelReadHandle.LOGGER.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h2 id="要点讲解"><a href="#要点讲解" class="headerlink" title="要点讲解"></a>要点讲解</h2><p>注意在JAVA NIO框架中，我们说到了一个重要概念“selector”(选择器)。它负责代替应用查询中所有已注册的通道到操作系统中进行IO事件轮询、管理当前注册的通道集合，定位发生事件的通道等操操作；但是在JAVA AIO框架中，由于应用程序不是“轮询”方式，而是订阅-通知方式，所以不再需要“selector”(选择器)了，改由channel通道直接到操作系统注册监听。</p>
<p>JAVA AIO框架中，只实现了两种网络IO通道“AsynchronousServerSocketChannel”(服务器监听通道)、“AsynchronousSocketChannel”(socket套接字通道)。但是无论哪种通道他们都有独立的fileDescriptor(文件标识符)、attachment(附件，附件可以使任意对象，类似“通道上下文”)，并被独立的SocketChannelReadHandle类实例引用。我们通过debug操作来看看它们的引用结构:</p>
<p>在测试过程中，我们启动了两个客户端(客户端用什么语言来写都行，用阻塞或者非阻塞方式也都行，只要是支持 TCP Socket套接字的就行，然后我们观察服务器端对这两个客户端通道的处理情况:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-aio-3-1.png" alt="img"></p>
<p>可以看到，在服务器端分别为客户端1和客户端2创建的两个WindowsAsynchronousSocketChannelImpl对象为:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-aio-4.png" alt="img"></p>
<p>客户端1: WindowsAsynchronousSocketChannelImpl: 760 | FileDescriptor: 762</p>
<p>客户端2: WindowsAsynchronousSocketChannelImpl: 792 | FileDescriptor: 797</p>
<p>接下来，我们让两个客户端发送信息到服务器端，并观察服务器端的处理情况。客户端1发来的消息和客户端2发来的消息，在服务器端的处理情况如下图所示:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-aio-5.png" alt="img"></p>
<p>客户端1: WindowsAsynchronousSocketChannelImpl: 760 | FileDescriptor: 762 | SocketChannelReadHandle: 803 | HeapByteBuffer: 808</p>
<p>客户端2: WindowsAsynchronousSocketChannelImpl: 792 | FileDescriptor: 797 | SocketChannelReadHandle: 828 | HeapByteBuffer: 833</p>
<p>可以明显看到，服务器端处理每一个客户端通道所使用的SocketChannelReadHandle(处理器)对象都是独立的，并且所引用的SocketChannel对象都是独立的。</p>
<p>JAVA NIO和JAVA AIO框架，除了因为操作系统的实现不一样而去掉了Selector外，其他的重要概念都是存在的，例如上文中提到的Channel的概念，还有演示代码中使用的Buffer缓存方式。实际上JAVA NIO和JAVA AIO框架您可以看成是一套完整的“高并发IO处理”的实现。</p>
<h2 id="还有改进可能"><a href="#还有改进可能" class="headerlink" title="还有改进可能"></a>还有改进可能</h2><p>当然，以上代码是示例代码，目标是为了让您了解JAVA AIO框架的基本使用。所以它还有很多改造的空间，例如:</p>
<p>在生产环境下，我们需要记录这个通道上“用户的登录信息”。那么这个需求可以使用JAVA AIO中的“附件”功能进行实现。</p>
<p>记住JAVA AIO 和 JAVA NIO 框架都是要使用线程池的(当然您也可以不用)，线程池的使用原则，一定是只有业务处理部分才使用，使用后马上结束线程的执行(还回线程池或者消灭它)。JAVA AIO框架中还有一个线程池，是拿给“通知处理器”使用的，这是因为JAVA AIO框架是基于“订阅-通知”模型的，“订阅”操作可以由主线程完成，但是您总不能要求在应用程序中并发的“通知”操作也在主线程上完成吧^_^。</p>
<p>最好的改进方式，当然就是使用Netty或者Mina咯。</p>
<h1 id="为什么还有Netty"><a href="#为什么还有Netty" class="headerlink" title="为什么还有Netty"></a>为什么还有Netty</h1><ul>
<li>既然JAVA NIO / JAVA AIO已经实现了各主流操作系统的底层支持，那么为什么现在主流的JAVA NIO技术会是Netty和MINA呢? 答案很简单: 因为更好用，这里举几个方面的例子:</li>
<li>虽然JAVA NIO 和 JAVA AIO框架提供了 多路复用IO/异步IO的支持，但是并没有提供上层“信息格式”的良好封装。例如前两者并没有提供针对 Protocol Buffer、JSON这些信息格式的封装，但是Netty框架提供了这些数据格式封装(基于责任链模式的编码和解码功能)</li>
<li>要编写一个可靠的、易维护的、高性能的(注意它们的排序)NIO/AIO 服务器应用。除了框架本身要兼容实现各类操作系统的实现外。更重要的是它应该还要处理很多上层特有服务，例如: 客户端的权限、还有上面提到的信息格式封装、简单的数据读取。这些Netty框架都提供了响应的支持。</li>
<li>JAVA NIO框架存在一个poll/epoll bug: Selector doesn’t block on Selector.select(timeout)，不能block意味着CPU的使用率会变成100%(这是底层JNI的问题，上层要处理这个异常实际上也好办)。当然这个bug只有在Linux内核上才能重现。</li>
<li>这个问题在JDK 1.7版本中还没有被完全解决: <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=2147719%E3%80%82%E8%99%BD%E7%84%B6Netty">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=2147719。虽然Netty</a> 4.0中也是基于JAVA NIO框架进行封装的(上文中已经给出了Netty中NioServerSocketChannel类的介绍)，但是Netty已经将这个bug进行了处理。</li>
<li>其他原因，用过Netty后，您就可以自己进行比较了。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>IO流之BIO</title>
    <url>/posts/4ef4f867/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>BIO就是: blocking IO,同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。最容易理解、最容易实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态</p>
</blockquote>
<a id="more"></a>

<h1 id="传统-BIO"><a href="#传统-BIO" class="headerlink" title="传统 BIO"></a>传统 BIO</h1><p>BIO通信（一请求一应答）模型图如下(图源网络，原出处不明)：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2.png" alt="传统BIO通信模型图"></p>
<p>采用 <strong>BIO 通信模型</strong> 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在<code>while(true)</code> 循环中服务端会调用 <code>accept()</code> 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。</p>
<p>如果要让 <strong>BIO 通信模型</strong> 能够同时处理多个客户端请求，就必须使用多线程（主要原因是<code>socket.accept()</code>、<code>socket.read()</code>、<code>socket.write()</code> 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 <strong>一请求一应答通信模型</strong> 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 <strong>线程池机制</strong> 改善，线程池还可以让线程的创建和回收成本相对较低。使用<code>FixedThreadPool</code> 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），</p>
<p><strong>我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题？</strong></p>
<p>在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p>
<h1 id="伪异步-IO"><a href="#伪异步-IO" class="headerlink" title="伪异步 IO"></a>伪异步 IO</h1><p>为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p>
<p>伪异步IO模型图(图源网络，原出处不明)：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/3.png" alt="伪异步IO模型图"></p>
<p>采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p>
<p>但是使用线程来解决这个问题实际上是有局限性的:</p>
<ul>
<li>虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()的方式还是单个的。也就是，实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来(下文的示例代码和debug过程我们可以明确看到这一点)</li>
<li>在linux系统中，可以创建的线程是有限的。我们可以通过cat /proc/sys/kernel/threads-max 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，CPU切换所需的时间也就越长，用来处理真正业务的需求也就越少。</li>
<li>创建一个线程是有较大的资源消耗的。JVM创建一个线程的时候，即使这个线程不做任何的工作，JVM都会分配一个堆栈空间。这个空间的大小默认为128K，您可以通过-Xss参数进行调整。当然您还可以使用ThreadPoolExecutor线程池来缓解线程的创建问题，但是又会造成BlockingQueue积压任务的持续增加，同样消耗了大量资源。</li>
<li>另外，如果您的应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。 那么，如果你真想单纯使用线程解决阻塞的问题，那么您自己都可以算出来您一个服务器节点可以一次接受多大的并发了。看来，单纯使用线程解决这个问题不是最好的办法。</li>
</ul>
<h1 id="BIO通信方式深入分析"><a href="#BIO通信方式深入分析" class="headerlink" title="BIO通信方式深入分析"></a>BIO通信方式深入分析</h1><p>BIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于accept()、read()的操作点都是被阻塞。要测试这个问题，也很简单。我们模拟了20个客户端(用20根线程模拟)，利用JAVA的同步计数器CountDownLatch，保证这20个客户都初始化完成后然后同时向服务器发送请求，然后我们来观察一下Server这边接受信息的情况。</p>
<h3 id="模拟20个客户端并发请求，服务器端使用单线程"><a href="#模拟20个客户端并发请求，服务器端使用单线程" class="headerlink" title="模拟20个客户端并发请求，服务器端使用单线程:"></a>模拟20个客户端并发请求，服务器端使用单线程:</h3><p>客户端代码(SocketClientDaemon)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testBSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClientDaemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer clientNumber = <span class="number">20</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别开始启动这20个客户端</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span> ; index &lt; clientNumber ; index++ , countDownLatch.countDown()) &#123;</span><br><span class="line">            SocketClientRequestThread client = <span class="keyword">new</span> SocketClientRequestThread(countDownLatch, index);</span><br><span class="line">            <span class="keyword">new</span> Thread(client).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个wait不涉及到具体的实验逻辑，只是为了保证守护线程在启动所有线程后，进入等待状态</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SocketClientDaemon.class) &#123;</span><br><span class="line">            SocketClientDaemon.class.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码(SocketClientRequestThread模拟请求)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testBSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.BasicConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个SocketClientRequestThread线程模拟一个客户端请求。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinwenjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClientRequestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        BasicConfigurator.configure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(SocketClientRequestThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个线层的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countDownLatch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer clientIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * countDownLatch是java提供的同步计数器。</span></span><br><span class="line"><span class="comment">     * 当计数器数值减为0时，所有受其影响而等待的线程将会被激活。这样保证模拟并发请求的真实性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countDownLatch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClientRequestThread</span><span class="params">(CountDownLatch countDownLatch , Integer clientIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        <span class="keyword">this</span>.clientIndex = clientIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream clientRequest = <span class="keyword">null</span>;</span><br><span class="line">        InputStream clientResponse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">83</span>);</span><br><span class="line">            clientRequest = socket.getOutputStream();</span><br><span class="line">            clientResponse = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待，直到SocketClientDaemon完成所有线程的启动，然后所有线程一起发送请求</span></span><br><span class="line">            <span class="keyword">this</span>.countDownLatch.await();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送请求信息</span></span><br><span class="line">            clientRequest.write((<span class="string">&quot;这是第&quot;</span> + <span class="keyword">this</span>.clientIndex + <span class="string">&quot; 个客户端的请求。&quot;</span>).getBytes());</span><br><span class="line">            clientRequest.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在这里等待，直到服务器返回信息</span></span><br><span class="line">            SocketClientRequestThread.LOGGER.info(<span class="string">&quot;第&quot;</span> + <span class="keyword">this</span>.clientIndex + <span class="string">&quot;个客户端的请求发送完成，等待服务器返回信息&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> maxLen = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] contextBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[maxLen];</span><br><span class="line">            <span class="keyword">int</span> realLen;</span><br><span class="line">            String message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//程序执行到这里，会一直等待服务器返回信息(注意，前提是in和out都不能close，如果close了就收不到服务器的反馈了)</span></span><br><span class="line">            <span class="keyword">while</span>((realLen = clientResponse.read(contextBytes, <span class="number">0</span>, maxLen)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                message += <span class="keyword">new</span> String(contextBytes , <span class="number">0</span> , realLen);</span><br><span class="line">            &#125;</span><br><span class="line">            SocketClientRequestThread.LOGGER.info(<span class="string">&quot;接收到来自服务器的信息:&quot;</span> + message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            SocketClientRequestThread.LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(clientRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    clientRequest.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(clientResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    clientResponse.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                SocketClientRequestThread.LOGGER.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端(SocketServer1)单个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testBSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.BasicConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        BasicConfigurator.configure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(SocketServer1.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">83</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//下面我们收取信息</span></span><br><span class="line">                InputStream in = socket.getInputStream();</span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                Integer sourcePort = socket.getPort();</span><br><span class="line">                <span class="keyword">int</span> maxLen = <span class="number">2048</span>;</span><br><span class="line">                <span class="keyword">byte</span>[] contextBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[maxLen];</span><br><span class="line">                <span class="comment">//这里也会被阻塞，直到有数据准备好</span></span><br><span class="line">                <span class="keyword">int</span> realLen = in.read(contextBytes, <span class="number">0</span>, maxLen);</span><br><span class="line">                <span class="comment">//读取信息</span></span><br><span class="line">                String message = <span class="keyword">new</span> String(contextBytes , <span class="number">0</span> , realLen);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//下面打印信息</span></span><br><span class="line">                SocketServer1.LOGGER.info(<span class="string">&quot;服务器收到来自于端口: &quot;</span> + sourcePort + <span class="string">&quot;的信息: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//下面开始发送信息</span></span><br><span class="line">                out.write(<span class="string">&quot;回发响应信息！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//关闭</span></span><br><span class="line">                out.close();</span><br><span class="line">                in.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            SocketServer1.LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="多线程来优化服务器端"><a href="#多线程来优化服务器端" class="headerlink" title="多线程来优化服务器端"></a>多线程来优化服务器端</h3><p>客户端代码和上文一样，最主要是更改服务器端的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testBSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.BasicConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        BasicConfigurator.configure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(SocketServer2.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">83</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">//当然业务处理过程可以交给一个线程(这里可以使用线程池),并且线程的创建是很耗资源的。</span></span><br><span class="line">                <span class="comment">//最终改变不了.accept()只能一个一个接受socket的情况,并且被阻塞的情况</span></span><br><span class="line">                SocketServerThread socketServerThread = <span class="keyword">new</span> SocketServerThread(socket);</span><br><span class="line">                <span class="keyword">new</span> Thread(socketServerThread).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            SocketServer2.LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当然，接收到客户端的socket后，业务的处理过程可以交给一个线程来做。</span></span><br><span class="line"><span class="comment"> * 但还是改变不了socket被一个一个的做accept()的情况。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinwenjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(SocketServerThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServerThread</span> <span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//下面我们收取信息</span></span><br><span class="line">            in = socket.getInputStream();</span><br><span class="line">            out = socket.getOutputStream();</span><br><span class="line">            Integer sourcePort = socket.getPort();</span><br><span class="line">            <span class="keyword">int</span> maxLen = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] contextBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[maxLen];</span><br><span class="line">            <span class="comment">//使用线程，同样无法解决read方法的阻塞问题，</span></span><br><span class="line">            <span class="comment">//也就是说read方法处同样会被阻塞，直到操作系统有数据准备好</span></span><br><span class="line">            <span class="keyword">int</span> realLen = in.read(contextBytes, <span class="number">0</span>, maxLen);</span><br><span class="line">            <span class="comment">//读取信息</span></span><br><span class="line">            String message = <span class="keyword">new</span> String(contextBytes , <span class="number">0</span> , realLen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面打印信息</span></span><br><span class="line">            SocketServerThread.LOGGER.info(<span class="string">&quot;服务器收到来自于端口: &quot;</span> + sourcePort + <span class="string">&quot;的信息: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面开始发送信息</span></span><br><span class="line">            out.write(<span class="string">&quot;回发响应信息！&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            SocketServerThread.LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//试图关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                SocketServerThread.LOGGER.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="看看服务器端的执行效果"><a href="#看看服务器端的执行效果" class="headerlink" title="看看服务器端的执行效果"></a>看看服务器端的执行效果</h3><p>我们主要看一看服务器使用多线程处理时的情况:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-bio-3.png" alt="img"></p>
<h3 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h3><p>那么重点的问题并不是“是否使用了多线程”，而是为什么accept()、read()方法会被阻塞。即: 异步IO模式 就是为了解决这样的并发性存在的。但是为了说清楚异步IO模式，在介绍IO模式的时候，我们就要首先了解清楚，什么是 阻塞式同步、非阻塞式同步、多路复用同步模式。</p>
<p>API文档中对于 serverSocket.accept() 方法的使用描述:</p>
<blockquote>
<p>Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made.</p>
</blockquote>
<p>serverSocket.accept()会被阻塞? 这里涉及到阻塞式同步IO的工作原理:</p>
<ul>
<li>服务器线程发起一个accept动作，询问操作系统 是否有新的socket套接字信息从端口X发送过来。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/io/java-io-bio-4.png" alt="img"></p>
<ul>
<li>注意，是询问操作系统。也就是说socket套接字的IO模式支持是基于操作系统的，那么自然同步IO/异步IO的支持就是需要操作系统级别的了。如下图:</li>
</ul>
<p><img src="https://www.pdai.tech/_images/io/java-io-bio-5.png" alt="img"></p>
<p><img src="https://www.pdai.tech/_images/io/java-io-bio-6.png" alt="img"></p>
<p>如果操作系统没有发现有套接字从指定的端口X来，那么操作系统就会等待。这样serverSocket.accept()方法就会一直等待。这就是为什么accept()方法为什么会阻塞: 它内部的实现是使用的操作系统级别的同步IO。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>BIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC锁之AQS框架</title>
    <url>/posts/9b690daf/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>AQS框架的源码详解</p>
</blockquote>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>AQS是AbstractQueuedSynchronizer的缩写，是java.util.concurrent（简称 JUC）包下的一个抽象类；它是我们构建锁和同步器的一个框架</p>
</blockquote>
<p>AQS解决了实现同步器时涉及到的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><blockquote>
<p>AQS的核心思想就如果请求的共享资源空闲，那么就将当前申请的线程作为工作线程并将共享资源上锁；如果共享资源已被占用，那么就需要一套线程阻塞和唤醒时锁分配的机制来对锁进行分配和管理</p>
</blockquote>
<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）</p>
<h3 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h3><ul>
<li><p>独占式(Exclusive)：锁在同一时间只能被一个线程占有，如ReentrantLock；</p>
</li>
<li><p>共享式(Share)：锁可以被多个线程同时占有，如Semaphore/CountDownLatch）</p>
</li>
</ul>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>AQS利用设计模式里的模板模式，他将一个同步器的大体框架已经搭建好了，我们 只需要根据我们要具体实现的同步器的情况来重写几个方法就行了，下面是需要重写的几个方法</p>
<ul>
<li>**isHeldExclusively()**：该线程是否正在独占资源，只有用到condition才用实现它</li>
<li>**tryAcquire(int)**：独占方式，尝试获取锁，成功返回true，失败false</li>
<li>**tryRelease(int)**：独占方式,尝试释放资源，成功true，失败false</li>
<li>**tryacquireShared(int)**：共享方式，尝试获取资源，负数代表失败，0代表成功，但无资源可用，正数代表成功，且有资源可用</li>
<li>**tryReleaseShared(int)**：共享方式，尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false</li>
</ul>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<h2 id="同步状态（state）"><a href="#同步状态（state）" class="headerlink" title="同步状态（state）"></a>同步状态（state）</h2><p>AQS通过一个int类型的成员变量state来表示同步状态，当state&gt;0时，表示获取了锁；当state=0时，表示释放了锁，AQS通过3种方法来保证同步状态更新的安全性：</p>
<ul>
<li>getState()：返回同步状态的当前值；</li>
<li>setState(int newState)：设置当前同步状态；</li>
<li>compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li>
</ul>
<h2 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h2><blockquote>
<p>CLH(就是3个人名)是一个FIFO（先进先出）的双端队列，AQS依赖它来完成同步状态的管理，当线程获取同步器失败时AQS会将当前线程以及等待状态等信息打包成一个节点，加入到CLH的队列，同时阻塞当前线程，当同步器释放锁唤醒同步队列里的首个线程，让其再次获取同步状态</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/13/16efec71afe8c4b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Picture1.png"></p>
<p>在同步队列CLH中，一个结点对应一个线程，它保存着线程的引用(Thread)，状态(WaitStatus)，前驱结点(prev)，后继节点(next);</p>
<p>在CLH里线程一共有5种状态：</p>
<ul>
<li><strong>CANCELLED 值为1，表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化</strong>；场景：当线程等待超时或被中断，需从等待队列里取消等待，则该线程状态被置为一，</li>
<li><strong>SINGLE 值为-1，表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL</strong>；场景：后继的节点处于等待状态，当前节点的线程如果释放了同步状态或者被取消（当前节点状态置为-1），将会通知后继节点，使后继节点的线程得以运行；</li>
<li><strong>CONDITION，值为-2，表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁；</strong>场景：节点处于等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，该节点从等待队列中转移到同步队列中，加入到对同步状态的获取中</li>
<li><strong>PROPAGATE，值为-3，共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点；</strong>场景：表示下一次的共享状态会被无条件的传播下去；</li>
<li><strong>INITIAL，值为0，初始状态。</strong></li>
</ul>
<p>在AQS中维护了两个变量head和tial，它们分别指向同步队列的头结点和尾结点。</p>
<h1 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h1><h2 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a>acquire(int)</h2><blockquote>
<p>此方法是独占模式的线程获取资源的顶级入口。如果获取到资源，则直接返回，否则进入等待队列，直到获取资源为止，且整个过程忽略中断影响。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法流程如下：</p>
<p><strong>a.首先，调用使用者重写的tryAcquire方法（该方法必须要保证线程安全的获取同步状态。），若返回true，意味着获取同步状态成功，后面的逻辑不再执行；若返回false，也就是获取同步状态失败，进入b步骤；</strong></p>
<p><strong>b.此时，获取同步状态失败，构造独占式同步结点，通过addWaiter将此结点添加到同步队列的尾部（此时可能会有多个线程结点试图加入同步队列尾部，需要以线程安全的方式添加）；</strong></p>
<p><strong>c.acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</strong></p>
<p><strong>d.如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</strong></p>
<h3 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h3><p>此方法去尝试获取资源。如果获取成功，返回true，否则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现</strong>就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p>
<p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p>
<h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试快速方式直接放到队尾。</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//如果尾结点不为空，CAS快速尝试在尾部添加，若CAS设置成功，返回；否则，enq。</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一步失败则通过enq入队。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先cas快速设置，若失败，进入enq方法　　</p>
<p>将结点添加到同步队列尾部这个操作，同时可能会有多个线程尝试添加到尾部，是非线程安全的操作。</p>
<p>以上代码可以看出，使用了compareAndSetTail这个cas操作保证安全添加尾结点。</p>
<hr>
<p>**enq(Node)**方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CAS&quot;自旋&quot;，直到成功加入队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常流程，放入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enq内部是个死循环，通过CAS设置尾结点，不成功就一直重试。很经典的CAS自旋的用法，这是一种<strong>乐观的并发策略</strong>。</p>
<h3 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h3><p>通过前面的<strong>tryAcquire</strong>方法和addWaiter方法，获取资源失败，线程已经进入等待队列，接下来要做的就是进入等待状态，直到线程被唤醒再去获取资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//又是一个“自旋”！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line">            <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 成功获取资源</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="shouldParkAfterFailedAcquire-Node-Node"><a href="#shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="shouldParkAfterFailedAcquire(Node, Node)"></a>shouldParkAfterFailedAcquire(Node, Node)</h4><p>此方法用来检查状态，看自己是否可以进入等待状态(Waiting)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h4><p>真正进入等待状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);<span class="comment">//调用park()使线程进入waiting状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();<span class="comment">//如果被唤醒，查看自己是不是被中断的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结下该函数的具体流程：</p>
<ol>
<li>结点进入队尾后，检查状态，找到安全休息点；</li>
<li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li>
<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li>
</ol>
<h3 id="Acquire小结"><a href="#Acquire小结" class="headerlink" title="Acquire小结"></a>Acquire小结</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/13/16efec71b0a7c39a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Picture1.png"></p>
<h2 id="release-int"><a href="#release-int" class="headerlink" title="release(int)"></a>release(int)</h2><blockquote>
<p>是独占模式释放资源的顶层入口，它会释放指定量的资源，如果彻底释放了(state=0)，它会唤醒队列里的其他线程来获取资源    </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;<span class="comment">//找到头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，就是调用tryRelease来释放资源，但需要注意的是，它是<strong>根据tryRelase的返回值来确定是否释放了资源</strong>，所以我们在实现同步器的时候需要注意这一点</p>
<h3 id="tryRelease-int"><a href="#tryRelease-int" class="headerlink" title="tryRelease(int)"></a>tryRelease(int)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，<strong>release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！</strong>所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p>
<h3 id="unparkSuccessor-Node"><a href="#unparkSuccessor-Node" class="headerlink" title="unparkSuccessor(Node)"></a>unparkSuccessor(Node)</h3><p>用于唤醒队列中的下一个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从后向前找。</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一句话概括：<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程</strong>，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p>
<p>获取锁的线程在什么情形下会release抛出异常呢？？</p>
<ol>
<li>线程突然死掉了？可以通过thread.stop来停止线程的执行，但该函数的执行条件要严苛的多，而且函数注明是非线程安全的，已经标明Deprecated；</li>
<li>线程被interupt了？线程在运行态是不响应中断的，所以也不会抛出异常；</li>
</ol>
<h2 id="acquireShared-int"><a href="#acquireShared-int" class="headerlink" title="acquireShared(int)"></a>acquireShared(int)</h2><p>此方法是共享模式获取资源的顶层入口，它会 获取指定量的资源，获取成功则返回true，失败则进入等待队列，直到获取资源为止，整个过程忽略中断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p>
<ol>
<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>
<li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li>
</ol>
<h3 id="doAcquireShared-int"><a href="#doAcquireShared-int" class="headerlink" title="doAcquireShared(int)"></a>doAcquireShared(int)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//加入队列尾部</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//是否成功标志</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//等待过程中是否被中断过的标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//前驱</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">//尝试获取资源</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);<span class="comment">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)<span class="comment">//如果等待过程中被打断过，此时将中断补上。</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与acquireQueued()流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外。</p>
<p>　　跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p>
<h3 id="setHeadAndPropagate-Node-int"><a href="#setHeadAndPropagate-Node-int" class="headerlink" title="setHeadAndPropagate(Node, int)"></a>setHeadAndPropagate(Node, int)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    setHead(node);<span class="comment">//head指向自己</span></span><br><span class="line">     <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p>
<h2 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared()"></a>releaseShared()</h2><blockquote>
<p>此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放资源</span></span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p>
<h3 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于doReleaseShared的几点分析：</p>
<ol>
<li><strong>调用该方法的线程可能有很多</strong>：在共享锁中，持有共享锁的线程可以有多个，这些线程都可以调用releaseShared方法释放锁；而这些线程想要获得共享锁，则它们必然曾经成为过头节点，或者就是现在的头节点。因此，如果是在releaseShared方法中调用的doReleaseShared，可能此时调用方法的线程已经不是头节点所代表的线程了，头节点可能已经被易主好几次了。</li>
<li><strong>调用该方法的目的</strong>：无论是在acquireShared中调用，还是在releaseShared方法中调用，该方法的目的都是在当前共享锁是可获取的状态时，唤醒head节点的下一个节点。这一点看上去和独占锁似乎一样，但是它们的一个重要的差别是——在共享锁中，当头节点发生变化时，是会回到循环中再立即唤醒head节点的下一个节点的。也就是说，在当前节点完成唤醒后继节点的任务之后将要退出时，如果发现被唤醒后继节点已经成为了新的头节点，则会立即触发唤醒head节点的下一个节点的操作，如此周而复始。</li>
<li><strong>只有在当前head没有易主时，才会退出，否则继续循环</strong>。因为当前可能有多个线程在队列中，比如A -&gt; B -&gt; C -&gt; D， 如果A唤醒B，则B成为新的头节点，接着B会调用doReleaseShared去唤醒C，此时A线程中的head变成了C，因此也加入到了唤醒D的队伍中，此时可能出现A、B、C同时唤醒D的情况，提高了系统效率。当队列中的所有线程都唤醒之后，此时程序退出。</li>
</ol>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>AQS是JUC中很多同步组件的构建基础，简单来讲，它<strong>内部实现主要是状态变量state和一个FIFO队列来完成</strong>，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。</p>
<p>AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞/唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。　</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之原子类</title>
    <url>/posts/f956818d/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>JUC中多数类是通过volatile和CAS来实现的，CAS本质上提供的是一种无锁方案，而Synchronized和Lock是互斥锁方案; java原子类本质上使用的是CAS，而CAS底层是通过Unsafe类实现的</p>
</blockquote>
<a id="more"></a>

<h1 id="UnSafe类详解"><a href="#UnSafe类详解" class="headerlink" title="UnSafe类详解"></a>UnSafe类详解</h1><p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p>
<p>这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p>
<p>先来看下这张图，对UnSafe类总体功能：</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-atomicinteger-unsafe.png" alt="img"></p>
<p>如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。</p>
<h3 id="Unsafe与CAS"><a href="#Unsafe与CAS" class="headerlink" title="Unsafe与CAS"></a>Unsafe与CAS</h3><p>反编译出来的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      i = getIntVolatile(paramObject, paramLong);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      l = getLongVolatile(paramObject, paramLong1);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapLong(paramObject, paramLong1, l, l + paramLong2));</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      i = getIntVolatile(paramObject, paramLong);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapInt(paramObject, paramLong, i, paramInt));</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSetLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      l = getLongVolatile(paramObject, paramLong1);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapLong(paramObject, paramLong1, l, paramLong2));</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Object localObject;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      localObject = getObjectVolatile(paramObject1, paramLong);</span><br><span class="line">    <span class="keyword">while</span> (!compareAndSwapObject(paramObject1, paramLong, localObject, paramObject2));</span><br><span class="line">    <span class="keyword">return</span> localObject;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从源码中发现，内部使用自旋的方式进行CAS更新(while循环进行CAS更新，如果更新失败，则循环再次重试)。</p>
<p>又从Unsafe类中发现，原子操作其实只支持下面三个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2, <span class="keyword">long</span> paramLong3)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong。都是native方法。</p>
<h3 id="Unsafe底层"><a href="#Unsafe底层" class="headerlink" title="Unsafe底层"></a>Unsafe底层</h3><p>不妨再看看Unsafe的compareAndSwap*方法来实现CAS操作，它是一个本地方法，实现位于unsafe.cpp中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>可以看到它通过 <code>Atomic::cmpxchg</code> 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。</p>
<p>如果是Linux的x86，<code>Atomic::cmpxchg</code>方法的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而windows的x86的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mp = os::isMP(); <span class="comment">//判断是否是多处理器</span></span><br><span class="line">    _asm &#123;</span><br><span class="line">        mov edx, dest</span><br><span class="line">        mov ecx, exchange_value</span><br><span class="line">        mov eax, compare_value</span><br><span class="line">        LOCK_IF_MP(mp)</span><br><span class="line">        cmpxchg dword ptr [edx], ecx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="comment">// VC++ doesn&#x27;t like the lock prefix to be on a single line</span></span><br><span class="line"><span class="comment">// so we can&#x27;t insert a label after the lock prefix.</span></span><br><span class="line"><span class="comment">// By emitting a lock prefix, we can define a label after it.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit <span class="number">0xF0</span> \</span><br><span class="line">                       __asm L0:</span><br></pre></td></tr></table></figure>
<p>如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。</p>
<blockquote>
<p>cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在Intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。</p>
</blockquote>
<h3 id="Unsafe其它功能"><a href="#Unsafe其它功能" class="headerlink" title="Unsafe其它功能"></a>Unsafe其它功能</h3><p>Unsafe 提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过 Java 本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。</p>
<p>举两个例子，比方说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field paramField)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个方法可以用来获取给定的 paramField 的内存地址偏移量，这个值对于给定的 field 是唯一的且是固定不变的。</p>
<p>再比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class paramClass)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class paramClass)</span></span>;</span><br></pre></td></tr></table></figure>
<p>前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。</p>
<p>最后看三个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> paramLong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> paramLong)</span></span>;</span><br></pre></td></tr></table></figure>
<p>分别用来分配内存，扩充内存和释放内存的。</p>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><h3 id="Atomic-原子类介绍"><a href="#Atomic-原子类介绍" class="headerlink" title="Atomic 原子类介绍"></a>Atomic 原子类介绍</h3><p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88.png" alt="JUC原子类概览"></p>
<p>根据操作的数据类型，可以将JUC包中的原子类分为4类</p>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整型数组原子类</li>
<li>AtomicLongArray：长整型数组原子类</li>
<li>AtomicReferenceArray ：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来</li>
<li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">AtomicMarkableReference是将一个boolean值作是否有更改的标记，本质就是它的版本号只有两个，true和false，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修改的时候在这两个版本号之间来回切换，这样做并不能解决ABA的问题，只是会降低ABA问题发生的几率而已</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolveABAByAtomicMarkableReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AtomicMarkableReference atomicMarkableReference = <span class="keyword">new</span> AtomicMarkableReference(<span class="number">100</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Thread refT1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicMarkableReference.isMarked(), !atomicMarkableReference.isMarked());</span><br><span class="line">                atomicMarkableReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicMarkableReference.isMarked(), !atomicMarkableReference.isMarked());</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread refT2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">boolean</span> marked = atomicMarkableReference.isMarked();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> c3 = atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, marked, !marked);</span><br><span class="line">                System.out.println(c3); <span class="comment">// 返回true,实际应该返回false</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            refT1.start();</span><br><span class="line">            refT2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>CAS ABA 问题</strong></p>
<ul>
<li>描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。</li>
<li>例子描述(可能不太合适，但好理解): 年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！</li>
<li>代码例子（以<code>AtomicInteger</code>为例）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDefectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        defectOfABA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">defectOfABA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread coreThread = <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> currentValue = atomicInteger.get();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这段目的：模拟处理其他业务花费的时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">boolean</span> casResult = atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue</span><br><span class="line">                            + <span class="string">&quot;, finalValue=&quot;</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">&quot;, compareAndSet Result=&quot;</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        coreThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这段目的：为了让 coreThread 线程先跑起来</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread amateurThread = <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">int</span> currentValue = atomicInteger.get();</span><br><span class="line">                    <span class="keyword">boolean</span> casResult = atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue</span><br><span class="line">                            + <span class="string">&quot;, finalValue=&quot;</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">&quot;, compareAndSet Result=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">                    currentValue = atomicInteger.get();</span><br><span class="line">                    casResult = atomicInteger.compareAndSet(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue</span><br><span class="line">                            + <span class="string">&quot;, finalValue=&quot;</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">&quot;, compareAndSet Result=&quot;</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        amateurThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出内容如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Thread-0 ------ <span class="attribute">currentValue</span>=1</span><br><span class="line">Thread-1 ------ <span class="attribute">currentValue</span>=1, <span class="attribute">finalValue</span>=2, compareAndSet <span class="attribute">Result</span>=<span class="literal">true</span></span><br><span class="line">Thread-1 ------ <span class="attribute">currentValue</span>=2, <span class="attribute">finalValue</span>=1, compareAndSet <span class="attribute">Result</span>=<span class="literal">true</span></span><br><span class="line">Thread-0 ------ <span class="attribute">currentValue</span>=1, <span class="attribute">finalValue</span>=2, compareAndSet <span class="attribute">Result</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>下面我们来详细介绍一下这些原子类。</p>
<h3 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h3><h4 id="基本类型原子类介绍"><a href="#基本类型原子类介绍" class="headerlink" title="基本类型原子类介绍"></a>基本类型原子类介绍</h4><p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicInteger 为例子来介绍。</p>
<p><strong>AtomicInteger 类常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>
<h4 id="AtomicInteger-常见方法使用"><a href="#AtomicInteger-常见方法使用" class="headerlink" title="AtomicInteger 常见方法使用"></a>AtomicInteger 常见方法使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span> temvalue = <span class="number">0</span>;</span><br><span class="line">        AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        temvalue = i.getAndSet(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);<span class="comment">//temvalue:0;  i:3</span></span><br><span class="line">        temvalue = i.getAndIncrement();</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);<span class="comment">//temvalue:3;  i:4</span></span><br><span class="line">        temvalue = i.getAndAdd(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);<span class="comment">//temvalue:4;  i:9</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基本数据类型原子类的优势"><a href="#基本数据类型原子类的优势" class="headerlink" title="基本数据类型原子类的优势"></a>基本数据类型原子类的优势</h4><p>通过一个简单例子带大家看一下基本数据类型原子类的优势</p>
<p><strong>①多线程环境不使用原子类保证线程安全（基本数据类型）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若要线程安全执行执行count++，需要加锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  count++; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>②多线程环境使用原子类保证线程安全（基本数据类型）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AtomicInteger-线程安全原理简单分析"><a href="#AtomicInteger-线程安全原理简单分析" class="headerlink" title="AtomicInteger 线程安全原理简单分析"></a>AtomicInteger 线程安全原理简单分析</h4><p>AtomicInteger 类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>
<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h3 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h3><h4 id="数组类型原子类介绍"><a href="#数组类型原子类介绍" class="headerlink" title="数组类型原子类介绍"></a>数组类型原子类介绍</h4><p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray ：引用类型数组原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。</p>
<p><strong>AtomicIntegerArray 类常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>
<h4 id="AtomicIntegerArray-常见方法使用"><a href="#AtomicIntegerArray-常见方法使用" class="headerlink" title="AtomicIntegerArray 常见方法使用"></a>AtomicIntegerArray 常见方法使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span> temvalue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        AtomicIntegerArray i = <span class="keyword">new</span> AtomicIntegerArray(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            System.out.println(i.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        temvalue = i.getAndSet(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">        temvalue = i.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">        temvalue = i.getAndAdd(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h3><h4 id="引用类型原子类介绍"><a href="#引用类型原子类介绍" class="headerlink" title="引用类型原子类介绍"></a>引用类型原子类介绍</h4><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicReference 为例子来介绍。</p>
<h4 id="AtomicReference-类使用示例"><a href="#AtomicReference-类使用示例" class="headerlink" title="AtomicReference 类使用示例"></a>AtomicReference 类使用示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference&lt;Person&gt; ar = <span class="keyword">new</span> AtomicReference&lt;Person&gt;();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;SnailClimb&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        ar.set(person);</span><br><span class="line">        Person updatePerson = <span class="keyword">new</span> Person(<span class="string">&quot;Daisy&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        ar.compareAndSet(person, updatePerson);</span><br><span class="line"></span><br><span class="line">        System.out.println(ar.get().getName());</span><br><span class="line">        System.out.println(ar.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson。实现原理与 AtomicInteger 类中的 compareAndSet 方法相同。运行上面的代码后的输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Daisy</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h4 id="AtomicStampedReference-类使用示例"><a href="#AtomicStampedReference-类使用示例" class="headerlink" title="AtomicStampedReference 类使用示例]"></a>AtomicStampedReference 类使用示例]</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> Integer initialRef = <span class="number">0</span>, initialStamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicStampedReference&lt;Integer&gt; asr = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> Integer newReference = <span class="number">666</span>, newStamp = <span class="number">999</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> casResult = asr.compareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, casResult=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 stamp 值</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> Integer currentValue = asr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> currentStamp = arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + currentValue + <span class="string">&quot;, currentStamp=&quot;</span> + currentStamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> attemptStampResult = asr.attemptStamp(newReference, <span class="number">88</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, attemptStampResult=&quot;</span> + attemptStampResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 stamp 值</span></span><br><span class="line">        asr.set(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span></span><br><span class="line">        <span class="comment">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span></span><br><span class="line">        <span class="comment">// 但是注释上写着 &quot;May fail spuriously and does not provide ordering guarantees,</span></span><br><span class="line">        <span class="comment">// so is only rarely an appropriate alternative to compareAndSet.&quot;</span></span><br><span class="line">        <span class="comment">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wCasResult = asr.weakCompareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, wCasResult=&quot;</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">currentValue</span>=0, <span class="attribute">currentStamp</span>=0</span><br><span class="line"><span class="attribute">currentValue</span>=666, <span class="attribute">currentStamp</span>=999, <span class="attribute">casResult</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">currentValue</span>=666, <span class="attribute">currentStamp</span>=999</span><br><span class="line"><span class="attribute">currentValue</span>=666, <span class="attribute">currentStamp</span>=88, <span class="attribute">attemptStampResult</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">currentValue</span>=0, <span class="attribute">currentStamp</span>=0</span><br><span class="line"><span class="attribute">currentValue</span>=666, <span class="attribute">currentStamp</span>=999, <span class="attribute">wCasResult</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="AtomicMarkableReference-类使用示例"><a href="#AtomicMarkableReference-类使用示例" class="headerlink" title="AtomicMarkableReference 类使用示例"></a>AtomicMarkableReference 类使用示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicMarkableReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> Boolean initialRef = <span class="keyword">null</span>, initialMark = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicMarkableReference&lt;Boolean&gt; amr = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> Boolean newReference1 = <span class="keyword">true</span>, newMark1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> casResult = amr.compareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, casResult=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 mark 值</span></span><br><span class="line">        <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> Boolean currentValue = amr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> currentMark = arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + currentValue + <span class="string">&quot;, currentMark=&quot;</span> + currentMark);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> attemptMarkResult = amr.attemptMark(newReference1, <span class="keyword">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, attemptMarkResult=&quot;</span> + attemptMarkResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 mark 值</span></span><br><span class="line">        amr.set(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span></span><br><span class="line">        <span class="comment">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span></span><br><span class="line">        <span class="comment">// 但是注释上写着 &quot;May fail spuriously and does not provide ordering guarantees,</span></span><br><span class="line">        <span class="comment">// so is only rarely an appropriate alternative to compareAndSet.&quot;</span></span><br><span class="line">        <span class="comment">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wCasResult = amr.weakCompareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, wCasResult=&quot;</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">currentValue</span>=<span class="literal">null</span>, <span class="attribute">currentMark</span>=<span class="literal">false</span></span><br><span class="line"><span class="attribute">currentValue</span>=<span class="literal">true</span>, <span class="attribute">currentMark</span>=<span class="literal">true</span>, <span class="attribute">casResult</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">currentValue</span>=<span class="literal">true</span>, <span class="attribute">currentMark</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">currentValue</span>=<span class="literal">true</span>, <span class="attribute">currentMark</span>=<span class="literal">false</span>, <span class="attribute">attemptMarkResult</span>=<span class="literal">true</span></span><br><span class="line"><span class="attribute">currentValue</span>=<span class="literal">null</span>, <span class="attribute">currentMark</span>=<span class="literal">false</span></span><br><span class="line"><span class="attribute">currentValue</span>=<span class="literal">true</span>, <span class="attribute">currentMark</span>=<span class="literal">true</span>, <span class="attribute">wCasResult</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="对象的属性修改类型原子类"><a href="#对象的属性修改类型原子类" class="headerlink" title="对象的属性修改类型原子类"></a>对象的属性修改类型原子类</h3><h4 id="对象的属性修改类型原子类介绍"><a href="#对象的属性修改类型原子类介绍" class="headerlink" title="对象的属性修改类型原子类介绍"></a>对象的属性修改类型原子类介绍</h4><p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p>
<ul>
<li>AtomicIntegerFieldUpdater:原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
<li>AtomicReferenceFieldUpdater ：原子更新引用类型里的字段的更新器</li>
</ul>
<p>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。</p>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code>为例子来介绍。</p>
<h4 id="AtomicIntegerFieldUpdater-类使用示例"><a href="#AtomicIntegerFieldUpdater-类使用示例" class="headerlink" title="AtomicIntegerFieldUpdater 类使用示例"></a>AtomicIntegerFieldUpdater 类使用示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;Java&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">        System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>原子类</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC锁之ReentrantReadWriteLock</title>
    <url>/posts/ceba1a8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>ReentrantReadWriteLock锁的源码详解</p>
</blockquote>
<a id="more"></a>

<h1 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回用于读取操作的锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//返回用于写入操作的锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。</strong></p>
<p><strong>JAVA的并发包提供了读写锁ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</strong></p>
<h3 id="线程进入读锁的前提条件："><a href="#线程进入读锁的前提条件：" class="headerlink" title="线程进入读锁的前提条件："></a>线程进入读锁的前提条件：</h3><p>没有其他线程的写锁，</p>
<p>没有写请求或者<strong>有写请求，但调用线程和持有锁的线程是同一个。</strong></p>
<h3 id="线程进入写锁的前提条件："><a href="#线程进入写锁的前提条件：" class="headerlink" title="线程进入写锁的前提条件："></a>线程进入写锁的前提条件：</h3><p>没有其他线程的读锁</p>
<p>没有其他线程的写锁</p>
<h3 id="读写锁的一些特性"><a href="#读写锁的一些特性" class="headerlink" title="读写锁的一些特性"></a>读写锁的一些特性</h3><ol>
<li><strong>公平选择性：支持公平和非公平的获取锁的方式；</strong></li>
<li><strong>支持可重入。</strong>读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</li>
<li><strong>支持“锁降级”，</strong>允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</li>
<li>读取锁和写入锁都支持锁获取期间的中断；</li>
<li>Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException。 </li>
</ol>
<h1 id="ReentrantReadWriteLock实现"><a href="#ReentrantReadWriteLock实现" class="headerlink" title="ReentrantReadWriteLock实现"></a>ReentrantReadWriteLock实现</h1><p>我们先来看下 ReentrantReadWriteLock 类的整体结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 读锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 写锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回用于写入操作的锁 */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 返回用于读取操作的锁 */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantReadWriteLock有五个内部类，五个内部类之间也是相互关联的。内部类的关系如下图所示。</p>
<p><img src="https://images2015.cnblogs.com/blog/616953/201604/616953-20160421204144304-278034246.png" alt="img"></p>
<p>说明：如上图所示，Sync继承自AQS、NonfairSync继承自Sync类、FairSync继承自Sync类（通过构造函数传入的布尔值决定要构造哪一种Sync实例）；ReadLock实现了Lock接口、WriteLock也实现了Lock接口。</p>
<p>ReentrantReadWriteLock在内部也是利用了AQS进行锁的竞争与释放，同时也实现了ReadWriteLock接口。</p>
<hr>
<p>为了同时保存读锁和写锁的状态，在内部用一个int保存读和写的状态。读状态从高16位读出，写状态从低16位读出，在保证读写锁互斥的前提下，直接利用了AQS现有的数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;        </span><br><span class="line">    <span class="comment">// 高16位为读锁，低16位为写锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 读锁单位</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="comment">// 读锁最大数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 写锁最大数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 本地线程计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">    <span class="comment">// 缓存的计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">    <span class="comment">// 第一个读线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 第一个读线程的计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://user-gold-cdn.xitu.io/2019/12/13/16efec7253307eec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a><strong>写锁的获取与释放</strong></h2><p>看下WriteLock类中的lock和unlock方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到就是调用的独占式同步状态的获取与释放，因此真实的实现就是Sync的 tryAcquire和 tryRelease。</p>
<h3 id="写锁的获取，看下tryAcquire："><a href="#写锁的获取，看下tryAcquire：" class="headerlink" title="写锁的获取，看下tryAcquire："></a><strong>写锁的获取，看下tryAcquire：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">//当前线程</span></span><br><span class="line"> <span class="number">3</span>     Thread current = Thread.currentThread();</span><br><span class="line"> <span class="number">4</span>     <span class="comment">//获取状态</span></span><br><span class="line"> <span class="number">5</span>     <span class="keyword">int</span> c = getState();</span><br><span class="line"> <span class="number">6</span>     <span class="comment">//写线程数量（即获取独占锁的重入数）</span></span><br><span class="line"> <span class="number">7</span>     <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line"> <span class="number">8</span>     </span><br><span class="line"> <span class="number">9</span>     <span class="comment">//当前同步状态state != 0，说明已经有其他线程获取了读锁或写锁</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">11</span>         <span class="comment">// 当前state不为0，此时：如果写锁状态为0说明读锁此时被占用返回false；</span></span><br><span class="line"><span class="number">12</span>         <span class="comment">// 如果写锁状态不为0且写锁没有被当前线程持有返回false</span></span><br><span class="line"><span class="number">13</span>         <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line"><span class="number">14</span>             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">15</span>         </span><br><span class="line"><span class="number">16</span>         <span class="comment">//判断同一线程获取写锁是否超过最大次数（65535），支持可重入</span></span><br><span class="line"><span class="number">17</span>         <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line"><span class="number">18</span>             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"><span class="number">19</span>         <span class="comment">//更新状态</span></span><br><span class="line"><span class="number">20</span>         <span class="comment">//此时当前线程已持有写锁，现在是重入，所以只需要修改锁的数量即可。</span></span><br><span class="line"><span class="number">21</span>         setState(c + acquires);</span><br><span class="line"><span class="number">22</span>         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span>     </span><br><span class="line"><span class="number">25</span>     <span class="comment">//到这里说明此时c=0,读锁和写锁都没有被获取</span></span><br><span class="line"><span class="number">26</span>     <span class="comment">//writerShouldBlock表示是否阻塞</span></span><br><span class="line"><span class="number">27</span>     <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line"><span class="number">28</span>         !compareAndSetState(c, c + acquires))</span><br><span class="line"><span class="number">29</span>         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">30</span>     </span><br><span class="line"><span class="number">31</span>     <span class="comment">//设置锁为当前线程所有</span></span><br><span class="line"><span class="number">32</span>     setExclusiveOwnerThread(current);</span><br><span class="line"><span class="number">33</span>     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure>
<p>其中exclusiveCount方法表示占有写锁的线程数量，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>
<p>说明：直接将状态state和（2^16 - 1）做与运算，其等效于将state模上2^16。写锁数量由state的低十六位表示。</p>
<p>从源代码可以看出，获取写锁的步骤如下：</p>
<p>（1）首先获取c、w。c表示当前锁状态；w表示写线程数量。然后判断同步状态state是否为0。如果state!=0，说明已经有其他线程获取了读锁或写锁，执行(2)；否则执行(5)。</p>
<p>（2）如果锁状态不为零（c != 0），而写锁的状态为0（w = 0），说明读锁此时被其他线程占用，所以当前线程不能获取写锁，自然返回false。或者锁状态不为零，而写锁的状态也不为0，但是获取写锁的线程不是当前线程，则当前线程也不能获取写锁。</p>
<p>（3）判断当前线程获取写锁是否超过最大次数，若超过，抛异常，反之更新同步状态（此时当前线程已获取写锁，更新是线程安全的），返回true。</p>
<p>（4）如果state为0，此时读锁或写锁都没有被获取，判断是否需要阻塞（公平和非公平方式实现不同），在非公平策略下总是不会被阻塞，在公平策略下会进行判断（判断同步队列中是否有等待时间更长的线程，若存在，则需要被阻塞，否则，无需阻塞），如果不需要阻塞，则CAS更新同步状态，若CAS成功则返回true，失败则说明锁被别的线程抢去了，返回false。如果需要阻塞则也返回false。</p>
<p>（5）成功获取写锁后，将当前线程设置为占有写锁的线程，返回true。</p>
<p>方法流程图如下：</p>
<p><img src="https://images2018.cnblogs.com/blog/249993/201806/249993-20180607130802005-1386429088.png" alt="img"></p>
<h3 id="写锁的释放，tryRelease方法："><a href="#写锁的释放，tryRelease方法：" class="headerlink" title="写锁的释放，tryRelease方法："></a><strong>写锁的释放，tryRelease方法：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">//若锁的持有者不是当前线程，抛出异常</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line"> <span class="number">4</span>         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"> <span class="number">5</span>     <span class="comment">//写锁的新线程数</span></span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line"> <span class="number">7</span>     <span class="comment">//如果独占模式重入数为0了，说明独占模式被释放</span></span><br><span class="line"> <span class="number">8</span>     <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">if</span> (free)</span><br><span class="line"><span class="number">10</span>         <span class="comment">//若写锁的新线程数为0，则将锁的持有者设置为null</span></span><br><span class="line"><span class="number">11</span>         setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">12</span>     <span class="comment">//设置写锁的新线程数</span></span><br><span class="line"><span class="number">13</span>     <span class="comment">//不管独占模式是否被释放，更新独占重入数</span></span><br><span class="line"><span class="number">14</span>     setState(nextc);</span><br><span class="line"><span class="number">15</span>     <span class="keyword">return</span> free;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure>
<p>  写锁的释放过程还是相对而言比较简单的：首先查看当前线程是否为写锁的持有者，如果不是抛出异常。然后检查释放后写锁的线程数是否为0，如果为0则表示写锁空闲了，释放锁资源将锁的持有线程设置为null，否则释放仅仅只是一次重入锁而已，并不能将写锁的线程清空。</p>
<p>  说明：此方法用于释放写锁资源，首先会判断该线程是否为独占线程，若不为独占线程，则抛出异常，否则，计算释放资源后的写锁的数量，若为0，表示成功释放，资源不将被占用，否则，表示资源还被占用。其方法流程图如下。</p>
<p><img src="https://images2018.cnblogs.com/blog/249993/201806/249993-20180607131006282-1633551158.png" alt="img"></p>
<h2 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a><strong>读锁的获取与释放</strong></h2><p>类似于写锁，读锁的lock和unlock的实际实现对应Sync的 tryAcquireShared 和 tryReleaseShared方法。</p>
<h3 id="读锁的获取，看下tryAcquireShared方法"><a href="#读锁的获取，看下tryAcquireShared方法" class="headerlink" title="读锁的获取，看下tryAcquireShared方法"></a><strong>读锁的获取，看下tryAcquireShared方法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">// 获取当前线程</span></span><br><span class="line"> <span class="number">3</span>     Thread current = Thread.currentThread();</span><br><span class="line"> <span class="number">4</span>     <span class="comment">// 获取状态</span></span><br><span class="line"> <span class="number">5</span>     <span class="keyword">int</span> c = getState();</span><br><span class="line"> <span class="number">6</span>     </span><br><span class="line"> <span class="number">7</span>     <span class="comment">//如果写锁线程数 != 0 ，且独占锁不是当前线程则返回失败，因为存在锁降级</span></span><br><span class="line"> <span class="number">8</span>     <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line"> <span class="number">9</span>         getExclusiveOwnerThread() != current)</span><br><span class="line"><span class="number">10</span>         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="number">11</span>     <span class="comment">// 读锁数量</span></span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line"><span class="number">13</span>     <span class="comment">/*</span></span><br><span class="line"><span class="comment">14      * readerShouldBlock():读锁是否需要等待（公平锁原则）</span></span><br><span class="line"><span class="comment">15      * r &lt; MAX_COUNT：持有线程小于最大数（65535）</span></span><br><span class="line"><span class="comment">16      * compareAndSetState(c, c + SHARED_UNIT)：设置读取锁状态</span></span><br><span class="line"><span class="comment">17      */</span></span><br><span class="line"><span class="number">18</span>      <span class="comment">// 读线程是否应该被阻塞、并且小于最大值、并且比较设置成功</span></span><br><span class="line"><span class="number">19</span>     <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line"><span class="number">20</span>         r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line"><span class="number">21</span>         compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"><span class="number">22</span>         <span class="comment">//r == 0，表示第一个读锁线程，第一个读锁firstRead是不会加入到readHolds中</span></span><br><span class="line"><span class="number">23</span>         <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 读锁数量为0</span></span><br><span class="line"><span class="number">24</span>             <span class="comment">// 设置第一个读线程</span></span><br><span class="line"><span class="number">25</span>             firstReader = current;</span><br><span class="line"><span class="number">26</span>             <span class="comment">// 读线程占用的资源数为1</span></span><br><span class="line"><span class="number">27</span>             firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line"><span class="number">28</span>         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程为第一个读线程，表示第一个读锁线程重入</span></span><br><span class="line"><span class="number">29</span>             <span class="comment">// 占用资源数加1</span></span><br><span class="line"><span class="number">30</span>             firstReaderHoldCount++;</span><br><span class="line"><span class="number">31</span>         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 读锁数量不为0并且不为当前线程</span></span><br><span class="line"><span class="number">32</span>             <span class="comment">// 获取计数器</span></span><br><span class="line"><span class="number">33</span>             HoldCounter rh = cachedHoldCounter;</span><br><span class="line"><span class="number">34</span>             <span class="comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span></span><br><span class="line"><span class="number">35</span>             <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) </span><br><span class="line"><span class="number">36</span>                 <span class="comment">// 获取当前线程对应的计数器</span></span><br><span class="line"><span class="number">37</span>                 cachedHoldCounter = rh = readHolds.get();</span><br><span class="line"><span class="number">38</span>             <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>) <span class="comment">// 计数为0</span></span><br><span class="line"><span class="number">39</span>                 <span class="comment">//加入到readHolds中</span></span><br><span class="line"><span class="number">40</span>                 readHolds.set(rh);</span><br><span class="line"><span class="number">41</span>             <span class="comment">//计数+1</span></span><br><span class="line"><span class="number">42</span>             rh.count++;</span><br><span class="line"><span class="number">43</span>         &#125;</span><br><span class="line"><span class="number">44</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">45</span>     &#125;</span><br><span class="line"><span class="number">46</span>     <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line"><span class="number">47</span> &#125;</span><br></pre></td></tr></table></figure>
<p> 其中sharedCount方法表示占有读锁的线程数量，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br></pre></td></tr></table></figure>
<p>说明：直接将state右移16位，就可以得到读锁的线程数量，因为state的高16位表示读锁，对应的第十六位表示写锁数量。</p>
<p>  读锁获取锁的过程比写锁稍微复杂些，首先判断写锁是否为0并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前没有读锁，则设置第一个读线程firstReader和firstReaderHoldCount；若当前线程线程为第一个读线程，则增加firstReaderHoldCount；否则，将设置当前线程对应的HoldCounter对象的值。流程图如下。</p>
<p><img src="https://images2018.cnblogs.com/blog/249993/201806/249993-20180607131704903-887096141.png" alt="img"></p>
<p>注意：更新成功后会在firstReaderHoldCount中或readHolds(ThreadLocal类型的)的本线程副本中记录当前线程重入数（23行至43行代码），这是为了实现jdk1.6中加入的getReadHoldCount()方法的，这个方法能获取当前线程重入共享锁的次数(state中记录的是多个线程的总重入次数)，加入了这个方法让代码复杂了不少，但是其原理还是很简单的：如果当前只有一个线程的话，还不需要动用ThreadLocal，直接往firstReaderHoldCount这个成员变量里存重入数，当有第二个线程来的时候，就要动用ThreadLocal变量readHolds了，每个线程拥有自己的副本，用来保存自己的重入数。</p>
<p>fullTryAcquireShared方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123; <span class="comment">// 写线程数量不为0</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current) <span class="comment">// 不为当前线程</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123; <span class="comment">// 写线程数量为0并且读线程被阻塞</span></span><br><span class="line">            <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程为第一个读线程</span></span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前线程不为第一个读线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123; <span class="comment">// 计数器不为空</span></span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123; <span class="comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT) <span class="comment">// 读锁数量为最大值，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">// 比较并且设置成功</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123; <span class="comment">// 读线程数量为0</span></span><br><span class="line">                <span class="comment">// 设置第一个读线程</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：在tryAcquireShared函数中，如果下列三个条件不满足（读线程是否应该被阻塞、小于最大值、比较设置成功）则会进行fullTryAcquireShared函数中，它用来保证相关操作可以成功。其逻辑与tryAcquireShared逻辑类似，不再累赘。</p>
<h3 id="读锁的释放，tryReleaseShared方法"><a href="#读锁的释放，tryReleaseShared方法" class="headerlink" title="读锁的释放，tryReleaseShared方法"></a><strong>读锁的释放，tryReleaseShared方法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">// 获取当前线程</span></span><br><span class="line"> <span class="number">3</span>     Thread current = Thread.currentThread();</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程为第一个读线程</span></span><br><span class="line"> <span class="number">5</span>         <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>) <span class="comment">// 读线程占用的资源数为1</span></span><br><span class="line"> <span class="number">7</span>             firstReader = <span class="keyword">null</span>;</span><br><span class="line"> <span class="number">8</span>         <span class="keyword">else</span> <span class="comment">// 减少占用的资源</span></span><br><span class="line"> <span class="number">9</span>             firstReaderHoldCount--;</span><br><span class="line"><span class="number">10</span>     &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前线程不为第一个读线程</span></span><br><span class="line"><span class="number">11</span>         <span class="comment">// 获取缓存的计数器</span></span><br><span class="line"><span class="number">12</span>         HoldCounter rh = cachedHoldCounter;</span><br><span class="line"><span class="number">13</span>         <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) <span class="comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span></span><br><span class="line"><span class="number">14</span>             <span class="comment">// 获取当前线程对应的计数器</span></span><br><span class="line"><span class="number">15</span>             rh = readHolds.get();</span><br><span class="line"><span class="number">16</span>         <span class="comment">// 获取计数</span></span><br><span class="line"><span class="number">17</span>         <span class="keyword">int</span> count = rh.count;</span><br><span class="line"><span class="number">18</span>         <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123; <span class="comment">// 计数小于等于1</span></span><br><span class="line"><span class="number">19</span>             <span class="comment">// 移除</span></span><br><span class="line"><span class="number">20</span>             readHolds.remove();</span><br><span class="line"><span class="number">21</span>             <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="comment">// 计数小于等于0，抛出异常</span></span><br><span class="line"><span class="number">22</span>                 <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line"><span class="number">23</span>         &#125;</span><br><span class="line"><span class="number">24</span>         <span class="comment">// 减少计数</span></span><br><span class="line"><span class="number">25</span>         --rh.count;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line"><span class="number">28</span>         <span class="comment">// 获取状态</span></span><br><span class="line"><span class="number">29</span>         <span class="keyword">int</span> c = getState();</span><br><span class="line"><span class="number">30</span>         <span class="comment">// 获取状态</span></span><br><span class="line"><span class="number">31</span>         <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line"><span class="number">32</span>         <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 比较并进行设置</span></span><br><span class="line"><span class="number">33</span>             <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line"><span class="number">34</span>             <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line"><span class="number">35</span>             <span class="comment">// both read and write locks are now free.</span></span><br><span class="line"><span class="number">36</span>             <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line"><span class="number">37</span>     &#125;</span><br><span class="line"><span class="number">38</span> &#125;</span><br></pre></td></tr></table></figure>
<p>  说明：此方法表示读锁线程释放锁。首先判断当前线程是否为第一个读线程firstReader，若是，则判断第一个读线程占有的资源数firstReaderHoldCount是否为1，若是，则设置第一个读线程firstReader为空，否则，将第一个读线程占有的资源数firstReaderHoldCount减1；若当前线程不是第一个读线程，那么首先会获取缓存计数器（上一个读锁线程对应的计数器 ），若计数器为空或者tid不等于当前线程的tid值，则获取当前线程的计数器，如果计数器的计数count小于等于1，则移除当前线程对应的计数器，如果计数器的计数count小于等于0，则抛出异常，之后再减少计数即可。无论何种情况，都会进入无限循环，该循环可以确保成功设置状态state。其流程图如下。</p>
<p><img src="https://images2018.cnblogs.com/blog/249993/201806/249993-20180607132608771-1291388784.png" alt="img"></p>
<p>  在读锁的获取、释放过程中，总是会有一个对象存在着，同时该对象在获取线程获取读锁是+1，释放读锁时-1，该对象就是HoldCounter。</p>
<p>  要明白HoldCounter就要先明白读锁。前面提过读锁的内在实现机制就是共享锁，对于共享锁其实我们可以稍微的认为它不是一个锁的概念，它更加像一个计数器的概念。一次共享锁操作就相当于一次计数器的操作，获取共享锁计数器+1，释放共享锁计数器-1。只有当线程获取共享锁后才能对共享锁进行释放、重入操作。所以HoldCounter的作用就是当前线程持有共享锁的数量，这个数量必须要与线程绑定在一起，否则操作其他线程锁就会抛出异常。</p>
<p>先看读锁获取锁的部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;<span class="comment">//r == 0，表示第一个读锁线程，第一个读锁firstRead是不会加入到readHolds中</span></span><br><span class="line">    firstReader = current;</span><br><span class="line">    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;<span class="comment">//第一个读锁线程重入</span></span><br><span class="line">    firstReaderHoldCount++;    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    <span class="comment">//非firstReader计数</span></span><br><span class="line">    HoldCounter rh = cachedHoldCounter;<span class="comment">//readHoldCounter缓存</span></span><br><span class="line">    <span class="comment">//rh == null 或者 rh.tid != current.getId()，需要获取rh</span></span><br><span class="line">    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())    </span><br><span class="line">        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">        readHolds.set(rh);  <span class="comment">//加入到readHolds中</span></span><br><span class="line">    rh.count++; <span class="comment">//计数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里为什么要搞一个firstRead、firstReaderHoldCount呢？而不是直接使用else那段代码？这是为了一个效率问题，firstReader是不会放入到readHolds中的，如果读锁仅有一个的情况下就会避免查找readHolds。可能就看这个代码还不是很理解HoldCounter。我们先看firstReader、firstReaderHoldCount的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure>
<p>这两个变量比较简单，一个表示线程，当然该线程是一个特殊的线程，一个是firstReader的重入计数。</p>
<p>HoldCounter的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = Thread.currentThread().getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在HoldCounter中仅有count和tid两个变量，其中count代表着计数器，tid是线程的id。但是如果要将一个对象和线程绑定起来仅记录tid肯定不够的，而且HoldCounter根本不能起到绑定对象的作用，只是记录线程tid而已。</p>
<p>  诚然，在java中，我们知道如果要将一个线程和对象绑定在一起只有ThreadLocal才能实现。所以如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocalHoldCounter继承ThreadLocal，并且重写了initialValue方法。</p>
<p>  故而，HoldCounter应该就是绑定线程上的一个计数器，而ThradLocalHoldCounter则是线程绑定的ThreadLocal。从上面我们可以看到ThreadLocal将HoldCounter绑定到当前线程上，同时HoldCounter也持有线程Id，这样在释放锁的时候才能知道ReadWriteLock里面缓存的上一个读取线程（cachedHoldCounter）是否是当前线程。这样做的好处是可以减少ThreadLocal.get()的次数，因为这也是一个耗时操作。需要说明的是这样HoldCounter绑定线程id而不绑定线程对象的原因是避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们（尽管GC能够智能的发现这种引用而回收它们，但是这需要一定的代价），所以其实这样做只是为了帮助GC快速回收对象而已。</p>
]]></content>
      <categories>
        <category>并发</category>
        <category>Lock</category>
      </categories>
      <tags>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之String</title>
    <url>/posts/415bd4eb/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>String 被声明为 final，因此它不可被继承。</p>
<p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
</blockquote>
<a id="more"></a>

<h1 id="获取内存地址的方法"><a href="#获取内存地址的方法" class="headerlink" title="获取内存地址的方法"></a>获取内存地址的方法</h1><p>Object的hashCode()默认是返回内存地址的，但是hashCode()可以重写，所以hashCode()不能代表内存地址的不同。</p>
<p>System.identityHashCode(Object)方法可以返回对象的内存地址,不管该对象的类是否重写了hashCode()方法。</p>
<h1 id="什么是String，它是什么数据类型？"><a href="#什么是String，它是什么数据类型？" class="headerlink" title="什么是String，它是什么数据类型？"></a>什么是String，它是什么数据类型？</h1><p>String是定义在 java.lang 包下的一个类。它不是基本数据类型。</p>
<p>String是不可变的，JVM使用字符串池来存储所有的字符串对象。</p>
<h2 id="String被设计成不可变和不能被继承的原因"><a href="#String被设计成不可变和不能被继承的原因" class="headerlink" title="String被设计成不可变和不能被继承的原因"></a>String被设计成不可变和不能被继承的原因</h2><p>String是不可变和不能被继承的（final修饰），这样设计的原因主要是为了设计考虑、效率和安全性。     <strong>字符串常量池的需要：</strong></p>
<p>​    只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。假若字符串对象允许改变,那么将会导致各种逻辑错误,比如改变一个对象会影响到另一个独立对象. 严格来说，这种常量池的思想,是一种优化手段。</p>
<p><img src="https://www.pdai.tech/_images/pics/f76067a5-7d5f-4135-9549-8199c77d8f1c.jpg" alt="img"></p>
<p><strong>String对象缓存HashCode：</strong></p>
<p>​    上面解析String类的源码的时候已经提到了HashCode。Java中的String对象的哈希码被频繁地使用，字符串的不可变性保证了hash码的唯一性。</p>
<p><strong>安全性:</strong></p>
<p>​    首先String被许多Java类用来当参数，如果字符串可变，那么会引起各种严重错误和安全漏洞。</p>
<p>​    再者String作为核心类，很多的内部方法的实现都是本地调用的，即调用操作系统本地API，其和操作系统交流频繁，假如这个类被继承重写的话，难免会是操作系统造成巨大的隐患。</p>
<p>​    最后字符串的不可变性使得同一字符串实例被多个线程共享，所以保障了多线程的安全性。而且类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。</p>
<h1 id="几种不同的创建字符串的方式"><a href="#几种不同的创建字符串的方式" class="headerlink" title="几种不同的创建字符串的方式"></a>几种不同的创建字符串的方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">String f = <span class="string">&quot;f&quot;</span> + <span class="string">&quot;g&quot;</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">String d = String.valueOf(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">String e = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;e&quot;</span>).toString();</span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span> + <span class="string">&quot;3&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="string">&quot;4&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>从上到下依次解释一下，只有明白了这几种创建的区别所在才能明白一个字符串在内存中的分布情况。</p>
<h2 id="String-a-“a”"><a href="#String-a-“a”" class="headerlink" title="String a = “a”;"></a>String a = “a”;</h2><ul>
<li>在JDK 1.7 之前，会在字符串常量池中创建对象，并返回池中的引用；</li>
<li>在JDK 1.7 之后，在堆中创建对象，同时在字符串常量池中保存一份引用，返回池中的引用，同时也是堆中对象的引用，如果常量池中已经存在对象或者堆中对象的引用，那么则直接返回该引用。</li>
</ul>
<h2 id="String-c-new-String-“c”"><a href="#String-c-new-String-“c”" class="headerlink" title="String c = new String(“c”);"></a>String c = new String(“c”);</h2><ul>
<li>如果常量池中<strong>没有</strong>“c”，那么同时在堆中和常量池中创建对象，会创建两个对象，返回堆中对象的引用。</li>
<li>如果常量池中<strong>有</strong>“c”，只会在堆中创建，并返回堆中对象的引用。</li>
</ul>
<p>注意：在JDK1.7之后，常量池中不在存字符串对象了，只会存对象的引用，字符串对象会创建在相应的堆中。</p>
<h2 id="String-f-“f”-“g”"><a href="#String-f-“f”-“g”" class="headerlink" title="String f = “f” + “g”;"></a>String f = “f” + “g”;</h2><p>使用包含常量的字符串连接创建是也是常量，编译期就能确定了，直接入字符串常量池，当然同样需要判断常量池中是否已经存在”fg”字符串。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1584120197896-6f4e09be-b357-423a-8c8f-37b922bac477.png" alt="image.png"></p>
<h2 id="String-b-new-String-“a”-new-String-“b”"><a href="#String-b-new-String-“a”-new-String-“b”" class="headerlink" title="String b = new String(“a”) + new String(“b”);"></a>String b = new String(“a”) + new String(“b”);</h2><p>可以看成先把第一种情况执行了两次。因为“+”的关系还创建了StringBuilder对象，最后StringBuilder对象调用toString()方法的时候又new了String对象并将它的引用返回给b。整个过程在堆中创建了三个String对象**(“a”,”b”,”ab”）<strong>，在运行时常量池中创建了两个String对象</strong>(“a”,”b”)**。</p>
<p>注意：这里在jdk1.7之后，就应该是在堆中创建5个String对象了，然后在常量池中存其中两个对象的引用（这个是自己的理解)，那两个对象也就相当于存在常量池中吗，相当于吧。</p>
<p>下面我们通过对应</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1584116460652-187f8b06-0507-40a2-ad04-81aaeed9172f.png" alt="image.png"></p>
<p>这里我们将其用javap -c  对应的路径+class文件名反编译对应的class文件得到下面的java字节码（bytecode）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1584116532943-3f64e301-e354-4cc2-b97d-03ed868ebf4f.png" alt="image.png"></p>
<p>emmm，很难看懂，但是慢慢读下来我们发现</p>
<p>0 执行new指令在堆上分配对象的内存，对象的引用推送至操作数栈，这里就相当于new了一个StringBuilder对象吧</p>
<p>3 执行dup指令 复制栈顶元素，常用于复制 new 指令所生成的未经初始化的引用</p>
<p>4 执行invokespecial指令调用初始化方法。 注：invokespecial只能调用三类方法：<init>方法；私有方法；super.method()。因为这三类方法的调用对象在编译时就可以确定。</p>
<p>7 同0，不过这次相当于new了一个String对象</p>
<p>10 同3</p>
<p>11 执行ldc指令将”a”加载到操作数栈顶 (ldc指令描述：常量池中的常量值（int, float, string reference, object reference）入栈)。换句话说，如果常量池中没有”a”对象的引用，那么就会在堆中创建”a”对象，并把该对象的引用保存到字符串常量池中(1.7之前的话就是直接在常量池中创建”a”对象)。</p>
<p>13 执行String类的初始化，这里后面有个V，个人感觉就是从常量池中把”a”字符串复制过来了，下面2.7的图示上也能很好的说明。</p>
<p>16 调用StringBuilder方法</p>
<p>19 同0，不过这次相当于new了一个String对象</p>
<p>22 同3</p>
<p>23 同11，如果常量池中没有”b”对象的引用，那么就会在堆中创建”b”对象，并把该对象的引用保存到字符串常量池中(1.7之前的话就是直接在常量池中创建”b”对象)。</p>
<p>25 同13 </p>
<p>28 同16</p>
<p>31 执行toString()方法，这里会在堆中新建一个对象（”ab”）并返回一个对象的引用</p>
<p>32 执行astore_1 将引用其赋值给我们定义的局部变量b</p>
<h2 id="String-d-String-valueOf-“d”"><a href="#String-d-String-valueOf-“d”" class="headerlink" title="String d = String.valueOf(“d”);"></a>String d = String.valueOf(“d”);</h2><p>相当于String d = “d”;</p>
<ul>
<li>在JDK 1.7 之前，会在字符串常量池中创建对象，并返回池中的引用；</li>
<li>在JDK 1.7 之后，在堆中创建对象，同时在字符串常量池中保存一份引用，返回池中的引用，同时也是堆中对象的引用，如果常量池中已经存在对象或者堆中对象的引用，那么则直接返回该引用。</li>
</ul>
<h2 id="String-e-new-StringBuilder-“e”-toString"><a href="#String-e-new-StringBuilder-“e”-toString" class="headerlink" title="String e = new StringBuilder(“e”).toString();"></a>String e = new StringBuilder(“e”).toString();</h2><p>只会在堆中创建对象String对象”e”</p>
<h2 id="String-s2-”1”-”3”-new-String-“1”-”4”"><a href="#String-s2-”1”-”3”-new-String-“1”-”4”" class="headerlink" title="String s2=”1”+”3”+new String(“1”)+”4”;"></a>String s2=”1”+”3”+new String(“1”)+”4”;</h2><p>网上拿过来的例子，算是对2.4的补充。</p>
<p>当使用“+”连接字符串中含有变量时，是在运行期才能确定的。首先连接操作最开始时如果都是字符串常量，编译后将尽可能多的字符串常量连接在一起，形成新的字符串常量参与后续的连接（可通过反编译工具jd-gui进行查看）。接下来的字符串连接是从左向右依次进行，对于不同的字符串，首先以最左边的字符串为参数创建StringBuilder对象（可变字符串对象），然后依次对右边进行append操作，最后将StringBuilder对象通过toString()方法转换成String对象（注意：中间的多个字符串常量不会自动拼接）。 </p>
<p>实际上的实现过程为：</p>
<p>String s2=new StringBuilder(“13”).append(new String(“1”)).append(“4”).toString();</p>
<p>当使用+进行多个字符串连接时，实际上是而外产生了一个StringBuilder对象和一个String对象。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1584202319317-e346c0cf-6353-4173-9a22-ce1d4dcc4af7.png" alt="image.png"></p>
<p>注：这里String对象1和常量池中的1 中间用复制，我想作者的意思是现在常量池中创建，而后复制一份字符串到堆中，查看2.4的字节码可知，确实应该是如此。</p>
<h1 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h1><ul>
<li>在JDK 1.7 之前，如果常量池中含有一个字符串和当前调用方法的字符串equals相等，那么就会返回池中的字符串，如果池中没有的话，则首先在常量池中创建该字符串，然后返回引用</li>
<li>在JDK 1.7 之后，如果常量池中含有一个字符串和当前调用方法的字符串equals相等，那么就会返回池中的字符串，如果池中没有的话，会将堆中的引用复制到常量池中，并返回这个引用。</li>
</ul>
<p>案例解析：   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s3.intern());</span><br></pre></td></tr></table></figure>
<p>JDK1.7之后，字符串常量池已经被转移至Java堆中，开发人员也对intern 方法做了一些修改。因为字符串常量池和new的对象都存于Java堆中，为了优化性能和减少内存开销，当调用 intern 方法时，如果常量池中已经存在该字符串，则返回池中字符串；否则直接存储堆中的引用，也就是字符串常量池中存储的是指向堆里的对象。所以结果为true。具体如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1584197142251-e5948a05-4eaf-420e-8b53-cdf71300268f.png" alt="image"></p>
<p>所以这个时候如果在中间加了一个String s4 = “11”;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">System.out.println(s3 == s3.intern());<span class="comment">//false</span></span><br><span class="line">System.out.println(s4 == s3.intern());<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>但是如果把String s4 = “11”; 放在s3.intern()方法的后面  就会是 true true true了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(s3 == s3.intern());<span class="comment">//true</span></span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">System.out.println(s4 == s3.intern());<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h1 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h1><p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h1 id="String典型案例"><a href="#String典型案例" class="headerlink" title="String典型案例"></a>String典型案例</h1><h2 id="关于equals和-："><a href="#关于equals和-：" class="headerlink" title="关于equals和== ："></a>关于equals和== ：</h2><p>（1）对于==，如果作用于基本数据类型的变量（byte,short,char,int,long,float,double,boolean ），则直接比较其存储的”值”是否相等；如果作用于引用类型的变量（String），则比较的是所指向的对象的地址（即是否指向同一个对象）。</p>
<p>（2）equals方法是基类Object中的方法，因此对于所有的继承于Object的类都会有该方法。在Object类中，equals方法是用来比较两个对象的引用是否相等。对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而String类对equals方法进行了重写，用来比较指向的字符串对象所存储的字符串是否相等。其他的一些类诸如Double，Date，Integer等，都对equals方法进行了重写用来比较指向的对象所存储的内容是否相等。</p>
<h2 id="考考你："><a href="#考考你：" class="headerlink" title="考考你："></a>考考你：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 情景一：字符串池</span></span><br><span class="line"><span class="comment">             * JAVA虚拟机(JVM)中存在着一个字符串池，其中保存着很多String对象(1.7之后他只存引用了);</span></span><br><span class="line"><span class="comment">             * 并且可以被共享使用，因此它提高了效率。</span></span><br><span class="line"><span class="comment">             * 由于String类是final的，它的值一经创建就不可改变。</span></span><br><span class="line"><span class="comment">             * 字符串池由String类维护，我们可以调用intern()方法来访问字符串池。  </span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            String s1 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//在字符串池创建了一个对象  </span></span><br><span class="line">            String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//字符串pool已经存在对象“abc”(共享),所以创建0个对象，累计创建一个对象      </span></span><br><span class="line">            System.out.println(<span class="string">&quot;s1 == s2 : &quot;</span>+(s1==s2));<span class="comment">//true 指向同一个对象 </span></span><br><span class="line">            System.out.println(<span class="string">&quot;s1.equals(s2) : &quot;</span> + (s1.equals(s2)));<span class="comment">//true  值相等      </span></span><br><span class="line">            <span class="comment">//↑------------------------------------------------------over  </span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 情景二：关于new String(&quot;&quot;)</span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">//创建了两个对象，一个存放在字符串池中，一个存在与堆区中；  </span></span><br><span class="line">            <span class="comment">//↑还有一个对象引用s3存放在栈中  </span></span><br><span class="line">            String s4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);   </span><br><span class="line">            <span class="comment">//↑字符串池中已经存在“abc”对象，所以只在堆中创建了一个对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;s3 == s4 : &quot;</span>+(s3==s4));  </span><br><span class="line">            <span class="comment">//↑false   s3和s4栈区的地址不同，指向堆区的不同地址；  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;s3.equals(s4) : &quot;</span>+(s3.equals(s4)));  </span><br><span class="line">            <span class="comment">//↑true  s3和s4的值相同  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;s1 == s3 : &quot;</span>+(s1==s3));  </span><br><span class="line">            <span class="comment">//↑false 存放的地区多不同，一个栈区，一个堆区  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;s1.equals(s3) : &quot;</span>+(s1.equals(s3)));  </span><br><span class="line">            <span class="comment">//↑true  值相同  </span></span><br><span class="line">            <span class="comment">//↑------------------------------------------------------over  </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 情景三：  </span></span><br><span class="line"><span class="comment">             * 由于常量的值在编译的时候就被确定(优化)了。</span></span><br><span class="line"><span class="comment">             * 在这里，&quot;ab&quot;和&quot;cd&quot;都是常量，因此变量str3的值在编译时就可以确定。</span></span><br><span class="line"><span class="comment">             * 这行代码编译后的效果等同于： String str3 = &quot;abcd&quot;;</span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            String str1 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;cd&quot;</span>;  <span class="comment">//1个对象  </span></span><br><span class="line">            String str11 = <span class="string">&quot;abcd&quot;</span>;   </span><br><span class="line">            System.out.println(<span class="string">&quot;str1 = str11 : &quot;</span>+ (str1 == str11));  </span><br><span class="line">            <span class="comment">//true↑------------------------------------------------------over  </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 情景四：  </span></span><br><span class="line"><span class="comment">             * 局部变量str2,str3存储的是存储两个拘留字符串对象(intern字符串对象)的地址。</span></span><br><span class="line"><span class="comment">             *  </span></span><br><span class="line"><span class="comment">             * 第三行代码原理(str2+str3)：</span></span><br><span class="line"><span class="comment">             * 运行期JVM首先会在堆中创建一个StringBuilder类，</span></span><br><span class="line"><span class="comment">             * 同时用str2指向的拘留字符串对象完成初始化，</span></span><br><span class="line"><span class="comment">             * 然后调用append方法完成对str3所指向的拘留字符串的合并，</span></span><br><span class="line"><span class="comment">             * 接着调用StringBuilder的toString()方法在堆中创建一个String对象，</span></span><br><span class="line"><span class="comment">             * 最后将刚生成的String对象的堆地址存放在局部变量str4中。</span></span><br><span class="line"><span class="comment">             *  </span></span><br><span class="line"><span class="comment">             * 而str5存储的是字符串池中&quot;abcd&quot;所对应的拘留字符串对象的地址。</span></span><br><span class="line"><span class="comment">             * str4与str5地址当然不一样了。</span></span><br><span class="line"><span class="comment">             *  </span></span><br><span class="line"><span class="comment">             * 内存中实际上有五个字符串对象：</span></span><br><span class="line"><span class="comment">             *       三个拘留字符串对象、一个String对象和一个StringBuilder对象。</span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            String str2 = <span class="string">&quot;ab&quot;</span>;  <span class="comment">//1个对象  </span></span><br><span class="line">            String str3 = <span class="string">&quot;cd&quot;</span>;  <span class="comment">//1个对象                                         </span></span><br><span class="line">            String str4 = str2+str3;                                        </span><br><span class="line">            String str5 = <span class="string">&quot;abcd&quot;</span>;    </span><br><span class="line">            System.out.println(<span class="string">&quot;str4 = str5 : &quot;</span> + (str4==str5)); <span class="comment">// false  </span></span><br><span class="line">            <span class="comment">//↑------------------------------------------------------over  </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 情景五：</span></span><br><span class="line"><span class="comment">             *  JAVA编译器对string + 基本类型/常量 是当成常量表达式直接求值来优化的。</span></span><br><span class="line"><span class="comment">             *  运行期的两个string相加，会产生新的对象的，存储在堆(heap)中</span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            String str6 = <span class="string">&quot;b&quot;</span>;  </span><br><span class="line">            String str7 = <span class="string">&quot;a&quot;</span> + str6;  </span><br><span class="line">            String str67 = <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">            System.out.println(<span class="string">&quot;str7 = str67 : &quot;</span>+ (str7 == str67));  </span><br><span class="line">            <span class="comment">//↑str6为变量，在运行期才会被解析。结果为false </span></span><br><span class="line">            <span class="keyword">final</span> String str8 = <span class="string">&quot;b&quot;</span>;  </span><br><span class="line">            String str9 = <span class="string">&quot;a&quot;</span> + str8;  </span><br><span class="line">            String str89 = <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">            System.out.println(<span class="string">&quot;str9 = str89 : &quot;</span>+ (str9 == str89));  </span><br><span class="line">            <span class="comment">//↑str8为常量变量，编译期会被优化，结果为true  </span></span><br><span class="line">            <span class="comment">//↑------------------------------------------------------over  </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器之HashMap</title>
    <url>/posts/2dca70a2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>HashMap 是 Java 程序中使用率最高的数据结构之一，其主要用于处理键值对这种数据结构。而且在 JDK 1.8 中对底层的实现进行了优化，比如引入了红黑树、优化了扩容机制等。</p>
<p>本文主要是基于 JDK 最常用的 1.8 版本来介绍，详细分析了几个最重要的参数和方法，比如索引的计算、数组的扩容、put() 方法等，末尾也会稍微对比下 1.8 和 1.7 版本之间的差异。</p>
</blockquote>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>HashMap 继承自 Map，有如下特点：</p>
<ol>
<li>存储 key - value 类型结构，数据类型不限制</li>
<li>根据 key 的 hashcode 值进行存储数据</li>
<li>最多只允许一条记录的键(key)为 null（对 value 值不约束）</li>
<li>它是无序的（其实一见 hash 我们便知道了）</li>
<li>查询效率很高</li>
<li>它是线程不安全的（要线程安全，可以使用 Collections 的 synchronizedMap，或者使用更加推荐的 ConcurrentHashMap）</li>
</ol>
<p>它还有一些常见的兄弟姐妹，比如 LinkedHashMap、TreeMap、Hashtable，本文就不进行对比介绍了。</p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>HashMap 的结构，是数组+链表+红黑树的结构，草图可以见下图。</p>
<blockquote>
<p>红黑树是在 JDK1.8 版本才引入的，目的是加快链表的查询效率</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/1/171348d1ada3138e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="HashMap 数据结构草图"></p>
<p>从上图可看出，HashMap 底层是一个哈希桶数组，名为 table，数组内存储的是基于 Node 类型的数据，所以，这个 <strong>Node</strong> 甚为关键，下文会详解。</p>
<p>然后同一个数组所以的位置可以存储多个 Node，并以链表或红黑树的形式来实现，所以很容易猜到，既然是链表，那么每个 Node 必然会记录下一个 Node。但是如果链表很长，那查询效率便会降低，所以自 JDK1.8 开始便引入了红黑树，即当链表长度超过 8 的时候，链表便会转为红黑树，另外，当链表长度小于 6 的时候，会从红黑树转为链表。</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>HashMap 是使用哈希表来存储数据的。哈希表为了解决冲突，一般有两种方案：<strong>开放地址法</strong> 和 <strong>链地址法</strong>。</p>
<blockquote>
<p>开放地址法：哈希完后如果有冲突，则按照某种规则找到空位插入</p>
</blockquote>
<p>HashMap 采用的便是 <strong>链地址法</strong>，即在数组的每个索引处都是一个链表结构，这样就可以有效解决 hash 冲突。</p>
<blockquote>
<p>当两个 key 的 hash 值相同时，则会将他们至于数组的同一个位置处，并以链表的形式呈现。</p>
</blockquote>
<p>但是如果大部分的数据都集中在了数组中的同一索引处，而其余索引处的数据比较少，即分配不均衡，则说明哈希碰撞较多。</p>
<p>所以为了提高 HashMap 的存取效率，我们需要将数据尽可能多地分散到数组中去，即减少哈希碰撞，为了达到这一目的，最直接的方案便是改善 hash 算法，其次是扩大哈希桶数组的大小（扩容），在下文会详细介绍。</p>
<h1 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h1><h2 id="一些默认参数"><a href="#一些默认参数" class="headerlink" title="一些默认参数"></a>一些默认参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量为 16 （PS：aka 应该是 as know as）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量（容量不够时需要扩容）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表长度为 8 的时候会转为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为 6 的时候会从红黑树转为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有桶内数据量大于 64 的时候才会允许转红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始容量是 16，可以扩容，但是扩容之后的容量，也是 2 的幂次方，比如 32、64，why？这里面涉及到很多巧妙的设计，下文介绍 resize() 方法的时候会详细介绍。</p>
<p>另外，我们解释下 <strong>MIN_TREEIFY_CAPACITY</strong>，虽然说当链表长度大于 8 的时候，链表会转为红黑树，但是也是需要满足桶内存储的数据量大于上述这个参数的值，否则不仅不会转红黑树，反而会进行扩容操作。</p>
<p>比如下面这段代码是判断是否要将链表转为红黑树，乍看，只是将链表长度和 <strong>UNTREEIFY_THRESHOLD</strong> 进行对比，其实不然，点开 <code>treeifyBin(tab, hash)</code> 这个方法，我们便可以看到，如果此时桶数组内的数据量小于 <strong>MIN_TREEIFY_CAPACITY</strong>，则不会将链表转红黑树，而是进行扩容操作，见下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/1/171348d0b9fd7732?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="链表转红黑树"></p>
<h2 id="一些重要的字段"><a href="#一些重要的字段" class="headerlink" title="一些重要的字段"></a>一些重要的字段</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map 中存储的数据量，即 key-value 键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 内部结构发生变化的次数，即新增、删除数据的时候都会记录，</span></span><br><span class="line"><span class="comment">// 注意：修改某个 key 的值，并不会改变这个 modCount</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点，代表最多能容纳的数据量</span></span><br><span class="line"><span class="comment">// 即最多能容纳的 key-value 键值对的数量</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子，默认为 0.75</span></span><br><span class="line"><span class="comment">// 注意，这个值是可以大于 1 的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>其中有两个参数需要注意一下，一个是 <strong>threshold</strong>，还有一个是 <strong>loadFactor</strong>。</p>
<p><strong>threshold</strong> 代表最多能容纳的 Node 数量，一般 <code>threshold = length * loadFactor</code>，也就是说要想 HashMap 能够存储更多的数据（即获得较大的 threshold），有两种方案，一种是扩容（即增大数组长度 length），另一种便是增大负载因子。</p>
<blockquote>
<p>threshold 和数组长度不是一回事</p>
</blockquote>
<p>0.75 这个默认的负载因子的值是基于时间和空间考虑而得的一个比较平衡的点，所以负载因子我们一般不去调整，除非有特殊的需求：</p>
<ol>
<li>比如 <strong>以空间换时间</strong>，意思是如果内存比较大，并且需要有较高的存取效率，则可以适当降低负载因子，这样做的话，就会减小哈希碰撞的概率。</li>
<li>再比如 <strong>以时间换空间</strong>，意思是如果内存比较小，并且接受适当减小存取效率，则可以适当调大负载因子，哪怕大于 1，这样做的话，就会增大哈希碰撞的概率。</li>
</ol>
<h4 id="Node-lt-K-V-gt"><a href="#Node-lt-K-V-gt" class="headerlink" title="Node&lt;K,V&gt;"></a>Node&lt;K,V&gt;</h4><p>HashMap 底层是一个 Node[] table，所以 Node 是一个很重要的数据结构。</p>
<p>Node 实现了 Entry 接口，所以，Node 本质上就是一个 Key-Value 数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// key 的 hash 值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 记录下一个 Node</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap()"></a>HashMap()</h2><p>构造一个空的 HashMap，初始容量为 16，负载因子为 0.75</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空的 HashMap，初始容量为 16，负载因子为默认值 0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;  <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap(int initialCapacity)"></a>HashMap(int initialCapacity)</h2><p>构造一个空的 HashMap，并指定初始化容量，负载因子为默认的 0.75。</p>
<p>构造函数内部会调用下文紧接着讲到的第三种构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空的 HashMap，并指定初始化容量，负载因子采用默认的 0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 调用另一个构造函数</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h2><p>构造一个空的 HashMap，并指定初始化容量，指定负载因子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空的 HashMap，并指定初始化容量，指定负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始容量不为负数</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +  initialCapacity);</span><br><span class="line">    <span class="comment">// 初始容量大于最大值时，则取最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 负载因子不能小于 0，并且必须是数字，否则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大容量 MAXIMUM_CAPACITY 为 1 &lt;&lt; 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构造函数中会进行一系列的参数判断，并且会进行初始化操作。</p>
<ol>
<li>如果初始容量小于 0，或者负载因子小于 0 或不为数字时，会抛出 <code>IllegalArgumentException</code>  异常。</li>
<li>如果初始容量大于最大值（2^30），则会使用最大容量。</li>
<li>设置 threshold，直接调用 <code>tableSizeFor()</code> 方法，该方法会返回一个大于等于指定容量的 2 的幂次方的整数，例如传入 6，则会返回 8。</li>
</ol>
<blockquote>
<p>另外，直接将得到的值赋给 <code>threshold</code>，难道不是应该是这样的操作吗？<code>this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</code>, 其实不然，我们再看一眼源码，会发现初始化的动作放在了 put 操作中。</p>
</blockquote>
<h2 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><p>构造一个非空的 HashMap，保证初始化容量能够完全容下传进来的 Map，另外，负载因子使用的是默认值 0.75。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个非空的 HashMap，指定了默认的负载因子 0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">// 将 Map 中的 key-value 赋值到新的 Map 中去</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>putMapEntries()</code> 方法是将传递进来的 Map 中的数据全都存入到当前的 HashMap 中去，方法的详解见下文。</p>
<h1 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h1><h2 id="tableSizeFor-int-cap"><a href="#tableSizeFor-int-cap" class="headerlink" title="tableSizeFor(int cap)"></a>tableSizeFor(int cap)</h2><p>顾名思义，初始化桶数组的大小。</p>
<p>该方法的作用是返回一个大于等于传入的参数的数值，并且返回值会满足以下两点：</p>
<ol>
<li>返回值是 2 的幂次方</li>
<li>返回值是最接近传入的参数的值</li>
</ol>
<p>比如：传入 5，则返回 8；传入 8，则返回 8；</p>
<p>这个方法的设计是很令人惊叹的，十分巧妙，除了敬仰还是敬仰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2 的幂次方有个特点，就是它的字节码除了最高位是 1，其余全是 0。</p>
<p>比如 2，字节码为：10，最高位为 1，其余为 0</p>
<p>再比如16，字节码为：10000，最高位为 1，其余为 0</p>
<p>所以方法内使用了大量的 “或运算”和 “右移”操作，目的是保证从最高位起的每个 bit 都是 1。</p>
<ol>
<li>首行 <code>int n = cap - 1;</code> 的作用，是为了防止传入的参数本身就是一个 2 的幂次方，否则会返回两倍于参数的值；</li>
<li><code>n |= n &gt;&gt;&gt; 1;</code> 的作用，是保证倒数第二个高位也是 1，下面的代码类似。</li>
<li>最后一行之前，得到的数类似 0000 1111 这种从第一个高位起全是 1，这样只要加了 1，则返回的数值必然是 2 的幂次方。</li>
</ol>
<p>详细的计算过程详解见下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/1/171348d0b9982e90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="tableSizeFor 过程"></p>
<h2 id="putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict"><a href="#putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict" class="headerlink" title="putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)"></a>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</h2><p>该方法是将参数 m 中的所有数据存入到当前的 HashMap 中去，比如在上文提到的第四种构造函数便调用了此方法。</p>
<p>此方法还是比较简单的，下文代码中都注释，其中涉及到的两个关键方法 <code>resize()</code> 和 <code>putVal()</code> 方法，作用分别为扩容和赋值，下文再详细介绍这两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将参数 m 中的所有元素存入到当前的 HashMap 中去</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 m 中的参数个数（key-value 的数量）</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断 table 是否被初始化过，否则初始化一遍。（PS：table 是在 put 操作的时候进行初始化的，所以如果当前的 HashMap 没有进行过 put 操作，则当前的 table 并不会被初始化）</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 根据传进来的 map 的元素数量来计算当前 HashMap 需要的容量</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">// 计算而得的容量是不能大于最大容量的</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ? (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 将计算而得的容量赋值给 threshold，前提是大于当前容量（即不会减小当前的 HashMap 的容量）</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                <span class="comment">// 将容量转换为最近的 2 的 幂次方</span></span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// table 不为空，即已经初始化过了，</span></span><br><span class="line">        <span class="comment">// 如果 m 中的元素数量超过了当前 HashMap 的容量，则要进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 遍历 m 的每个元素，将它的 key-value 插入到当前的 HashMap 中去</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            <span class="comment">// 插入数据（注意，为什么不是 put() 呢，因为 put() 其实也是调用的 putVal() 方法）</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a>hash(Object key)</h2><p>HashMap 中的 hash 算法，是将 key 进行 hashCode 计算得到 h，然后将 h 的高16位与低16位进行异或运算。</p>
<p>这样做是从速度、质量等多方面综合考虑的，而且将高位和低位进行混合运算，这样是可以有效降低冲突概率的。</p>
<p>另外，高位是可以保证不变的，变的是低位，并且低位中掺杂了高位的信息，最后生成的 hash 值的随机性会增大。</p>
<p>下图举例介绍异或计算（例如 h 为 467,926,597）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/1/171348d0b7b28b61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="异或运算"></p>
<p>从上图中也看出，高位的数字是不变的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 高 16 位与低 16 位进行异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，hash() 的作用是根据 key 计算一个 hash 数值，然后根据这个 hash 数值计算得到数组的索引 i，基于这个索引我们才能进行相关的增删改查操作，所以这个索引甚是关键。</p>
<p>计算公式为：<code>i = hash(key) &amp; (n-1)</code>，即下面这个方法，但是这个下面这个方法仅限 1.8 以前的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk1.7 的源码，jdk1.8 没有这个方法，但是原理一样</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 取模运算</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里又是一个很精妙的设计，一般情况下，我们要获取索引 i，最常用的计算方式是取模运算：<code>hash % length</code>，但是此处却使用的是：<code>hash &amp; （length-1）</code>，妙哉妙哉。</p>
<p>为什么要这么做呢？因为 ‘%’ 操作相对于位运算是比较消耗性能的，所以采用了奇淫技巧 ‘&amp;’ 运算。但是为什么结果是和取模运算是一致的呢？其实还是因为table的 length 的问题。</p>
<p>我们上文提到过，HashMap 的长度 length 始终是 2 的幂次方，这个是关键，所以才会有这种结果，简单分析见下图：</p>
<blockquote>
<p>使用 &amp; 位运算替代常规的 % 取模运算，性能上提高了很多，这个是 table 如此设计数组长度的优势之一，另一个很大的优势是在扩容的时候，下文会分析。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/1/171348d0b6db95a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="取模运算"></p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>resize() 是一个很重要的方法，作用是扩容，从而使得 HashMap 可以存储更多的数据。</p>
<p>因为当我们不断向 HashMap 中添加数据时，它总会超过允许存储的数据量上限，所以必然会经历 <strong>扩容</strong> 这一步操作，但是 HashMap 底层是一个数组，我们都知道数组是无法增大容量的，所以 resize 的过程其实就是新建一个更大容量的数组来存储当前 HashMap 中的数据。</p>
<p>resize() 方法是很精妙的，我们就一起来看下 JDK1.8 的源码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 当前 table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 当前的 table 的大小</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 当前 table 的 threshold，即允许存储的数据量阀值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 新的 table 的大小和阀值暂时初始化为 0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ① 开始计算新的 table 的大小和阀值</span></span><br><span class="line">    <span class="comment">// a、当前 table 的大小大于 0，则意味着当前的 table 肯定是有数据的</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前 table 的大小已经到了上线了，还咋扩容，自个儿继续哈希碰撞去吧 </span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新的 table 的大小直接翻倍，阀值也直接翻倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b、当前的 table 中无数据，但是阀值不为零，说明初始化的时候指定过容量或者阀值，但是没有被 put 过数据，因为在上文中有提到过，此时的阀值就是数组的大小，所以直接把当前的阀值当做新 table 的数组大小即可</span></span><br><span class="line">    <span class="comment">// 回忆一下：threshold = tableSizeFor(t);</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// c、这种情况就代表当前的 table 是调用的空参构造来初始化的，所有的数据都是默认值，所以新的 table 也只要使用默认值即可</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的阀值是 0，那么就简单计算一遍就行了</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// ② 初始化新的 table</span></span><br><span class="line">    <span class="comment">// 这个 newTab 就是新的 table，数组大小就是上面这一堆逻辑所计算出来的</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历当前 table，处理每个下标处的 bucket，将其处理到新的 table 中去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放当前 table 数组的对象引用（for循环后，当前 table 数组不再引用任何对象）</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// a、只有一个 Node，则直接 rehash 赋值即可</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// b、当前的 bucket 是红黑树，直接进行红黑树的 rehash 即可</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// c、当前的 bucket 是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表中的每个 Node，分别判断是否需要进行 rehash 操作</span></span><br><span class="line">                    <span class="comment">// (e.hash &amp; oldCap) == 0 算法是精髓，充分运用了上文提到的 table 大小为 2 的幂次方这一优势，下文会细讲</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 根据 e.hash &amp; oldCap 算法来判断节点位置是否需要变更</span></span><br><span class="line">                        <span class="comment">// 索引不变</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原 bucket 位置的尾指针不为空(即还有 node )</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 链表末尾必须置为 null</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 链表末尾必须置为 null</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>好了，下面我们就介绍下上面的源码中提到的计算索引的操作，即判断 <code>if ((e.hash &amp; oldCap) == 0)</code>。</p>
<p>下图展示的是扩容前和扩容后的计算索引的方法，主要关注红色框中的内容。这种方案是没问题的，但是之前我们提到，table 的大小为 2 的幂次方，这什么要这么设计呢，期间的又一个奥秘便体现在此，请看图中的备注。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/1/171348d0ddf6425e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="扩容索引计算1"></p>
<p>既然扩容后每个 key 的新索引的生成规则是固定有规律的，即只有两种形式，要么不变 i，要么增加原先的数组大小的量（i+n），所以我们其实并不需要真的去计算每个 key 的索引，而只需要判断索引是否不变即可。所以此处巧妙地使用了 <code>(e.hash &amp; oldCap) == 0</code> 这个判断，着实精妙，计算的细节过程看下面的图即可。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/1/171348d0e3c69063?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="扩容索引计算2"></p>
<h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><p>此处介绍的是 <code>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code>，因为 put() 其实就是直接调用的 putVal()；</p>
<p>put() 方法是 HashMap 中最常用的方法之一，我们先大体关注下 put() 方法的流程，文字就暂不赘述了，看下图便很清晰了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/1/171348d0e8ae26a7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="put 流程"></p>
<p>下面简单分析下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数 onlyIfAbsent，true：不修改已存在的 value，false：已存在则进行修改</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// ① 如果当前 table 为空则进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 计算得到索引 i，算法在上文有提到，然后查看索引处是否有数据</span></span><br><span class="line">    <span class="comment">// ② 如果没有数据，则新建一个新的 Node</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 索引处有数据</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// ③ 索引处的第一个 Node 的  key 和参数 key 是一致的，所以直接修改 value 值即可（修改的动作放在下面）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// ④ 索引处的 bucket 是红黑树，按照红黑树的逻辑进行插入或修改</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// ⑤ 索引处的 bucket 是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表上面的所有 Node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 索引处的 Node 为尾链</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 直接新建一个 Node 插在尾链处</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断是否需要转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 链表转换为红黑树，此方法在上文中也有介绍</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前 Node 的 key 值和参数 key 是一致的，即直接修改 value 值即可（修改的动作放在下面）</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了相同 key 的 Node，所以进行修改 vlaue 值即可</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 修改 value 值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 修改操作，直接 return 结束掉代码逻辑</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结构发生变化的次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// ⑥ 判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">// 新增的 Node，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h2><p>此处介绍的是 <code>getNode(int hash, Object key</code>，因为 get() 其实就是直接调用的 getNode()；</p>
<p>get() 方法也是比较简单的，就是根据 key 获取 table 的索引，然后再分情况查找拥有相同 key 的 Node；</p>
<p>源码大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 当前 table 不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断索引处的第一个 Node 的 key 值是否和参数 key 相同，相同则返回该 Node</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 索引处的第一个 Node 不是想要的，则接着查 next</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// bucket 是红黑树结构</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// bucket 是链表结构</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="JDK1-8-VS-JDK1-7"><a href="#JDK1-8-VS-JDK1-7" class="headerlink" title="JDK1.8 VS JDK1.7"></a>JDK1.8 VS JDK1.7</h1><p>1.7 和 1.8 之间的区别，最最主要的是如下三方面，当然，鄙人觉得这三点的变化可以算是比较成功的优化。</p>
<ol>
<li>扩容后 Node 索引的计算方式不同。上文提到，由于 table 大小的这种神奇的设计，所以扩容时计算索引的时候，1.8 中只需要简单使用 &amp; 运算来判断是否为 0 即可，并不需要像 1.7 一样每次都是用 &amp; 运算来计算出索引值。</li>
<li>1.8 中引入了红黑树结构。上文也提到了，当链表长度大于 8 的时候会转换为红黑树，但是 1.7 中是数组+链表的组合。</li>
<li>1.8 中采用的是尾插法，而 1.7 中采用的是头插法。比如扩容的时候，头插法会使链表上 Node 的顺序调转，而尾插法则不会，另外，头插法也会造成环形链死循环等问题，本文就不深讨了。</li>
</ol>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>HashMap 是线程不安全的，因为它是允许多线程同时操作同一个数组的，比如 put()，比如 resize()，这些都会造成数据异常甚至死循环。</p>
<p>所以要使用线程安全的 Map 的时候，可以使用 HashTable，但是这个不推荐，或者使用自 JDK1.8 开始引入的 Concurrent 包中的 ConcurrentHashMap，这个是比较推荐的，具体的介绍就放到下文再说吧。</p>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器之集合总结</title>
    <url>/posts/8bb8caa2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:</p>
<ul>
<li>降低编程难度</li>
<li>提高程序性能</li>
<li>提高API间的互操作性</li>
<li>降低学习难度</li>
<li>降低设计和实现相关API的难度</li>
<li>增加程序的重用性</li>
</ul>
<p>Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程</p>
</blockquote>
<a id="more"></a>

<h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><h2 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h2><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>
<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>
<h2 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h2><p>接下来，我们可以对数组和集合的区别来分析一下：</p>
<p>数组和集合的区别:</p>
<p>长度的区别</p>
<ul>
<li><p><strong>数组的长度固定</strong></p>
</li>
<li><p><strong>集合的长度可变</strong></p>
</li>
</ul>
<p>内容不同</p>
<ul>
<li><p>数组存储的是同一种类型的元素</p>
</li>
<li><p>集合可以存储不同类型的元素(但是一般我们不这样干..)</p>
</li>
</ul>
<p>元素的数据类型</p>
<ul>
<li>数组可以存储基本数据类型,也可以存储引用类型</li>
<li><strong>集合只能存储引用类型(你存储的是简单的int，它会自动装箱成Integer)</strong></li>
</ul>
<h2 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h2><p>从下图可以看出，在 Java 中除了以 <code>Map</code> 结尾的类之外， 其他类都实现了 <code>Collection</code> 接口。</p>
<p>并且，以 <code>Map</code> 结尾的类都实现了 <code>Map</code> 接口。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/java-collection-hierarchy.png" alt="img"></p>
<h2 id="说说-List-Set-Map-三者的区别？"><a href="#说说-List-Set-Map-三者的区别？" class="headerlink" title="说说 List,Set,Map 三者的区别？"></a>说说 List,Set,Map 三者的区别？</h2><ul>
<li><code>List</code>(对付顺序的好帮手)： 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Map</code>(用 Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，”y”代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h2 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h2><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><code>Arraylist</code>： <code>Object[]</code>数组</li>
<li><code>Vector</code>：<code>Object[]</code>数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li><code>HashSet</code>（无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h2 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h2><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>
<h1 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h1><p>List集合下最常见的集合类有两个：<strong>ArrayList和LinkedList</strong></p>
<p>众所周知，ArrayList底层是数组，LinkedList底层是链表。数组遍历速度快，LinkedList增删元素快。</p>
<p>为什么在工作中一般就用ArrayList，而不用LinkedList呢？原因也很简单：</p>
<ul>
<li>在工作中，<strong>遍历的需求比增删多</strong>，即便是增加元素往往也只是从尾部插入元素，而ArrayList在尾部插入元素也是O(1)</li>
<li>ArrayList增删没有想象中慢，ArrayList的增删底层调用的<code>copyOf()</code>被优化过，加上现代CPU对内存可以<strong>块操作</strong>，普通大小的ArrayList增删比LinkedList更快。</li>
</ul>
<p>所以，在开发中，想到要用集合来装载元素，第一个想到的就是ArrayList。</p>
<p>那么来了，LinkedList用在什么地方呢？我们一般用在刷算法题上。把LinkedList当做一个先进先出的队列，LinkedList本身就实现了Queue接口</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/2BGWl1qPxib3mhZCl4TgE6S1LuyZnSg8lgRU6mYqwfMVf5FDRibbia9zSWe0uroaYpL0qIKbSGUeR9qvJdPibc8CBw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果考虑线程安全的问题，可以看看CopyOnWriteArrayList，实际开发用得不多，但我觉得可以了解一下它的思想（CopyOnWrite），这个思想在Linux/文件系统都有用到。</p>
<h2 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别?"></a>Arraylist 和 Vector 的区别?</h2><ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code> Object[ ]</code> 存储，线程安全的。</li>
</ul>
<h2 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h2><ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h1 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h1><p>Set集合下最常见的集合类有三个：<strong>HashSet、TreeSet、LinkedHashSet</strong></p>
<p>List和Set都是集合，一般来说：<strong>如果我们需要保证集合的元素是唯一的，就应该想到用Set集合</strong></p>
<p>比如说：现在要发送一批消息给用户，我们为了减少「一次发送重复的内容给用户」这样的错误，我们就用Set集合来保存用户的<code>userId/phone</code></p>
<p>自然地，首先要保证最上游的那批用户的<code>userId/phone</code>是没有重复的，而我们用Set集合只是为了做一个<strong>兜底</strong>来尽可能避免重复发送的问题。</p>
<p>一般我们在开发中最多用到的也就是<strong>HashSet</strong>。TreeSet是可以排序的Set，一般我们需要有序，从数据库拉出来的数据就是有序的，可能往往写<code>order by id desc</code>比较多。而在开发中也很少管元素插入有序的问题，所以LinkedHashSet一般也用不上。</p>
<p>如果考虑线程安全的问题，可以考虑CopyOnWriteArraySet，用得就更少了（这是一个线程安全的Set，底层实际上就是CopyOnWriteArrayList)</p>
<p>TreeSet和LinkedHashSet更多的可能用在刷算法的时候。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/2BGWl1qPxib3mhZCl4TgE6S1LuyZnSg8lgs41oy2JiakAGYcMz1H8HPicfy8FGjWbs88iaRBpZFD3HPArZEricAmfYA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h2><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p>
<p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p>
<p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p>
<h1 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h1><p>Map集合最常见的子类也有三个：HashMap、LinkedHashMap、TreeMap</p>
<p>如果考虑线程安全问题，应该想到的是ConcurrentHashMap，当然了Hashtable也要有一定的了解，因为面试实在是问得太多太多了。</p>
<p>HashMap在实际开发中用得也非常多，只要是<code>key-value</code>结构的，一般我们就用<code>HashMap</code>。LinkedHashMap和TreeMap用的不多，原因跟HashSet和TreeSet一样。</p>
<p>ConcurrentHashMap在实际开发中也用得挺多，我们很多时候把ConcurrentHashMap用于<strong>本地缓存</strong>，不想每次都网络请求数据，在本地做本地缓存。监听数据的变化，如果数据有变动了，就把ConcurrentHashMap对应的值给更新了。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/2BGWl1qPxib3mhZCl4TgE6S1LuyZnSg8lxzB6YGxfIuHvUrWFoafuDLhxtibajS51PEgz5bwibQiaJd8rdpPM2xtpA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ol>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的,因为 <code>HashTable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>HashTable</code> 效率高一点。另外，<code>HashTable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<p><strong><code>HashMap</code> 中带有初始容量的构造函数：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个方法保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h2><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th><code>HashMap</code></th>
<th><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现了 <code>Map</code> 接口</td>
<td>实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 <code>put()</code>向 map 中添加元素</td>
<td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code> equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h2 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h2><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/TreeMap%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="img"></p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年06月15日 17:02:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person person1, Person person2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> num = person1.getAge() - person2.getAge();</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">3</span>), <span class="string">&quot;person1&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">18</span>), <span class="string">&quot;person2&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">35</span>), <span class="string">&quot;person3&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">16</span>), <span class="string">&quot;person4&quot;</span>);</span><br><span class="line">        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;</span><br><span class="line">            System.out.println(personStringEntry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">perso<span class="symbol">n1</span></span><br><span class="line">perso<span class="symbol">n4</span></span><br><span class="line">perso<span class="symbol">n2</span></span><br><span class="line">perso<span class="symbol">n3</span></span><br></pre></td></tr></table></figure>
<p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p>
<p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;((person1, person2) -&gt; &#123;</span><br><span class="line">  <span class="keyword">int</span> num = person1.getAge() - person2.getAge();</span><br><span class="line">  <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h2><p>以下内容摘自《Head fist java》第二版：</p>
<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<p><strong><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li>
<li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li>
<li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li>
<li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li>
<li><code>hashCode() </code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p><strong>==与 equals 的区别</strong></p>
<p>对于基本类型来说，== 比较的是值是否相等；</p>
<p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p>
<p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>
<h1 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h1><p>Collections 工具类常用方法:</p>
<ol>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ol>
<h2 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span></span><br></pre></td></tr></table></figure>
<h2 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span>, 用新元素替换旧元素</span></span><br></pre></td></tr></table></figure>
<h2 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h2><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>
<p>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>List</tag>
        <tag>Set</tag>
        <tag>Map</tag>
        <tag>Collections</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发之理论基础</title>
    <url>/posts/294cdc36/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>并发的一些理论基础知识</p>
</blockquote>
<a id="more"></a>

<h1 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h1><p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p>
<ul>
<li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致 <code>可见性</code>问题</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 <code>原子性</code>问题</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 <code>有序性</code>问题</li>
</ul>
<h1 id="线程不安全示例"><a href="#线程不安全示例" class="headerlink" title="线程不安全示例"></a>线程不安全示例</h1><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">997 // 结果总是小于1000</span><br></pre></td></tr></table></figure>
<h1 id="并发出现问题的根源-并发三要素"><a href="#并发出现问题的根源-并发三要素" class="headerlink" title="并发出现问题的根源: 并发三要素"></a>并发出现问题的根源: 并发三要素</h1><p>上述代码输出为什么不是1000? 并发出现问题的根源是什么?</p>
<h2 id="可见性-CPU缓存引起"><a href="#可见性-CPU缓存引起" class="headerlink" title="可见性: CPU缓存引起"></a>可见性: CPU缓存引起</h2><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p>
<p>举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>
<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h2 id="原子性-分时复用引起"><a href="#原子性-分时复用引起" class="headerlink" title="原子性: 分时复用引起"></a>原子性: 分时复用引起</h2><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>经典的<strong>转账问题</strong>：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<h2 id="有序性-重排序引起"><a href="#有序性-重排序引起" class="headerlink" title="有序性: 重排序引起"></a>有序性: 重排序引起</h2><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<p><img src="https://www.pdai.tech/_images/jvm/java-jmm-3.png" alt="img"></p>
<p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）</p>
<h1 id="JAVA是怎么解决并发问题的-JMM-Java内存模型"><a href="#JAVA是怎么解决并发问题的-JMM-Java内存模型" class="headerlink" title="JAVA是怎么解决并发问题的: JMM(Java内存模型)"></a>JAVA是怎么解决并发问题的: JMM(Java内存模型)</h1><p><strong>理解的第一个维度：核心知识点</strong></p>
<p>JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p>
<ul>
<li>volatile、synchronized 和 final 三个关键字</li>
<li>Happens-Before 规则</li>
</ul>
<p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p>
<ul>
<li>原子性</li>
</ul>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>;        <span class="comment">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span></span><br><span class="line">y = x;         <span class="comment">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span></span><br><span class="line">x++;           <span class="comment">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4： 同语句3</span></span><br></pre></td></tr></table></figure>
<p>上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<blockquote>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
</blockquote>
<ul>
<li>可见性</li>
</ul>
<p>Java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<blockquote>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
</blockquote>
<ul>
<li>有序性</li>
</ul>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</p>
<h2 id="关键字-volatile、synchronized-和-final"><a href="#关键字-volatile、synchronized-和-final" class="headerlink" title="关键字: volatile、synchronized 和 final"></a>关键字: volatile、synchronized 和 final</h2><h2 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<p> <strong>单一线程原则（Single Thread rule）</strong>：在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<p><img src="https://www.pdai.tech/_images/pics/single-thread-rule.png" alt="image"></p>
<p> <strong>管程锁定规则（Monitor Lock Rule）</strong>：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<p><img src="https://www.pdai.tech/_images/pics/monitor-lock-rule.png" alt="image"></p>
<p><strong>volatile 变量规则（Volatile Variable Rule）</strong>：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<p><img src="https://www.pdai.tech/_images/pics/volatile-variable-rule.png" alt="image"></p>
<p> <strong>线程启动规则（Thread Start Rule）</strong>：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<p><img src="https://www.pdai.tech/_images/pics/thread-start-rule.png" alt="image"></p>
<p> <strong>线程加入规则（Thread Join Rule）</strong>：Thread 对象的结束先行发生于 join() 方法返回。</p>
<p><img src="https://www.pdai.tech/_images/pics/thread-join-rule.png" alt="image"></p>
<p> <strong>线程中断规则（Thread Interruption Rule）</strong>：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<p> <strong>对象终结规则（Finalizer Rule）</strong>：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。</p>
<p><strong>传递性（Transitivity）</strong>：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
<h1 id="线程安全-不是一个非真即假的命题"><a href="#线程安全-不是一个非真即假的命题" class="headerlink" title="线程安全: 不是一个非真即假的命题"></a>线程安全: 不是一个非真即假的命题</h1><p>一个类在可以被多个线程安全调用时就是线程安全的。</p>
<p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。</p>
<p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变的类型:</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections<span class="variable">$UnmodifiableMap</span>.put(Collections.java:1457)</span><br><span class="line">    at ImmutableExample.main(ImmutableExample.java:9)</span><br></pre></td></tr></table></figure>
<p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h2><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p>
<h2 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h2><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<p>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p>
<p>对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorUnsafeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;Thread-159738&quot;</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 3</span><br><span class="line">    at java.util.Vector.remove(Vector.java:831)</span><br><span class="line">    at VectorUnsafeExample.lambda$main<span class="variable">$0</span>(VectorUnsafeExample.java:14)</span><br><span class="line">    at VectorUnsafeExample$$Lambda<span class="variable">$1</span>/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)   </span><br></pre></td></tr></table></figure>
<p>如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);   </span><br></pre></td></tr></table></figure>
<h2 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h2><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p>
<h2 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h2><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p>
<h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>synchronized 和 ReentrantLock</p>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>J.U.C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下代码是 incrementAndGet() 的源码，它调用了 unsafe 的 getAndAddInt() 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p>
<p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a><strong>栈封闭</strong></h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">100   </span><br></pre></td></tr></table></figure>
<h3 id="线程本地存储-Thread-Local-Storage"><a href="#线程本地存储-Thread-Local-Storage" class="headerlink" title="线程本地存储(Thread Local Storage)"></a><strong>线程本地存储(Thread Local Storage)</strong></h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1  </span><br></pre></td></tr></table></figure>
<p>为了理解 ThreadLocal，先看以下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>它所对应的底层结构图为:</p>
<p><img src="https://www.pdai.tech/_images/pics/3646544a-cb57-451d-9e03-d3c4f5e4434a.png" alt="image"></p>
<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象，Thread 类中就定义了 ThreadLocal.ThreadLocalMap 成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;   </span><br></pre></td></tr></table></figure>
<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>get() 方法类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h3 id="可重入代码-Reentrant-Code"><a href="#可重入代码-Reentrant-Code" class="headerlink" title="可重入代码(Reentrant Code)"></a>可重入代码(Reentrant Code)</h3><p>这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发之线程基础</title>
    <url>/posts/ce5bca27/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>线程的一些相关基础知识</p>
</blockquote>
<a id="more"></a>

<h1 id="CPU核心与线程数关系"><a href="#CPU核心与线程数关系" class="headerlink" title="CPU核心与线程数关系"></a>CPU核心与线程数关系</h1><blockquote>
<p>Java中通过多线程的手段来实现并发，对于单处理器机器上来讲，宏观上的多线程并行执行是通过CPU的调度来实现的，微观上CPU在某个时刻只会运行一个线程。事实上，如果这些任务不存在阻塞，也就是程序中的某个任务因为该程序控制范围之外的某些条件（通常是I/O）而导致不能继续执行，由于在任务之间切换会产生开销，因此并行的效率可能没有顺序执行的效率高，并行也就没有意义。</p>
</blockquote>
<p>一般来讲，CPU核心数和线程数的关系为核心数:线程数=1:1；但是如果使用了超线程技术，可以达到1:2甚至更多。</p>
<h4 id="CPU调度方式"><a href="#CPU调度方式" class="headerlink" title="CPU调度方式"></a>CPU调度方式</h4><p>CPU采用时间片轮转机制，来调度不同的线程运行，又称RR调度，注意这样会导致上下文切换。如果线程数目过大，可能产生较大的线程切换开销。</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h2><blockquote>
<p>进程是程序的一次执行，进程是一个程序及其数据在处理机上顺序执行所发生的活动，进程是具有独立功能的程序在一个数据集合上运行的过程，他是系统进行资源分配的调度的独立单位</p>
</blockquote>
<p>总结一下：<strong>进程是程序的一次执行，是系统进行 资源分配和调度的独立单位。每一个进程都有自己的内存空间 和系统资源</strong></p>
<h2 id="线程定义"><a href="#线程定义" class="headerlink" title="线程定义"></a>线程定义</h2><blockquote>
<p>线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位；线程基本上不拥有系统资源。只有一点在运行中必不可少的资源，但它可以与跟它同属一个进程的其他线程共享进程的资源</p>
</blockquote>
<h3 id="有了进程为什么还要有线程"><a href="#有了进程为什么还要有线程" class="headerlink" title="有了进程为什么还要有线程"></a><strong>有了进程为什么还要有线程</strong></h3><p>因为每一个进程会占据一定的空间资源和系统资源；而我们的操作系统为了满足用户同时打开运行多个程序的情况；不会让CPU一直被同一个进程所占据，而是采用并发（后面会讲）的策略来实现“同时”运行多个程序的效果；而采用并发的方式就必然会涉及到频繁的上下文切换，由于进程所占有的资源，会导致上下文切换的时间和空间代价比较大；而线程由于基本不会占用系统资源，所以上下文切换的代价要远远小于进程；从而提高了系统的执行效率。</p>
<p>简单点说：<strong>进程实现并发非常消耗CPU的资源；而引入线程取代了进程的资源调度功能；减少了CPU的开销</strong>。</p>
<h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p>进程与线程的最大区别在与进程之间是相互独立的，而线程之间可能因为在同一进程下而相互影响；<strong>线程开销小，但不利于资源的管理和保护；而进程则相反</strong>。</p>
<blockquote>
<p>关系：一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。   区别：主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
</blockquote>
<blockquote>
<p>优缺点：线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>
</blockquote>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p><strong>并行性：</strong>同一时间，多个任务同时执行；</p>
<p><strong>并行：</strong>发生不同实体上的多个事件</p>
<p><strong>并发性：</strong>同一段时间，多个任务都在执行；</p>
<p><strong>并发：</strong>发生在同一实体上的多个事件</p>
<p>理解：比如说你今天要完成三件事，敲代码，写博客 ，看视频；如果你敲了会代码，就去看视频了，看了会视频，有了灵感，又去写博客了，你在这三件事之间来回换，但都是你自己一个人完成的这些，这就是并发，而并行就是你去看视频了，又叫了两个人分别帮你敲代码和写博客，这三件事是同时发生的。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="为什么要用多线程"><a href="#为什么要用多线程" class="headerlink" title="为什么要用多线程"></a>为什么要用多线程</h2><p>从计算机层面来说：因为线程上下文切换的开销要小于进程，所以我们要用进程；而现在的操作系统都是多核的，多线程能够提高我们对CPU资源的利用效率；</p>
<p>从实际来说：现在的系统随随便便就是要求百万级别甚至千万界别的并发量，而多线程则是并发系统的基础；利用好多线程可以大大提高系统的并发能力和性能。</p>
<h2 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h2><h3 id="继承Thread类，重写run-方法"><a href="#继承Thread类，重写run-方法" class="headerlink" title="继承Thread类，重写run()方法"></a>继承Thread类，重写run()方法</h3><p>步骤为：</p>
<p>  （1）创建一个类继承Thread类，重写run()方法，将所要完成的任务代码写进run()方法中；</p>
<p>  （2）创建Thread类的子类的对象；</p>
<p>  （3）调用该对象的start()方法，该start()方法表示先开启线程，然后调用run()方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;输出的结果&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个新线程</span></span><br><span class="line">        ThreadDemo1 thread1 = <span class="keyword">new</span> ThreadDemo1();</span><br><span class="line">        <span class="comment">//为线程设置名称</span></span><br><span class="line">        thread1.setName(<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;输出的结果&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现Runnable接口，实现run-方法"><a href="#实现Runnable接口，实现run-方法" class="headerlink" title="实现Runnable接口，实现run()方法"></a>实现Runnable接口，实现run()方法</h3><p>Runnable实例对象作为Thread构造方法中的target参数传入，充当线程执行体。这种方式适用于多个线程共享资源的情况。</p>
<p>执行的话必须new Thread(该类的实例).start();方法</p>
<p>步骤为：</p>
<p>   （1）创建一个类并实现Runnable接口</p>
<p>   （2）重写run()方法，将所要完成的任务代码写进run()方法中</p>
<p>   （3）创建实现Runnable接口的类的对象，将该对象当做Thread类的构造方法中的参数传进去</p>
<p>   （4）使用Thread类的构造方法创建一个对象，并调用start()方法即可运行该线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;输出的结果&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个新线程</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo2());</span><br><span class="line">        <span class="comment">//为线程设置名称</span></span><br><span class="line">        thread2.setName(<span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;输出的结果&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐使用实现接口的方式，他比继承类的方式更灵活，也能减少程序之间的耦合度，<strong>面向接口编程</strong>也是设计模式6大原则的核心；</p>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>步骤为：</p>
<p>  （1）创建一个类并实现Callable接口</p>
<p>  （2）重写call()方法，将所要完成的任务的代码写进call()方法中，需要注意的是call()方法有返回值，并且可以抛出异常</p>
<p>  （3）如果想要获取运行该线程后的返回值，需要创建Future接口的实现类的对象，即FutureTask类的对象，调用该对象的get()方法可获取call()方法的返回值</p>
<p>　（4）使用Thread类的有参构造器创建对象，将FutureTask类的对象当做参数传进去，然后调用start()方法开启并运行该线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread3</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;输出的结果&quot;</span>);</span><br><span class="line">        <span class="comment">//创建FutureTask的对象</span></span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> ThreadDemo3());</span><br><span class="line">        <span class="comment">//创建Thread类的对象</span></span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        thread3.setName(<span class="string">&quot;线程三&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        thread3.start();</span><br><span class="line">        <span class="comment">//获取call()方法的返回值，即线程运行结束后的返回值</span></span><br><span class="line">        String result = task.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;输出的结果&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+<span class="string">&quot;返回的结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、使用线程池创建</p>
<p>​    使用线程池创建线程的步骤：</p>
<p>  （1）使用new ThreadPoolExecutor 来创建线程池，而不是使用Executors类中的几种方法来创建</p>
<p>  （2）调用线程池中的execute()方法执行由实现Runnable接口创建的线程；调用submit()方法执行由实现Callable接口创建的线程</p>
<p>  （3）调用线程池中的shutdown()方法关闭线程池</p>
<h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java 线程的状态 "></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java 线程状态变迁 "></p>
<h4 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h4><p>当用new操作符创建一个新线程时，如newThread (r)，该线程还没有开始运行。这意味 着它的状态是New，当一个线程处于新创建状态时 程序还没有开始运行线程中的代码 在 线程运行之前还有一些基础工作要做</p>
<h4 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h4><p>一旦调用start方法，线程处于runnable状态。一个可运行的线桿可能正在运行也可能没 有运行，这取决于操作系统给线程提供运行的时间（ Java 的规范说明没有将它作为一个单独状态。）</p>
<h4 id="阻塞、等待、计时等待状态"><a href="#阻塞、等待、计时等待状态" class="headerlink" title="阻塞、等待、计时等待状态"></a>阻塞、等待、计时等待状态</h4><ul>
<li>当一个线程试图获取一个内部的对象锁（而不是 java.util.concurrent 库中的锁 而该锁被其他线程持有，则该线程进人<strong>阻塞状态</strong>。当所有其他线程释放该锁 并且线程调度器允许，本线程持有它的时候 该线程将变成非阻塞状态。</li>
<li>当线程等待另一个线程通知调度器一个条件时 它自己进入<strong>等待状态</strong>。在调用 Object.wait方法或Thread.join方法或者是等待java.util.concurrent库中的 Lock或Condition时,就会出现这种情况。注意，被阻塞状态与等待状态是有很大不同的。</li>
<li>有几个方法有一个超时参数。调用它们导致线程进人<strong>计时等待</strong>（ timed waiting ) 状态这一状态将一直保持到超时期满或者接收到适当的通知，带有超时参数的方法有Thread.sleep和Object.wait、Thread.join、Lock, try Lock 以及 Condition.await的计时版。</li>
</ul>
<h4 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h4><p>线程因如下两个原因之一而被终止：</p>
<ul>
<li>因为run方法正常退出而自然死亡。</li>
<li>因为一个没有捕获的异常终止了run方法而意外死亡。</li>
</ul>
<blockquote>
<p>可以调用线程的stop方法杀死一个线程,该方法抛出ThreadDeath错误对象,由此杀死线程。</p>
</blockquote>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java中每个线程有一个优先级，默认情况下会继承父线程的优先级。可以用setPriority方法来设定线程的优先级，优先级在MIN_PRIORITY（1）和MAX_PRIORITY（10）之间。</p>
<blockquote>
<p>注意：优先级的实现高度依赖系统，Java的优先级会被映射到宿主机平台的优先级上，因此有可能优先级变多或者变少，极端情况下，可能所有优先级映射到了宿主机的同一个优先级，因此不要过度依赖优先级。</p>
</blockquote>
<p>优先级的设置不合理，可能导致低优先级的线程永远无法运行。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>可以通过调用t.setDaemon(true)来将线程转换为守护线程。守护线程的唯一功能就是为其他线程提供服务。<strong>当只剩下守护线程时，虚拟机会退出。</strong></p>
<blockquote>
<p>守护线程应该永远不去访问固有资源，如文件、数据库等，因为它可能在一个操作的中间发生中断。</p>
</blockquote>
<h2 id="线程同步与共享"><a href="#线程同步与共享" class="headerlink" title="线程同步与共享"></a>线程同步与共享</h2><p>在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果多个线程之间不进行协调与同步，无法保证在访问共享资源时的正确性。Java提供了一些用于线程共享的工具。</p>
<h3 id="Synchronized内置锁"><a href="#Synchronized内置锁" class="headerlink" title="Synchronized内置锁"></a>Synchronized内置锁</h3><p>synchronized主要有两种用法，分别是</p>
<ul>
<li><strong>对象锁</strong>，锁的是类的对象实例。</li>
<li><strong>类锁</strong>，锁的是每个类的的Class对象，每个类的的Class对象在一个虚拟机中只有一个，所以类锁也只有一个。</li>
</ul>
<p>具体来讲，有如下几种用法，</p>
<p><strong>1. 修饰代码块</strong></p>
<p>被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象.</p>
<p>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。类似如下操作，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。</p>
</blockquote>
<p><strong>2. 修饰一个方法</strong></p>
<p>Synchronized修饰一个方法很简单，就是在方法的前面加synchronized.修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">         Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。</p>
</blockquote>
<p><strong>3. 修饰一个静态的方法</strong></p>
<p>Synchronized也可修饰一个静态方法，用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 修饰一个类</strong></p>
<p>Synchronized还可作用于一个类，用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(ClassName.class) &#123;</span><br><span class="line">         <span class="comment">// todo</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。</p>
<p><strong>总结</strong></p>
<blockquote>
<p>A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。<br> B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br> C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p>
</blockquote>
<h3 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h3><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。</p>
<p>当把变量声明成volatile类型后，编译器和运行时都会注意到这个变量是共享的，因此不会将改变量与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在读取volatile类型的变量时，总会返回最新写入的值。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>维护线程封闭性的一种更规范性的方法是ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口与方法，这些方法为使用该变量的每个线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。</p>
<p>当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。从概念上讲，你可以将ThreadLocal视为包含了Map&lt;Thread, T&gt;对象，其中保存了特定于该线程的值，但ThreadLocal的实现并非如此，这些特定的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。</p>
<p>具体使用可以参考下面的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseThreadLocal</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//可以理解为 一个map，类型 Map&lt;Thread,Integer&gt;</span></span><br><span class="line">	<span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLaocl = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行3个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartThreadArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread[] runs = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;runs.length;i++)&#123;</span><br><span class="line">            runs[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> TestThread(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;runs.length;i++)&#123;</span><br><span class="line">            runs[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *类说明：测试线程，线程的工作是将ThreadLocal变量的值变化，并写回，看看线程之间是否会互相影响</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:start&quot;</span>);</span><br><span class="line">            Integer s = threadLaocl.get();<span class="comment">//获得变量的值</span></span><br><span class="line">            s = s+id;</span><br><span class="line">            threadLaocl.set(s);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span></span><br><span class="line">            +threadLaocl.get());</span><br><span class="line">            <span class="comment">//threadLaocl.remove();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	UseThreadLocal test = <span class="keyword">new</span> UseThreadLocal();</span><br><span class="line">        test.StartThreadArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h2><h4 id="等待与通知wait、notify、notifyAll"><a href="#等待与通知wait、notify、notifyAll" class="headerlink" title="等待与通知wait、notify、notifyAll"></a>等待与通知wait、notify、notifyAll</h4><p>JDK提供了wait、notify、notifyAll方法来进行多个线程之间的协作，注意这些方法是在Object类中的。</p>
<ul>
<li>调用Object.wait()方法后，当前线程会在这个对象上等待；一直等待到其他线程调用了该对象对应的notifyAll对象为止。</li>
<li>如果该对象上有多个线程调用了wait()方法，那样为了唤醒所有的线程，需要调用notifyAll()方法。</li>
</ul>
<blockquote>
<p>注意：一般wait和notifyAll配合使用，因为当有多个线程调用wait后，会进入到该对象的等待队列，如果调用notify，则只会从等待列表中随机唤醒一个线程。可能并不是我们想要的结果。</p>
</blockquote>
<p>以下是wait和notify、notifyAll方法的工作流程：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/5/16ed667dba216904?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Screen Shot 2019-11-29 at 12.45.25 PM.png"></p>
<p>以下是notify和wait的使用范例，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Express</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String CITY = <span class="string">&quot;ShangHai&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> km;<span class="comment">/*快递运输里程数*/</span></span><br><span class="line">    <span class="keyword">private</span> String site;<span class="comment">/*快递到达地点*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Express</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Express</span><span class="params">(<span class="keyword">int</span> km, String site)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.km = km;</span><br><span class="line">        <span class="keyword">this</span>.site = site;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">changeKm</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.km = <span class="number">101</span>;</span><br><span class="line">    	notifyAll();</span><br><span class="line"><span class="comment">//    	notify();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 变化地点，然后通知处于wait状态并需要处理地点的线程进行业务处理*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">changeSite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.site = <span class="string">&quot;BeiJing&quot;</span>;</span><br><span class="line">    	notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitKm</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="keyword">this</span>.km&lt;=<span class="number">100</span>) &#123;</span><br><span class="line">    		<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;check km thread[&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">						+<span class="string">&quot;] is still waiting.&quot;</span>);</span><br><span class="line">				wait();</span><br><span class="line">				System.out.println(<span class="string">&quot;check km thread[&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">						+<span class="string">&quot;] is notified.&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitSite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(CITY.equals(<span class="keyword">this</span>.site)) &#123;</span><br><span class="line">    		<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;check site thread[&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">						+<span class="string">&quot;] is still waiting.&quot;</span>);</span><br><span class="line">				wait();</span><br><span class="line">				System.out.println(<span class="string">&quot;check site thread[&quot;</span>+Thread.currentThread().getId()</span><br><span class="line">						+<span class="string">&quot;] is notified.&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试程序中，启动了6个线程，当changeKm调用后，所有wait的线程被唤醒。但是由于城市未发生变化，因此检查城市的线程在被唤醒后继续等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWN</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Express express = <span class="keyword">new</span> Express(<span class="number">0</span>,Express.CITY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*检查里程数变化的线程,不满足条件，线程一直等待*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckKm</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	express.waitKm();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*检查地点变化的线程,不满足条件，线程一直等待*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckSite</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	express.waitSite();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;<span class="comment">//三个线程</span></span><br><span class="line">            <span class="keyword">new</span> CheckSite().start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;<span class="comment">//里程数的变化</span></span><br><span class="line">            <span class="keyword">new</span> CheckKm().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        express.changeKm();<span class="comment">//快递地点变化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到调用wait和notify的方法都有synchronized关键字，因为在调用这些方法之前，都需要获得目标对象的监视器，执行完后会释放这个监视器。当某个线程被唤醒时，第一件事是试图获取目标对象的监视器，如果获取到了，则执行后续代码，否则一直等待获取监视器。</p>
</blockquote>
<h4 id="等待线程结束-join-和谦让-yeild"><a href="#等待线程结束-join-和谦让-yeild" class="headerlink" title="等待线程结束(join)和谦让(yeild)"></a>等待线程结束(join)和谦让(yeild)</h4><p><strong>join方法</strong></p>
<p>当一个线程的输入可能非常依赖另一个线程或者多个线程的输出，此时，这个线程需要等待依赖线程执行完毕才能继续。JDK提供了join操作来实现这个功能，</p>
<p>比如在线程A里，执行了线程B.join()方法，线程A必须要等待B执行完成了以后，线程A才能继续自己的工作。</p>
<p><strong>yeild方法</strong></p>
<p>Thread.yield()是一个静态方法，一旦执行，他会使当前线程让出CPU，但是让出CPU并不表示当前线程不执行。当前线程在让出CPU之后，还会进行CPU资源的争夺，但是是否能被分配就不一定。</p>
<h4 id="yield-、sleep-、wait-、notify-等方法对锁有何影响"><a href="#yield-、sleep-、wait-、notify-等方法对锁有何影响" class="headerlink" title="yield() 、sleep()、wait()、notify()等方法对锁有何影响"></a>yield() 、sleep()、wait()、notify()等方法对锁有何影响</h4><ul>
<li>yield：让出时间片，不会释放锁</li>
<li>sleep：线程进入睡眠状态，不会释放锁</li>
<li>wait：必须拿到锁才能执行，执行后释放锁，进入锁的等待队列，方法被notify返回后重新拿到锁。</li>
<li>notify：必须拿到锁才能执行，执行后不会立马释放锁，而是通知等待队列中的某一个线程，同步代码块执行完毕后才会释放锁。本身是不会释放锁的。</li>
</ul>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$0(InterruptExample.java:5)</span><br><span class="line">    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>
<h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h3><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Thread end</span><br></pre></td></tr></table></figure>
<h3 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h3><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>
<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring声明式事务</title>
    <url>/posts/94350444/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>spring事务的理解与使用</p>
</blockquote>
<a id="more"></a>

<h2 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1. 什么是事务？"></a>1. 什么是事务？</h2><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p>我们系统的每个业务方法可能包括了多个原子性的数据库操作，比如下面的 <code>savePerson()</code> 方法中就有两个原子性的数据库操作。这些原子性的数据库操作是有依赖的，它们要么都执行，要不就都不执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	personDao.save(person);</span><br><span class="line">	personDetailDao.save(personDetail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，需要格外注意的是：<strong>事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的<code>innodb</code>引擎。但是，如果把数据库引擎变为 <code>myisam</code>，那么程序也就不再支持事务了！</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p>
<ol>
<li>将小明的余额减少 1000 元</li>
<li>将小红的余额增加 1000 元。</li>
</ol>
<p>万一在这两个操作之间突然出现错误比如银行系统崩溃或者网络故障，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdersService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrdersDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional(propagation = Propagation.REQUIRED,</span></span><br><span class="line"><span class="meta">                isolation = Isolation.DEFAULT, readOnly = false, timeout = -1)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小红账户多1000</span></span><br><span class="line">		accountDao.addMoney(<span class="number">1000</span>,xiaohong);</span><br><span class="line">		<span class="comment">//模拟突然出现的异常，比如银行中可能为突然停电等等</span></span><br><span class="line">    <span class="comment">//如果没有配置事务管理的话会造成，小红账户多了1000而小明账户没有少钱</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//小王账户少1000</span></span><br><span class="line">		accountDao.reduceMoney(<span class="number">1000</span>,xiaoming);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，数据库事务的 ACID 四大特性是事务的基础，下面简单来了解一下。</p>
<h2 id="2-事物的特性（ACID）了解么"><a href="#2-事物的特性（ACID）了解么" class="headerlink" title="2. 事物的特性（ACID）了解么?"></a>2. 事物的特性（ACID）了解么?</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f36debf2d04ce3815c0cfa289b6798~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li><strong>原子性（Atomicity）：</strong> 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p><a href="https://zh.wikipedia.org/wiki/ACID](https://zh.wikipedia.org/wiki/ACID)">参考</a></p>
<h2 id="3-详谈-Spring-对事务的支持"><a href="#3-详谈-Spring-对事务的支持" class="headerlink" title="3. 详谈 Spring 对事务的支持"></a>3. 详谈 Spring 对事务的支持</h2><p><strong>再提醒一次：你的程序是否支持事务首先取决于数据库 ，比如使用 MySQL 的话，如果你选择的是 innodb 引擎，那么恭喜你，是可以支持事务的。但是，如果你的 MySQL 数据库使用的是 myisam 引擎的话，那不好意思，从根上就是不支持事务的。</strong></p>
<p>这里再多提一下一个非常重要的知识点： <strong>MySQL 怎么保证原子性的？</strong></p>
<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<p>###3.1. Spring 支持两种方式的事务管理</p>
<h4 id="1-编程式事务管理"><a href="#1-编程式事务管理" class="headerlink" title="1).编程式事务管理"></a>1).编程式事务管理</h4><p>通过 <code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</p>
<p>使用<code>TransactionTemplate</code> 进行编程式事务管理的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ....  业务代码</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>TransactionManager</code> 进行编程式事务管理的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// ....  业务代码</span></span><br><span class="line">              transactionManager.commit(status);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              transactionManager.rollback(status);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-声明式事务管理"><a href="#2-声明式事务管理" class="headerlink" title="2)声明式事务管理"></a>2)声明式事务管理</h4><p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）。</p>
<p>使用 <code>@Transactional</code>注解进行事务管理的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-Spring-事务管理接口介绍"><a href="#3-2-Spring-事务管理接口介绍" class="headerlink" title="3.2. Spring 事务管理接口介绍"></a>3.2. Spring 事务管理接口介绍</h3><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p>
<ul>
<li>**<code>PlatformTransactionManager</code>**： （平台）事务管理器，Spring 事务策略的核心。</li>
<li>**<code>TransactionDefinition</code>**： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li>
<li>**<code>TransactionStatus</code>**： 事务运行状态。</li>
</ul>
<p>我们可以把 <strong><code>PlatformTransactionManager</code></strong> 接口可以被看作是事务上层的管理者，而 <strong><code>TransactionDefinition</code></strong> 和 <strong><code>TransactionStatus</code></strong> 这两个接口可以看作是事物的描述。</p>
<p><strong><code>PlatformTransactionManager</code></strong> 会根据 <strong><code>TransactionDefinition</code></strong> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <strong><code>TransactionStatus</code></strong> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p>
<h4 id="3-2-1-PlatformTransactionManager-事务管理接口"><a href="#3-2-1-PlatformTransactionManager-事务管理接口" class="headerlink" title="3.2.1. PlatformTransactionManager:事务管理接口"></a>3.2.1. PlatformTransactionManager:事务管理接口</h4><p><strong>Spring 并不直接管理事务，而是提供了多种事务管理器</strong> 。Spring 事务管理器的接口是： <strong><code>PlatformTransactionManager</code></strong> 。</p>
<p>通过这个接口，Spring 为各个平台如 JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<p><strong><code>PlatformTransactionManager</code> 接口的具体实现如下:</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca32ed4e77b4a7c89644e458aa195f9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><code>PlatformTransactionManager</code>接口中定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>这里多插一嘴。为什么要定义或者说抽象出来<code>PlatformTransactionManager</code>这个接口呢？</strong></p>
<p>主要是因为要将事务管理行为抽象出来，然后不同的平台去实现它，这样我们可以保证提供给外部的行为不变，方便我们扩展。我前段时间分享过：<strong>“为什么我们要用接口？”</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86aea41102e642f09727b697c6be3f58~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h4 id="3-2-2-TransactionDefinition-事务属性"><a href="#3-2-2-TransactionDefinition-事务属性" class="headerlink" title="3.2.2. TransactionDefinition:事务属性"></a>3.2.2. TransactionDefinition:事务属性</h4><p>事务管理器接口 <strong><code>PlatformTransactionManager</code></strong> 通过 <strong><code>getTransaction(TransactionDefinition definition)</code></strong> 方法来得到一个事务，这个方法里面的参数是 <strong><code>TransactionDefinition</code></strong> 类 ，这个类就定义了一些基本的事务属性。</p>
<p>那么什么是 <strong>事务属性</strong> 呢？</p>
<p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</p>
<p>事务属性包含了 5 个方面： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1b7c16ffe454ee5933fdc1cdcc08385~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><code>TransactionDefinition</code> 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-TransactionStatus-事务状态"><a href="#3-2-3-TransactionStatus-事务状态" class="headerlink" title="3.2.3. TransactionStatus:事务状态"></a>3.2.3. TransactionStatus:事务状态</h4><p><code>TransactionStatus</code>接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</p>
<p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回一个 <code>TransactionStatus</code> 对象。</p>
<p><strong>TransactionStatus 接口接口内容如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-事务属性详解"><a href="#3-3-事务属性详解" class="headerlink" title="3.3. 事务属性详解"></a>3.3. 事务属性详解</h3><p><em>实际业务开发中，大家一般都是使用 <code>@Transactional</code> 注解来开启事务，很多人并不清楚这个参数里面的参数是什么意思，有什么用。为了更好的在项目中使用事务管理，强烈推荐好好阅读一下下面的内容。</em></p>
<h4 id="3-3-1-事务传播行为"><a href="#3-3-1-事务传播行为" class="headerlink" title="3.3.1. 事务传播行为"></a>3.3.1. 事务传播行为</h4><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p><strong>举个例子！</strong></p>
<p>我们在 A 类的<code>aMethod（）</code>方法中调用了 B 类的 <code>bMethod()</code> 方法。这个时候就涉及到业务层方法之间互相调用的事务问题。如果我们的 <code>bMethod()</code>如果发生异常需要回滚，如何配置事务传播行为才能让 <code>aMethod()</code>也跟着回滚呢？这个时候就需要事务传播行为的知识了，如果你不知道的话一定要好好看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过如此，为了方便使用，Spring 会相应地定义了一个枚举类：<code>Propagation</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">	SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">	MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line">	REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">	NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">	NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">	NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">	Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正确的事务传播行为可能的值如下</strong> ：</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：</p>
<ol>
<li>如果外部方法没有开启事务的话，<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
<li>如果外部方法开启事务并且被<code>Propagation.REQUIRED</code>的话，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。</li>
</ol>
<p>举个例子：如果我们上面的<code>aMethod()</code>和<code>bMethod()</code>使用的都是<code>PROPAGATION_REQUIRED</code>传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p>举个例子：如果我们上面的<code>bMethod()</code>使用<code>PROPAGATION_REQUIRES_NEW</code>事务传播行为修饰，<code>aMethod</code>还是用<code>PROPAGATION_REQUIRED</code>修饰的话。如果<code>aMethod()</code>发生异常回滚，<code>bMethod()</code>不会跟着回滚，因为 <code>bMethod()</code>开启了独立的事务。但是，如果 <code>bMethod()</code>抛出了未被捕获的异常并且这个异常满足事务回滚规则的话,<code>aMethod()</code>同样也会回滚，因为这个异常被 <code>aMethod()</code>的事务管理机制检测到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong>:</p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。也就是说：</p>
<ol>
<li>在外部方法未开启事务的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
<li>如果外部方法开启事务的话，<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。</li>
</ol>
<p>这里还是简单举个例子：</p>
<p>如果 <code>aMethod()</code> 回滚的话，<code>bMethod()</code>和<code>bMethod2()</code>都要回滚，而<code>bMethod()</code>回滚的话，并不会造成 <code>aMethod()</code> 和<code>bMethod()</code>回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.bMethod();</span><br><span class="line">        b.bMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod2 &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少，就不举例子来说了。</p>
<p><strong>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少。</strong></p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p>更多关于事务传播行为的内容请看这篇文章：<a href="http://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486668&idx=2&sn=0381e8c836442f46bdc5367170234abb&chksm=cea24307f9d5ca11c96943b3ccfa1fc70dc97dd87d9c540388581f8fe6d805ff548dff5f6b5b&token=1776990505&lang=zh_CN#rd">《太难了~面试官让我结合案例讲讲自己对 Spring 事务传播行为的理解。》</a></p>
<h4 id="3-3-2-事务隔离级别"><a href="#3-3-2-事务隔离级别" class="headerlink" title="3.3.2 事务隔离级别"></a>3.3.2 事务隔离级别</h4><p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">	READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">	READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">	REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">	SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">	Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<p>因为平时使用 MySQL 数据库比较多，这里再多提一嘴！</p>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code>（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong><code>REPEATABLE-READ</code>（可重读）</strong> 事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code>（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong><code>SERIALIZABLE</code>(可串行化)</strong> 隔离级别。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong><code>READ-COMMITTED</code>(读取提交内容)</strong> :，但是你要知道的是 InnoDB 存储引擎默认使用 <strong><code>REPEATABLE-READ</code>（可重读）</strong> 并不会什么任何性能上的损失。</p>
<p>更多关于事务隔离级别的内容请看：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485085&idx=1&sn=01e5c29c49f32886bc897af7632b34ba&chksm=cea24956f9d5c040a07e4d335219f11f888a2d32444c16cade3f69c294ae0a1e416bcd221fb6&token=1613452699&lang=zh_CN&scene=21#wechat_redirect">《一文带你轻松搞懂事务隔离级别(图文详解)》</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486625&idx=2&sn=e235dab2757739438b8f33d205a9327f&chksm=cea2436af9d5ca7c9a1a8db9d020f71205687beca23ac958f9c9a711ee0185cab30173ad2b1a&token=1776990505&lang=zh_CN#rd">面试官：你说对 MySQL 事务很熟？那我问你 10 个问题</a></li>
</ol>
<h4 id="3-3-3-事务超时属性"><a href="#3-3-3-事务超时属性" class="headerlink" title="3.3.3. 事务超时属性"></a>3.3.3. 事务超时属性</h4><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 <code>TransactionDefinition</code> 中以 int 的值来表示超时时间，其单位是秒，默认值为-1。</p>
<h4 id="3-3-3-事务只读属性"><a href="#3-3-3-事务只读属性" class="headerlink" title="3.3.3. 事务只读属性"></a>3.3.3. 事务只读属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p>
<p>很多人就会疑问了，为什么我一个数据查询操作还要启用事务支持呢？</p>
<p>拿 MySQL 的 innodb 举例子，根据官网 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html">dev.mysql.com/doc/refman/…</a> 描述：</p>
<blockquote>
<p>MySQL 默认对每一个新建立的连接都启用了<code>autocommit</code>模式。在该模式下，每一个发送到 MySQL 服务器的<code>sql</code>语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。</p>
</blockquote>
<p>但是，如果你给方法加上了<code>Transactional</code>注解的话，这个方法执行的所有<code>sql</code>会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。</p>
<p>如果不加<code>Transactional</code>，每条<code>sql</code>会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。</p>
<p>分享一下关于事务只读属性，其他人的解答：</p>
<ol>
<li>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</li>
<li>如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持</li>
</ol>
<h4 id="3-3-4-事务回滚规则"><a href="#3-3-4-事务回滚规则" class="headerlink" title="3.3.4. 事务回滚规则"></a>3.3.4. 事务回滚规则</h4><p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（RuntimeException 的子类）时才会回滚，Error 也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18487b3e6aa94d009a826f537b8c52e2~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>如果你想要回滚你定义的特定的异常类型的话，可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-Transactional-注解使用详解"><a href="#3-4-Transactional-注解使用详解" class="headerlink" title="3.4. @Transactional 注解使用详解"></a>3.4. @Transactional 注解使用详解</h3><h4 id="1-Transactional-的作用范围"><a href="#1-Transactional-的作用范围" class="headerlink" title="1) @Transactional 的作用范围"></a>1) <code>@Transactional</code> 的作用范围</h4><ol>
<li><strong>方法</strong> ：推荐将注解使用于方法上，不过需要注意的是：<strong>该注解只能应用到 public 方法上，否则不生效。</strong></li>
<li><strong>类</strong> ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li>
<li><strong>接口</strong> ：不推荐在接口上使用。</li>
</ol>
<h4 id="2-Transactional-的常用配置参数"><a href="#2-Transactional-的常用配置参数" class="headerlink" title="2) @Transactional 的常用配置参数"></a>2) <code>@Transactional</code> 的常用配置参数</h4><p><code>@Transactional</code>注解源码如下，里面包含了基本事务属性的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>@Transactional</code> 的常用配置参数总结（只列举 5 个平时比较常用的）：</strong></p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>propagation</td>
<td>事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过</td>
</tr>
<tr>
<td>isolation</td>
<td>事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过</td>
</tr>
<tr>
<td>timeout</td>
<td>事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td>readOnly</td>
<td>指定事务是否为只读事务，默认值为 false。</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</td>
</tr>
</tbody></table>
<h4 id="3-Transactional-事务注解原理"><a href="#3-Transactional-事务注解原理" class="headerlink" title="3)@Transactional 事务注解原理"></a>3)<code>@Transactional</code> 事务注解原理</h4><p>面试中在问 AOP 的时候可能会被问到的一个问题。简单说下吧！</p>
<p>我们知道，**<code>@Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。**</p>
<p>多提一嘴：<code>createAopProxy()</code> 方法 决定了是使用 JDK 还是 Cglib 来做动态代理，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类或者一个类中的 public 方法上被标注<code>@Transactional</code> 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>
<blockquote>
<p><code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法内部实际调用的是 <code>TransactionAspectSupport</code> 类的 <code>invokeWithinTransaction()</code>方法。由于新版本的 Spring 对这部分重写很大，而且用到了很多响应式编程的知识，这里就不列源码了。</p>
</blockquote>
<h4 id="4-Spring-AOP-自调用问题"><a href="#4-Spring-AOP-自调用问题" class="headerlink" title="4)Spring AOP 自调用问题"></a>4)Spring AOP 自调用问题</h4><p>若同一类中的其他没有 <code>@Transactional</code> 注解的方法内部调用有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。</p>
<p>这是由于<code>Spring AOP</code>代理的原因造成的，因为只有当 <code>@Transactional</code> 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p>
<p><code>MyService</code> 类中的<code>method1()</code>调用<code>method2()</code>就会导致<code>method2()</code>的事务失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     method2();</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</p>
<h4 id="5-Transactional-的使用注意事项总结"><a href="#5-Transactional-的使用注意事项总结" class="headerlink" title="5) @Transactional 的使用注意事项总结"></a>5) <code>@Transactional</code> 的使用注意事项总结</h4><ol>
<li><code>@Transactional</code> 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；</li>
<li>避免同一个类中调用 <code>@Transactional</code> 注解的方法，这样会导致事务失效；</li>
<li>正确的设置 <code>@Transactional</code> 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败</li>
<li>……</li>
</ol>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/posts/6b3e1469/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="Spring介绍"><a href="#Spring介绍" class="headerlink" title="Spring介绍"></a>Spring介绍</h2><blockquote>
<p>spring是一个轻量的、非入侵式的、基于控制反转（IOC）和面向切面的（AOP）的框架</p>
</blockquote>
<ul>
<li>Rod Johnson是Spring Framework的创始人。Spring的理念：使Java企业级开发更加简单</li>
<li><strong>官网：<a href="https://spring.io/projects/spring-framework#overview">spring.io/projects/sp…</a></strong></li>
<li>优点：<ul>
<li>基于pojo轻量级和最小入侵式开发</li>
<li>通过依赖注入和面向接口实现松耦合</li>
<li>基于切面和惯例进行声明式编程</li>
<li>通过切面和模板减少样式化代码</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h3 id="侵入式概念"><a href="#侵入式概念" class="headerlink" title="侵入式概念"></a>侵入式概念</h3><p>侵入式：通常是实现了特定的接口，继承特定的类来增强目标类的功能</p>
<p>非入侵式：对现有的类结构 没有影响，就能增强目标类的功能</p>
<p> ==<strong>区别在于是否改变了类的结构</strong>==</p>
<h3 id="松耦合概念"><a href="#松耦合概念" class="headerlink" title="松耦合概念"></a>松耦合概念</h3><p>在spring之前，我们都是面向接口编程。通过DaoFactory等方法来实现松耦合；在spring中，通过控制反转的思想来实现松耦合</p>
<h3 id="面向切面"><a href="#面向切面" class="headerlink" title="面向切面"></a>面向切面</h3><p>可以简单理解成在执行某些代码前后，执行另外的代码</p>
<h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><blockquote>
<p>spring的核心思想之一 ：Inversion of Control , 控制反转 IOC；即对象的创建交给外部容器来完成</p>
</blockquote>
<p><strong>控制反转这一思想的理解：</strong></p>
<p>ioc的思想最核心的地方在于，资源不由使用资源的双方来管理而是交给了不使用资源的双方来管理。</p>
<p>由此带来的好处：</p>
<ol>
<li>资源集中管理，实现资源的可配置和易管理</li>
<li>降低了使用资源使用资源的双方的依赖程度，即降低了耦合度</li>
<li>便于单元测试</li>
<li>便于进行AOP操作，对于使用者是透明的</li>
</ol>
<h2 id="Spring组成"><a href="#Spring组成" class="headerlink" title="Spring组成"></a>Spring组成</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b44f6fb9c2e70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><strong>Spring Core</strong>：Core包是框架的最基础部分，并提供依赖注入（Dependency Injection）管理Bean容器功能</li>
<li><strong>Spring Context</strong>：Core模块的BeanFactory使Spring成为一个容器，而上下文模块使它成为一个框架。这个模块扩展了BeanFactory的概念，增加了对国际化（I18N）消息、事件传播以及验证的支持。另外，这个模块提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括了对模版框架例如Velocity和FreeMarker集成的支持。</li>
<li><strong>Spring AOP</strong>：Spring在它的AOP模块中提供了对面向切面编程的丰富支持。例如方法拦截器（method-interceptors）和切点（pointcuts），可以有效的防止代码上功能的耦合，这个模块是在Spring应用中实现切面编程的基础。</li>
<li><strong>Spring DAO</strong>：对JDBC进行了抽象，大大简化了数据库访问等繁琐的操作；</li>
<li><strong>Spring ORM</strong>：关系映射模块，ORM包为流行的“关系/对象”映射APIs提供了集成层，包括JDO，Hibernate和iBatis（MyBatis）。通过ORM包，可以混合使用所有Spring提供的特性进行“对象/关系”映射，方便开发时小组内整合代码。</li>
<li><strong>Spring Web</strong>：Web上下文模块建立于应用上下文模块之上，提供了一个适合于Web应用的上下文。另外，这个模块还提供了一些面向服务支持。利用Servlet listeners进行IOC容器初始化和针Webapplicationcontext。</li>
<li><strong>Spring MVC</strong>：提供面向Web应用的Model-View-Controller实现。</li>
</ul>
<h2 id="Spring后续框架"><a href="#Spring后续框架" class="headerlink" title="Spring后续框架"></a>Spring后续框架</h2><p><strong>Spring Boot</strong></p>
<ul>
<li>一个快速的脚手架，基于SpringBoot可以快速的开发单个微服务</li>
<li>特点：约束&gt;配置</li>
</ul>
<p><strong>Spring Cloud</strong></p>
<ul>
<li>基于SpringBoot实现的完整的微服务开发，是目前的主流</li>
<li>特点：完整的微服务框架</li>
</ul>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="IOC的推导"><a href="#IOC的推导" class="headerlink" title="IOC的推导"></a>IOC的推导</h2><ul>
<li>之前的Web工程需要Dao，DaoImpl，Service，ServiceImpl，Controller实现应用，但如果代码量过大，变更需求过多，修改一次代码需要更改关联的更多代码，成本十分昂贵</li>
<li>假设，我们不在代码中=new XXimpl，而是通过接口的set方法设值，让程序员不用再去管理对象的创建</li>
<li>于是，<strong>使用了set注入后，程序不再具有主动权，而是变成了被动接受的对象=IOC原型</strong></li>
<li><strong>明确概念：IOC是一种思想，DI（依赖注入）是IOC的实现的一种方式，两者不完全相同</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b44fa535a8200?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="初试application"><a href="#初试application" class="headerlink" title="初试application"></a>初试application</h2><ul>
<li><strong>import:多人开发，导入多个application配置文件</strong></li>
<li><strong>bean：创建对象</strong></li>
<li><strong>alias：取对象的别名，但在bean中直接使用name=XX，比单独使用alias更推荐使用</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b44ff8ab59e17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="spring容器对象"><a href="#spring容器对象" class="headerlink" title="spring容器对象"></a>spring容器对象</h2><p><strong>bean工厂</strong>：``BeanFactory `顶级接口，功能较少</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载Spring的资源⽂件</span></span><br><span class="line"> Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"> <span class="comment">//创建IOC容器对象【IOC容器=⼯⼚类+applicationContext.xml】</span></span><br><span class="line"> BeanFactory beanFactory = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br></pre></td></tr></table></figure>
<p><strong>上下文对象</strong>: <code>ApplicationContext</code>，功能更加强大，是BeanFactory的子接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="工厂静态方法配置bean"><a href="#工厂静态方法配置bean" class="headerlink" title="工厂静态方法配置bean"></a>工厂静态方法配置bean</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.java.bean.Factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getbean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="工厂非静态方法配置bean"><a href="#工厂非静态方法配置bean" class="headerlink" title="工厂非静态方法配置bean"></a>工厂非静态方法配置bean</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.java.bean.Factory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.java.bean.User&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUser&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Summer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><p><strong>默认是使用无参构造创建bean</strong></p>
<p><strong>如果没有无参构造，就必须使用<code>&lt; constructor-arg /&gt;</code>指定构造器</strong></p>
<p><strong>总结：在配置文件里面注册bean的时候，就已经实例化了</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b45024dd11f09?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><p><strong>原理：通过Setter方法注入的。同时明白什么DI（依赖注入的概念）</strong></p>
<p><strong>依赖：bean的对象创建依赖于Spring容器来实现</strong></p>
<p><strong>注入：bean对象的所有属性由Spring容器来注入</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b45078fc442b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="application-xml"><a href="#application-xml" class="headerlink" title="application.xml"></a>application.xml</h4><ul>
<li>学习各种基本类型，引用类型注入，扩展补充：p命令，c命令简化注入（需要导入约束），但使用的很少</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置bean的成员属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;addressRef&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;中国贵州&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--各种数据类型的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置String类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置另一个bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addressRef&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置数组--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置List--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>学习<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>打球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置map--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;银行卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置set--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>BOB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--NUll--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--properties--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;url&quot;</span>&gt;</span>www.baidu.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--p注入：通过setter注入属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Hello&quot;</span> <span class="attr">p:str</span>=<span class="string">&quot;p标签注入，是通过setter注入的&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--c注入：通过有参构造器注入属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloAndC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Hello&quot;</span> <span class="attr">c:str</span>=<span class="string">&quot;c标签注入，是通过构造器注入的&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Java配置application"><a href="#Java配置application" class="headerlink" title="Java配置application"></a>Java配置application</h2><p>编写一个Java类用@Configuration注解修饰；表明该类是配置类；</p>
<p>在配置类中编写获取实例对象的方法用@Bean修饰；bean的id默认为方法名</p>
<blockquote>
<p>这个配置类就相当于spring的xml配置文件</p>
</blockquote>
<ul>
<li>普通开发很少使用，但是各种框架源码大量使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    方法名= bean id ；返回值=bean 的class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">beanId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;张三&quot;)</span></span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b450cc75e0823?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">Scope</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton">singleton</a></td>
<td align="left">(默认)为每个Spring IoC容器将单个bean定义作用于单个对象实例。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype">prototype</a></td>
<td align="left">每个bean都产生一个新的对象实例</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request">request</a></td>
<td align="left">将单个bean定义的范围限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有自己的bean实例，这些实例是在单个bean定义的基础上创建的。仅在web感知的Spring“ApplicationContext”的上下文中有效。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session">session</a></td>
<td align="left">将单个bean定义定义为HTTP“会话”的生命周期。仅在web感知的Spring“ApplicationContext”的上下文中有效。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application">application</a></td>
<td align="left">将单个bean定义的范围扩展到“ServletContext”的生命周期。仅在web感知的Spring“ApplicationContext”的上下文中有效。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope">websocket</a></td>
<td align="left">将单个bean定义的范围扩展到“WebSocket”的生命周期。仅在web感知的Spring“ApplicationContext”的上下文中有效。</td>
</tr>
</tbody></table>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><ul>
<li>不用显示配置bean，添加约束后，Spring会在上下文中自动寻找，并自动给bean装配属性</li>
<li>三种装配方式<ul>
<li>xml中显示装配</li>
<li>自动装配</li>
<li>java装配：=前面的 “Java配置application”</li>
</ul>
</li>
</ul>
<h3 id="bean中的自动装配"><a href="#bean中的自动装配" class="headerlink" title="bean中的自动装配"></a>bean中的自动装配</h3><ul>
<li><strong>byName：bean的id = 自动注入的成员属性setXXX一样</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b451019249ed0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><strong>byType：bean中的class和成员变量的类型一致</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b45141ce11c67?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="注解实现自动装配"><a href="#注解实现自动装配" class="headerlink" title="注解实现自动装配"></a>注解实现自动装配</h3><ul>
<li><strong>导入注解约束</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>@Autowired+@Qualifier=@Resource(name = “xx”)</strong></li>
</ul>
<ol>
<li>使用：直接在成员属性上使用，也可以在set上使用</li>
<li>原理：通过反射去xml中寻找成员类型 = class的bean，并自动装配；</li>
<li>默认装配不能为空：可以使用<code>@Autowired(required = false)</code>指定为空</li>
<li>多个相同bean的class：使用<code>@Qualifier(value = &quot;dog1&quot;)</code></li>
<li><strong><code>@Autowired+@Qualifier=@Resource(name = “xx”)</code>区别</strong><ol>
<li>相同点：都是自动装配配置</li>
<li>不同点：<code>@Autowired+@Qualifier</code>通过byType=class来查找；<code>@Resource(name = “xx”)</code>默认通过byname=id来查找，如果没找到，接着用byType=class来查找</li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初识Spring中的bean，使用Spring来创建对象，这些对象称为bean，是Spring通过set方法来创建的：</span></span><br><span class="line"><span class="comment">        bean id/name = new class</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;你好，Spring&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--alias取对象的别名,但是name也可以取别名，更方便--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;hello1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--import导入另一个.xml配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;application1.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--bean中使用autowired--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--byName：通过setXXX名字去匹配，原理是Name id= SetXXX--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;people1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- byType：通过成员属性去匹配，缺点是class必须唯一，否则找不到--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;bean id=&quot;people2&quot; class=&quot;com.pojo.People&quot; autowire=&quot;byType&quot; scope=&quot;prototype&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;name&quot; value=&quot;people2&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--最简单：使用注解配置自动装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;peopleAnnotation&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.PeopleAnnotation&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><h3 id="导入aop包"><a href="#导入aop包" class="headerlink" title="导入aop包"></a>导入aop包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="导入xml配置"><a href="#导入xml配置" class="headerlink" title="导入xml配置"></a>导入xml配置</h3><ul>
<li>注解配置+指定扫描包</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注解配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssl.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Component和-Value"><a href="#Component和-Value" class="headerlink" title="@Component和@Value"></a>@Component和@Value</h3><ul>
<li>注解注入bean组件：<code>@Component</code>,不用手动去xml中配置bean<ul>
<li>component三大衍生注解<ul>
<li>@Repository：对应dao层</li>
<li>@Service：对应service层</li>
<li>@Controller：对应controller层</li>
</ul>
</li>
</ul>
</li>
<li>注入成员属性：<code>@Value(&quot;张三&quot;)</code></li>
<li>作用域：<code>@Scope(value=&quot;prototype&quot;)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Component = &lt;bean id= &quot;user class=&quot;com.ssl.pojo.User&quot; /&gt;</span></span><br><span class="line"><span class="comment">    @Value(&quot;张三&quot;) = 通过setter方法区赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = &quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;张三&quot;)</span></span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="xml配置和注解开发"><a href="#xml配置和注解开发" class="headerlink" title="xml配置和注解开发"></a>xml配置和注解开发</h3><ul>
<li>xml：用来配置Spring一些需求，但bean使用注解配置</li>
<li>注解：只负责完成bean的创建和属性的注入</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><img src="https://user-gold-cdn.xitu.io/2020/5/1/171ce368bc2b6db1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul>
<li>动态代理分为：1 基于接口的；2 基于类的动态代理<ul>
<li>基于接口的：JDK动态代理</li>
<li>基于类的的：cglib</li>
<li>基于java字节码：Javasist</li>
</ul>
</li>
<li><strong>学习两个类：Proxy；InvocationHandler(调用处理器)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学习动态代理类的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInva</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 实现被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 获得代理对象,通过Proxy.newProxyInstance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                <span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                rent.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 处理代理对象，被返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        beforeSee();</span><br><span class="line">        <span class="comment">//激活被代理角色的行为</span></span><br><span class="line">        Object invoke = method.invoke(rent, args);</span><br><span class="line">        afterSee();</span><br><span class="line">        <span class="keyword">return</span>  invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态代理原型：在invoke前后添加的方法就是aop原型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提前看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过后看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态代理模版</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvaObject</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 创建抽象接口，需要set方法实现反射</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 代理方法，Spring自动实现中介角色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 实现抽象接口的实体方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        addMethod(method.getName());<span class="comment">//反射的强大之处</span></span><br><span class="line">        <span class="comment">//方法.invoke(接口名，参数)</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4 添加的功能，学习反射的强大之处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addMethod</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span> + msg + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态代理的调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        Rent host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理角色</span></span><br><span class="line">        ProxyInva proxyInva = <span class="keyword">new</span> ProxyInva();</span><br><span class="line">        <span class="comment">//代理角色设置真实角色实现的抽象接口</span></span><br><span class="line">        proxyInva.setRent(host);</span><br><span class="line">        <span class="comment">//代理角色获得Rent代理类</span></span><br><span class="line">        Rent proxy = (Rent) proxyInva.getProxy();</span><br><span class="line">        <span class="comment">//由proxy动态代理调用被代理的接口方法</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><blockquote>
<p>面向切面编程 (Aspect Oriented Programming, AOP)，基于 OOP 基础上的一种新的编程思想，<strong>指在程序运行期间，将『某段代码』动态地切入到『指定方法的指定位置』进行运行的编程方法</strong>。</p>
</blockquote>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><ul>
<li>aop：不改变原有代码情况下，增加一些功能</li>
<li>原理图：各种名词请反复看</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b451ff1bee63b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="Spring实现AOP"><a href="#Spring实现AOP" class="headerlink" title="Spring实现AOP"></a>Spring实现AOP</h3><ul>
<li><strong>方式一：无需切面，直接实现InvocationHandler接口</strong></li>
<li><strong>方式二：自定义切面，其中编写需要的通知方法</strong></li>
<li><strong>方式三：注解配置切面，使用@Aspect</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b452316c01ee6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--aop依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--AOP配置1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beforeLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;log.beforeLog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userImpl1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.UserServiceImpl1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点，expression是被切入的类中的什么方法，这里是万能的切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.UserServiceImpl1.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--环绕通知=自动前后都增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;beforeLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--AOP配置2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diyPoint&quot;</span> <span class="attr">class</span>=<span class="string">&quot;diyAop.DiyPointCut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userImpl2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.UserServiceImpl2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diyPoint&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.UserServiceImpl2.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--前后通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--AOP配置3：注解aop配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userImpl3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.UserServiceImpl3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anonCut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;anon.AnonPointCut&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//aop配置1：方法前通知=MethodBeforeAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">beforeLog</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 前置增加日志功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被aop增强的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   method形参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target method所在的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String targetName = target.getClass().getName();</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        System.out.println(targetName + <span class="string">&quot;:的[&quot;</span> + methodName + <span class="string">&quot;]方法被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//aop配置2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiyPointCut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====方法前=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====方法后=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//aop配置3：注解定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonPointCut</span> </span>&#123;</span><br><span class="line">    <span class="comment">//切入点1</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* service.UserServiceImpl3.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Anon=====方法前=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//切入点2</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* service.UserServiceImpl3.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;Anon=====方法后=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* service.UserServiceImpl3.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            环绕前</span></span><br><span class="line"><span class="comment">            Anon=====方法前=====</span></span><br><span class="line"><span class="comment">            增加了一个用户</span></span><br><span class="line"><span class="comment">            环绕后</span></span><br><span class="line"><span class="comment">            Anon=====方法后=====</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AOP-使用场景"><a href="#AOP-使用场景" class="headerlink" title="AOP 使用场景"></a>AOP 使用场景</h2><ul>
<li>AOP 加日志到数据库</li>
<li>AOP 做权限验证</li>
<li>AOP 做安全检查</li>
<li><strong>[重点] AOP 做事务控制</strong></li>
</ul>
<h2 id="Spring-AOP-的使用"><a href="#Spring-AOP-的使用" class="headerlink" title="Spring AOP 的使用"></a>Spring AOP 的使用</h2><p>要使用 Spring AOP，需要涉及到了另外 6 个注解：</p>
<ul>
<li><code>@Aspect</code>: 它用于标记切面类</li>
<li><code>@Before</code>: 前置通知</li>
<li><code>@After</code>: 后置通知</li>
<li><code>@AfterReturning</code>: 返回通知</li>
<li><code>@AfterThrowing</code>: 异常通知</li>
<li><code>@Around</code>: 环绕通知，Spring 里面最强大的通知，上面 4 个通知的四合一，其实就相当于是自己写动态代理。</li>
<li><code>@PointCut</code>: 用于复用切入点表达式</li>
</ul>
<p>还没有完，还有上述说到的<strong>切入点表达式</strong>，它用于指示这些通知方法究竟用在哪里。下方的 <code>execution(...)</code> 就是切入点表达式，内容就是<strong>方法的完整声明</strong> (全路径)。</p>
<h2 id="Spring-AOP-的细节"><a href="#Spring-AOP-的细节" class="headerlink" title="Spring AOP 的细节"></a>Spring AOP 的细节</h2><ol>
<li><p><strong>测试中的 <code>bean</code> 的类型并不是我们定义的 类</strong>！而是 Spring 自动创建的一个动态代理类！这也说明，<strong>Spring 底层用的依然是动态代理</strong>。这也是为什么测试代码中获取 bean 时要传入接口类，而不是本类。</p>
<p> <strong>如果 <code>MyCalculator</code> 没有继承 <code>Calculator</code> 接口，那么将 <code>ioc.getBean()</code> 方法的参数改为 <code>MyCalculator.class</code>，则上述代码依然可以运行！</strong>只是此时测试代码中 <code>bean</code> 的类型将是 <code>MyCalculator</code> 的一个内部类，这个内部类由 cglib 库创建，并实现了 <code>MaCalculator</code> 的全部方法。这也证明了，<strong>即使没有实现接口，Spring 依然可以实现切面编程！</strong></p>
</li>
<li><p>切入点表达式的写法：<code>execution(权限修饰符(可不写,默认为全部) 返回类型 包名.方法名(参数列表))</code></p>
<ul>
<li><p>通配符：*</p>
<ul>
<li><p>匹配一个或多个字符，可以用在切入点表达式的任意地方，包括参数列表中 (方法重载的情况)，如果用在路径中，则表示匹配<strong>一层路径</strong>。例如 <code>execution(public int com.learning.*.MyCal*r.*(int, *))</code></p>
</li>
<li><p><code>*</code> 通配符<strong>不能</strong>用于修饰方法的权限！即上述的 <code>public</code> 等权限修饰符。如果想匹配任意权限，则不写权限既可 (但即使这样也只能切 <code>public</code> 的，切不了 <code>private</code>)；</p>
</li>
</ul>
</li>
<li><p>.. ：两个点，它有如下含义：</p>
<ul>
<li>表示匹配<strong>任意多个任意类型的参数</strong>。例如 <code>execution(public int com.learning.aspect.MyCalculator.*(..))</code></li>
<li>表示匹配<strong>任意多层路径</strong>：例如 <code>execution(public int com.learning.*.MyCalculator.*(..))</code> 只表示匹配一层路径，而 <code>execution(public int com.learning..MyCalculator.*(..))</code> 则表示匹配任意层路径</li>
</ul>
</li>
<li><p>切记两种表达式：</p>
<ul>
<li>最精确的：<code>execution(public int com.learning.aspect.MyCalculator.add(int, int))</code></li>
<li>最糢糊的：<code>execution(* *.*(..))</code> 或者 <code>execution(* *(..))</code>，它们都表示任意包下的任意类的任意方法，<strong>千万别写这种</strong>！</li>
</ul>
</li>
<li><p><code>&amp;&amp;</code>, <code>||</code>, <code>!</code>：切入点表达式还可以用逻辑运算符组合起来使用，含义和 java 中的含义一样，例如:<code>execution(public int com.learning.*.MyCal*r.*(int, *))&amp;&amp;execution(*, *.*(..))</code></p>
</li>
</ul>
</li>
<li><p>上述两个切面类中带有切面注解的方法就是通知方法。</p>
</li>
<li><p>通知方法的执行顺序：和我们的习惯有些出入：</p>
<ul>
<li><p>无异常情况的顺序：<code>@Before —&gt; @After —&gt; @AfterReturning</code></p>
</li>
<li><p>有异常情况的顺序：<code>@Before —&gt; @After —&gt; @AfterThrowing</code></p>
<p>别人底层就是这么写的，并不是我们用错了。</p>
</li>
</ul>
</li>
<li><p>给切面方法设置 <code>JoinPoint</code> 形参可以用于获取连结点的信息，比如<strong>连结点的方法名</strong>和<strong>传入连结点的参数</strong>。</p>
</li>
<li><p>如果想要获取连接点的返回值，可以才注解中使用 <code>returning</code> 参数，并在通知方法的参数列表中加入一个形参用于接收返回值。不过，<strong>用于接收返回值的形参名必须和 <code>returning</code> 的参数值相同</strong>！</p>
</li>
<li><p>如果想要获取连接点抛出的异常，可以才注解中使用 <code>throwing</code> 参数，并在通知方法的参数列表中加入一个形参用于接收异常。不过，<strong>用于接收异常的形参名必须和 <code>throwing</code> 的参数值相同</strong>！</p>
</li>
<li><p>Spring 对通知方法的要求并不严格，即使通知方法有返回值，或者通知方法是 <code>private</code> 的都没有关系，依然可以正常运行。唯一有要求的就是通知方法的形参列表不能乱加参数，你加的每一个参数都要通过给注解传入相应的参数，告诉 Spring，你添加的这个参数是用来干什么的。</p>
</li>
<li><p>注解中的切入点表达式可以单独抽去出来进行复用，例如上述的 <code>FileOutUtils</code> 类中传入切入点表达式的方式。具体方法就是在切入类中随便声明一个方法，例如上述的 <code>forAnno()</code> 方法，并在这个方法上使用 <code>@PointCut</code> 注解，<code>@PointCut</code> 中的参数就是要复用的切入点表达式。当某个通知方法要复用这个切入点表达式时，传入这个带有 <code>@PointCut</code> 注解的方法名以及括号既可，例如 <code>@Before(&quot;forAnno()&quot;)</code></p>
</li>
<li><p>切面类执行顺序：如果有多个切面类，<strong>默认情况下，是按照切面类类名的 ASCII 码顺序来进入切面类的</strong>，但是可以通过 <code>@Order(数字)</code> 注解来控制切面的执行顺序，数字范围就是 <code>int</code> 的范围，<strong>数字越小，优先级越高。</strong>而离开切面类则是相反的顺序，也就是类似于栈，先进后出。切面类对于被代理的对象来说是一种包裹关系，优先级最高的切面类包裹在最外面，优先级最低的包裹在最里面，<code>@Before</code> 注解表示 “进入”，其他注解表示 “出去”，那当然是最外面的先进入，最后才出去。从上述例子的输出也可以看到这一点。</p>
<p>多个切面类的执行示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/SpaceRocket321/ImageBase/master/BlogImgs/20200706213605.png" alt="img"></p>
</li>
</ol>
<p>最后还要重点介绍一下环绕通知 <code>@Around</code></p>
<h2 id="环绕通知-Around"><a href="#环绕通知-Around" class="headerlink" title="环绕通知 @Around"></a>环绕通知 @Around</h2><p>观察 <code>SysOutUtils.around()</code> 方法可以发现，环绕通知其实就相当于是自己写一个动态代理类，它完全接管了连结点的运行，也就是说，它能控制连结点究竟运不运行，要传入什么参数，要抛出什么异常，以及返回什么值。而要让连结点运行，我们还需要使用一个类型为 <code>ProceedingJoinPoint</code>(<code>JoinPoint</code> 的子类) 的参数 pjp，并调用它的<code>.proceed()</code> 方法。</p>
<p>另一个点则是，环绕通知先于其他 4 个类型的通知执行。如果环绕通知存在，那么其他 4 个通知接收到的信息 (比如参数，返回值，抛出的异常等) 就都是环绕通知反馈给它们的。也就是说，原本 add (1, 2) 应该返回 3，且不抛出异常，但在环绕通知中，我们可以让这个方法不执行；也可以让这个方法执行，但传入的参数由我们指定；还一个返回一个我们想让他返回的值；甚至可以让它抛出一些异常。</p>
<p>但需要提醒的是，只在同一个切面类中，环绕通知才优先于其他 4 个类型的通知执行，环绕通知只影响自己所在的切面类，影响不到其他切面类。例如上述结果中，<code>SysOutUtils.around()</code> 方法总是<strong>先于</strong>同类中的其他通知方法执行，但 <code>FileOutUtils</code> 中的通知方法又 “优先” 于 <code>SysOutUtils</code> 中的所有通知方法。</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog_Create</title>
    <url>/posts/9ba9cfdb/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="GitHub-Hexo-从零开始搭建个人博客"><a href="#GitHub-Hexo-从零开始搭建个人博客" class="headerlink" title="GitHub + Hexo 从零开始搭建个人博客"></a>GitHub + Hexo 从零开始搭建个人博客</h1><blockquote>
<p>搭建博客的一个记录</p>
</blockquote>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 GitHub Pages 服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花钱就可以搭建个人博客，不需要服务器不需要后台；</li>
<li>可以随意绑定自己的域名；</li>
<li>数据绝对安全，基于 GitHub 的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
<li>自己可以随性所欲的设计，美观大气上档次；</li>
</ol>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>有一个 <strong>GitHub</strong> 账号，没有的话去注册一个；</li>
<li>安装了 <strong>node.js</strong>、<strong>npm</strong>，并了解相关基础知识；</li>
<li>安装了 git for windows（或者其它 git 客户端）；</li>
</ul>
<h3 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h3><p>进入<a href="https://github.com/">GitHub官网</a>，新用户注册，一定记住注册的账号名和邮箱，后面会用到。</p>
<h3 id="安装node-js和npm"><a href="#安装node-js和npm" class="headerlink" title="安装node.js和npm"></a>安装node.js和npm</h3><p>进入<a href="https://nodejs.org/en/download/">Node官网</a>，下载相应版本。在Windows上安装时务必选择全部组件，包括勾选 <code>Add to Path</code>。</p>
<p>注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在cmd命令行中输入：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">-v</span> <span class="comment"># 会显示相应版本号，说明安装成功</span></span><br><span class="line">$ npm -v <span class="comment"># 会显示相应版本号，说明安装成功</span></span><br></pre></td></tr></table></figure>
<h3 id="安装Git-for-windows"><a href="#安装Git-for-windows" class="headerlink" title="安装Git for windows"></a>安装Git for windows</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>建议到<a href="https://git-scm.com/">Git官网</a>下载最新版本，国内访问会很慢，可以到网上搜索下载，然后默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”，打开后界面如下：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/01_Git.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/01_Git.jpg" alt="Git"></a></p>
<h4 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h4><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。在命令行输入如下：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">$ git config --<span class="keyword">global</span> user.name <span class="string">&quot;user_name&quot;</span> <span class="meta"># user_name填入GitHub用户名</span></span><br><span class="line">$ git config --<span class="keyword">global</span> user.email <span class="string">&quot;user_email&quot;</span> <span class="meta"># user_email填入GitHub注册的邮箱</span></span><br></pre></td></tr></table></figure>
<p>查看已设置的用户名和邮箱，在命令行输入如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git config <span class="keyword">user</span>.name</span><br><span class="line">$ git config <span class="keyword">user</span>.email</span><br></pre></td></tr></table></figure>
<h4 id="本文所使用的环境："><a href="#本文所使用的环境：" class="headerlink" title="本文所使用的环境："></a>本文所使用的环境：</h4><ul>
<li>windows8</li>
<li>node.js version — v7.6.0</li>
<li>git version — 2.15.1.windows.2</li>
</ul>
<h2 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>登陆GitHub，新建一个名为**<code>你的用户名.github.io</code>**的仓库，如下图：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/02_Create_Repository.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/02_Create_Repository.jpg" alt="Create_Repository"></a></p>
<p>这里一定注意（否则后面的操作会出问题），如果你的 GitHub 用户名是 test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="https://test.github.io/">https://test.github.io</a> 了，如下图：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/03_Repository_name.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/03_Repository_name.jpg" alt="Repository_Name"></a></p>
<p>由此可见，每一个 GitHub 账户最多只能创建一个这样可以直接使用域名访问的仓库。</p>
<h3 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h3><p>打开Git Bash，在窗口中输入命令：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -C <span class="string">&quot;user.email&quot;</span> <span class="comment"># user.email为GitHub上注册的邮箱</span></span><br></pre></td></tr></table></figure>
<p>然后直接三个回车即可，默认不需要设置密码。查看是否已经有 ssh 密钥：打开用户主目录<code>C:\Users\lenovo\.ssh</code>，.ssh文件夹一定存放在<code>C:\Users\</code>目录下，至于后面的路径lenovo这个不一定每台电脑都相同。找到.ssh文件夹，打开如下：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/04_.ssh.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/04_.ssh.jpg" alt=".ssh"></a></p>
<p>然后找到生成的 <code>.ssh</code> 的文件夹中的 <code>id_rsa.pub</code> 密钥，将内容全部复制。其中 <code>id_rsa</code> 是私钥不能泄露，<code>id_rsa.pub</code> 是公钥可以放心告诉他人。</p>
<p>打开 <a href="https://github.com/settings/keys">GitHub_Settings_keys</a> 页面，新建 <code>new SSH Key</code></p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/05_GitHub_Settings_Keys.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/05_GitHub_Settings_Keys.jpg" alt="GitHub_Settings_keys"></a></p>
<p><code>Title</code> 为标题，任意填即可，将刚刚复制的 <code>id_rsa.pub</code> 内容粘贴进去，最后点击 <code>Add SSH key</code> 。在 <code>Git Bash</code> 中检测 <code>GitHub</code> 公钥设置是否成功，输入如下命令：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh -T git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure>
<p>验证是否连接成功，连接成功显示如下：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/06_ssh_GitHub.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/06_ssh_GitHub.jpg" alt="ssh_GitHub"></a></p>
<h2 id="使用Hexo博客框架"><a href="#使用Hexo博客框架" class="headerlink" title="使用Hexo博客框架"></a>使用Hexo博客框架</h2><p>Hexo官方使用文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p>本文使用的命令和官方文档不太一样，但意思相同，达到的效果也相同。初学者建议跟着本文一步一步做。</p>
<h3 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h3><h4 id="hexo是什么"><a href="#hexo是什么" class="headerlink" title="hexo是什么"></a>hexo是什么</h4><p><code>Hexo</code> 是一个简单、快速、强大的基于 <code>Github Pages</code> 的博客框架，支持 <code>Markdown</code> 格式，有众多优秀插件和主题。</p>
<p>GitHub：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p>
<h4 id="hexo原理"><a href="#hexo原理" class="headerlink" title="hexo原理"></a>hexo原理</h4><p>由于 <code>github pages</code> 存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以 <code>hexo</code> 所做的就是将这些 <code>md</code> 文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到 <code>GitHub</code> 。</p>
<h3 id="安装hexo与配置"><a href="#安装hexo与配置" class="headerlink" title="安装hexo与配置"></a>安装hexo与配置</h3><p>很多命令既可以用 Windows 的 <code>cmd</code> 来完成，也可以使用 <code>git bash</code> 来完成。几乎所有的命令我都是在 <code>git bash</code>上完成的，但是我在hexo初始化的过程中遇到文件夹node_modules无法生成的问题，需要 <code>cmd</code> 命令配合解决（后面会详细说明这个bug）。</p>
<h4 id="安装与初始化"><a href="#安装与初始化" class="headerlink" title="安装与初始化"></a>安装与初始化</h4><p>在 <code>git bash</code> 输入以下命令：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-<span class="keyword">cli</span> <span class="meta"># 该命令完成hexo的安装</span></span><br></pre></td></tr></table></figure>
<p>这个安装时间较长耐心等待。</p>
<p>安装完成后，在电脑的某个地方新建一个文件夹（名字可以随便取）专门用于存放博客代码，比如我的是 E:\web\github\username，由于这个文件夹将来存放博客的所有内容和素材，以及所有的博客操作都会在其中完成，所以最好不要随便放。</p>
<p>进入新建的博客目录，输入如下命令：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">init</span> <span class="meta"># 该命令完成hexo在本地博客目录的初始化</span></span><br></pre></td></tr></table></figure>
<p>完成后检查博客目录中的文件信息，如下图：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/07_Hexo.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/07_Hexo.jpg" alt="Hexo"></a></p>
<p>如果缺少 <code>node_modules</code> 文件夹，请按照如下所述操作（否则跳过此步骤），导致这个原因为在自己的博客文件夹中 <code>.gitignore</code> 文件中添加了 <code>node_modules/</code> ，导致更新的时候，这个文件夹被忽略，没有被更新上去。</p>
<p>解决方案：</p>
<ol>
<li>cmd进入博客当前文件夹路径</li>
<li>执行 npm install</li>
<li>执行 hexo server</li>
</ol>
<h4 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h4><p>在 <code>git bash</code> 输入以下命令：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo g <span class="comment"># 生成静态文件</span></span><br></pre></td></tr></table></figure>
<p>执行以上命令之后，Hexo 就会在 <code>public</code> 文件夹生成相关 HTML 文件，这些文件将来都是要提交到 <code>GitHub</code> 上 <strong><code>你的用户名.github.io</code></strong> 的仓库上去的：</p>
<h4 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h4><p>在 <code>git bash</code> 输入以下命令：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo s <span class="comment"># 开启本地预览</span></span><br></pre></td></tr></table></figure>
<p><code>hexo s</code> 是开启本地预览服务，打开浏览器访问 <code>http://localhost:4000</code> 即可看到内容，<code>Ctrl+C</code> 停止本地预览。本地预览可以实时查看博客的编辑情况，待博客写完后一起部署到 <code>GitHub</code> 上。</p>
<p>第一次初始化的时候 hexo 已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/08_Hello_World.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/08_Hello_World.jpg" alt="Hello_World"></a></p>
<h3 id="上传到GitHub"><a href="#上传到GitHub" class="headerlink" title="上传到GitHub"></a>上传到GitHub</h3><h4 id="配置站点配置文件"><a href="#配置站点配置文件" class="headerlink" title="配置站点配置文件"></a>配置站点配置文件</h4><p>hexo 有2种 <code>_config.yml</code>文件，一个是根目录下的全局的 <code>_config.yml</code>，一个是各个主体 theme 下的 <code>_config.yml</code>。将前者称为<strong>站点配置文件</strong>， 后者称为<strong>主题配置文件</strong>。</p>
<p>打开根目录下站点配置文件 <code>_config.yml</code>，配置有关 deploy 的部分：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/09_config_Deployment.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/09_config_Deployment.jpg" alt="config_deploy"></a></p>
<h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>在 <code>git bash</code> 输入以下命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-deployer-git --save <span class="comment"># 安装部署插件</span></span><br></pre></td></tr></table></figure>
<p>如果不进行上述操作，直接使用 <code>hexo d</code> 部署到 <code>GitHub</code>，将会报错。</p>
<h4 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h4><p>在 <code>git bash</code> 输入以下命令：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo d</span><br></pre></td></tr></table></figure>
<p><code>hexo d</code> 部署这个命令一定要用 git bash，否则会提示 <code>Permission denied (publickey)</code>。</p>
<p>部署成功后，打开你的网址 <strong><code>https://你的用户名.github.io/</code></strong> 出现下图，表示部署成功。</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/08_Hello_World.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/08_Hello_World.jpg" alt="Hello_World"></a></p>
<p>自此博客的搭建就完成了，剩下的就是学习如何美化博客了！</p>
<h2 id="Hexo博客基本配置"><a href="#Hexo博客基本配置" class="headerlink" title="Hexo博客基本配置"></a>Hexo博客基本配置</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h4><p>官方默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。</p>
<blockquote>
<p><a href="https://hexo.io/themes/">官方主题</a>：官方提供的各种主题</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/24422335">知乎</a>、<a href="https://github.com/hexojs/hexo/wiki/Themes">GitHub</a> 上都能够找到各种主题推荐，这里不详细介绍。只以使用量排名第一的主题 NexT。更换 NexT 主题可以参考 <a href="http://theme-next.iissnan.com/">NexT 官方使用文档</a>，点击开始使用一步一步操作。下面做一个示范，其他主题的安装方法都是一样的。</p>
<p>下载主题，在 <code>git bash</code> 输入以下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/iissnan/</span>hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>启用主题，打开根目录下站点配置文件 <code>_config.yml</code>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>，如下：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/10_themes_next.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/10_themes_next.jpg" alt="thems_next"></a></p>
<p>打开主题的 <code>_config.yml</code> 配置文件，不是<strong>站点配置文件</strong>，找到Scheme Settings</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/11_Scheme_Settings.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/11_Scheme_Settings.jpg" alt="Scheme_Settings"></a></p>
<p><code>next</code> 主题有四个样式，我用的是 <code>Gemini</code>，大家根据喜好设置。</p>
<p>在切换主题之后、验证之前，我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存，以免出现一些莫名其妙的问题。然后重新执行 <code>hexo g</code> 以及 <code>hexo s</code> 来重新生成和本地预览。如下图，说明主题修改完成。</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/12_Next_Hello_World.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/12_Next_Hello_World.jpg" alt="img"></a></p>
<h4 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h4><p>打开根目录下站点配置文件 <code>_config.yml</code>，设置如下内容：</p>
<p><a href="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/13_Site.jpg"><img src="https://raw.githubusercontent.com/tengzi-will/img.tengzi-will.github.io/master/GitHub-Hexo-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/13_Site.jpg" alt="Site"></a></p>
<p>参数说明：</p>
<ul>
<li>title：网站标题</li>
<li>subtitle：网站副标题</li>
<li>description：网站描述</li>
<li>keywords：关键字</li>
<li>author：作者</li>
<li>language：网站使用的语言</li>
<li>timezone：网站时区。Hexo 默认使用您电脑的时区</li>
</ul>
<p>其中language一定要设置为主题能够识别的语言（不然中文可能出现乱码），在 <code>\themes\next\languages\</code> 中可以找到，中文有两种格式 <code>zh-Hans</code> 、 <code>zh-hk</code> 和 <code>zh-tw</code> 可选。</p>
<h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><h4 id="初识-Markdown-语法"><a href="#初识-Markdown-语法" class="headerlink" title="初识 Markdown 语法"></a>初识 Markdown 语法</h4><p><strong>Markdown</strong> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<strong>Markdown</strong> 语法简洁明了、容易掌握，而且功能比纯文本更强，因此写博客使用它，可以让用户更加专注的写文章，而不需要费尽心力的考虑样式，相对于 <code>html</code> 已经算是轻量级语言，像有道云笔记也支持<br><strong>Markdown</strong> 写作。并且 <strong>Markdown</strong> 完全兼容 <code>html</code>，也就是可以在文章里直接插入 <code>html</code> 代码。比如给博文添加音乐，就可以直接把音乐的外链 <code>html</code> 代码插入文章中。</p>
<p>具体语法参看：<a href="https://www.appinn.com/markdown/">Markdown 语法说明(简体中文版)</a> 可以说十分钟就可以入门。当然，工欲善其事必先利其器，选择一个好的 <code>Markdown</code> 编辑器也是非常重要的，这里推荐 <a href="http://www.markdownpad.com/"><code>MarkdownPad</code></a>，这是带有预览效果的编辑器，也可以使用本地的文本编辑器，更多的 <code>Markdown</code> 的语法与编辑器自己可以搜索了解。</p>
<h4 id="创建一篇博文"><a href="#创建一篇博文" class="headerlink" title="创建一篇博文"></a>创建一篇博文</h4><p>执行如下命令：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="string">&#x27;blog_name&#x27;</span> <span class="meta"># blog_name填入文章名字</span></span><br></pre></td></tr></table></figure>
<p>hexo会帮我们在 <code>..\hexo\source\_posts</code> 下生成相关 <code>md</code> 文件，每一篇博客对应一个 <code>md</code> 文件。直接使用编辑器打开 <code>md</code> 文件可以直接编辑。</p>
<h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站配置信息，也就是本文所称的<strong>站点配置文件</strong>，可以在此配置大部分的参数。基本配置在前面基本已经设置过了。</p>
<h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p>模版文件夹。新建文章时，<code>Hexo</code> 会根据 <code>scaffold</code> 来建立文件。默认的模板有三种 draft.md 、 page.md 和 post.md，我们自己也可以在该文件夹下创建属于自己定制的模板，推荐格式如下：</p>
<ul>
<li>title: GitHub + Hexo 从零开始搭建个人博客</li>
<li>date: 1544357859000</li>
<li>tags:</li>
<li>categories：</li>
<li>description：</li>
</ul>
<p>然后，输入 <code>hexo new blog &quot;文章名&quot;</code> 进行测试。</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>该文件夹中的内容将被最终 <code>push</code> 到 <code>GitHub</code> 仓库中。</p>
<h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_ (下划线)</code> 的文件 / 文件夹和隐藏的文件将会被忽略。<code>Markdown</code> 和 <code>HTML</code> 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝到 <code>public</code> 文件夹。</p>
<h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>主题文件夹，下载的主题都保存在此文件夹下。Hexo 会根据主题来生成静态页面。</p>
<p>另外主题的配置也有很多高级技巧，这里附上 <a href="http://theme-next.iissnan.com/getting-started.html">Next 主题官方的配置文档教程</a>。</p>
<p>还有许多个性化设置，如SEO、评论系统、个人头像、博客分享、订阅功能High功能、404网页设置等，可以参看：</p>
<ul>
<li><a href="http://theme-next.iissnan.com/theme-settings.html">主题配置 - NexT 使用文档</a></li>
<li><a href="http://theme-next.iissnan.com/third-party-services.html">第三方服务集成 - NexT 使用文档</a></li>
<li><a href="http://theme-next.iissnan.com/tag-plugins.html">内置标签 - NexT 使用文</a></li>
<li><a href="http://theme-next.iissnan.com/advanced-settings.html">档进阶设定 - NexT 使用文档</a></li>
<li><a href="http://www.iamlj.com/2016/08/add-special-effect-harlem-shake-for-hexo/">High功能特效 - Next 主题网站推荐博主的文章</a></li>
</ul>
<h4 id="寻找图床"><a href="#寻找图床" class="headerlink" title="寻找图床"></a>寻找图床</h4><p>图床，当博文中有图片时，若是少量图片，可以直接把图片存放在 <code>source</code> 文件夹中，但这显然不合理的，因为图片会占据大量的存储的空间，加载的时候相对缓慢 ，这时考虑把博文里的图片上传到某一网站，然后获得外部链接，使用 <code>Markdown</code> 语法，<code>![图片信息](外部链接)</code> 完成图片的插入，这种网站就被成为图床。</p>
<p>常见的图床网站：<a href="http://www.tietuku.com/">贴图库</a> <a href="https://www.qiniu.com/">七牛云</a> 新浪微博</p>
<p>其实也可以直接在 GitHub 中新建一个仓库，专门用来存放博客的图片，我就是用的这个方法。</p>
<h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ol>
<li>hexo new “postName” # 新建文章</li>
<li>hexo clean # 清除缓存</li>
<li>hexo generate # 生成静态页面至 public 目录</li>
<li>hexo server # 开启预览访问端口（默认端口 4000，’ctrl + c’关闭 server）</li>
<li>hexo deploy # 部署到 GitHub</li>
<li>hexo help # 查看帮助</li>
<li>hexo version # 查看 Hexo 的版本</li>
</ol>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><ol>
<li>hexo n == hexo new</li>
<li>hexo g == hexo generate</li>
<li>hexo s == hexo server</li>
<li>hexo d == hexo deploy</li>
</ol>
<h3 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h3><ol>
<li>hexo s -g # 生成并本地预览</li>
<li>hexo d -g # 生成并上传</li>
</ol>
]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>工具篇之Git</title>
    <url>/posts/4d47980d/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>Git的一些使用方法的记录</p>
</blockquote>
<a id="more"></a>

<h1 id="第一部分-Git"><a href="#第一部分-Git" class="headerlink" title="第一部分 Git"></a>第一部分 Git</h1><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>✨Git官网下载地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p>官网选择系统对应的版本下载并按<code>默认安装</code>即可。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a0c1295e9e8453e85233e416d0a4658~tplv-k3u1fbpfcp-zoom-1.image" alt="Dowload"></p>
<h2 id="Git仓库"><a href="#Git仓库" class="headerlink" title="Git仓库"></a>Git仓库</h2><h3 id="git-init（初始化仓库）"><a href="#git-init（初始化仓库）" class="headerlink" title="git init（初始化仓库）"></a>git init（初始化仓库）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> C:/Users/Administrator/Desktop/LearnGit/.git/</span><br></pre></td></tr></table></figure>
<p>打开GitBash，切换到目标文件夹。执行git初始化命令。</p>
<p>执行后提示<code>初始化了一个空目录</code>，并且在目录下生成一个隐藏文件夹<code>.git</code>。</p>
<p>这时，我们目标文件夹就是一个仓库（Repository），这个目录里的所有文件都可以被版本控制系统管理。</p>
<p>有了仓库，我们需要创建我们的文件，然后对其进行版本管理。</p>
<p>首先，我们在仓库中新建一个文本文档，命名为“Readme.txt”，并向其写入如下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">This is the first line in the Readme.txt</span><br><span class="line">We will learn how to use Git.</span><br></pre></td></tr></table></figure>
<p>这时，我们可以认为仓库中的文件<code>被修改</code>了，我们需要将它<code>提交以创建新的版本</code>，下面将介绍用到的命令：</p>
<h3 id="git-add（添加到暂存区）"><a href="#git-add（添加到暂存区）" class="headerlink" title="git add（添加到暂存区）"></a>git add（添加到暂存区）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git add Readme.txt</span><br></pre></td></tr></table></figure>
<p>执行后，我们将Readme.txt添加到了<code>暂存区</code>，便于修改后选择<code>丢弃修改、临时存储或提交</code>。</p>
<p>我们在将文件提交新版本<code>之前</code>必须将文件保存到<code>暂存区</code>。</p>
<h3 id="git-status（查看仓库当前状态）"><a href="#git-status（查看仓库当前状态）" class="headerlink" title="git status（查看仓库当前状态）"></a>git status（查看仓库当前状态）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64</span><br><span class="line">~/Desktop/LearnGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   Readme.txt</span><br></pre></td></tr></table></figure>
<p>执行后，发现new file，即有了新文件。</p>
<p>这时，我们可以继续执行 <code>git commit -m 命令</code>提交</p>
<h3 id="git-commit（提交新版本）"><a href="#git-commit（提交新版本）" class="headerlink" title="git commit（提交新版本）"></a>git commit（提交新版本）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git commit -m <span class="string">&quot;Creat a new file&quot;</span></span><br><span class="line">[master (root-commit) ebec5bf] Creat a new file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 Readme.txt</span><br></pre></td></tr></table></figure>
<p>-m 参数后面是<code>版本说明</code>，即注释。我们这里是 Creat a new file，即创建新文件。</p>
<p>这样就提交成功了，git为我们的文件<code>创建了个新版本</code>，版本号ebec5bf，修改了1个文件，插入了2行文本。</p>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>工作区：<code>仓库文件夹</code>即一个工作区，也就是我们<code>直接修改文件并保存</code>的地方。</p>
<p>暂存区：使用<code>add命令</code>后，git会为文件在.git文件夹<code>创建副本</code>，用于<code>暂存</code>我们对文件的更改。（便于后续丢弃更改、临时存储或提交）</p>
<p>⚠PS：</p>
<p>1.我们在使用commit命令时是提交的<code>暂存区</code>的文件，也就是说，我们在commit之前一定要使用<code>add命令</code>将文件存到暂存区。</p>
<p>2.在实际使用中，我们可以每写一部分代码就使用一次add命令，使用add命令后将在暂存区修改。若代码出现问题，我们可以从暂存区恢复文件到使用add命令之前的状态。</p>
<h2 id="Git版本说明"><a href="#Git版本说明" class="headerlink" title="Git版本说明"></a>Git版本说明</h2><p>完成以上所有流程后，我们创建了一个<code>新的版本</code>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0e4e154ed494a7b92b12b7ab5d86964~tplv-k3u1fbpfcp-zoom-1.image" alt="Creat"></p>
<p>对之前的操作进行简单的复习：</p>
<p>git init —— git add <filename> —— git commit -m “说明”</p>
<p>首先对仓库进行<code>初始化</code>，确定当作仓库的目录。</p>
<p>然后把待修改文件<code>加入到暂存区</code>。</p>
<p>最后使用<code>commit提交更改</code>，创建新版本。</p>
<h3 id="再次创建新版本"><a href="#再次创建新版本" class="headerlink" title="再次创建新版本"></a>再次创建新版本</h3><p>我们再来创建一个新的版本：</p>
<p>对刚才的txt文件随机删除几个字符，然后使用<code>git status</code>查看状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   Readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>modified: Readme.txt</code>，即检测到了Readme.txt修改，但还<code>没有加到暂存区</code>。</p>
<p>（实际显示效果，modified：Readme.txt 为红色，上文还提示 use git add，表明已修改但为添加到暂存区）</p>
<p>我们使用 <code>add 命令</code>将它加入<code>暂存区</code>，再次使用<code>git status命令</code>查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   Readme.txt</span><br></pre></td></tr></table></figure>
<p>这时候可以看到，状态变成了<code>等待commit</code>。</p>
<p>（实际显示效果，modified：Readme.txt 为绿色，上文提示消失，表明修改已经添加到暂存区）</p>
<p>我们继续使用commit命令提交新的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git commit -m <span class="string">&quot;change a text&quot;</span></span><br><span class="line">[master 1a1f981] change a text</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>提交成功，一个文件被修改，修改了一行。</p>
<p>新的版本id为1a1f981。</p>
<p>这时，我们有了两个版本：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3621506bd103447398db100834b1ba27~tplv-k3u1fbpfcp-zoom-1.image" alt="change"></p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p><code>创建版本</code>有什么用呢？怎么进行<code>版本控制</code>？现在我们来看一下Git怎么进行<code>版本回退</code>。</p>
<p>顾名思义，版本回退就是<code>还原</code>到之前的某一个时间点的文件。</p>
<p>比如：腾讯QQ发布了个新版本，却发现不稳定，存在漏洞，需要紧急恢复老版本，这时候就用到<code>版本回退</code>了。</p>
<p>首先，我们使用 git log 命令查看提交日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 1a1f98115f5c31ceae7e52d4600b220d38fbc24b (HEAD -&gt; master)</span><br><span class="line">Author: Simplicity &lt;290255@qq.com&gt;</span><br><span class="line">Date:   Fri Dec 25 10:45:47 2020 +0800</span><br><span class="line"></span><br><span class="line">    change a text</span><br><span class="line"></span><br><span class="line">commit ebec5bfe1c45b35a48c24c718c89f09e55a214bc</span><br><span class="line">Author: Simplicity &lt;290255@qq.com&gt;</span><br><span class="line">Date:   Fri Dec 25 10:30:46 2020 +0800</span><br><span class="line"></span><br><span class="line">    Creat a new file</span><br></pre></td></tr></table></figure>
<p>可以看到，我们提交了两个版本。最新的版本右边标有<code>（HEAD -&gt; master）</code>。</p>
<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p>假设，我们想回退上一个版本，我们可以使用 git reset –hard HEAD^ 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at ebec5bf Creat a new file</span><br></pre></td></tr></table></figure>
<p>现在，我们的Readme.txt就回到了上一个版本，也就是刚创建时候的状态。</p>
<p>当前仓库中版本示意图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b4befdd164f4dbcb86022e50e5ec37b~tplv-k3u1fbpfcp-zoom-1.image" alt="return"></p>
<p>再次使用git log查看版本记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit ebec5bfe1c45b35a48c24c718c89f09e55a214bc (HEAD -&gt; master)</span><br><span class="line">Author: Simplicity &lt;290255@qq.com&gt;</span><br><span class="line">Date:   Fri Dec 25 10:30:46 2020 +0800</span><br><span class="line"></span><br><span class="line">    Creat a new file</span><br></pre></td></tr></table></figure>
<h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h4><p>如果我们想再回到最新版本，也就是修改文件后的版本，又该如何操作？</p>
<p>回退版本后git log不再显示最新版本，我们可以使用git reflog查看版本变更记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">ebec5bf (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">1a1f981 HEAD@&#123;1&#125;: commit: change a text</span><br><span class="line">ebec5bf (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): Creat a new file</span><br></pre></td></tr></table></figure>
<p>我们可以看到，最新版本，也就是修改文件后的版本id是1a1f981。</p>
<p>我们可以使用下面的命令回到任意版本（只需知道版本ID）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git reset --hard 1a1f981</span><br><span class="line">HEAD is now at 1a1f981 change a text</span><br></pre></td></tr></table></figure>
<p>现在， 文件再次回到了修改后的状态，使用git log查看下目前的版本信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 1a1f98115f5c31ceae7e52d4600b220d38fbc24b (HEAD -&gt; master)</span><br><span class="line">Author: Simplicity &lt;290255@qq.com&gt;</span><br><span class="line">Date:   Fri Dec 25 10:45:47 2020 +0800</span><br><span class="line"></span><br><span class="line">    change a text</span><br><span class="line"></span><br><span class="line">commit ebec5bfe1c45b35a48c24c718c89f09e55a214bc</span><br><span class="line">Author: Simplicity &lt;290255@qq.com&gt;</span><br><span class="line">Date:   Fri Dec 25 10:30:46 2020 +0800</span><br><span class="line"></span><br><span class="line">    Creat a new file</span><br></pre></td></tr></table></figure>
<p>目前的版本状态：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64ba35333f604dd8994c5c92247633b1~tplv-k3u1fbpfcp-zoom-1.image" alt="change"></p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>暂存区和工作区到底有什么作用？为什么不能直接把工作区的修改直接commit到仓库？</p>
<p>下面，就来看一下，Git的<code>优势</code>所在：</p>
<h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><p>还记得add命令吗，我们使用add命令可以将目前的文件<code>添加到暂存区</code>。</p>
<p>添加到暂存区，相等于在暂存区<code>创建了一份备份</code>。</p>
<p>当我们在工作区修改文件出错想<code>撤回</code>的时候，我们可以直接让暂存区的文件<code>覆盖</code>当前文件。</p>
<p>我们先打开Readme.txt文件查看其中的内容：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/584649574c77464d866af3a6bf075633~tplv-k3u1fbpfcp-zoom-1.image" alt="old"></p>
<p>然后使用git add命令添加到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git add Readme.txt</span><br></pre></td></tr></table></figure>
<p>添加成功后，我们随意修改Readme.txt中的内容：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de3ff360abd4116a97db4730fc7197e~tplv-k3u1fbpfcp-zoom-1.image" alt="new"></p>
<p>然后可以使用如下命令，让文件回到使用add添加到暂存区时的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git checkout -- Readme.txt</span><br></pre></td></tr></table></figure>
<p>执行命令后，发现文件已经回退到了添加到暂存区时的状态：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6f99bc8895a4934b8f3868e75d5c289~tplv-k3u1fbpfcp-zoom-1.image" alt="old"></p>
<p>git checkout命令有两种情况：</p>
<p>1.若已经使用add添加文件到暂存区，执行命令会使文件回退到add命令时的状态。</p>
<p>2.若未使用add添加文件到暂存区，执行命令会使文件回退到版本库中的状态。</p>
<h4 id="git-reset-1"><a href="#git-reset-1" class="headerlink" title="git reset"></a>git reset</h4><p>若文件被修改乱了，并且已经把改乱后的文件添加到了暂存区，又该怎么办呢？</p>
<p>这时候，我们可以使用下面的命令从<code>版本仓库</code>中获取文件<code>覆盖</code>当前文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git reset HEAD Readme.txt</span><br></pre></td></tr></table></figure>
<p>执行完命令后，<code>暂存区</code>的文件将被版本库<code>覆盖</code>。</p>
<p>然后使用 git checkout命令将暂存区的文件覆盖到工作区即可。</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>现在我们在工作区删除某一个文件。</p>
<p>使用git status命令查看工作区状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        deleted:    Readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>它告诉我们 Readme.txt 文件被删除了。</p>
<p>如果是误删，我们想恢复文件，可以使用撤销修改命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~&#x2F;Desktop&#x2F;LearnGit (master)</span><br><span class="line">$ git checkout Readme.txt</span><br><span class="line">Updated 1 path from the index</span><br></pre></td></tr></table></figure>
<p>这样，Readme.txt便从暂存区或版本库中恢复了。</p>
<p>如果我们确实想删除这个文件，并且在版本库中删除：</p>
<p>我们可以使用 <code>git add</code> 命令 或 <code>git rm</code> 命令，下面介绍两个目录的不同。</p>
<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>手动删除文件后，使用git add将变动告诉暂存区，然后使用commit命令提交这次变动，即可成功删除。</p>
<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>git rm = rm + git add，使用git rm可以将工作区文件删除并将变动告诉暂存区，然后使用commit命令提交这次变动，即可成功删除。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>以前我们在学习Git的时候没有提到<code>分支</code>的概念，我们始终在使用一个分支，即<code>Master分支</code>。</p>
<p>当多人协同开发时，我们需要完成自己的任务同时不耽误它人开发，每个人都需要有自己的分支。</p>
<p>当我们Debug、实验开发时，我们需要单独一个分支用来修改并测试，稳定后再推送至主分支。</p>
<p>根据以往的流程图，Head即当前版本，它实际指向Master分支，而Master分支指向最新提交的版本：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35da1553d4884d33a7d333b7f7a57fc0~tplv-k3u1fbpfcp-zoom-1.image" alt="master"></p>
<h3 id="git-switch-c"><a href="#git-switch-c" class="headerlink" title="git switch -c"></a>git switch -c</h3><p>现在，我们使用<code>git switch -c</code>命令<code>创建</code>并<code>切换</code>到dev分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f526e014a1714eaeb6cbe5402de38ce2~tplv-k3u1fbpfcp-zoom-1.image" alt="dev"></p>
<p>（Head即当前版本指向dev指针，dev指针指向最新版本。）</p>
<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>我们可以使用 <code>git branch</code> 命令<code>查看分支</code>（<code>星号</code>后的是当前分支）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (dev)</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<h3 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h3><p>还可以使用git switch命令<code>切换分支</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (dev)</span><br><span class="line">$ git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们<code>切回dev分支</code>并<code>创建</code>新的版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git switch dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line"></span><br><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (dev)</span><br><span class="line">$ git add Readme.txt</span><br><span class="line"></span><br><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (dev)</span><br><span class="line">$ git commit -m <span class="string">&quot;updata&quot;</span></span><br><span class="line">[dev b20a57f] updata</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cab7791dcf7542ebb7af444164a6f5f4~tplv-k3u1fbpfcp-zoom-1.image" alt="dev"></p>
<p>创建新版本后，Head依旧指向dev，dev指向<code>最新的版本</code>。而Master由于是另外一个分支并<code>没有变动</code>。</p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>在dev分支更新版本后，我们切回master会发现文件还是老版本，这是因为master分支并没有更新。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d4e475969e4db7ad751622eab2750b~tplv-k3u1fbpfcp-zoom-1.image" alt="dev"></p>
<p>（切换版本实际是修改Head指针，令他指向Master指针。）</p>
<p>如果经过我们测试，dev分支没问题，我们可以将它<code>合并</code>到Master分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git merge dev</span><br><span class="line">Updating 1a1f981..b20a57f</span><br><span class="line">Fast-forward</span><br><span class="line"> Readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p><code>Fast-forward</code>：<code>快进模式</code>，这里是将master版本指针指向dev指针指向的版本。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca711e3dd55847a882e0649fd485c228~tplv-k3u1fbpfcp-zoom-1.image" alt="dev"></p>
<h3 id="git-branch-d"><a href="#git-branch-d" class="headerlink" title="git branch -d"></a>git branch -d</h3><p>如上图所示，Master和dev指向了同一个版本，如果我们不再需要dev，可以将其<code>删除</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Administrator@LAPTOP-89OP7KJM MINGW64 ~/Desktop/LearnGit (master)</span><br><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b20a57f).</span><br></pre></td></tr></table></figure>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>使用git tag [标签名]命令即可打标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag [标签名]</span><br></pre></td></tr></table></figure>
<p>使用git tag命令可以查看所有标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>使用git tag [标签名] [id]可以给指定版本打标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag [标签名]  [id]</span><br></pre></td></tr></table></figure>
<p>使用git show [标签名]可以查看标签详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show [标签名]</span><br></pre></td></tr></table></figure>
<h1 id="第二部分-GitHub"><a href="#第二部分-GitHub" class="headerlink" title="第二部分 GitHub"></a>第二部分 GitHub</h1><p><img src="https://upload-images.jianshu.io/upload_images/4064394-badc6aa178c1173b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp" alt="img"></p>
<h2 id="为什么用GitHub"><a href="#为什么用GitHub" class="headerlink" title="为什么用GitHub?"></a>为什么用GitHub?</h2><p>学会使用Git后我们的团队合作能力大大提升，我们可以设置一台代码仓库服务器，本地提交完成（commit）后将代码与仓库同步，就能实现分布式版本控制了。</p>
<p>然而，为一个小项目单独设立仓库服务器成本有些高，另外，自己搭建的物理主机服务器难免会有故障，我们也很难保障网络（独立ip很贵），于是，大胆的想法就出现了！</p>
<p>没错！就是上云啦！GitHub就是这样一家提供免费代码仓库的公司，它是由Git之父、linux之父linus成立的（git其实是linus为了维护linux开发的）为广大程序员提供远程代码仓库的伟大公司～～</p>
<p>前不久被微软收购了。</p>
<p>页面大概是这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064394-275d48bd7cb63cf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt="img"></p>
<p>github个人主页</p>
<p>每个用户有一个类似博客的主页，和很多仓库（一个项目一个仓库），程序员把自己写的代码上传到GitHub来托管，因为是大公司在管，你不必担心它的服务器会挂掉，在全球任何有网络的地方你都可以开始工作！<br>没错，很多公司也使用GitHub管理他们的项目</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064394-e995a51e49888cd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/711/format/webp" alt="img"></p>
<p>大概有三种用途：</p>
<p><strong>合作开发</strong></p>
<p>如果有多个人一起开发某项目，把仓库设在GitHub，大家在各自笔记本写代码、修改使用git上传、同步，避免了复制粘贴代码，而且还能实现版本控制，谁修改了什么内容一清二楚，连谁写了多少行改了多少行代码都能统计清楚。摸鱼是不可能的。</p>
<p><strong>软件仓库</strong></p>
<p>GitHub提供两种仓库私有仓库和公开仓库。</p>
<p>GitHub免费为所有用户提供公开仓库空间，公开仓库向网络公开，所有人都能访问，但只有所有者和授权用户才能修改。</p>
<p>私有仓库不对外公开，但要向GitHub付费。</p>
<p><strong>代码公开</strong></p>
<p>这一条应该是最有用的了，你可以在这里找到全世界程序员的劳动成果，上到各种算法实现、下到各种app源码。只要遵循开源协议，你都可以copy下来用。</p>
<h2 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h2><p>第一步：注册账号<a href="https://github.com/">GitHub官网</a></p>
<p>第二步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> &quot;<span class="selector-tag">youremail</span><span class="keyword">@example</span>.com&quot;</span><br></pre></td></tr></table></figure>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。<br>打开id_rsa.pub,复制里面的内容。<br>第三步，登陆GitHub，打开“Account settings”，“SSH Keys and GPG keys”页面：</p>
<p>然后，点“New SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064394-79cd18224d3a27c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/757/format/webp" alt="img"></p>
<p>添加sshkey</p>
<p>点“Add Key”，你就应该看到已经添加的Key。</p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>然后你可以创建仓库了<br>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064394-1606a08db48f4591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/772/format/webp" alt="img"><br>然后起一个项目名</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064394-16fdfb94c4019404.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/727/format/webp" alt="img"><br>来到这个项目的主页</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064394-07a2a92a3756b47e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1031/format/webp" alt="img"></p>
<p>可以看到主页提供了两种和本地仓库关联起来的方式<br><strong>方法一：</strong><br>把本地已有的同名Git仓库和GitHub上的仓库关联起来<br>我们在本地新建了一个名为Gittest的文件夹</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure>
<p>将Gittest文件夹设置为Git仓库<br>添加文件,比如我们新写了一个hello.txt：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span> hello.txt</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br></pre></td></tr></table></figure>
<p>到此为止已经提交到了本地仓库<br>接下来我们把本地仓库和远程仓库联系起来</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> origin git@github.com:MachinePlay/Gittest.git</span><br></pre></td></tr></table></figure>
<p>请千万注意，把上面的MachinePlay替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库<br>下一步，就可以把本地库的所有内容推送到远程库上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>此后<code>git add</code> <code>git commit-m</code>之后 就可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>就可以把自己的代码上传到远程仓库了。</p>
<p><strong>方法二：</strong></p>
<p>使用<code>Git clone</code>直接从远程仓库克隆下来</p>
<p>前面我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆GitHub，创建一个新的仓库，名字叫Gittest</p>
<p>每个仓库都有一个地址：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064394-9e9acb7734a49193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1053/format/webp" alt="img"></p>
<p>我们在本地使用<code>git clone</code>直接把远程仓库克隆下来。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">git clone git<span class="meta">@github</span>.com:MachinePlay/Gittest.git</span><br></pre></td></tr></table></figure>
<p>看到这里大家就懂了，不仅仅是自己的仓库可以克隆，也可以克隆其他用户的公开仓库。</p>
<p>例如现在随便找一个安卓阅读app的仓库</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064394-f6e14f77bb04a117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1049/format/webp" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:smuyyh/BookReader.git</span><br></pre></td></tr></table></figure>
<p>就把这位用户仓库里一个完整的阅读app源码全部下载到本地了。</p>
<h2 id="如何上传更新"><a href="#如何上传更新" class="headerlink" title="如何上传更新"></a>如何上传更新</h2><p>你在本地目录有任何变动，只需按照以下顺序就能上传：</p>
<ol>
<li>git add 文件路径</li>
<li>git commit -m “信息”</li>
<li>git pull （相信我，你一定会忘记这一个命令）</li>
<li>git push</li>
</ol>
<p>下面是例子</p>
<ol>
<li><code>cd git-demo-1</code></li>
<li><code>touch index2.html</code></li>
<li><code>git add index2.html</code></li>
<li><code>git commit -m &quot;新建 index2.html&quot;</code></li>
<li><code>git pull</code></li>
<li><code>git push</code></li>
</ol>
<h2 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git ignore"></a>git ignore</h2><p>在项目目录创建 .gitignore 文件就可以指定「哪些文件不上传到远程仓库」，比如</p>
<p>.gitignroe</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/node_modules/</span><br><span class="line">/.vscode/</span><br></pre></td></tr></table></figure>
<p>这样就可以避免 node_modules/ 和 .vscode/ 目录被上传到 github 了。</p>
<h2 id="记住一句话：永远都不要上传-node-modules-到-github。"><a href="#记住一句话：永远都不要上传-node-modules-到-github。" class="headerlink" title="记住一句话：永远都不要上传 node_modules 到 github。"></a>记住一句话：永远都不要上传 node_modules 到 github。</h2><p>如果你想防止自己手贱上传 node_modules 到 github ，可以：</p>
<ol>
<li>在项目根目录 touch .gitignore</li>
<li>在 .gitignore 里添加一行 <code>/node_modules/</code></li>
<li>git add .gitignore; git commit -m ‘ignore’</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有一些有用的命令</p>
<ul>
<li><code>git remote add origin git@github.com:xxxxxxx.git</code> 将本地仓库与远程仓库关联</li>
<li><code>git remote set-url origin git@github.com:xxxxx.git</code> 上一步手抖了，可以用这个命令来挽回</li>
<li><code>git branch</code> 新建分支</li>
<li><code>git merge</code> 合并分支</li>
<li><code>git stash</code> 通灵术</li>
<li><code>git stash pop</code> 反转通灵术</li>
<li><code>git revert</code> 后悔了</li>
<li><code>git reset</code> 另一种后悔了</li>
<li><code>git diff</code> 查看详细变化</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>并发关键字之volatile</title>
    <url>/posts/6591a841/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>并发关键字volatile的深入理解及其原理详解</p>
</blockquote>
<a id="more"></a>

<h1 id="volatile的作用详解"><a href="#volatile的作用详解" class="headerlink" title="volatile的作用详解"></a>volatile的作用详解</h1><h2 id="防重排序"><a href="#防重排序" class="headerlink" title="防重排序"></a>防重排序</h2><p>我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁(DCL)的方式来实现。其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有，禁止外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
</ul>
<p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p>
<ul>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ul>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p>
<h2 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h2><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span>+b+<span class="string">&quot;;a=&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> VolatileTest test = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.change();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直观上说，这段代码的结果只可能有两种：b=3;a=3 或 b=2;a=1。不过运行上面的代码(可能时间上要长一点)，你会发现除了上两种结果之外，还出现了第三种结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b=<span class="number">2</span>;a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span>;a=<span class="number">1</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">1</span> <span class="comment">// 这里</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">2</span>;a=<span class="number">1</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br><span class="line">b=<span class="number">3</span>;a=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>为什么会出现b=3;a=1这种结果呢? 正常情况下，如果先执行change方法，再执行print方法，输出结果应该为b=3;a=3。相反，如果先执行的print方法，再执行change方法，结果应该是 b=2;a=1。那b=3;a=1的结果是怎么出来的? 原因就是第一个线程将值a=3修改后，但是对第二个线程是不可见的，所以才出现这一结果。如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。</p>
<h2 id="保证原子性-单次读-写"><a href="#保证原子性-单次读-写" class="headerlink" title="保证原子性:单次读/写"></a>保证原子性:单次读/写</h2><p>基于volatile保证单次的读/写操作具有原子性的理解，你将能够理解如下两个问题：</p>
<h3 id="问题1：-i-为什么不能保证原子性"><a href="#问题1：-i-为什么不能保证原子性" class="headerlink" title="问题1： i++为什么不能保证原子性?"></a>问题1： i++为什么不能保证原子性?</h3><p>对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p>
<p>现在我们就通过下列程序来演示一下这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addI</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span>  VolatileTest01 test01 = <span class="keyword">new</span> VolatileTest01();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; n++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    test01.addI();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);<span class="comment">//等待10秒，保证上面程序执行完成</span></span><br><span class="line">        System.out.println(test01.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：981 可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的(否则结果应该是1000)。原因也很简单，i++其实是一个复合操作，包括三步骤：</p>
<ul>
<li>读取i的值。</li>
<li>对i加1。</li>
<li>将i的值写回内存。 volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。</li>
</ul>
<h3 id="问题2：-共享的long和double变量的为什么要用volatile"><a href="#问题2：-共享的long和double变量的为什么要用volatile" class="headerlink" title="问题2： 共享的long和double变量的为什么要用volatile?"></a>问题2： 共享的long和double变量的为什么要用volatile?</h3><p>因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。</p>
<p>目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。</p>
<h1 id="volatile-的实现原理"><a href="#volatile-的实现原理" class="headerlink" title="volatile 的实现原理"></a>volatile 的实现原理</h1><h2 id="volatile-可见性实现"><a href="#volatile-可见性实现" class="headerlink" title="volatile 可见性实现"></a>volatile 可见性实现</h2><blockquote>
<p>volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:</p>
</blockquote>
<ul>
<li>内存屏障，又称内存栅栏，是一个 CPU 指令。</li>
<li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</li>
</ul>
<p>写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000000002951563: and    <span class="variable">$0xffffffffffffff87</span>,%rdi</span><br><span class="line">0x0000000002951567: je     0x00000000029515f8</span><br><span class="line">0x000000000295156d: <span class="built_in">test</span>   <span class="variable">$0x7</span>,%rdi</span><br><span class="line">0x0000000002951574: jne    0x00000000029515bd</span><br><span class="line">0x0000000002951576: <span class="built_in">test</span>   <span class="variable">$0x300</span>,%rdi</span><br><span class="line">0x000000000295157d: jne    0x000000000295159c</span><br><span class="line">0x000000000295157f: and    <span class="variable">$0x37f</span>,%rax</span><br><span class="line">0x0000000002951586: mov    %rax,%rdi</span><br><span class="line">0x0000000002951589: or     %r15,%rdi</span><br><span class="line">0x000000000295158c: lock cmpxchg %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span><br><span class="line">0x0000000002951591: jne    0x0000000002951a15</span><br><span class="line">0x0000000002951597: jmpq   0x00000000029515f8</span><br><span class="line">0x000000000295159c: mov    0x8(%rdx),%edi</span><br><span class="line">0x000000000295159f: shl    <span class="variable">$0x3</span>,%rdi</span><br><span class="line">0x00000000029515a3: mov    0xa8(%rdi),%rdi</span><br><span class="line">0x00000000029515aa: or     %r15,%rdi </span><br></pre></td></tr></table></figure>
<p>lock 前缀的指令在多核处理器下会引发两件事情:</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的额数据无效。</li>
</ul>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p>
<p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p>
<p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p>
<p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>
<h3 id="lock-指令"><a href="#lock-指令" class="headerlink" title="lock 指令"></a>lock 指令</h3><p>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议(MESI)来保证。</p>
<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>缓存是分段(line)的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。 LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ 嗅探(snooping)” 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</p>
<h2 id="volatile-有序性实现"><a href="#volatile-有序性实现" class="headerlink" title="volatile 有序性实现"></a>volatile 有序性实现</h2><h3 id="volatile-的-happens-before-关系"><a href="#volatile-的-happens-before-关系" class="headerlink" title="volatile 的 happens-before 关系"></a>volatile 的 happens-before 关系</h3><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设线程A执行writer方法，线程B执行reader方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;              <span class="comment">// 1 线程A修改共享变量</span></span><br><span class="line">        flag = <span class="keyword">true</span>;        <span class="comment">// 2 线程A写volatile变量</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3 线程B读同一个volatile变量</span></span><br><span class="line">        <span class="keyword">int</span> i = a;          <span class="comment">// 4 线程B读共享变量</span></span><br><span class="line">        ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p>
<ul>
<li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li>
<li>根据 volatile 规则：2 happens-before 3。</li>
<li>根据 happens-before 的传递性规则：1 happens-before 4。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-key-volatile-1.png" alt="img"></p>
<p>因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。</p>
<h3 id="volatile-禁止重排序"><a href="#volatile-禁止重排序" class="headerlink" title="volatile 禁止重排序"></a>volatile 禁止重排序</h3><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</p>
<p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p>
<p>JMM 会针对编译器制定 volatile 重排序规则表。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-key-volatile-2.png" alt="img"></p>
<p>“ NO “ 表示禁止重排序。</p>
<p>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p>
<table>
<thead>
<tr>
<th>内存屏障</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>StoreStore 屏障</td>
<td>禁止上面的普通写和下面的 volatile 写重排序。</td>
</tr>
<tr>
<td>StoreLoad 屏障</td>
<td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td>
</tr>
<tr>
<td>LoadLoad 屏障</td>
<td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td>
</tr>
<tr>
<td>LoadStore 屏障</td>
<td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td>
</tr>
</tbody></table>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-key-volatile-3.png" alt="img"></p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-key-volatile-4.png" alt="img"></p>
<h1 id="volatile-的应用场景"><a href="#volatile-的应用场景" class="headerlink" title="volatile 的应用场景"></a>volatile 的应用场景</h1><p>使用 volatile 必须具备的条件</p>
<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
<li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li>
</ul>
<h2 id="模式1：状态标志"><a href="#模式1：状态标志" class="headerlink" title="模式1：状态标志"></a>模式1：状态标志</h2><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; shutdownRequested = <span class="keyword">true</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h2 id="模式2：一次性安全发布-one-time-safe-publication"><a href="#模式2：一次性安全发布-one-time-safe-publication" class="headerlink" title="模式2：一次性安全发布(one-time safe publication)"></a>模式2：一次性安全发布(one-time safe publication)</h2><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h2 id="模式3：独立观察-independent-observation"><a href="#模式3：独立观察-independent-observation" class="headerlink" title="模式3：独立观察(independent observation)"></a>模式3：独立观察(independent observation)</h2><p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> String lastUser;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">authenticate</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> valid = passwordIsValid(user, password);</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            User u = <span class="keyword">new</span> User();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h2 id="模式4：volatile-bean-模式"><a href="#模式4：volatile-bean-模式" class="headerlink" title="模式4：volatile bean 模式"></a>模式4：volatile bean 模式</h2><p>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="模式5：开销较低的读－写锁策略"><a href="#模式5：开销较低的读－写锁策略" class="headerlink" title="模式5：开销较低的读－写锁策略"></a>模式5：开销较低的读－写锁策略</h2><p>volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesyCounter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Employs the cheap read-write lock trick</span></span><br><span class="line">    <span class="comment">// All mutative operations MUST be done with the &#x27;this&#x27; lock held</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="模式6：双重检查-double-checked"><a href="#模式6：双重检查-double-checked" class="headerlink" title="模式6：双重检查(double-checked)"></a>模式6：双重检查(double-checked)</h2><p>就是我们上文举的例子。</p>
<p>单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            syschronized(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器之ConcurrentLinkedQueue</title>
    <url>/posts/8aa9f2a3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>ConcurerntLinkedQueue一个基于链接节点的无界线程安全队列。此队列按照 FIFO(先进先出)原则对元素进行排序。队列的头部是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue是一个恰当的选择。此队列不允许使用null元素</p>
</blockquote>
<a id="more"></a>

<h1 id="ConcurrentLinkedQueue数据结构"><a href="#ConcurrentLinkedQueue数据结构" class="headerlink" title="ConcurrentLinkedQueue数据结构"></a>ConcurrentLinkedQueue数据结构</h1><p>通过源码分析可知，ConcurrentLinkedQueue的数据结构与LinkedBlockingQueue的数据结构相同，都是使用的链表结构。ConcurrentLinkedQueue的数据结构如下:</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-1.png" alt="img"></p>
<p>说明: ConcurrentLinkedQueue采用的链表结构，并且包含有一个头结点和一个尾结点。</p>
<h1 id="ConcurrentLinkedQueue源码分析"><a href="#ConcurrentLinkedQueue源码分析" class="headerlink" title="ConcurrentLinkedQueue源码分析"></a>ConcurrentLinkedQueue源码分析</h1><h2 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>说明: ConcurrentLinkedQueue继承了抽象类AbstractQueue，AbstractQueue定义了对队列的基本操作；同时实现了Queue接口，Queue定义了对队列的基本操作，同时，还实现了Serializable接口，表示可以被序列化。</p>
<h2 id="类的内部类"><a href="#类的内部类" class="headerlink" title="类的内部类"></a>类的内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="comment">// next域</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Constructs a new node.  Uses relaxed write because item can</span></span><br><span class="line"><span class="comment">        * only be seen after publication via casNext.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        <span class="comment">// 设置item的值</span></span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较并替换item值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置next域的值，并不会保证修改对其他线程立即可见</span></span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较并替换next域的值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="comment">// 反射机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// item域的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="comment">// next域的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = Node.class;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;item&quot;</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: Node类表示链表结点，用于存放元素，包含item域和next域，item域表示元素，next域表示下一个结点，其利用反射机制和CAS机制来更新item域和next域，保证原子性。</p>
<h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本序列号        </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">196745693267521676L</span>;</span><br><span class="line">    <span class="comment">// 反射机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// head域的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="comment">// tail域的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = ConcurrentLinkedQueue.class;</span><br><span class="line">            headOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">            tailOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 属性中包含了head域和tail域，表示链表的头结点和尾结点，同时，ConcurrentLinkedQueue也使用了反射机制和CAS机制来更新头结点和尾结点，保证原子性。</p>
<h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><p><code>ConcurrentLinkedQueue()</code>型构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化头结点与尾结点</span></span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 该构造函数用于创建一个最初为空的 ConcurrentLinkedQueue，头结点与尾结点指向同一个结点，该结点的item域为null，next域也为null。</p>
<p><code>ConcurrentLinkedQueue(Collection&lt;? extends E&gt;)</code>型构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = <span class="keyword">null</span>, t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123; <span class="comment">// 遍历c集合</span></span><br><span class="line">        <span class="comment">// 保证元素不为空</span></span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="comment">// 新生一个结点</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="comment">// 头结点为null</span></span><br><span class="line">            <span class="comment">// 赋值头结点与尾结点</span></span><br><span class="line">            h = t = newNode;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直接头结点的next域</span></span><br><span class="line">            t.lazySetNext(newNode);</span><br><span class="line">            <span class="comment">// 重新赋值头结点</span></span><br><span class="line">            t = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="comment">// 头结点为null</span></span><br><span class="line">        <span class="comment">// 新生头结点与尾结点</span></span><br><span class="line">        h = t = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 赋值头结点</span></span><br><span class="line">    head = h;</span><br><span class="line">    <span class="comment">// 赋值尾结点</span></span><br><span class="line">    tail = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 该构造函数用于创建一个最初包含给定 collection 元素的 ConcurrentLinkedQueue，按照此 collection 迭代器的遍历顺序来添加元素。</p>
<h2 id="核心函数分析"><a href="#核心函数分析" class="headerlink" title="核心函数分析"></a>核心函数分析</h2><h3 id="offer函数"><a href="#offer函数" class="headerlink" title="offer函数"></a>offer函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 元素不为null</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 新生一个结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="comment">// q为p结点的下一个结点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123; <span class="comment">// q结点为null</span></span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123; <span class="comment">// 比较并进行替换p结点的next域</span></span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become &quot;live&quot;.</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// p不等于t结点，不一致    // hop two nodes at a time</span></span><br><span class="line">                    <span class="comment">// 比较并替换尾结点</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="comment">// 返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">// p结点等于q结点</span></span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            <span class="comment">// 原来的尾结点与现在的尾结点是否相等，若相等，则p赋值为head，否则，赋值为现在的尾结点</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            <span class="comment">// 重新赋值p结点</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: offer函数用于将指定元素插入此队列的尾部。下面模拟offer函数的操作，队列状态的变化(假设单线程添加元素，连续添加10、20两个元素)。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-2.png" alt="img"></p>
<ul>
<li>若ConcurrentLinkedQueue的初始状态如上图所示，即队列为空。单线程添加元素，此时，添加元素10，则状态如下所示</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-3.png" alt="img"></p>
<ul>
<li>如上图所示，添加元素10后，tail没有变化，还是指向之前的结点，继续添加元素20，则状态如下所示</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-4.png" alt="img"></p>
<ul>
<li>如上图所示，添加元素20后，tail指向了最新添加的结点。</li>
</ul>
<h3 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123; <span class="comment">// 保存头结点</span></span><br><span class="line">            <span class="comment">// item项</span></span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123; <span class="comment">// item不为null并且比较并替换item成功</span></span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// p不等于h    // hop two nodes at a time</span></span><br><span class="line">                    <span class="comment">// 更新头结点</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p); </span><br><span class="line">                <span class="comment">// 返回item</span></span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// q结点为null</span></span><br><span class="line">                <span class="comment">// 更新头结点</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">// p等于q</span></span><br><span class="line">                <span class="comment">// 继续循环</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// p赋值为q</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 此函数用于获取并移除此队列的头，如果此队列为空，则返回null。下面模拟poll函数的操作，队列状态的变化(假设单线程操作，状态为之前offer10、20后的状态，poll两次)。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-5.png" alt="img"></p>
<ul>
<li>队列初始状态如上图所示，在poll操作后，队列的状态如下图所示</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-6.png" alt="img"></p>
<ul>
<li>如上图可知，poll操作后，head改变了，并且head所指向的结点的item变为了null。再进行一次poll操作，队列的状态如下图所示。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-7.png" alt="img"></p>
<ul>
<li>如上图可知，poll操作后，head结点没有变化，只是指示的结点的item域变成了null。</li>
</ul>
<h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 元素为null，返回</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node&lt;E&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) &#123; <span class="comment">// 获取第一个存活的结点</span></span><br><span class="line">        <span class="comment">// 第一个存活结点的item值</span></span><br><span class="line">        E item = p.item;</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            o.equals(item) &amp;&amp;</span><br><span class="line">            p.casItem(item, <span class="keyword">null</span>)) &#123; <span class="comment">// 找到item相等的结点，并且将该结点的item设置为null</span></span><br><span class="line">            <span class="comment">// p的后继结点</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) <span class="comment">// pred不为null并且next不为null</span></span><br><span class="line">                <span class="comment">// 比较并替换next域</span></span><br><span class="line">                pred.casNext(p, next);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pred赋值为p</span></span><br><span class="line">        pred = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 此函数用于从队列中移除指定元素的单个实例(如果存在)。其中，会调用到first函数和succ函数，first函数的源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，确保成功</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="comment">// p结点的item域是否为null</span></span><br><span class="line">            <span class="keyword">boolean</span> hasItem = (p.item != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (hasItem || (q = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// item不为null或者next域为null</span></span><br><span class="line">                <span class="comment">// 更新头结点</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="comment">// 返回结点</span></span><br><span class="line">                <span class="keyword">return</span> hasItem ? p : <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">// p等于q</span></span><br><span class="line">                <span class="comment">// 继续从头结点开始</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// p赋值为q</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: first函数用于找到链表中第一个存活的结点。succ函数源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p结点的next域</span></span><br><span class="line">    Node&lt;E&gt; next = p.next;</span><br><span class="line">    <span class="comment">// 如果next域为自身，则返回头结点，否则，返回next</span></span><br><span class="line">    <span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>说明: succ用于获取结点的下一个结点。如果结点的next域指向自身，则返回head头结点，否则，返回next结点。下面模拟remove函数的操作，队列状态的变化(假设单线程操作，状态为之前offer10、20后的状态，执行remove(10)、remove(20)操作)。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-8.png" alt="img"></p>
<ul>
<li>如上图所示，为ConcurrentLinkedQueue的初始状态，remove(10)后的状态如下图所示</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-9.png" alt="img"></p>
<ul>
<li>如上图所示，当执行remove(10)后，head指向了head结点之前指向的结点的下一个结点，并且head结点的item域置为null。继续执行remove(20)，状态如下图所示</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-concurrentlinkedqueue-10.png" alt="img"></p>
<ul>
<li>如上图所示，执行remove(20)后，head与tail指向同一个结点，item域为null。</li>
</ul>
<h3 id="size函数"><a href="#size函数" class="headerlink" title="size函数"></a>size函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) <span class="comment">// 从第一个存活的结点开始往后遍历</span></span><br><span class="line">        <span class="keyword">if</span> (p.item != <span class="keyword">null</span>) <span class="comment">// 结点的item域不为null</span></span><br><span class="line">            <span class="comment">// Collection.size() spec says to max out</span></span><br><span class="line">            <span class="keyword">if</span> (++count == Integer.MAX_VALUE) <span class="comment">// 增加计数，若达到最大值，则跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 返回大小</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 此函数用于返回ConcurrenLinkedQueue的大小，从第一个存活的结点(first)开始，往后遍历链表，当结点的item域不为null时，增加计数，之后返回大小。</p>
<h1 id="ConcurrentLinkedQueue示例"><a href="#ConcurrentLinkedQueue示例" class="headerlink" title="ConcurrentLinkedQueue示例"></a>ConcurrentLinkedQueue示例</h1><p>下面通过一个示例来了解ConcurrentLinkedQueue的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Integer&gt; clq;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(ConcurrentLinkedQueue&lt;Integer&gt; clq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clq = clq;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;add &quot;</span> + i);</span><br><span class="line">                clq.add(i);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Integer&gt; clq;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetThread</span><span class="params">(ConcurrentLinkedQueue&lt;Integer&gt; clq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clq = clq;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;poll &quot;</span> + clq.poll());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcurrentLinkedQueue&lt;Integer&gt; clq = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Integer&gt;();</span><br><span class="line">        PutThread p1 = <span class="keyword">new</span> PutThread(clq);</span><br><span class="line">        GetThread g1 = <span class="keyword">new</span> GetThread(clq);</span><br><span class="line">        </span><br><span class="line">        p1.start();</span><br><span class="line">        g1.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果(某一次):</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">add 0</span><br><span class="line">poll null</span><br><span class="line">add 1</span><br><span class="line">poll 0</span><br><span class="line">add 2</span><br><span class="line">poll 1</span><br><span class="line">add 3</span><br><span class="line">poll 2</span><br><span class="line">add 4</span><br><span class="line">poll 3</span><br><span class="line">add 5</span><br><span class="line">poll 4</span><br><span class="line">poll 5</span><br><span class="line">add 6</span><br><span class="line">add 7</span><br><span class="line">poll 6</span><br><span class="line">poll 7</span><br><span class="line">add 8</span><br><span class="line">add 9</span><br><span class="line">poll 8</span><br></pre></td></tr></table></figure>
<p>说明: GetThread线程不会因为ConcurrentLinkedQueue队列为空而等待，而是直接返回null，所以当实现队列不空时，等待时，则需要用户自己实现等待逻辑。</p>
<h1 id="再深入理解"><a href="#再深入理解" class="headerlink" title="再深入理解"></a>再深入理解</h1><h2 id="HOPS-延迟更新的策略-的设计"><a href="#HOPS-延迟更新的策略-的设计" class="headerlink" title="HOPS(延迟更新的策略)的设计"></a>HOPS(延迟更新的策略)的设计</h2><p>通过上面对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：</p>
<ul>
<li><code>tail更新触发时机</code>：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过casTail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。</li>
<li><code>head更新触发时机</code>：当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updateHead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。</li>
</ul>
<p>并且在更新操作时，源码中会有注释为：<code>hop two nodes at a time</code>。所以这种延迟更新的策略就被叫做HOPS的大概原因是这个(猜的 😃)，从上面更新时的状态图可以看出，head和tail的更新是“跳着的”即中间总是间隔了一个。那么这样设计的意图是什么呢?</p>
<p>如果让tail永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点，如果大量的入队操作，每次都要执行CAS进行tail的更新，汇总起来对性能也会是大大的损耗。如果能减少CAS更新的操作，无疑可以大大提升入队的操作效率，所以doug lea大师每间隔1次(tail和队尾节点的距离为1)进行才利用CAS更新tail。对head的更新也是同样的道理，虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能，因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。</p>
<h2 id="ConcurrentLinkedQueue适合的场景"><a href="#ConcurrentLinkedQueue适合的场景" class="headerlink" title="ConcurrentLinkedQueue适合的场景"></a>ConcurrentLinkedQueue适合的场景</h2><p>ConcurrentLinkedQueue通过无锁来做到了更高的并发量，是个高性能的队列，但是使用场景相对不如阻塞队列常见，毕竟取数据也要不停的去循环，不如阻塞的逻辑好设计，但是在并发量特别大的情况下，是个不错的选择，性能上好很多，而且这个队列的设计也是特别费力，尤其的使用的改良算法和对哨兵的处理。整体的思路都是比较严谨的，这个也是使用了无锁造成的，我们自己使用无锁的条件的话，这个队列是个不错的参考。</p>
]]></content>
      <categories>
        <category>容器</category>
        <category>并发容器</category>
      </categories>
      <tags>
        <tag>ConcurrentLinkedQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器之CopyOnWriteArrayList</title>
    <url>/posts/adb715db/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>CopyOnWriteArrayList是ArrayList 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的拷贝来实现的。COW模式的体现</p>
</blockquote>
<a id="more"></a>

<h1 id="CopyOnWriteArrayList源码分析"><a href="#CopyOnWriteArrayList源码分析" class="headerlink" title="CopyOnWriteArrayList源码分析"></a>CopyOnWriteArrayList源码分析</h1><h2 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h2><p>CopyOnWriteArrayList实现了List接口，List接口定义了对列表的基本操作；同时实现了RandomAccess接口，表示可以随机访问(数组具有随机访问的特性)；同时实现了Cloneable接口，表示可克隆；同时也实现了Serializable接口，表示可被序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的内部类"><a href="#类的内部类" class="headerlink" title="类的内部类"></a>类的内部类</h2><p>COWIterator类</p>
<p>COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作(remove、set 和 add)不受支持。这些方法将抛出 UnsupportedOperationException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="comment">// 快照</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="comment">// 游标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否还有下一项</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有上一项</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next项</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext()) <span class="comment">// 不存在下一项，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 返回下一项</span></span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下一项索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一项索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment">        *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 不支持remove操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> set&#125;</span></span><br><span class="line"><span class="comment">        *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 不支持set操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> add&#125;</span></span><br><span class="line"><span class="comment">        *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 不支持add操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        Object[] elements = snapshot;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = elements.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cursor; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) elements[i];</span><br><span class="line">            action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><p>属性中有一个可重入锁，用来保证线程安全访问，还有一个Object类型的数组，用来存放具体的元素。当然，也使用到了反射机制和CAS来保证原子性的修改lock域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 对象数组，用于存放元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">    <span class="comment">// 反射机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// lock域的内存偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> lockOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CopyOnWriteArrayList.class;</span><br><span class="line">            lockOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;lock&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><p>默认构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置数组</span></span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CopyOnWriteArrayList(Collection&lt;? extends E&gt;)</code>型构造函数　 该构造函数用于创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class) <span class="comment">// 类型相同</span></span><br><span class="line">        <span class="comment">// 获取c集合的数组</span></span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 类型不相同</span></span><br><span class="line">        <span class="comment">// 将c集合转化为数组并赋值给elements</span></span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class) <span class="comment">// elements类型不为Object[]类型</span></span><br><span class="line">            <span class="comment">// 将elements数组转化为Object[]类型的数组</span></span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置数组</span></span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该构造函数的处理流程如下</p>
<ul>
<li><p>判断传入的集合c的类型是否为CopyOnWriteArrayList类型，若是，则获取该集合类型的底层数组(Object[])，并且设置当前CopyOnWriteArrayList的数组(Object[]数组)，进入步骤③；否则，进入步骤②</p>
</li>
<li><p>将传入的集合转化为数组elements，判断elements的类型是否为Object[]类型(toArray方法可能不会返回Object类型的数组)，若不是，则将elements转化为Object类型的数组。进入步骤③</p>
</li>
<li><p>设置当前CopyOnWriteArrayList的Object[]为elements。</p>
</li>
<li><p><code>CopyOnWriteArrayList(E[])</code>型构造函数</p>
</li>
</ul>
<p>该构造函数用于创建一个保存给定数组的副本的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将toCopyIn转化为Object[]类型数组，然后设置当前数组</span></span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="核心函数分析"><a href="#核心函数分析" class="headerlink" title="核心函数分析"></a>核心函数分析</h2><p>对于CopyOnWriteArrayList的函数分析，主要明白Arrays.copyOf方法即可理解CopyOnWriteArrayList其他函数的意义。</p>
<h3 id="copyOf函数"><a href="#copyOf函数" class="headerlink" title="copyOf函数"></a>copyOf函数</h3><p>该函数用于复制指定的数组，截取或用 null 填充(如有必要)，以使副本具有指定的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 确定copy的类型(将newType转化为Object类型，将Object[].class转化为Object类型，判断两者是否相等，若相等，则生成指定长度的Object数组</span></span><br><span class="line">    <span class="comment">// 否则,生成指定长度的新类型的数组)</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    <span class="comment">// 将original数组从下标0开始，复制长度为(original.length和newLength的较小者),复制到copy数组中(也从下标0开始)</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 元素数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 存放元素e</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数用于将指定元素添加到此列表的尾部，处理流程如下</p>
<ul>
<li>获取锁(保证多线程的安全访问)，获取当前的Object数组，获取Object数组的长度为length，进入步骤②。</li>
<li>根据Object数组复制一个长度为length+1的Object数组为newElements(此时，newElements[length]为null)，进入下一步骤。</li>
<li>将下标为length的数组元素newElements[length]设置为元素e，再设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。</li>
</ul>
<h3 id="addIfAbsent方法"><a href="#addIfAbsent方法" class="headerlink" title="addIfAbsent方法"></a>addIfAbsent方法</h3><p>该函数用于添加元素(如果数组中不存在，则添加；否则，不添加，直接返回)，可以保证多线程环境下不会重复添加元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123; <span class="comment">// 快照不等于当前数组，对数组进行了修改</span></span><br><span class="line">            <span class="comment">// Optimize for lost race to another addXXX operation</span></span><br><span class="line">            <span class="comment">// 取较小者</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++) <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) <span class="comment">// 当前数组的元素与快照的元素不相等并且e与当前元素相等</span></span><br><span class="line">                    <span class="comment">// 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在</span></span><br><span class="line">                    <span class="comment">// 返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>) <span class="comment">// 在当前数组中找到e元素</span></span><br><span class="line">                    <span class="comment">// 返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对数组len索引的元素赋值为e</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的流程如下:</p>
<p>① 获取锁，获取当前数组为current，current长度为len，判断数组之前的快照snapshot是否等于当前数组current，若不相等，则进入步骤②；否则，进入步骤④</p>
<p>② 不相等，表示在snapshot与current之间，对数组进行了修改(如进行了add、set、remove等操作)，获取长度(snapshot与current之间的较小者)，对current进行遍历操作，若遍历过程发现snapshot与current的元素不相等并且current的元素与指定元素相等(可能进行了set操作)，进入步骤⑤，否则，进入步骤③</p>
<p>③ 在当前数组中索引指定元素，若能够找到，进入步骤⑤，否则，进入步骤④</p>
<p>④ 复制当前数组current为newElements，长度为len+1，此时newElements[len]为null。再设置newElements[len]为指定元素e，再设置数组，进入步骤⑤</p>
<p>⑤ 释放锁，返回。</p>
<h3 id="set函数"><a href="#set函数" class="headerlink" title="set函数"></a>set函数</h3><p>此函数用于用指定的元素替代此列表指定位置上的元素，也是基于数组的复制来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取index索引的元素</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123; <span class="comment">// 旧值等于element</span></span><br><span class="line">            <span class="comment">// 数组长度</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 复制数组</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 重新赋值index索引的值</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><p>此函数用于移除此列表指定位置上的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 获取旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="comment">// 需要移动的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>) <span class="comment">// 移动个数为0</span></span><br><span class="line">            <span class="comment">// 复制后设置数组</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 移动个数不为0</span></span><br><span class="line">            <span class="comment">// 新生数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 复制index索引之前的元素</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 复制index索引之后的元素</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                                numMoved);</span><br><span class="line">            <span class="comment">// 设置索引</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理流程如下</p>
<p>① 获取锁，获取数组elements，数组长度为length，获取索引的值elements[index]，计算需要移动的元素个数(length - index - 1),若个数为0，则表示移除的是数组的最后一个元素，复制elements数组，复制长度为length-1，然后设置数组，进入步骤③；否则，进入步骤②</p>
<p>② 先复制index索引前的元素，再复制index索引后的元素，然后设置数组。</p>
<p>③ 释放锁，返回旧值。</p>
<h1 id="CopyOnWriteArrayList示例"><a href="#CopyOnWriteArrayList示例" class="headerlink" title="CopyOnWriteArrayList示例"></a>CopyOnWriteArrayList示例</h1><p>下面通过一个示例来了解CopyOnWriteArrayList的使用: 在程序中，有一个PutThread线程会每隔50ms就向CopyOnWriteArrayList中添加一个元素，并且两次使用了迭代器，迭代器输出的内容都是生成迭代器时，CopyOnWriteArrayList的Object数组的快照的内容，在迭代的过程中，往CopyOnWriteArrayList中添加元素也不会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Integer&gt; cowal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(CopyOnWriteArrayList&lt;Integer&gt; cowal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cowal = cowal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt; <span class="number">110</span>; i++) &#123;</span><br><span class="line">                cowal.add(i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; cowal = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cowal.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        PutThread p1 = <span class="keyword">new</span> PutThread(cowal);</span><br><span class="line">        p1.start();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = cowal.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        iterator = cowal.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果(某一次)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 100 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 100 101 102 103 </span><br></pre></td></tr></table></figure>
<h1 id="更深入理解"><a href="#更深入理解" class="headerlink" title="更深入理解"></a>更深入理解</h1><h2 id="CopyOnWriteArrayList的缺陷和使用场景"><a href="#CopyOnWriteArrayList的缺陷和使用场景" class="headerlink" title="CopyOnWriteArrayList的缺陷和使用场景"></a>CopyOnWriteArrayList的缺陷和使用场景</h2><p>CopyOnWriteArrayList 有几个缺点：</p>
<ul>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；</li>
</ul>
<p><strong>CopyOnWriteArrayList 合适读多写少的场景，不过这类慎用</strong></p>
<p>因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</p>
<h2 id="CopyOnWriteArrayList为什么并发安全且性能比Vector好"><a href="#CopyOnWriteArrayList为什么并发安全且性能比Vector好" class="headerlink" title="CopyOnWriteArrayList为什么并发安全且性能比Vector好?"></a>CopyOnWriteArrayList为什么并发安全且性能比Vector好?</h2><p>Vector对单独的add，remove等方法都是在方法上加了synchronized; 并且如果一个线程A调用size时，另一个线程B 执行了remove，然后size的值就不是最新的，然后线程A调用remove就会越界(这时就需要再加一个Synchronized)。这样就导致有了双重锁，效率大大降低，何必呢。于是vector废弃了，要用就用CopyOnWriteArrayList 吧。</p>
]]></content>
      <categories>
        <category>容器</category>
        <category>并发容器</category>
      </categories>
      <tags>
        <tag>CopyOnWriteArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池之FutureTask</title>
    <url>/posts/b944ce89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>Future 表示了一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对其结果的访问。在并发包中许多异步任务类都继承自Future，其中最典型的就是 FutureTask。</p>
</blockquote>
<a id="more"></a>

<h1 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h1><p>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由CAS来保证。</p>
<h1 id="FutureTask类关系"><a href="#FutureTask类关系" class="headerlink" title="FutureTask类关系"></a>FutureTask类关系</h1><p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-futuretask-1.png" alt="img"></p>
<p>可以看到,FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口，所以FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。</p>
<h1 id="FutureTask源码解析"><a href="#FutureTask源码解析" class="headerlink" title="FutureTask源码解析"></a>FutureTask源码解析</h1><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>Callable是个泛型接口，泛型V就是要call()方法返回的类型。对比Runnable接口，Runnable不会返回数据也不能抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h2><p>Future接口代表异步计算的结果，通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。Future接口的定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cancel()</code>:cancel()方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。如果任务还没有被执行，则会返回true并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true，若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。</li>
<li><code>isCanceled()</code>:判断任务是否被取消，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。</li>
<li><code>isDone()</code>:判断任务是否已经完成，如果完成则返回true，否则返回false。需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true。</li>
<li><code>get()</code>:获取任务执行结果，如果任务还没完成则会阻塞等待直到任务执行完成。如果任务被取消则会抛出CancellationException异常，如果任务执行过程发生异常则会抛出ExecutionException异常，如果阻塞等待过程中被中断则会抛出InterruptedException异常。</li>
<li><code>get(long timeout,Timeunit unit)</code>:带超时时间的get()版本，如果阻塞等待过程中超时则会抛出TimeoutException异常。</li>
</ul>
<h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部持有的callable任务，运行完毕后置空</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从get()中返回的结果或抛出的异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行callable的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Treiber栈保存等待线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>其中需要注意的是state是volatile类型的，也就是说只要有任何一个线程修改了这个变量，那么其他所有的线程都会知道最新的值。7种状态具体表示：</p>
<ul>
<li><code>NEW</code>:表示是个新的任务或者还没被执行完的任务。这是初始状态。</li>
<li><code>COMPLETING</code>:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。</li>
<li><code>NORMAL</code>:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。</li>
<li><code>EXCEPTIONAL</code>:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。</li>
<li><code>CANCELLED</code>:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。</li>
<li><code>INTERRUPTING</code>: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。</li>
<li><code>INTERRUPTED</code>:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。 有一点需要注意的是，所有值大于COMPLETING的状态都表示任务已经执行完成(任务正常执行完成，任务执行异常或者任务被取消)。</li>
</ul>
<p>各个状态之间的可能转换关系如下图所示:</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-futuretask-2.png" alt="img"></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="FutureTask-Callable-callable"><a href="#FutureTask-Callable-callable" class="headerlink" title="FutureTask(Callable callable)"></a>FutureTask(Callable<V> callable)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数会把传入的Callable变量保存在this.callable字段中，该字段定义为<code>private Callable&lt;V&gt; callable</code>;用来保存底层的调用，在被执行完成以后会指向null,接着会初始化state字段为NEW。</p>
<h3 id="FutureTask-Runnable-runnable-V-result"><a href="#FutureTask-Runnable-runnable-V-result" class="headerlink" title="FutureTask(Runnable runnable, V result)"></a>FutureTask(Runnable runnable, V result)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。这种情况下如果不需要返回值的话可以传入一个null。</p>
<p>顺带看下Executors.callable()这个方法，这个方法的功能是把Runnable转换成Callable，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里采用的是适配器模式，调用<code>RunnableAdapter&lt;T&gt;(task, result)</code>方法来适配，实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个适配器很简单，就是简单的实现了Callable接口，在call()实现中调用Runnable.run()方法，然后把传入的result作为任务的结果返回。</p>
<p>在new了一个FutureTask对象之后，接下来就是在另一个线程中执行这个Task,无论是通过直接new一个Thread还是通过线程池，执行的都是run()方法，接下来就看看run()方法的实现。</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建任务，CAS替换runner为当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);<span class="comment">//设置执行结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);<span class="comment">//处理中断逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>运行任务，如果任务状态为NEW状态，则利用CAS修改为当前线程。执行完毕调用set(result)方法设置执行结果。set(result)源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();<span class="comment">//执行完毕，唤醒等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先利用cas修改state状态为COMPLETING，设置返回结果，然后使用 lazySet(UNSAFE.putOrderedInt)的方式设置state状态为NORMAL。结果设置完毕后，调用finishCompletion()方法唤醒等待线程，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;<span class="comment">//移除等待线程</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋遍历等待线程</span></span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);<span class="comment">//唤醒等待线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务完成后调用函数，自定义扩展</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>回到run方法，如果在 run 期间被中断，此时需要调用handlePossibleCancellationInterrupt方法来处理中断逻辑，确保任何中断(例如cancel(true))只停留在当前run或runAndReset的任务中，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在中断者中断线程之前可能会延迟，所以我们只需要让出CPU时间片自旋等待</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：FutureTask 通过get()方法获取任务执行结果。如果任务处于未完成的状态(<code>state &lt;= COMPLETING</code>)，就调用awaitDone方法(后面单独讲解)等待任务完成。任务完成后，通过report方法获取执行结果或抛出执行期间的异常。report源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回执行结果或抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="awaitDone-boolean-timed-long-nanos"><a href="#awaitDone-boolean-timed-long-nanos" class="headerlink" title="awaitDone(boolean timed, long nanos)"></a>awaitDone(boolean timed, long nanos)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;<span class="comment">//获取并清除中断状态</span></span><br><span class="line">            removeWaiter(q);<span class="comment">//移除等待WaitNode</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;<span class="comment">//置空等待节点的线程</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//CAS修改waiter</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);<span class="comment">//超时，移除等待节点</span></span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);<span class="comment">//阻塞当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);<span class="comment">//阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：awaitDone用于等待任务完成，或任务因为中断或超时而终止。返回任务的完成状态。函数执行逻辑如下：</p>
<p>如果线程被中断，首先清除中断状态，调用removeWaiter移除等待节点，然后抛出InterruptedException。removeWaiter源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;<span class="comment">//首先置空线程</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="comment">//依次遍历查找</span></span><br><span class="line">            <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,q, s)) <span class="comment">//cas替换</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果当前状态为结束状态(state&gt;COMPLETING),则根据需要置空等待节点的线程，并返回 Future 状态；</li>
<li>如果当前状态为正在完成(COMPLETING)，说明此时 Future 还不能做出超时动作，为任务让出CPU执行时间片；</li>
<li>如果state为NEW，先新建一个WaitNode，然后CAS修改当前waiters；</li>
<li>如果等待超时，则调用removeWaiter移除等待节点，返回任务状态；如果设置了超时时间但是尚未超时，则park阻塞当前线程；</li>
<li>其他情况直接阻塞当前线程。</li>
</ul>
<h3 id="cancel-boolean-mayInterruptIfRunning"><a href="#cancel-boolean-mayInterruptIfRunning" class="headerlink" title="cancel(boolean mayInterruptIfRunning)"></a>cancel(boolean mayInterruptIfRunning)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;<span class="comment">//可以在运行时中断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();<span class="comment">//移除并唤醒所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：尝试取消任务。如果任务已经完成或已经被取消，此操作会失败。</p>
<ul>
<li>如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED。</li>
<li>如果当前状态不为NEW，则根据参数mayInterruptIfRunning决定是否在任务运行中也可以中断。中断操作完成后，调用finishCompletion移除并唤醒所有等待线程。</li>
</ul>
<h1 id="FutureTask示例"><a href="#FutureTask示例" class="headerlink" title="FutureTask示例"></a>FutureTask示例</h1><p><strong>常用使用方式：</strong></p>
<ul>
<li>第一种方式:Future + ExecutorService</li>
<li>第二种方式: FutureTask + ExecutorService</li>
<li>第三种方式:FutureTask + Thread</li>
</ul>
<h2 id="Future使用示例"><a href="#Future使用示例" class="headerlink" title="Future使用示例"></a>Future使用示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">          Future future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  Long start = System.currentTimeMillis();</span><br><span class="line">                  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                      Long current = System.currentTimeMillis();</span><br><span class="line">                     <span class="keyword">if</span> ((current - start) &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Integer result = (Integer)future.get();</span><br><span class="line">             System.out.println(result);</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FutureTask-Thread例子"><a href="#FutureTask-Thread例子" class="headerlink" title="FutureTask+Thread例子"></a>FutureTask+Thread例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一种方式:Future + ExecutorService</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * ExecutorService service = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Future&lt;Integer&gt; future = service.submit(task1);</span></span><br><span class="line"><span class="comment">         * service.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二种方式: FutureTask + ExecutorService</span></span><br><span class="line"><span class="comment">         * ExecutorService executor = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">         * executor.submit(futureTask);</span></span><br><span class="line"><span class="comment">         * executor.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第三种方式:FutureTask + Thread</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2. 新建FutureTask,需要一个实现了Callable接口的类的实例作为构造函数参数</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Task());</span><br><span class="line">        <span class="comment">// 3. 新建Thread对象并启动</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.setName(<span class="string">&quot;Task thread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4. 调用isDone()判断任务是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(!futureTask.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task is not done&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5. 调用get()方法获取任务结果,如果任务没有执行完成则阻塞等待</span></span><br><span class="line">            result = futureTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;result is &quot;</span> + result);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. 继承Callable接口,实现call()方法,泛型参数为要返回的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span>  <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;++i) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>FutureTask</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池之ScheduledThreadPoolExecutor</title>
    <url>/posts/f11dd68e/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>在很多业务场景中，我们可能需要周期性的运行某项任务来获取结果，比如周期数据统计，定时发送数据等。在并发包出现之前，Java 早在1.3就提供了 Timer 类(只需要了解，目前已渐渐被 ScheduledThreadPoolExecutor 代替)来适应这些业务场景。随着业务量的不断增大，我们可能需要多个工作线程运行任务来尽可能的增加产品性能，或者是需要更高的灵活性来控制和监控这些周期业务。这些都是 ScheduledThreadPoolExecutor 诞生的必然性</p>
</blockquote>
<a id="more"></a>

<h1 id="ScheduledThreadPoolExecutor简介"><a href="#ScheduledThreadPoolExecutor简介" class="headerlink" title="ScheduledThreadPoolExecutor简介"></a>ScheduledThreadPoolExecutor简介</h1><p>ScheduledThreadPoolExecutor继承自 ThreadPoolExecutor，为任务提供延迟或周期执行，属于线程池的一种。和 ThreadPoolExecutor 相比，它还具有以下几种特性:</p>
<ul>
<li>使用专门的任务类型—ScheduledFutureTask 来执行周期任务，也可以接收不需要时间调度的任务(这些任务通过 ExecutorService 来执行)。</li>
<li>使用专门的存储队列—DelayedWorkQueue 来存储任务，DelayedWorkQueue 是无界延迟队列DelayQueue 的一种。相比ThreadPoolExecutor也简化了执行机制(delayedExecute方法，后面单独分析)。</li>
<li>支持可选的run-after-shutdown参数，在池被关闭(shutdown)之后支持可选的逻辑来决定是否继续运行周期或延迟任务。并且当任务(重新)提交操作与 shutdown 操作重叠时，复查逻辑也不相同。</li>
</ul>
<h1 id="ScheduledThreadPoolExecutor数据结构"><a href="#ScheduledThreadPoolExecutor数据结构" class="headerlink" title="ScheduledThreadPoolExecutor数据结构"></a>ScheduledThreadPoolExecutor数据结构</h1><p><img src="https://www.pdai.tech/_images/thread/java-thread-x-stpe-1.png" alt="img"></p>
<p>ScheduledThreadPoolExecutor继承自 <code>ThreadPoolExecutor</code></p>
<p>ScheduledThreadPoolExecutor 内部构造了两个内部类 <code>ScheduledFutureTask</code> 和 <code>DelayedWorkQueue</code>:</p>
<ul>
<li><code>ScheduledFutureTask</code>: 继承了FutureTask，说明是一个异步运算任务；最上层分别实现了Runnable、Future、Delayed接口，说明它是一个可以延迟执行的异步运算任务。</li>
<li><code>DelayedWorkQueue</code>: 这是 ScheduledThreadPoolExecutor 为存储周期或延迟任务专门定义的一个延迟队列，继承了 AbstractQueue，为了契合 ThreadPoolExecutor 也实现了 BlockingQueue 接口。它内部只允许存储 RunnableScheduledFuture 类型的任务。与 DelayQueue 的不同之处就是它只允许存放 RunnableScheduledFuture 对象，并且自己实现了二叉堆(DelayQueue 是利用了 PriorityQueue 的二叉堆结构)。</li>
</ul>
<h1 id="ScheduledThreadPoolExecutor源码解析"><a href="#ScheduledThreadPoolExecutor源码解析" class="headerlink" title="ScheduledThreadPoolExecutor源码解析"></a>ScheduledThreadPoolExecutor源码解析</h1><blockquote>
<p>以下源码的解析是基于已经理解了FutureTask。</p>
</blockquote>
<h2 id="内部类ScheduledFutureTask"><a href="#内部类ScheduledFutureTask" class="headerlink" title="内部类ScheduledFutureTask"></a>内部类ScheduledFutureTask</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为相同延时任务提供的顺序编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务可以执行的时间，纳秒级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重复任务的执行周期时间，纳秒级。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新入队的任务</span></span><br><span class="line">RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟队列的索引，以支持更快的取消操作</span></span><br><span class="line"><span class="keyword">int</span> heapIndex;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sequenceNumber</code>: 当两个任务有相同的延迟时间时，按照 FIFO 的顺序入队。sequenceNumber 就是为相同延时任务提供的顺序编号。</li>
<li><code>time</code>: 任务可以执行时的时间，纳秒级，通过triggerTime方法计算得出。</li>
<li><code>period</code>: 任务的执行周期时间，纳秒级。正数表示固定速率执行(为scheduleAtFixedRate提供服务)，负数表示固定延迟执行(为scheduleWithFixedDelay提供服务)，0表示不重复任务。</li>
<li><code>outerTask</code>: 重新入队的任务，通过reExecutePeriodic方法入队重新排序。</li>
</ul>
<h3 id="核心方法run"><a href="#核心方法run" class="headerlink" title="核心方法run()"></a>核心方法run()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();<span class="comment">//是否为周期任务</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))<span class="comment">//当前状态是否可以执行</span></span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        <span class="comment">//不是周期任务，直接执行</span></span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        setNextRunTime();<span class="comment">//设置下一次运行时间</span></span><br><span class="line">        reExecutePeriodic(outerTask);<span class="comment">//重排序一个周期任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: ScheduledFutureTask 的run方法重写了 FutureTask 的版本，以便执行周期任务时重置/重排序任务。任务的执行通过父类 FutureTask 的run实现。内部有两个针对周期任务的方法:</p>
<ul>
<li>setNextRunTime(): 用来设置下一次运行的时间，源码如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置下一次执行任务的时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)  <span class="comment">//固定速率执行，scheduleAtFixedRate</span></span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);  <span class="comment">//固定延迟执行，scheduleWithFixedDelay</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算固定延迟任务的执行时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now() +</span><br><span class="line">        ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>reExecutePeriodic(): 周期任务重新入队等待下一次执行，源码如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重排序一个周期任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;<span class="comment">//池关闭后可继续执行</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);<span class="comment">//任务入列</span></span><br><span class="line">        <span class="comment">//重新检查run-after-shutdown参数，如果不能继续运行就移除队列任务，并取消任务的执行</span></span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();<span class="comment">//启动一个新的线程等待任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>reExecutePeriodic与delayedExecute的执行策略一致，只不过reExecutePeriodic不会执行拒绝策略而是直接丢掉任务。</p>
<h3 id="cancel方法"><a href="#cancel方法" class="headerlink" title="cancel方法"></a>cancel方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> cancelled = <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">    <span class="keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="number">0</span>)</span><br><span class="line">        remove(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cancelled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ScheduledFutureTask.cancel本质上由其父类 FutureTask.cancel 实现。取消任务成功后会根据removeOnCancel参数决定是否从队列中移除此任务。</p>
<h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭后继续执行已经存在的周期任务 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> continueExistingPeriodicTasksAfterShutdown;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭后继续执行已经存在的延时任务 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executeExistingDelayedTasksAfterShutdown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消任务后移除 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> removeOnCancel = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为相同延时的任务提供的顺序编号，保证任务之间的FIFO顺序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>continueExistingPeriodicTasksAfterShutdown</code>和<code>executeExistingDelayedTasksAfterShutdown</code>是 ScheduledThreadPoolExecutor 定义的 <code>run-after-shutdown</code> 参数，用来控制池关闭之后的任务执行逻辑。</li>
<li><code>removeOnCancel</code>用来控制任务取消后是否从队列中移除。当一个已经提交的周期或延迟任务在运行之前被取消，那么它之后将不会运行。默认配置下，这种已经取消的任务在届期之前不会被移除。 通过这种机制，可以方便检查和监控线程池状态，但也可能导致已经取消的任务无限滞留。为了避免这种情况的发生，我们可以通过<code>setRemoveOnCancelPolicy</code>方法设置移除策略，把参数<code>removeOnCancel</code>设为true可以在任务取消后立即从队列中移除。</li>
<li><code>sequencer</code>是为相同延时的任务提供的顺序编号，保证任务之间的 FIFO 顺序。与 ScheduledFutureTask 内部的sequenceNumber参数作用一致。</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>首先看下构造函数，ScheduledThreadPoolExecutor 内部有四个构造函数，这里我们只看这个最大构造灵活度的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>构造函数都是通过super调用了ThreadPoolExecutor的构造，并且使用特定等待队列DelayedWorkQueue。</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> delay,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable, triggerTime(delay, unit)));<span class="comment">//构造ScheduledFutureTask任务</span></span><br><span class="line">    delayedExecute(t);<span class="comment">//任务执行主方法</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: schedule主要用于执行一次性(延迟)任务。函数执行逻辑分两步:</p>
<ul>
<li><code>封装 Callable/Runnable</code>: 首先通过triggerTime计算任务的延迟执行时间，然后通过 ScheduledFutureTask 的构造函数把 Runnable/Callable 任务构造为ScheduledThreadPoolExecutor可以执行的任务类型，最后调用decorateTask方法执行用户自定义的逻辑；decorateTask是一个用户可自定义扩展的方法，默认实现下直接返回封装的RunnableScheduledFuture任务，源码如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>执行任务</code>: 通过delayedExecute实现。下面我们来详细分析。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);<span class="comment">//池已关闭，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);<span class="comment">//任务入队</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<span class="comment">//判断run-after-shutdown参数</span></span><br><span class="line">            remove(task))<span class="comment">//移除任务</span></span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();<span class="comment">//启动一个新的线程等待任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: delayedExecute是执行任务的主方法，方法执行逻辑如下:</p>
<ul>
<li>如果池已关闭(ctl &gt;= SHUTDOWN)，执行任务拒绝策略；</li>
<li>池正在运行，首先把任务入队排序；然后重新检查池的关闭状态，执行如下逻辑:</li>
</ul>
<p><code>A</code>: 如果池正在运行，或者 run-after-shutdown 参数值为true，则调用父类方法ensurePrestart启动一个新的线程等待执行任务。ensurePrestart源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ensurePrestart是父类 ThreadPoolExecutor 的方法，用于启动一个新的工作线程等待执行任务，即使corePoolSize为0也会安排一个新线程。</p>
<p><code>B</code>: 如果池已经关闭，并且 run-after-shutdown 参数值为false，则执行父类(ThreadPoolExecutor)方法remove移除队列中的指定任务，成功移除后调用ScheduledFutureTask.cancel取消任务</p>
<h3 id="scheduleAtFixedRate-和-scheduleWithFixedDelay"><a href="#scheduleAtFixedRate-和-scheduleWithFixedDelay" class="headerlink" title="scheduleAtFixedRate 和 scheduleWithFixedDelay"></a>scheduleAtFixedRate 和 scheduleWithFixedDelay</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个周期执行的任务，第一次执行延期时间为initialDelay，</span></span><br><span class="line"><span class="comment"> * 之后每隔period执行一次，不等待第一次执行完成就开始计时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//构建RunnableScheduledFuture任务类型</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),<span class="comment">//计算任务的延迟时间</span></span><br><span class="line">                                      unit.toNanos(period));<span class="comment">//计算任务的执行周期</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<span class="comment">//执行用户自定义逻辑</span></span><br><span class="line">    sft.outerTask = t;<span class="comment">//赋值给outerTask，准备重新入队等待下一次执行</span></span><br><span class="line">    delayedExecute(t);<span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个周期执行的任务，第一次执行延期时间为initialDelay，</span></span><br><span class="line"><span class="comment"> * 在第一次执行完之后延迟delay后开始下一次执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//构建RunnableScheduledFuture任务类型</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),<span class="comment">//计算任务的延迟时间</span></span><br><span class="line">                                      unit.toNanos(-delay));<span class="comment">//计算任务的执行周期</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);<span class="comment">//执行用户自定义逻辑</span></span><br><span class="line">    sft.outerTask = t;<span class="comment">//赋值给outerTask，准备重新入队等待下一次执行</span></span><br><span class="line">    delayedExecute(t);<span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: scheduleAtFixedRate和scheduleWithFixedDelay方法的逻辑与schedule类似。</p>
<p><strong>注意scheduleAtFixedRate和scheduleWithFixedDelay的区别</strong>: 乍一看两个方法一模一样，其实，在unit.toNanos这一行代码中还是有区别的。没错，scheduleAtFixedRate传的是正值，而scheduleWithFixedDelay传的则是负值，这个值就是 ScheduledFutureTask 的period属性。</p>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title=":shutdown()"></a>:shutdown()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消并清除由于关闭策略不应该运行的所有任务</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();</span><br><span class="line">    <span class="comment">//获取run-after-shutdown参数</span></span><br><span class="line">    <span class="keyword">boolean</span> keepDelayed =</span><br><span class="line">        getExecuteExistingDelayedTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="keyword">boolean</span> keepPeriodic =</span><br><span class="line">        getContinueExistingPeriodicTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;<span class="comment">//池关闭后不保留任务</span></span><br><span class="line">        <span class="comment">//依次取消任务</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="keyword">false</span>);</span><br><span class="line">        q.clear();<span class="comment">//清除等待队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//池关闭后保留任务</span></span><br><span class="line">        <span class="comment">// Traverse snapshot to avoid iterator exceptions</span></span><br><span class="line">        <span class="comment">//遍历快照以避免迭代器异常</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t =</span><br><span class="line">                    (RunnableScheduledFuture&lt;?&gt;)e;</span><br><span class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||</span><br><span class="line">                    t.isCancelled()) &#123; <span class="comment">// also remove if already cancelled</span></span><br><span class="line">                    <span class="comment">//如果任务已经取消，移除队列中的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                        t.cancel(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); <span class="comment">//终止线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 池关闭方法调用了父类ThreadPoolExecutor的shutdown，具体分析见 ThreadPoolExecutor 篇。这里主要介绍以下在shutdown方法中调用的关闭钩子onShutdown方法，它的主要作用是在关闭线程池后取消并清除由于关闭策略不应该运行的所有任务，这里主要是根据 run-after-shutdown 参数(continueExistingPeriodicTasksAfterShutdown和executeExistingDelayedTasksAfterShutdown)来决定线程池关闭后是否关闭已经存在的任务。</p>
<h1 id="再深入理解"><a href="#再深入理解" class="headerlink" title="再深入理解"></a>再深入理解</h1><p><strong>为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor？</strong></p>
<p>例如: 由于 ScheduledThreadPoolExecutor 是一个固定核心线程数大小的线程池，并且使用了一个无界队列，所以调整maximumPoolSize对其没有任何影响(所以 ScheduledThreadPoolExecutor 没有提供可以调整最大线程数的构造函数，默认最大线程数固定为Integer.MAX_VALUE)。此外，设置corePoolSize为0或者设置核心线程空闲后清除(allowCoreThreadTimeOut)同样也不是一个好的策略，因为一旦周期任务到达某一次运行周期时，可能导致线程池内没有线程去处理这些任务。</p>
<p>Executors 提供了哪几种方法来构造 ScheduledThreadPoolExecutor？</p>
<ul>
<li>newScheduledThreadPool: 可指定核心线程数的线程池。</li>
<li>newSingleThreadScheduledExecutor: 只有一个工作线程的线程池。如果内部工作线程由于执行周期任务异常而被终止，则会新建一个线程替代它的位置。</li>
</ul>
<p>注意: newScheduledThreadPool(1, threadFactory) 不等价于newSingleThreadScheduledExecutor。newSingleThreadScheduledExecutor创建的线程池保证内部只有一个线程执行任务，并且线程数不可扩展；而通过newScheduledThreadPool(1, threadFactory)创建的线程池可以通过setCorePoolSize方法来修改核心线程数。</p>
]]></content>
      <categories>
        <category>并发</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>ScheduledThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池之ThreadPoolExecutor</title>
    <url>/posts/a1e19601/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p><strong>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类</strong>，里面提供了四个构造方法，其中参数最长的构造方法规定了6个参数；其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）</p>
</blockquote>
<a id="more"></a>

<h1 id="ThreadPoolExecutor例子"><a href="#ThreadPoolExecutor例子" class="headerlink" title="ThreadPoolExecutor例子"></a>ThreadPoolExecutor例子</h1><ul>
<li>WorkerThread</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command=s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Start. Command = &quot;</span>+command);</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; End.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SimpleThreadPool</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadPool</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Runnable worker = <span class="keyword">new</span> WorkerThread(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">          &#125;</span><br><span class="line">        executor.shutdown(); <span class="comment">// This will make the executor accept no new threads and finish all existing threads in the queue</span></span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123; <span class="comment">// Wait until all threads are finish,and also you can use &quot;executor.awaitTermination();&quot; to wait</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>程序中我们创建了固定大小为五个工作线程的线程池。然后分配给线程池十个工作，因为线程池大小为五，它将启动五个工作线程先处理五个工作，其他的工作则处于等待状态，一旦有工作完成，空闲下来工作线程就会捡取等待队列里的其他工作进行执行。</p>
<p>这里是以上程序的输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pool-1-thread-2 Start. Command = 1</span><br><span class="line">pool-1-thread-4 Start. Command = 3</span><br><span class="line">pool-1-thread-1 Start. Command = 0</span><br><span class="line">pool-1-thread-3 Start. Command = 2</span><br><span class="line">pool-1-thread-5 Start. Command = 4</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">pool-1-thread-5 End.</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">pool-1-thread-3 End.</span><br><span class="line">pool-1-thread-3 Start. Command = 8</span><br><span class="line">pool-1-thread-2 End.</span><br><span class="line">pool-1-thread-2 Start. Command = 9</span><br><span class="line">pool-1-thread-1 Start. Command = 7</span><br><span class="line">pool-1-thread-5 Start. Command = 6</span><br><span class="line">pool-1-thread-4 Start. Command = 5</span><br><span class="line">pool-1-thread-2 End.</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">pool-1-thread-3 End.</span><br><span class="line">pool-1-thread-5 End.</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure>
<p>输出表明线程池中至始至终只有五个名为 “pool-1-thread-1” 到 “pool-1-thread-5” 的五个线程，这五个线程不随着工作的完成而消亡，会一直存在，并负责执行分配给线程池的任务，直到线程池消亡。</p>
<p>Executors 类提供了使用了 ThreadPoolExecutor 的简单的 ExecutorService 实现，但是 ThreadPoolExecutor 提供的功能远不止于此。我们可以在创建 ThreadPoolExecutor 实例时指定活动线程的数量，我们也可以限制线程池的大小并且创建我们自己的 RejectedExecutionHandler 实现来处理不能适应工作队列的工作。</p>
<p>这里是我们自定义的 RejectedExecutionHandler 接口的实现。</p>
<ul>
<li>RejectedExecutionHandlerImpl.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectedExecutionHandlerImpl</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        System.out.println(r.toString() + <span class="string">&quot; is rejected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor 提供了一些方法，我们可以使用这些方法来查询 executor 的当前状态，线程池大小，活动线程数量以及任务数量。因此我是用来一个监控线程在特定的时间间隔内打印 executor 信息。</p>
<ul>
<li>MyMonitorThread.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMonitorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seconds;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> run=<span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMonitorThread</span><span class="params">(ThreadPoolExecutor executor, <span class="keyword">int</span> delay)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.seconds=delay;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                    String.format(<span class="string">&quot;[monitor] [%d/%d] Active: %d, Completed: %d, Task: %d, isShutdown: %s, isTerminated: %s&quot;</span>,</span><br><span class="line">                        <span class="keyword">this</span>.executor.getPoolSize(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getCorePoolSize(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getActiveCount(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getCompletedTaskCount(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.getTaskCount(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.isShutdown(),</span><br><span class="line">                        <span class="keyword">this</span>.executor.isTerminated()));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(seconds*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这里是使用 ThreadPoolExecutor 的线程池实现例子。</p>
<ul>
<li>WorkerPool.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerPool</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//RejectedExecutionHandler implementation</span></span><br><span class="line">        RejectedExecutionHandlerImpl rejectionHandler = <span class="keyword">new</span> RejectedExecutionHandlerImpl();</span><br><span class="line">        <span class="comment">//Get the ThreadFactory implementation to use</span></span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        <span class="comment">//creating the ThreadPoolExecutor</span></span><br><span class="line">        ThreadPoolExecutor executorPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>), threadFactory, rejectionHandler);</span><br><span class="line">        <span class="comment">//start the monitoring thread</span></span><br><span class="line">        MyMonitorThread monitor = <span class="keyword">new</span> MyMonitorThread(executorPool, <span class="number">3</span>);</span><br><span class="line">        Thread monitorThread = <span class="keyword">new</span> Thread(monitor);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">        <span class="comment">//submit work to the thread pool</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            executorPool.execute(<span class="keyword">new</span> WorkerThread(<span class="string">&quot;cmd&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">        <span class="comment">//shut down the pool</span></span><br><span class="line">        executorPool.shutdown();</span><br><span class="line">        <span class="comment">//shut down the monitor thread</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        monitor.shutdown();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>注意在初始化 ThreadPoolExecutor 时，我们保持初始池大小为 2，最大池大小为 4 而工作队列大小为 2。因此如果已经有四个正在执行的任务而此时分配来更多任务的话，工作队列将仅仅保留他们(新任务)中的两个，其他的将会被 RejectedExecutionHandlerImpl 处理。</p>
<p>上面程序的输出可以证实以上观点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pool-1-thread-1 Start. Command = cmd0</span><br><span class="line">pool-1-thread-4 Start. Command = cmd5</span><br><span class="line">cmd6 is rejected</span><br><span class="line">pool-1-thread-3 Start. Command = cmd4</span><br><span class="line">pool-1-thread-2 Start. Command = cmd1</span><br><span class="line">cmd7 is rejected</span><br><span class="line">cmd8 is rejected</span><br><span class="line">cmd9 is rejected</span><br><span class="line">[monitor] [0/2] Active: 4, Completed: 0, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [4/2] Active: 4, Completed: 0, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">pool-1-thread-2 End.</span><br><span class="line">pool-1-thread-3 End.</span><br><span class="line">pool-1-thread-1 Start. Command = cmd3</span><br><span class="line">pool-1-thread-4 Start. Command = cmd2</span><br><span class="line">[monitor] [4/2] Active: 2, Completed: 4, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [4/2] Active: 2, Completed: 4, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">[monitor] [4/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">false</span>, isTerminated: <span class="literal">false</span></span><br><span class="line">[monitor] [0/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">true</span>, isTerminated: <span class="literal">true</span></span><br><span class="line">[monitor] [0/2] Active: 0, Completed: 6, Task: 6, isShutdown: <span class="literal">true</span>, isTerminated: <span class="literal">true</span>   </span><br></pre></td></tr></table></figure>
<p>注意 executor 的活动任务、完成任务以及所有完成任务，这些数量上的变化。我们可以调用 shutdown() 方法来结束所有提交的任务并终止线程池。</p>
<h2 id="ThreadPoolExecutor使用详解"><a href="#ThreadPoolExecutor使用详解" class="headerlink" title="ThreadPoolExecutor使用详解"></a>ThreadPoolExecutor使用详解</h2><p>其实java线程池的实现原理很简单，说白了就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-executors-1.png" alt="img"></p>
<h1 id="ThreadPoolExecutor源码详解"><a href="#ThreadPoolExecutor源码详解" class="headerlink" title="ThreadPoolExecutor源码详解"></a>ThreadPoolExecutor源码详解</h1><h2 id="几个关键属性"><a href="#几个关键属性" class="headerlink" title="几个关键属性"></a>几个关键属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个属性是用来存放 当前运行的worker数量以及线程池状态的</span></span><br><span class="line"><span class="comment">//int是32位的，这里把int的高3位拿来充当线程池状态的标志位,后29位拿来充当当前运行worker的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//存放任务的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">//worker的集合,用set来存放</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//历史达到的worker数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//当队列满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//超出coreSize的worker的生存时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//常驻worker的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//最大worker的数量,一般当workQueue满了才会用到这个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize; </span><br></pre></td></tr></table></figure>
<h2 id="内部状态"><a href="#内部状态" class="headerlink" title="内部状态"></a>内部状态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<p>其中AtomicInteger变量ctl的功能非常强大: 利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态:</p>
<ul>
<li>RUNNING: -1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</li>
<li>SHUTDOWN:  0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li>
<li>STOP :  1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li>
<li>TIDYING :  2 &lt;&lt; COUNT_BITS，即高3位为010, 所有的任务都已经终止；</li>
<li>TERMINATED:  3 &lt;&lt; COUNT_BITS，即高3位为011, terminated()方法已经执行完成</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-executors-2.png" alt="img"></p>
<h2 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h2><blockquote>
<p>execute –&gt; addWorker –&gt;runworker (getTask)</p>
</blockquote>
<p>线程池的工作线程通过Woker类实现，在ReentrantLock锁的保证下，把Woker实例插入到HashSet后，并启动Woker中的线程。 从Woker类的构造方法实现可以发现: 线程工厂在创建线程thread时，将Woker实例本身this作为参数传入，当执行start方法启动线程thread时，本质是执行了Worker的runWorker方法。 firstTask执行完成之后，通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；</p>
<h3 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h3><p>ThreadPoolExecutor.execute(task)实现了Executor.execute(task)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  </span><br><span class="line">    <span class="comment">//workerCountOf获取线程池的当前线程数；小于corePoolSize，执行addWorker创建新线程执行command任务</span></span><br><span class="line">       <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// double check: c, recheck</span></span><br><span class="line">    <span class="comment">// 线程池处于RUNNING状态，把提交的任务成功放入阻塞队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// recheck and if necessary 回滚到入队操作前，即倘若线程池shutdown状态，就remove(command)</span></span><br><span class="line">        <span class="comment">//如果线程池没有RUNNING，成功从阻塞队列中删除任务，执行reject方法处理任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//线程池处于running状态，但是没有线程，则创建线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往线程池中创建新的线程失败，则reject任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<ul>
<li>为什么需要double check线程池的状态?</li>
</ul>
<p>在多线程环境下，线程池的状态时刻在变化，而ctl.get()是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将command加入workque是线程池之前的状态。倘若没有double check，万一线程池处于非running状态(在多线程环境下很有可能发生)，那么command永远不会执行。</p>
<h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><p>从方法execute的实现可以看出: addWorker主要负责创建新的线程并执行任务 线程池创建新线程执行任务时，需要 获取全局锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS更新线程池数量</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 线程池重入锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();  <span class="comment">// 线程启动，执行任务(Worker.thread(firstTask).start());</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Worker类的runworker方法"><a href="#Worker类的runworker方法" class="headerlink" title="Worker类的runworker方法"></a>Worker类的runworker方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>); <span class="comment">// 创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>继承了AQS类，可以方便的实现工作线程的中止操作；</li>
<li>实现了Runnable接口，可以将自身作为一个任务在工作线程中执行；</li>
<li>当前提交的任务firstTask作为参数传入Worker的构造方法；</li>
</ul>
<p>一些属性还有构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行的线程,前面addWorker方法中就是直接通过启动这个线程来启动这个worker</span></span><br><span class="line"><span class="keyword">final</span> Thread thread;</span><br><span class="line"><span class="comment">//当一个worker刚创建的时候,就先尝试执行这个任务</span></span><br><span class="line">Runnable firstTask;</span><br><span class="line"><span class="comment">//记录完成任务的数量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="comment">//创建一个Thread,将自己设置给他,后面这个thread启动的时候,也就是执行worker的run方法</span></span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>runWorker方法是线程池的核心:</p>
<ul>
<li>线程启动之后，通过unlock方法释放锁，设置AQS的state为0，表示运行可中断；</li>
<li>Worker执行firstTask或从workQueue中获取任务:<ul>
<li>进行加锁操作，保证thread不被其他线程中断(除非线程池被中断)</li>
<li>检查线程池状态，倘若线程池处于中断状态，当前线程将中断。</li>
<li>执行beforeExecute</li>
<li>执行任务的run方法</li>
<li>执行afterExecute方法</li>
<li>解锁操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先执行firstTask，再从workerQueue中取task(getTask())</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><p>下面来看一下getTask()方法，这里面涉及到keepAliveTime的使用，从这个方法我们可以看出先吃池是怎么让超过corePoolSize的那部分worker销毁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里一段代码是keepAliveTime起作用的关键:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br></pre></td></tr></table></figure>
<p>allowCoreThreadTimeOut为false，线程即使空闲也不会被销毁；倘若为ture，在keepAliveTime内仍空闲则会被销毁。</p>
<p>如果线程允许空闲等待而不被销毁timed == false，workQueue.take任务: 如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；</p>
<p>如果线程不允许无休止空闲timed == true, workQueue.poll任务: 如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null；</p>
<h2 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h2><p><img src="https://www.pdai.tech/_images/thread/java-thread-x-executors-3.png" alt="img"></p>
<ol>
<li>submit任务，等待线程池execute</li>
<li>执行FutureTask类的get方法时，会把主线程封装成WaitNode节点并保存在waiters链表中， 并阻塞等待运行结果；</li>
<li>FutureTask任务执行完成后，通过UNSAFE设置waiters相应的waitNode为null，并通过LockSupport类unpark方法唤醒主线程；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;future result&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = future.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际业务场景中，Future和Callable基本是成对出现的，Callable负责产生结果，Future负责获取结果。</p>
<ol>
<li>Callable接口类似于Runnable，只是Runnable没有返回值。</li>
<li>Callable任务除了返回正常结果之外，如果发生异常，该异常也会被返回，即Future可以拿到异步执行任务各种结果；</li>
<li>Future.get方法会导致主线程阻塞，直到Callable任务执行完成；</li>
</ol>
<h3 id="submit方法"><a href="#submit方法" class="headerlink" title="submit方法"></a>submit方法</h3><p>AbstractExecutorService.submit()实现了ExecutorService.submit() 可以获取执行完的返回值, 而ThreadPoolExecutor 是AbstractExecutorService.submit()的子类，所以submit方法也是ThreadPoolExecutor`的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// submit()在ExecutorService中的定义</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// submit方法在AbstractExecutorService中的实现</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。通过Executor.execute方法提交FutureTask到线程池中等待被执行，最终执行的是FutureTask的run方法；</p>
<h3 id="FutureTask对象"><a href="#FutureTask对象" class="headerlink" title="FutureTask对象"></a>FutureTask对象</h3><p><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</code> 可以将FutureTask提交至线程池中等待被执行(通过FutureTask的run方法来执行)</p>
<ul>
<li>内部状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The run state of this task, initially NEW. </span></span><br><span class="line"><span class="comment">    * ...</span></span><br><span class="line"><span class="comment">    * Possible state transitions:</span></span><br><span class="line"><span class="comment">    * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment">    * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment">    * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment">    * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;   </span><br></pre></td></tr></table></figure>
<p>内部状态的修改通过sun.misc.Unsafe修改</p>
<ul>
<li>get方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>内部通过awaitDone方法对主线程进行阻塞，具体实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果主线程被中断，则抛出中断异常；</li>
<li>判断FutureTask当前的state，如果大于COMPLETING，说明任务已经执行完成，则直接返回；</li>
<li>如果当前state等于COMPLETING，说明任务已经执行完，这时主线程只需通过yield方法让出cpu资源，等待state变成NORMAL；</li>
<li>通过WaitNode类封装当前线程，并通过UNSAFE添加到waiters链表；</li>
<li>最终通过LockSupport的park或parkNanos挂起线程；</li>
</ol>
<p>run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FutureTask.run方法是在线程池中被执行的，而非主线程</p>
<ol>
<li>通过执行Callable任务的call方法；</li>
<li>如果call执行成功，则通过set方法保存结果；</li>
<li>如果call执行有异常，则通过setException保存异常；</li>
</ol>
<h2 id="任务的关闭"><a href="#任务的关闭" class="headerlink" title="任务的关闭"></a>任务的关闭</h2><p>shutdown方法会将线程池的状态设置为SHUTDOWN,线程池进入这个状态后,就拒绝再接受任务,然后会将剩余的任务全部执行完</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查是否可以关闭线程</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//设置线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//尝试中断worker</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">            <span class="comment">//预留方法,留给子类实现</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历所有的worker</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">//先尝试调用w.tryLock(),如果获取到锁,就说明worker是空闲的,就可以直接中断它</span></span><br><span class="line">            <span class="comment">//注意的是,worker自己本身实现了AQS同步框架,然后实现的类似锁的功能</span></span><br><span class="line">            <span class="comment">//它实现的锁是不可重入的,所以如果worker在执行任务的时候,会先进行加锁,这里tryLock()就会返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shutdownNow做的比较绝，它先将线程池状态设置为STOP，然后拒绝所有提交的任务。最后中断左右正在运行中的worker,然后清空任务队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//检测权限</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//中断所有的worker</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//清空任务队列</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历所有worker，然后调用中断方法</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流之多路复用IO实现</title>
    <url>/posts/eadc4cf0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>本文主要对IO多路复用，Ractor模型以及Java NIO对其的支持</p>
</blockquote>
<a id="more"></a>

<h1 id="现实场景"><a href="#现实场景" class="headerlink" title="现实场景"></a>现实场景</h1><p>我们试想一下这样的现实场景:</p>
<p>一个餐厅同时有100位客人到店，当然到店后第一件要做的事情就是点菜。但是问题来了，餐厅老板为了节约人力成本目前只有一位大堂服务员拿着唯一的一本菜单等待客人进行服务。</p>
<ul>
<li>那么最笨(但是最简单)的方法是(方法A)，无论有多少客人等待点餐，服务员都把仅有的一份菜单递给其中一位客人，然后站在客人身旁等待这个客人完成点菜过程。在记录客人点菜内容后，把点菜记录交给后堂厨师。然后是第二位客人。。。。然后是第三位客人。很明显，只有脑袋被门夹过的老板，才会这样设置服务流程。因为随后的80位客人，再等待超时后就会离店(还会给差评)。</li>
<li>于是还有一种办法(方法B)，老板马上新雇佣99名服务员，同时印制99本新的菜单。每一名服务员手持一本菜单负责一位客人(关键不只在于服务员，还在于菜单。因为没有菜单客人也无法点菜)。在客人点完菜后，记录点菜内容交给后堂厨师(当然为了更高效，后堂厨师最好也有100名)。这样每一位客人享受的就是VIP服务咯，当然客人不会走，但是人力成本可是一个大头哦(亏死你)。</li>
<li>另外一种办法(方法C)，就是改进点菜的方式，当客人到店后，自己申请一本菜单。想好自己要点的才后，就呼叫服务员。服务员站在自己身边后记录客人的菜单内容。将菜单递给厨师的过程也要进行改进，并不是每一份菜单记录好以后，都要交给后堂厨师。服务员可以记录号多份菜单后，同时交给厨师就行了。那么这种方式，对于老板来说人力成本是最低的；对于客人来说，虽然不再享受VIP服务并且要进行一定的等待，但是这些都是可接受的；对于服务员来说，基本上她的时间都没有浪费，基本上被老板压杆了最后一滴油水。</li>
</ul>
<p>如果您是老板，您会采用哪种方式呢?</p>
<p>到店情况: 并发量。到店情况不理想时，一个服务员一本菜单，当然是足够了。所以不同的老板在不同的场合下，将会灵活选择服务员和菜单的配置。</p>
<ul>
<li>客人: 客户端请求</li>
<li>点餐内容: 客户端发送的实际数据</li>
<li>老板: 操作系统</li>
<li>人力成本: 系统资源</li>
<li>菜单: 文件状态描述符。操作系统对于一个进程能够同时持有的文件状态描述符的个数是有限制的，在linux系统中$ulimit -n查看这个限制值，当然也是可以(并且应该)进行内核参数调整的。</li>
<li>服务员: 操作系统内核用于IO操作的线程(内核线程)</li>
<li>厨师: 应用程序线程(当然厨房就是应用程序进程咯)</li>
<li>餐单传递方式: 包括了阻塞式和非阻塞式两种。<ul>
<li>方法A: 阻塞式/非阻塞式 同步IO</li>
<li>方法B: 使用线程进行处理的 阻塞式/非阻塞式 同步IO</li>
<li>方法C: 阻塞式/非阻塞式 多路复用IO</li>
</ul>
</li>
</ul>
<h1 id="典型的多路复用IO实现"><a href="#典型的多路复用IO实现" class="headerlink" title="典型的多路复用IO实现"></a>典型的多路复用IO实现</h1><p>目前流程的多路复用IO实现主要包括四种: <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>。下表是他们的一些重要特性的比较:</p>
<table>
<thead>
<tr>
<th>IO模型</th>
<th>相对性能</th>
<th>关键思路</th>
<th>操作系统</th>
<th>JAVA支持情况</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>较高</td>
<td>Reactor</td>
<td>windows/Linux</td>
<td>支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型</td>
</tr>
<tr>
<td>poll</td>
<td>较高</td>
<td>Reactor</td>
<td>Linux</td>
<td>Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式</td>
</tr>
<tr>
<td>epoll</td>
<td>高</td>
<td>Reactor/Proactor</td>
<td>Linux</td>
<td>Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO</td>
</tr>
<tr>
<td>kqueue</td>
<td>高</td>
<td>Proactor</td>
<td>Linux</td>
<td>目前JAVA的版本不支持</td>
</tr>
</tbody></table>
<p>多路复用IO技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用IO技术发挥不出来它的优势。另一方面，使用JAVA NIO进行功能实现，相对于传统的Socket套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。</p>
<h1 id="Reactor模型和Proactor模型"><a href="#Reactor模型和Proactor模型" class="headerlink" title="Reactor模型和Proactor模型"></a>Reactor模型和Proactor模型</h1><h2 id="JAVA对多路复用IO的支持"><a href="#JAVA对多路复用IO的支持" class="headerlink" title="JAVA对多路复用IO的支持"></a>JAVA对多路复用IO的支持</h2><p><img src="https://www.pdai.tech/_images/io/java-io-nio-1.png" alt="img"></p>
<h3 id="重要概念-Channel"><a href="#重要概念-Channel" class="headerlink" title="重要概念: Channel"></a>重要概念: Channel</h3><p>通道，被建立的一个应用程序和操作系统交互事件、传递内容的渠道(注意是连接到操作系统)。一个通道会有一个专属的文件状态描述符。那么既然是和操作系统进行内容的传递，那么说明应用程序可以通过通道读取数据，也可以通过通道向操作系统写数据。</p>
<p>JDK API中的Channel的描述是:</p>
<blockquote>
<p>A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing.</p>
</blockquote>
<blockquote>
<p>A channel is either open or closed. A channel is open upon creation, and once closed it remains closed. Once a channel is closed, any attempt to invoke an I/O operation upon it will cause a ClosedChannelException to be thrown. Whether or not a channel is open may be tested by invoking its isOpen method.</p>
</blockquote>
<p>JAVA NIO 框架中，自有的Channel通道包括:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-nio-2.png" alt="img"></p>
<p>所有被Selector(选择器)注册的通道，只能是继承了SelectableChannel类的子类。如上图所示</p>
<ul>
<li>ServerSocketChannel: 应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持“多路复用IO”的端口监听。同时支持UDP协议和TCP协议。</li>
<li>ScoketChannel: TCP Socket套接字的监听通道，一个Socket套接字对应了一个客户端IP: 端口 到 服务器IP: 端口的通信连接。</li>
<li>DatagramChannel: UDP 数据报文的监听通道。</li>
</ul>
<h3 id="重要概念-Buffer"><a href="#重要概念-Buffer" class="headerlink" title="重要概念: Buffer"></a>重要概念: Buffer</h3><p>数据缓存区: 在JAVA NIO 框架中，为了保证每个通道的数据读写速度JAVA NIO 框架为每一种需要支持数据读写的通道集成了Buffer的支持。</p>
<p>这句话怎么理解呢? 例如ServerSocketChannel通道它只支持对OP_ACCEPT事件的监听，所以它是不能直接进行网络数据内容的读写的。所以ServerSocketChannel是没有集成Buffer的。</p>
<p>Buffer有两种工作模式: 写模式和读模式。在读模式下，应用程序只能从Buffer中读取数据，不能进行写操作。但是在写模式下，应用程序是可以进行读操作的，这就表示可能会出现脏读的情况。所以一旦您决定要从Buffer中读取数据，一定要将Buffer的状态改为读模式。</p>
<p>如下图:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-nio-3.png" alt="img"></p>
<h3 id="重要概念-Selector"><a href="#重要概念-Selector" class="headerlink" title="重要概念: Selector"></a>重要概念: Selector</h3><p>Selector的英文含义是“选择器”，不过根据我们详细介绍的Selector的岗位职责，您可以把它称之为“轮询代理器”、“事件订阅器”、“channel容器管理机”都行。</p>
<ul>
<li>事件订阅和Channel管理</li>
</ul>
<p>应用程序将向Selector对象注册需要它关注的Channel，以及具体的某一个Channel会对哪些IO事件感兴趣。Selector中也会维护一个“已经注册的Channel”的容器。以下代码来自WindowsSelectorImpl实现类中，对已经注册的Channel的管理容器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initial capacity of the poll array</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAP = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// Maximum number of sockets for select().</span></span><br><span class="line"><span class="comment">// Should be INIT_CAP times a power of 2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_SELECTABLE_FDS = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The list of SelectableChannels serviced by this Selector. Every mod</span></span><br><span class="line"><span class="comment">// MAX_SELECTABLE_FDS entry is bogus, to align this array with the poll</span></span><br><span class="line"><span class="comment">// array,  where the corresponding entry is occupied by the wakeupSocket</span></span><br><span class="line"><span class="keyword">private</span> SelectionKeyImpl[] channelArray = <span class="keyword">new</span> SelectionKeyImpl[INIT_CAP];</span><br></pre></td></tr></table></figure>
<ul>
<li>轮询代理</li>
</ul>
<p>应用层不再通过阻塞模式或者非阻塞模式直接询问操作系统“事件有没有发生”，而是由Selector代其询问。</p>
<ul>
<li>实现不同操作系统的支持</li>
</ul>
<p>之前已经提到过，多路复用IO技术 是需要操作系统进行支持的，其特点就是操作系统可以同时扫描同一个端口上不同网络连接的事件。所以作为上层的JVM，必须要为 不同操作系统的多路复用IO实现 编写不同的代码。同样我使用的测试环境是Windows，它对应的实现类是sun.nio.ch.WindowsSelectorImpl:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-nio-4.png" alt="img"></p>
<h1 id="JAVA-NIO-框架简要设计分析"><a href="#JAVA-NIO-框架简要设计分析" class="headerlink" title="JAVA NIO 框架简要设计分析"></a>JAVA NIO 框架简要设计分析</h1><p>通过上文的描述，我们知道了多路复用IO技术是操作系统的内核实现。在不同的操作系统，甚至同一系列操作系统的版本中所实现的多路复用IO技术都是不一样的。那么作为跨平台的JAVA JVM来说如何适应多种多样的多路复用IO技术实现呢? 面向对象的威力就显现出来了: 无论使用哪种实现方式，他们都会有“选择器”、“通道”、“缓存”这几个操作要素，那么可以为不同的多路复用IO技术创建一个统一的抽象组，并且为不同的操作系统进行具体的实现。JAVA NIO中对各种多路复用IO的支持，主要的基础是java.nio.channels.spi.SelectorProvider抽象类，其中的几个主要抽象方法包括:</p>
<ul>
<li>public abstract DatagramChannel openDatagramChannel(): 创建和这个操作系统匹配的UDP 通道实现。</li>
<li>public abstract AbstractSelector openSelector(): 创建和这个操作系统匹配的NIO选择器，就像上文所述，不同的操作系统，不同的版本所默认支持的NIO模型是不一样的。</li>
<li>public abstract ServerSocketChannel openServerSocketChannel(): 创建和这个NIO模型匹配的服务器端通道。</li>
<li>public abstract SocketChannel openSocketChannel(): 创建和这个NIO模型匹配的TCP Socket套接字通道(用来反映客户端的TCP连接)</li>
</ul>
<p>由于JAVA NIO框架的整个设计是很大的，所以我们只能还原一部分我们关心的问题。这里我们以JAVA NIO框架中对于不同多路复用IO技术的选择器 进行实例化创建的方式作为例子，以点窥豹观全局:</p>
<p><img src="https://www.pdai.tech/_images/io/java-io-nio-5.png" alt="img"></p>
<p>很明显，不同的SelectorProvider实现对应了不同的 选择器。由具体的SelectorProvider实现进行创建。另外说明一下，实际上netty底层也是通过这个设计获得具体使用的NIO模型，我们后文讲解Netty时，会讲到这个问题。以下代码是Netty 4.0中NioServerSocketChannel进行实例化时的核心代码片段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *  Use the &#123;<span class="doctag">@link</span> SelectorProvider&#125; to open &#123;<span class="doctag">@link</span> SocketChannel&#125; and so remove condition in</span></span><br><span class="line"><span class="comment">            *  &#123;<span class="doctag">@link</span> SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            *  See &lt;a href=&quot;See https://github.com/netty/netty/issues/2308&quot;&gt;#2308&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                <span class="string">&quot;Failed to open a server socket.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JAVA实例"><a href="#JAVA实例" class="headerlink" title="JAVA实例"></a>JAVA实例</h2><p>下面，我们使用JAVA NIO框架，实现一个支持多路复用IO的服务器端(实际上客户端是否使用多路复用IO技术，对整个系统架构的性能提升相关性不大):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testNSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.BasicConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        BasicConfigurator.configure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(SocketServer1.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocket serverSocket = serverChannel.socket();</span><br><span class="line">        serverSocket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">83</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//注意、服务器通道只能注册SelectionKey.OP_ACCEPT事件</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//如果条件成立，说明本次询问selector，并没有获取到任何准备好的、感兴趣的事件</span></span><br><span class="line">                <span class="comment">//java程序对多路复用IO的支持也包括了阻塞模式 和非阻塞模式两种。</span></span><br><span class="line">                <span class="keyword">if</span>(selector.select(<span class="number">100</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//================================================</span></span><br><span class="line">                    <span class="comment">//      这里视业务情况，可以做一些然并卵的事情</span></span><br><span class="line">                    <span class="comment">//================================================</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里就是本次询问操作系统，所获取到的“所关心的事件”的事件类型(每一个通道都是独立的)</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; selecionKeys = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(selecionKeys.hasNext()) &#123;</span><br><span class="line">                    SelectionKey readyKey = selecionKeys.next();</span><br><span class="line">                    <span class="comment">//这个已经处理的readyKey一定要移除。如果不移除，就会一直存在在selector.selectedKeys集合中</span></span><br><span class="line">                    <span class="comment">//待到下一次selector.select() &gt; 0时，这个readyKey又会被处理一次</span></span><br><span class="line">                    selecionKeys.remove();</span><br><span class="line"></span><br><span class="line">                    SelectableChannel selectableChannel = readyKey.channel();</span><br><span class="line">                    <span class="keyword">if</span>(readyKey.isValid() &amp;&amp; readyKey.isAcceptable()) &#123;</span><br><span class="line">                        SocketServer1.LOGGER.info(<span class="string">&quot;======channel通道已经准备好=======&quot;</span>);</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * 当server socket channel通道已经准备好，就可以从server socket channel中获取socketchannel了</span></span><br><span class="line"><span class="comment">                         * 拿到socket channel后，要做的事情就是马上到selector注册这个socket channel感兴趣的事情。</span></span><br><span class="line"><span class="comment">                         * 否则无法监听到这个socket channel到达的数据</span></span><br><span class="line"><span class="comment">                         * */</span></span><br><span class="line">                        ServerSocketChannel serverSocketChannel = (ServerSocketChannel)selectableChannel;</span><br><span class="line">                        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                        registerSocketChannel(socketChannel , selector);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readyKey.isValid() &amp;&amp; readyKey.isConnectable()) &#123;</span><br><span class="line">                        SocketServer1.LOGGER.info(<span class="string">&quot;======socket channel 建立连接=======&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readyKey.isValid() &amp;&amp; readyKey.isReadable()) &#123;</span><br><span class="line">                        SocketServer1.LOGGER.info(<span class="string">&quot;======socket channel 数据准备完成，可以去读==读取=======&quot;</span>);</span><br><span class="line">                        readSocketChannel(readyKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            SocketServer1.LOGGER.error(e.getMessage() , e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在server socket channel接收到/准备好 一个新的 TCP连接后。</span></span><br><span class="line"><span class="comment">     * 就会向程序返回一个新的socketChannel。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 但是这个新的socket channel并没有在selector“选择器/代理器”中注册，</span></span><br><span class="line"><span class="comment">     * 所以程序还没法通过selector通知这个socket channel的事件。</span></span><br><span class="line"><span class="comment">     * 于是我们拿到新的socket channel后，要做的第一个事情就是到selector“选择器/代理器”中注册这个</span></span><br><span class="line"><span class="comment">     * socket channel感兴趣的事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketChannel 新的socket channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selector selector“选择器/代理器”</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerSocketChannel</span><span class="params">(SocketChannel socketChannel , Selector selector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//socket通道可以且只可以注册三种事件SelectionKey.OP_READ | SelectionKey.OP_WRITE | SelectionKey.OP_CONNECT</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ , ByteBuffer.allocate(<span class="number">2048</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法用于读取从客户端传来的信息。</span></span><br><span class="line"><span class="comment">     * 并且观察从客户端过来的socket channel在经过多次传输后，是否完成传输。</span></span><br><span class="line"><span class="comment">     * 如果传输完成，则返回一个true的标记。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readSocketChannel</span><span class="params">(SelectionKey readyKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel clientSocketChannel = (SocketChannel)readyKey.channel();</span><br><span class="line">        <span class="comment">//获取客户端使用的端口</span></span><br><span class="line">        InetSocketAddress sourceSocketAddress = (InetSocketAddress)clientSocketChannel.getRemoteAddress();</span><br><span class="line">        Integer resoucePort = sourceSocketAddress.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到这个socket channel使用的缓存区，准备读取数据</span></span><br><span class="line">        <span class="comment">//在后文，将详细讲解缓存区的用法概念，实际上重要的就是三个元素capacity,position和limit。</span></span><br><span class="line">        ByteBuffer contextBytes = (ByteBuffer)readyKey.attachment();</span><br><span class="line">        <span class="comment">//将通道的数据写入到缓存区，注意是写入到缓存区。</span></span><br><span class="line">        <span class="comment">//由于之前设置了ByteBuffer的大小为2048 byte，所以可以存在写入不完的情况</span></span><br><span class="line">        <span class="comment">//没关系，我们后面来调整代码。这里我们暂时理解为一次接受可以完成</span></span><br><span class="line">        <span class="keyword">int</span> realLen = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            realLen = clientSocketChannel.read(contextBytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="comment">//这里抛出了异常，一般就是客户端因为某种原因终止了。所以关闭channel就行了</span></span><br><span class="line">            SocketServer1.LOGGER.error(e.getMessage());</span><br><span class="line">            clientSocketChannel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果缓存区中没有任何数据(但实际上这个不太可能，否则就不会触发OP_READ事件了)</span></span><br><span class="line">        <span class="keyword">if</span>(realLen == -<span class="number">1</span>) &#123;</span><br><span class="line">            SocketServer1.LOGGER.warn(<span class="string">&quot;====缓存区没有数据? ====&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将缓存区从写状态切换为读状态(实际上这个方法是读写模式互切换)。</span></span><br><span class="line">        <span class="comment">//这是java nio框架中的这个socket channel的写请求将全部等待。</span></span><br><span class="line">        contextBytes.flip();</span><br><span class="line">        <span class="comment">//注意中文乱码的问题，我个人喜好是使用URLDecoder/URLEncoder，进行解编码。</span></span><br><span class="line">        <span class="comment">//当然java nio框架本身也提供编解码方式，看个人咯</span></span><br><span class="line">        <span class="keyword">byte</span>[] messageBytes = contextBytes.array();</span><br><span class="line">        String messageEncode = <span class="keyword">new</span> String(messageBytes , <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        String message = URLDecoder.decode(messageEncode, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果收到了“over”关键字，才会清空buffer，并回发数据；</span></span><br><span class="line">        <span class="comment">//否则不清空缓存，还要还原buffer的“写状态”</span></span><br><span class="line">        <span class="keyword">if</span>(message.indexOf(<span class="string">&quot;over&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//清空已经读取的缓存，并从新切换为写状态(这里要注意clear()和capacity()两个方法的区别)</span></span><br><span class="line">            contextBytes.clear();</span><br><span class="line">            SocketServer1.LOGGER.info(<span class="string">&quot;端口:&quot;</span> + resoucePort + <span class="string">&quot;客户端发来的信息======message : &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//======================================================</span></span><br><span class="line">            <span class="comment">//          当然接受完成后，可以在这里正式处理业务了        </span></span><br><span class="line">            <span class="comment">//======================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//回发数据，并关闭channel</span></span><br><span class="line">            ByteBuffer sendBuffer = ByteBuffer.wrap(URLEncoder.encode(<span class="string">&quot;回发处理结果&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).getBytes());</span><br><span class="line">            clientSocketChannel.write(sendBuffer);</span><br><span class="line">            clientSocketChannel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SocketServer1.LOGGER.info(<span class="string">&quot;端口:&quot;</span> + resoucePort + <span class="string">&quot;客户端信息还未接受完，继续接受======message : &quot;</span> + message);</span><br><span class="line">            <span class="comment">//这是，limit和capacity的值一致，position的位置是realLen的位置</span></span><br><span class="line">            contextBytes.position(realLen);</span><br><span class="line">            contextBytes.limit(contextBytes.capacity());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的注释是比较清楚的，但是还是要对几个关键点进行一下讲解:</p>
<ul>
<li>serverChannel.register(Selector sel, int ops, Object att): 实际上register(Selector sel, int ops, Object att)方法是ServerSocketChannel类的父类AbstractSelectableChannel提供的一个方法，表示只要继承了AbstractSelectableChannel类的子类都可以注册到选择器中。通过观察整个AbstractSelectableChannel继承关系，下图中的这些类可以被注册到选择器中:</li>
</ul>
<p><img src="https://www.pdai.tech/_images/io/java-io-nio-6.png" alt="img"></p>
<ul>
<li>SelectionKey.OP_ACCEPT: 不同的Channel对象可以注册的“我关心的事件”是不一样的。例如ServerSocketChannel除了能够被允许关注OP_ACCEPT事件外，不允许再关心其他事件了(否则运行时会抛出异常)。以下梳理了常使用的AbstractSelectableChannel子类可以注册的事件列表:</li>
<li></li>
</ul>
<table>
<thead>
<tr>
<th>通道类</th>
<th>通道作用</th>
<th>可关注的事件</th>
</tr>
</thead>
<tbody><tr>
<td>ServerSocketChannel</td>
<td>服务器端通道</td>
<td>SelectionKey.OP_ACCEPT</td>
</tr>
<tr>
<td>DatagramChannel</td>
<td>UDP协议通道</td>
<td>SelectionKey.OP_READ、SelectionKey.OP_WRITE</td>
</tr>
<tr>
<td>SocketChannel</td>
<td>TCP协议通道</td>
<td>SelectionKey.OP_READ、SelectionKey.OP_WRITE、SelectionKey.OP_CONNECT</td>
</tr>
</tbody></table>
<p>实际上通过每一个AbstractSelectableChannel子类所实现的public final int validOps()方法，就可以查看这个通道“可以关心的IO事件”。</p>
<p>selector.selectedKeys().iterator(): 当选择器Selector收到操作系统的IO操作事件后，它的selectedKeys将在下一次轮询操作中，收到这些事件的关键描述字(不同的channel，就算关键字一样，也会存储成两个对象)。但是每一个“事件关键字”被处理后都必须移除，否则下一次轮询时，这个事件会被重复处理。</p>
<blockquote>
<p>Returns this selector’s selected-key set. Keys may be removed from, but not directly added to, the selected-key set. Any attempt to add an object to the key set will cause an UnsupportedOperationException to be thrown. The selected-key set is not thread-safe.</p>
</blockquote>
<h2 id="JAVA实例改进"><a href="#JAVA实例改进" class="headerlink" title="JAVA实例改进"></a>JAVA实例改进</h2><p>上面的代码中，我们为了讲解selector的使用，在缓存使用上就进行了简化。实际的应用中，为了节约内存资源，我们一般不会为一个通道分配那么多的缓存空间。下面的代码我们主要对其中的缓存操作进行了优化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testNSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.BasicConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        BasicConfigurator.configure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(SocketServer2.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改进的java nio server的代码中，由于buffer的大小设置的比较小。</span></span><br><span class="line"><span class="comment">     * 我们不再把一个client通过socket channel多次传给服务器的信息保存在beff中了(因为根本存不下)&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 我们使用socketchanel的hashcode作为key(当然您也可以自己确定一个id)，信息的stringbuffer作为value，存储到服务器端的一个内存区域MESSAGEHASHCONTEXT。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果您不清楚ConcurrentHashMap的作用和工作原理，请自行百度/Google</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Integer, StringBuffer&gt; MESSAGEHASHCONTEXT = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer , StringBuffer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocket serverSocket = serverChannel.socket();</span><br><span class="line">        serverSocket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">83</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//注意、服务器通道只能注册SelectionKey.OP_ACCEPT事件</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//如果条件成立，说明本次询问selector，并没有获取到任何准备好的、感兴趣的事件</span></span><br><span class="line">                <span class="comment">//java程序对多路复用IO的支持也包括了阻塞模式 和非阻塞模式两种。</span></span><br><span class="line">                <span class="keyword">if</span>(selector.select(<span class="number">100</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//================================================</span></span><br><span class="line">                    <span class="comment">//      这里视业务情况，可以做一些然并卵的事情</span></span><br><span class="line">                    <span class="comment">//================================================</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里就是本次询问操作系统，所获取到的“所关心的事件”的事件类型(每一个通道都是独立的)</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; selecionKeys = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(selecionKeys.hasNext()) &#123;</span><br><span class="line">                    SelectionKey readyKey = selecionKeys.next();</span><br><span class="line">                    <span class="comment">//这个已经处理的readyKey一定要移除。如果不移除，就会一直存在在selector.selectedKeys集合中</span></span><br><span class="line">                    <span class="comment">//待到下一次selector.select() &gt; 0时，这个readyKey又会被处理一次</span></span><br><span class="line">                    selecionKeys.remove();</span><br><span class="line"></span><br><span class="line">                    SelectableChannel selectableChannel = readyKey.channel();</span><br><span class="line">                    <span class="keyword">if</span>(readyKey.isValid() &amp;&amp; readyKey.isAcceptable()) &#123;</span><br><span class="line">                        SocketServer2.LOGGER.info(<span class="string">&quot;======channel通道已经准备好=======&quot;</span>);</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * 当server socket channel通道已经准备好，就可以从server socket channel中获取socketchannel了</span></span><br><span class="line"><span class="comment">                         * 拿到socket channel后，要做的事情就是马上到selector注册这个socket channel感兴趣的事情。</span></span><br><span class="line"><span class="comment">                         * 否则无法监听到这个socket channel到达的数据</span></span><br><span class="line"><span class="comment">                         * */</span></span><br><span class="line">                        ServerSocketChannel serverSocketChannel = (ServerSocketChannel)selectableChannel;</span><br><span class="line">                        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                        registerSocketChannel(socketChannel , selector);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readyKey.isValid() &amp;&amp; readyKey.isConnectable()) &#123;</span><br><span class="line">                        SocketServer2.LOGGER.info(<span class="string">&quot;======socket channel 建立连接=======&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(readyKey.isValid() &amp;&amp; readyKey.isReadable()) &#123;</span><br><span class="line">                        SocketServer2.LOGGER.info(<span class="string">&quot;======socket channel 数据准备完成，可以去读==读取=======&quot;</span>);</span><br><span class="line">                        readSocketChannel(readyKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            SocketServer2.LOGGER.error(e.getMessage() , e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在server socket channel接收到/准备好 一个新的 TCP连接后。</span></span><br><span class="line"><span class="comment">     * 就会向程序返回一个新的socketChannel。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 但是这个新的socket channel并没有在selector“选择器/代理器”中注册，</span></span><br><span class="line"><span class="comment">     * 所以程序还没法通过selector通知这个socket channel的事件。</span></span><br><span class="line"><span class="comment">     * 于是我们拿到新的socket channel后，要做的第一个事情就是到selector“选择器/代理器”中注册这个</span></span><br><span class="line"><span class="comment">     * socket channel感兴趣的事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketChannel 新的socket channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selector selector“选择器/代理器”</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerSocketChannel</span><span class="params">(SocketChannel socketChannel , Selector selector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//socket通道可以且只可以注册三种事件SelectionKey.OP_READ | SelectionKey.OP_WRITE | SelectionKey.OP_CONNECT</span></span><br><span class="line">        <span class="comment">//最后一个参数视为 为这个socketchanne分配的缓存区</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ , ByteBuffer.allocate(<span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法用于读取从客户端传来的信息。</span></span><br><span class="line"><span class="comment">     * 并且观察从客户端过来的socket channel在经过多次传输后，是否完成传输。</span></span><br><span class="line"><span class="comment">     * 如果传输完成，则返回一个true的标记。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readSocketChannel</span><span class="params">(SelectionKey readyKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel clientSocketChannel = (SocketChannel)readyKey.channel();</span><br><span class="line">        <span class="comment">//获取客户端使用的端口</span></span><br><span class="line">        InetSocketAddress sourceSocketAddress = (InetSocketAddress)clientSocketChannel.getRemoteAddress();</span><br><span class="line">        Integer resoucePort = sourceSocketAddress.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到这个socket channel使用的缓存区，准备读取数据</span></span><br><span class="line">        <span class="comment">//在后文，将详细讲解缓存区的用法概念，实际上重要的就是三个元素capacity,position和limit。</span></span><br><span class="line">        ByteBuffer contextBytes = (ByteBuffer)readyKey.attachment();</span><br><span class="line">        <span class="comment">//将通道的数据写入到缓存区，注意是写入到缓存区。</span></span><br><span class="line">        <span class="comment">//这次，为了演示buff的使用方式，我们故意缩小了buff的容量大小到50byte，</span></span><br><span class="line">        <span class="comment">//以便演示channel对buff的多次读写操作</span></span><br><span class="line">        <span class="keyword">int</span> realLen = <span class="number">0</span>;</span><br><span class="line">        StringBuffer message = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//这句话的意思是，将目前通道中的数据写入到缓存区</span></span><br><span class="line">        <span class="comment">//最大可写入的数据量就是buff的容量</span></span><br><span class="line">        <span class="keyword">while</span>((realLen = clientSocketChannel.read(contextBytes)) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一定要把buffer切换成“读”模式，否则由于limit = capacity</span></span><br><span class="line">            <span class="comment">//在read没有写满的情况下，就会导致多读</span></span><br><span class="line">            contextBytes.flip();</span><br><span class="line">            <span class="keyword">int</span> position = contextBytes.position();</span><br><span class="line">            <span class="keyword">int</span> capacity = contextBytes.capacity();</span><br><span class="line">            <span class="keyword">byte</span>[] messageBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[capacity];</span><br><span class="line">            contextBytes.get(messageBytes, position, realLen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这种方式也是可以读取数据的，而且不用关心position的位置。</span></span><br><span class="line">            <span class="comment">//因为是目前contextBytes所有的数据全部转出为一个byte数组。</span></span><br><span class="line">            <span class="comment">//使用这种方式时，一定要自己控制好读取的最终位置(realLen很重要)</span></span><br><span class="line">            <span class="comment">//byte[] messageBytes = contextBytes.array();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意中文乱码的问题，我个人喜好是使用URLDecoder/URLEncoder，进行解编码。</span></span><br><span class="line">            <span class="comment">//当然java nio框架本身也提供编解码方式，看个人咯</span></span><br><span class="line">            String messageEncode = <span class="keyword">new</span> String(messageBytes , <span class="number">0</span> , realLen , <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            message.append(messageEncode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再切换成“写”模式，直接情况缓存的方式，最快捷</span></span><br><span class="line">            contextBytes.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果发现本次接收的信息中有over关键字，说明信息接收完了</span></span><br><span class="line">        <span class="keyword">if</span>(URLDecoder.decode(message.toString(), <span class="string">&quot;UTF-8&quot;</span>).indexOf(<span class="string">&quot;over&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//则从messageHashContext中，取出之前已经收到的信息，组合成完整的信息</span></span><br><span class="line">            Integer channelUUID = clientSocketChannel.hashCode();</span><br><span class="line">            SocketServer2.LOGGER.info(<span class="string">&quot;端口:&quot;</span> + resoucePort + <span class="string">&quot;客户端发来的信息======message : &quot;</span> + message);</span><br><span class="line">            StringBuffer completeMessage;</span><br><span class="line">            <span class="comment">//清空MESSAGEHASHCONTEXT中的历史记录</span></span><br><span class="line">            StringBuffer historyMessage = MESSAGEHASHCONTEXT.remove(channelUUID);</span><br><span class="line">            <span class="keyword">if</span>(historyMessage == <span class="keyword">null</span>) &#123;</span><br><span class="line">                completeMessage = message;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                completeMessage = historyMessage.append(message);</span><br><span class="line">            &#125;</span><br><span class="line">            SocketServer2.LOGGER.info(<span class="string">&quot;端口:&quot;</span> + resoucePort + <span class="string">&quot;客户端发来的完整信息======completeMessage : &quot;</span> + URLDecoder.decode(completeMessage.toString(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//======================================================</span></span><br><span class="line">            <span class="comment">//          当然接受完成后，可以在这里正式处理业务了        </span></span><br><span class="line">            <span class="comment">//======================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//回发数据，并关闭channel</span></span><br><span class="line">            ByteBuffer sendBuffer = ByteBuffer.wrap(URLEncoder.encode(<span class="string">&quot;回发处理结果&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).getBytes());</span><br><span class="line">            clientSocketChannel.write(sendBuffer);</span><br><span class="line">            clientSocketChannel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果没有发现有“over”关键字，说明还没有接受完，则将本次接受到的信息存入messageHashContext</span></span><br><span class="line">            SocketServer2.LOGGER.info(<span class="string">&quot;端口:&quot;</span> + resoucePort + <span class="string">&quot;客户端信息还未接受完，继续接受======message : &quot;</span> + URLDecoder.decode(message.toString(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//每一个channel对象都是独立的，所以可以使用对象的hash值，作为唯一标示</span></span><br><span class="line">            Integer channelUUID = clientSocketChannel.hashCode();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//然后获取这个channel下以前已经达到的message信息</span></span><br><span class="line">            StringBuffer historyMessage = MESSAGEHASHCONTEXT.get(channelUUID);</span><br><span class="line">            <span class="keyword">if</span>(historyMessage == <span class="keyword">null</span>) &#123;</span><br><span class="line">                historyMessage = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                MESSAGEHASHCONTEXT.put(channelUUID, historyMessage.append(message));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码应该没有过多需要讲解的了。当然，您还是可以加入线程池技术，进行具体的业务处理。注意，一定是线程池，因为这样可以保证线程规模的可控性。</p>
<h1 id="多路复用IO的优缺点"><a href="#多路复用IO的优缺点" class="headerlink" title="多路复用IO的优缺点"></a>多路复用IO的优缺点</h1><ul>
<li>不用再使用多线程来进行IO处理了(包括操作系统内核IO管理模块和应用程序进程而言)。当然实际业务的处理中，应用程序进程还是可以引入线程池技术的</li>
<li>同一个端口可以处理多种协议，例如，使用ServerSocketChannel测测的服务器端口监听，既可以处理TCP协议又可以处理UDP协议。</li>
<li>操作系统级别的优化: 多路复用IO技术可以是操作系统级别在一个端口上能够同时接受多个客户端的IO事件。同时具有之前我们讲到的阻塞式同步IO和非阻塞式同步IO的所有特点。Selector的一部分作用更相当于“轮询代理器”。</li>
<li>都是同步IO: 目前我们介绍的 阻塞式IO、非阻塞式IO甚至包括多路复用IO，这些都是基于操作系统级别对“同步IO”的实现。我们一直在说“同步IO”，一直都没有详细说，什么叫做“同步IO”。实际上一句话就可以说清楚: 只有上层(包括上层的某种代理机制)系统询问我是否有某个事件发生了，否则我不会主动告诉上层系统事件发生了:</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之异常</title>
    <url>/posts/fbeade06/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>Java异常是Java提供的一种识别及响应错误的一致性机制，java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。</p>
</blockquote>
<a id="more"></a>

<h1 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h1><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p>
<p>Java异常类层次结构图：</p>
<p><img src="https://www.pdai.tech/_images/java/java-basic-exception-1.png" alt="img"></p>
<h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><p>Throwable 是 Java 语言中所有错误与异常的超类。</p>
<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>
<p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p>
<h2 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h2><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
<p>此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>
<p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p>
<h2 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h2><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>
<ul>
<li><strong>运行时异常</strong></li>
</ul>
<p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<ul>
<li><strong>非运行时异常</strong> （编译异常）</li>
</ul>
<p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h2 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）。"><a href="#可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）。" class="headerlink" title="可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。"></a>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。</h2><ul>
<li><strong>可查异常</strong>（编译器要求必须处置的异常）：</li>
</ul>
<p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p>
<p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<ul>
<li><strong>不可查异常</strong>(编译器不要求强制处置的异常)</li>
</ul>
<p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
<h1 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h1><h2 id="异常关键字"><a href="#异常关键字" class="headerlink" title="异常关键字"></a>异常关键字</h2><ul>
<li><strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li>
<li><strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li>
<li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li>
<li><strong>throw</strong> – 用于抛出异常。</li>
<li><strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</li>
</ul>
<h2 id="异常的申明-throws"><a href="#异常的申明-throws" class="headerlink" title="异常的申明(throws)"></a>异常的申明(throws)</h2><p>在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException</span>&#123;</span><br><span class="line">    <span class="comment">//something statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p>
<p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Throws抛出异常的规则：</p>
<ul>
<li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li>
<li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li>
<li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li>
<li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li>
</ul>
<h2 id="异常的抛出-throw"><a href="#异常的抛出-throw" class="headerlink" title="异常的抛出(throw)"></a>异常的抛出(throw)</h2><p>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;参数不能为0&quot;</span>); <span class="comment">//抛出一个运行时异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5.0</span> / value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。</p>
<p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException </span>&#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        MyException ex = <span class="keyword">new</span> MyException(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常的自定义"><a href="#异常的自定义" class="headerlink" title="异常的自定义"></a>异常的自定义</h2><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h2><p>异常捕获处理的方法通常有：</p>
<ul>
<li>try-catch</li>
<li>try-catch-finally</li>
<li>try-finally</li>
<li>try-with-resource</li>
</ul>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException or UnknownHostException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>常规语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;                        </span><br><span class="line">    <span class="comment">//执行程序代码，可能会出现异常                 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;   </span><br><span class="line">    <span class="comment">//捕获异常并处理   </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//必执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的顺序</p>
<ul>
<li>当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</li>
<li>当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</li>
<li>当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</li>
</ul>
<p><img src="https://www.pdai.tech/_images/java/java-basic-exception-2.jpg" alt="img"></p>
<p>一个完整的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">        MyException ex = <span class="keyword">new</span> MyException(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method finally block.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != reader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h3><blockquote>
<p>可以直接用try-finally吗？ 可以。</p>
</blockquote>
<p>try块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。 try块没有引发异常，则执行完try块就执行finally语句。</p>
<p>try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以Lock加锁为例，演示try-finally</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//需要加锁的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">//保证锁一定被释放</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>finally遇见如下情况不会执行</p>
<ul>
<li>在前面的代码中用了System.exit()退出程序。</li>
<li>finally语句块中发生了异常。</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><blockquote>
<p>try-with-resource是Java 7中引入的，很容易被忽略。</p>
</blockquote>
<p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryWithResourceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;c:/abc&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下Scanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Scanner</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">String</span>&gt;, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Closeable</span> <span class="keyword">extends</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p>
<h2 id="异常基础总结"><a href="#异常基础总结" class="headerlink" title="异常基础总结"></a>异常基础总结</h2><ul>
<li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li>
<li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li>
<li>finally语句块中的代码一定会被执行，常用于回收资源 。</li>
<li>throws：声明一个异常，告知方法调用者。</li>
<li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。</li>
</ul>
<p>Java编程思想一书中，对异常的总结。</p>
<ul>
<li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li>
<li>解决问题并且重新调用产生异常的方法。</li>
<li>进行少许修补，然后绕过异常发生的地方继续执行。</li>
<li>用别的数据进行计算，以代替方法预计会返回的值。</li>
<li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li>
<li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li>
<li>终止程序。</li>
<li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li>
<li>让类库和程序更安全。</li>
</ul>
<h2 id="常用的异常"><a href="#常用的异常" class="headerlink" title="常用的异常"></a>常用的异常</h2><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p>
<h3 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a><strong>RuntimeException</strong></h3><ul>
<li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li>
<li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li>
<li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li>
<li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li>
<li>java.lang.NegativeArraySizeException 数组长度为负异常</li>
<li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li>
<li>java.lang.SecurityException 安全性异常</li>
<li>java.lang.IllegalArgumentException 非法参数异常</li>
</ul>
<h3 id="IOException"><a href="#IOException" class="headerlink" title="IOException"></a><strong>IOException</strong></h3><ul>
<li>IOException：操作输入流和输出流时可能出现的异常。</li>
<li>EOFException 文件已结束异常</li>
<li>FileNotFoundException 文件未找到异常</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><ul>
<li>ClassCastException 类型转换异常类</li>
<li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li>
<li>SQLException 操作数据库异常类</li>
<li>NoSuchFieldException 字段未找到异常</li>
<li>NoSuchMethodException 方法未找到抛出的异常</li>
<li>NumberFormatException 字符串转换为数字抛出的异常</li>
<li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li>
<li>IllegalAccessException 不允许访问某类异常</li>
<li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li>
</ul>
<h1 id="异常实践"><a href="#异常实践" class="headerlink" title="异常实践"></a>异常实践</h1><p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。</p>
<p>当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。</p>
<p>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p>
<p>这里给出几个被很多团队使用的异常处理最佳实践。</p>
<h2 id="只针对不正常的情况才使用异常"><a href="#只针对不正常的情况才使用异常" class="headerlink" title="只针对不正常的情况才使用异常"></a>只针对不正常的情况才使用异常</h2><blockquote>
<p>异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</p>
</blockquote>
<p>比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch Exception来实现</p>
<p>代码1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  obj.method(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>主要原因有三点：</p>
<ul>
<li>异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。</li>
<li>把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。</li>
<li>对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。</li>
</ul>
<h2 id="在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="在 finally 块中清理资源或者使用 try-with-resource 语句"></a>在 finally 块中清理资源或者使用 try-with-resource 语句</h2><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p>
<ul>
<li>错误示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCloseResourceInTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">        <span class="comment">// do NOT do this</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</p>
<p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p>
<p>方法一：使用 finally 代码块</p>
<p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeResourceInFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>方法二：Java 7 的 try-with-resource 语法</p>
<p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">automaticallyCloseResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尽量使用标准的异常"><a href="#尽量使用标准的异常" class="headerlink" title="尽量使用标准的异常"></a>尽量使用标准的异常</h2><blockquote>
<p>代码重用是值得提倡的，这是一条通用规则，异常也不例外。</p>
</blockquote>
<p>重用现有的异常有几个好处：</p>
<ul>
<li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li>
<li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li>
<li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</li>
</ul>
<p>Java标准异常中有几个是经常被使用的异常。如下表格：</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>使用场合</th>
</tr>
</thead>
<tbody><tr>
<td>IllegalArgumentException</td>
<td>参数的值不合适</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>参数的状态不合适</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>在null被禁止的情况下参数值为null</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>下标越界</td>
</tr>
<tr>
<td>ConcurrentModificationException</td>
<td>在禁止并发修改的情况下，对象检测到并发修改</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>对象不支持客户请求的方法</td>
</tr>
</tbody></table>
<p>虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。</p>
<p>最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。</p>
<h2 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h2><blockquote>
<p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p>
</blockquote>
<p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Method description</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> MyBusinessException - businuess exception description</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>同时，在抛出MyBusinessException 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>
<h2 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h2><blockquote>
<p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p>
</blockquote>
<p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p>
<p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p>
<p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMostSpecificExceptionFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething(<span class="string">&quot;A message&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="不要捕获 Throwable 类"></a>不要捕获 Throwable 类</h2><blockquote>
<p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p>
</blockquote>
<p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p>
<p>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCatchThrowable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t do this!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h2><blockquote>
<p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotIgnoreExceptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// this will never happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p>
<p>合理的做法是至少要记录异常的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAnException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;This should never happen: &quot;</span> + e); <span class="comment">// see this line</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h2><blockquote>
<p>这可能是本文中最常被忽略的最佳实践。</p>
</blockquote>
<p>可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Long(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">44</span>:<span class="number">28</span>,<span class="number">945</span> ERROR TestExceptionHandling:<span class="number">65</span> - java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">589</span>)</span><br><span class="line">at java.lang.Long.(Long.java:<span class="number">965</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:<span class="number">63</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:<span class="number">58</span>)</span><br></pre></td></tr></table></figure>
<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyBusinessException(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p>
<h2 id="包装异常时不要抛弃原始的异常"><a href="#包装异常时不要抛弃原始的异常" class="headerlink" title="包装异常时不要抛弃原始的异常"></a>包装异常时不要抛弃原始的异常</h2><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyBusinessException(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h2><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p>
<h2 id="不要在finally块中使用return。"><a href="#不要在finally块中使用return。" class="headerlink" title="不要在finally块中使用return。"></a>不要在finally块中使用return。</h2><p>try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。</p>
<p>如下是一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// x等于1，此处不返回</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 返回的结果是2</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h1 id="深入理解异常"><a href="#深入理解异常" class="headerlink" title="深入理解异常"></a>深入理解异常</h1><p>我们再深入理解下异常，看下底层实现。</p>
<h2 id="JVM处理异常的机制？"><a href="#JVM处理异常的机制？" class="headerlink" title="JVM处理异常的机制？"></a>JVM处理异常的机制？</h2><p>提到JVM处理异常的机制，就需要提及Exception Table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleTryCatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是一个很简单的例子，用来捕获处理一个潜在的空指针异常。</p>
<p>当然如果只是看简简单单的代码，我们很难看出什么高深之处，更没有了今天文章要谈论的内容。</p>
<p>所以这里我们需要借助一把神兵利器，它就是javap,一个用来拆解class文件的工具，和javac一样由JDK提供。</p>
<p>然后我们使用javap来分析这段代码（需要先使用javac编译）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//javap -c Main</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleTryCatch</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #3                  // Method testNPE:()V</span><br><span class="line">       <span class="number">3</span>: goto          <span class="number">11</span></span><br><span class="line">       <span class="number">6</span>: astore_0</span><br><span class="line">       <span class="number">7</span>: aload_0</span><br><span class="line">       8: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">      <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>     <span class="number">6</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure>
<p>看到上面的代码，应该会有会心一笑，因为终于看到了Exception table，也就是我们要研究的异常表。</p>
<p>异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下</p>
<ul>
<li><strong>from</strong> 可能发生异常的起始点</li>
<li><strong>to</strong> 可能发生异常的结束点</li>
<li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置</li>
<li><strong>type</strong> 异常处理者处理的异常的类信息</li>
</ul>
<p><strong>那么异常表用在什么时候呢</strong></p>
<p>答案是异常发生的时候，当一个异常发生时</p>
<ul>
<li>1.JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理</li>
<li>2.如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理。</li>
<li>3.如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目</li>
<li>4.如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。</li>
<li>5.如果所有的栈帧被弹出，仍然没有处理，则抛给当前的Thread，Thread则会终止。</li>
<li>6.如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。</li>
</ul>
<p>以上就是JVM处理异常的一些机制。</p>
<p><strong>try catch -finally</strong></p>
<p>除了简单的try-catch外，我们还常常和finally做结合使用。比如这样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleTryCatchFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>同样我们使用javap分析一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleTryCatchFinally</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #3                  // Method testNPE:()V</span><br><span class="line">       3: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       6: ldc           #7                  // String Finally</span><br><span class="line">       8: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">11</span>: goto          <span class="number">41</span></span><br><span class="line">      <span class="number">14</span>: astore_0</span><br><span class="line">      <span class="number">15</span>: aload_0</span><br><span class="line">      16: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">      19: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      22: ldc           #7                  // String Finally</span><br><span class="line">      24: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">27</span>: goto          <span class="number">41</span></span><br><span class="line">      <span class="number">30</span>: astore_1</span><br><span class="line">      31: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      34: ldc           #7                  // String Finally</span><br><span class="line">      36: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">39</span>: aload_1</span><br><span class="line">      <span class="number">40</span>: athrow</span><br><span class="line">      <span class="number">41</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>    <span class="number">14</span>   Class java/lang/Exception</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>    <span class="number">30</span>   any</span><br><span class="line">          <span class="number">14</span>    <span class="number">19</span>    <span class="number">30</span>   any</span><br></pre></td></tr></table></figure>
<p>和之前有所不同，这次异常表中，有三条数据，而我们仅仅捕获了一个Exception, 异常表的后两个item的type为any; 上面的三条异常表item的意思为:</p>
<ul>
<li>如果0到3之间，发生了Exception类型的异常，调用14位置的异常处理者。</li>
<li>如果0到3之间，无论发生什么异常，都调用30位置的处理者</li>
<li>如果14到19之间（即catch部分），不论发生什么异常，都调用30位置的处理者。</li>
</ul>
<p>再次分析上面的Java代码，finally里面的部分已经被提取到了try部分和catch部分。我们再次调一下代码来看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleTryCatchFinally</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">      <span class="comment">//try 部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至goto到41位置，执行返回操作。  </span></span><br><span class="line"></span><br><span class="line">       0: invokestatic  #3                  // Method testNPE:()V</span><br><span class="line">       3: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       6: ldc           #7                  // String Finally</span><br><span class="line">       8: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">11</span>: goto          <span class="number">41</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//catch部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至执行got到41位置，执行返回操作。</span></span><br><span class="line">      <span class="number">14</span>: astore_0</span><br><span class="line">      <span class="number">15</span>: aload_0</span><br><span class="line">      16: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">      19: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      22: ldc           #7                  // String Finally</span><br><span class="line">      24: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">27</span>: goto          <span class="number">41</span></span><br><span class="line">      <span class="comment">//finally部分的代码如果被调用，有可能是try部分，也有可能是catch部分发生异常。</span></span><br><span class="line">      <span class="number">30</span>: astore_1</span><br><span class="line">      31: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      34: ldc           #7                  // String Finally</span><br><span class="line">      36: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">39</span>: aload_1</span><br><span class="line">      <span class="number">40</span>: athrow     <span class="comment">//如果异常没有被catch捕获，而是到了这里，执行完finally的语句后，仍然要把这个异常抛出去，传递给调用处。</span></span><br><span class="line">      <span class="number">41</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p><strong>Catch先后顺序的问题</strong></p>
<p>我们在代码中的catch的顺序决定了异常处理者在异常表的位置，所以，越是具体的异常要先处理，否则就会出现下面的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">misuseCatchException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       t.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//error occurs during compilings with tips Exception Java.lang.Exception has already benn caught.</span></span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会导致编译失败，因为先捕获Throwable后捕获Exception，会导致后面的catch永远无法被执行。</p>
<p><strong>Return 和finally的问题</strong></p>
<p>这算是我们扩展的一个相对比较极端的问题，就是类似这样的代码，既有return，又有finally，那么finally导致会不会执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">tryCatchReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       testNPE();</span><br><span class="line">       <span class="keyword">return</span>  <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;tryCatchReturn&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>答案是finally会执行，那么还是使用上面的方法，我们来看一下为什么finally会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">tryCatchReturn</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #3                  // Method testNPE:()V</span><br><span class="line">       3: ldc           #6                  // String OK</span><br><span class="line">       <span class="number">5</span>: astore_0</span><br><span class="line">       6: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       9: ldc           #8                  // String tryCatchReturn</span><br><span class="line">      11: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">14</span>: aload_0</span><br><span class="line">      <span class="number">15</span>: areturn       返回OK字符串，areturn意思为<span class="keyword">return</span> a reference from a method</span><br><span class="line">      <span class="number">16</span>: astore_0</span><br><span class="line">      17: ldc           #10                 // String ERROR</span><br><span class="line">      <span class="number">19</span>: astore_1</span><br><span class="line">      20: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      23: ldc           #8                  // String tryCatchReturn</span><br><span class="line">      25: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">28</span>: aload_1</span><br><span class="line">      <span class="number">29</span>: areturn  <span class="comment">//返回ERROR字符串</span></span><br><span class="line">      <span class="number">30</span>: astore_2</span><br><span class="line">      31: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      34: ldc           #8                  // String tryCatchReturn</span><br><span class="line">      36: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">39</span>: aload_2</span><br><span class="line">      <span class="number">40</span>: athrow  如果<span class="keyword">catch</span>有未处理的异常，抛出去。</span><br></pre></td></tr></table></figure>
<h2 id="异常是否耗时？为什么会耗时？"><a href="#异常是否耗时？为什么会耗时？" class="headerlink" title="异常是否耗时？为什么会耗时？"></a>异常是否耗时？为什么会耗时？</h2><p>说用异常慢，首先来看看异常慢在哪里？有多慢？下面的测试用例简单的测试了建立对象、建立异常对象、抛出并接住异常对象三者的耗时对比：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> testTimes;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExceptionTest</span><span class="params">(<span class="keyword">int</span> testTimes)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.testTimes = testTimes;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newObject</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> l = System.nanoTime();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> Object();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;建立对象：&quot;</span> + (System.nanoTime() - l));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newException</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> l = System.nanoTime();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> Exception();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;建立异常对象：&quot;</span> + (System.nanoTime() - l));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchException</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> l = System.nanoTime();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;建立、抛出并接住异常对象：&quot;</span> + (System.nanoTime() - l));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        ExceptionTest test = <span class="keyword">new</span> ExceptionTest(<span class="number">10000</span>);  </span><br><span class="line">        test.newObject();  </span><br><span class="line">        test.newException();  </span><br><span class="line">        test.catchException();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">建立对象：<span class="number">575817</span>  </span><br><span class="line">建立异常对象：<span class="number">9589080</span>  </span><br><span class="line">建立、抛出并接住异常对象：<span class="number">47394475</span>    </span><br></pre></td></tr></table></figure>
<p>建立一个异常对象，是建立一个普通Object耗时的约20倍（实际上差距会比这个数字更大一些，因为循环也占用了时间，追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分），而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。</p>
<p>那占用时间的“大头”：抛出、接住异常，系统到底做了什么事情？请参考这篇文章：</p>
<ul>
<li><a href="https://www.iteye.com/blog/icyfenix-857722">https://www.iteye.com/blog/icyfenix-857722</a></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之泛型</title>
    <url>/posts/ae31c15e/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样</p>
</blockquote>
<a id="more"></a>

<h1 id="为什么会引入泛型"><a href="#为什么会引入泛型" class="headerlink" title="为什么会引入泛型"></a>为什么会引入泛型</h1><blockquote>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<p>引入泛型的意义在于：</p>
<p><strong>适用于多种数据类型执行相同的代码</strong>（代码复用）</p>
<p>我们通过一个例子来阐述，先看下下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Number&gt; <span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>泛型中的类型在使用时指定，不需要强制类型转换（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li>
</ul>
<p>看下这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> Person());</span><br></pre></td></tr></table></figure>
<p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现<code>java.lang.ClassCastException</code>异常。</p>
<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure>
<h1 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h1><p>我们通过一些例子来学习泛型的使用；泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>从一个简单的泛型类看起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span>&gt;</span>&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> Point&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多元泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;       <span class="comment">// 此处指定了两个泛型类型  </span></span><br><span class="line">    <span class="keyword">private</span> K key ;     <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">private</span> V value ;   <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo09</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        Notepad&lt;String,Integer&gt; t = <span class="keyword">null</span> ;        <span class="comment">// 定义两个泛型类型的对象  </span></span><br><span class="line">        t = <span class="keyword">new</span> Notepad&lt;String,Integer&gt;() ;       <span class="comment">// 里面的key为String，value为Integer  </span></span><br><span class="line">        t.setKey(<span class="string">&quot;汤姆&quot;</span>) ;        <span class="comment">// 设置第一个内容  </span></span><br><span class="line">        t.setValue(<span class="number">20</span>) ;            <span class="comment">// 设置第二个内容  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="comment">// 取得信息  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="comment">// 取得信息  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>简单的泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;        <span class="comment">// 在接口上定义泛型  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;   <span class="comment">// 定义泛型接口的子类  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;     <span class="comment">// 通过构造方法设置属性内容  </span></span><br><span class="line">        <span class="keyword">this</span>.setVar(<span class="keyword">var</span>) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo24</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arsg[])</span></span>&#123;  </span><br><span class="line">        Info&lt;String&gt; i = <span class="keyword">null</span>;        <span class="comment">// 声明接口对象  </span></span><br><span class="line">        i = <span class="keyword">new</span> InfoImpl&lt;String&gt;(<span class="string">&quot;汤姆&quot;</span>) ;  <span class="comment">// 通过子类实例化对象  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + i.getVar()) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型方法，是在调用方法的时候指明泛型的具体类型。重点看下泛型的方法（图参考自：<a href="https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html%EF%BC%89">https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html）</a></p>
<ul>
<li>定义泛型方法语法格式</li>
</ul>
<p><img src="https://www.pdai.tech/_images/java/java-basic-generic-4.png" alt="img"></p>
<ul>
<li>调用泛型方法语法格式</li>
</ul>
<p><img src="https://www.pdai.tech/_images/java/java-basic-generic-5.png" alt="img"></p>
<p>说明一下，定义泛型方法时，必须在返回值前边加一个<code>&lt;T&gt;</code>，来声明这是一个泛型方法，持有一个泛型<code>T</code>，然后才可以用泛型T作为方法的返回值。</p>
<p><code>Class&lt;T&gt;</code>的作用就是指明泛型的具体类型，而<code>Class&lt;T&gt;</code>类型的变量c，可以用来创建泛型类的对象。</p>
<p>为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p>
<p>泛型方法要求的参数是<code>Class&lt;T&gt;</code>类型，而<code>Class.forName()</code>方法的返回值也是<code>Class&lt;T&gt;</code>，因此可以用<code>Class.forName()</code>作为参数。其中，<code>forName()</code>方法中的参数是何种类型，返回的<code>Class&lt;T&gt;</code>就是何种类型。在本例中，<code>forName()</code>方法中传入的是User类的完整路径，因此返回的是<code>Class&lt;User&gt;</code>类型的对象，因此调用泛型方法时，变量c的类型就是<code>Class&lt;User&gt;</code>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。</p>
<p>当然，泛型方法不是仅仅可以有一个参数<code>Class&lt;T&gt;</code>，可以根据需要添加其他参数。</p>
<p><strong>为什么要使用泛型方法呢</strong>？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<h2 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h2><p><strong>先看下如下的代码，很明显是会报错的</strong> （具体错误原因请参考后文）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下两个方法不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    funA(b);</span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下funD方法会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">(List&lt;A&gt; listA)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funD</span><span class="params">(List&lt;B&gt; listB)</span> </span>&#123;</span><br><span class="line">    funC(listB); <span class="comment">// Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;)</span></span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>那么如何解决呢？</p>
<p>为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。<code>&lt;? extends A&gt;</code>表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">(List&lt;? extends A&gt; listA)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funD</span><span class="params">(List&lt;B&gt; listB)</span> </span>&#123;</span><br><span class="line">    funC(listB); <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// ...             </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>泛型上下限的引入</strong></p>
<p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<p>上限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;    <span class="comment">// 此处泛型只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;Integer&gt; i1 = <span class="keyword">new</span> Info&lt;Integer&gt;() ;        <span class="comment">// 声明Integer的泛型对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>下限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo21</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> Info&lt;String&gt;() ;        <span class="comment">// 声明String的泛型对象</span></span><br><span class="line">        Info&lt;Object&gt; i2 = <span class="keyword">new</span> Info&lt;Object&gt;() ;        <span class="comment">// 声明Object的泛型对象</span></span><br><span class="line">        i1.setVar(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        i2.setVar(<span class="keyword">new</span> Object()) ;</span><br><span class="line">        fun(i1) ;</span><br><span class="line">        fun(i2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;? <span class="keyword">super</span> String&gt; temp)</span></span>&#123;    <span class="comment">// 只能接收String或Object类型的泛型，String类的父类只有Object类</span></span><br><span class="line">        System.out.print(temp + <span class="string">&quot;, &quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?&gt; 无限制通配符</span><br><span class="line">&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类</span><br><span class="line">&lt;? <span class="keyword">super</span> E&gt; <span class="keyword">super</span> 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原则《Effictive Java》</span></span><br><span class="line"><span class="comment">// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</span></span><br><span class="line"><span class="number">1.</span> 如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;</span><br><span class="line"><span class="number">2.</span> 如果它表示一个 T 的消费者，就使用 &lt; ? <span class="keyword">super</span> T&gt;；</span><br><span class="line"><span class="number">3.</span> 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</span><br></pre></td></tr></table></figure>
<p>再看一个实际例子，<strong>加深印象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">E <span class="title">max</span><span class="params">(List&lt;? extends E&gt; e1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器返回的元素属于 E 的某个子类型</span></span><br><span class="line">    Iterator&lt;? extends E&gt; iterator = e1.iterator();</span><br><span class="line">    E result = iterator.next();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        E next = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (next.compareTo(result) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的类型参数 E 的范围是<code>&lt;E extends Comparable&lt;? super E&gt;&gt;</code>，我们可以分步查看：</p>
<ul>
<li>要进行比较，所以 E 需要是可比较的类，因此需要 <code>extends Comparable&lt;…&gt;</code>（注意这里不要和继承的 <code>extends</code> 搞混了，不一样）</li>
<li><code>Comparable&lt; ? super E&gt;</code> 要对 E 进行比较，即 E 的消费者，所以需要用 super</li>
<li>而参数 <code>List&lt; ? extends E&gt;</code> 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大</li>
<li><strong>多个限制</strong></li>
</ul>
<p>使用&amp;符号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">//工资低于2500元的上斑族并且站立的乘客车票打8折</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Staff &amp; Passenger&gt; <span class="function"><span class="keyword">void</span> <span class="title">discount</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.getSalary()&lt;<span class="number">2500</span> &amp;&amp; t.isStanding())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜你！您的车票打八折！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        discount(<span class="keyword">new</span> Me());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><blockquote>
<p>具体可以参考下文中关于泛型数组的理解。</p>
</blockquote>
<p>首先，我们泛型数组相关的申明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] list11 = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;String&gt;[] list12 = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，需要强转类型 </span></span><br><span class="line">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告 </span></span><br><span class="line">List&lt;?&gt;[] list14 = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;?&gt;[] list15 = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] list6 = <span class="keyword">new</span> ArrayList[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></table></figure>
<p>那么通常我们如何用呢？</p>
<ul>
<li>讨巧的使用场景</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo30</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        Integer i[] = fun1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) ;   <span class="comment">// 返回泛型数组  </span></span><br><span class="line">        fun2(i) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] fun1(T...arg)&#123;  <span class="comment">// 接收可变参数  </span></span><br><span class="line">        <span class="keyword">return</span> arg ;            <span class="comment">// 返回泛型数组  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(T param[])</span></span>&#123;   <span class="comment">// 输出  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;接收泛型数组：&quot;</span>) ;  </span><br><span class="line">        <span class="keyword">for</span>(T t:param)&#123;  </span><br><span class="line">            System.out.print(t + <span class="string">&quot;、&quot;</span>) ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>合理使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    array = (T[]) Array.newInstance(type, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="深入理解泛型"><a href="#深入理解泛型" class="headerlink" title="深入理解泛型"></a>深入理解泛型</h1><p>我们通过泛型背后的类型擦除以及相关的问题来进一步理解泛型。</p>
<h2 id="如何理解Java中的泛型是伪泛型？泛型中类型擦除"><a href="#如何理解Java中的泛型是伪泛型？泛型中类型擦除" class="headerlink" title="如何理解Java中的泛型是伪泛型？泛型中类型擦除"></a>如何理解Java中的泛型是伪泛型？泛型中类型擦除</h2><blockquote>
<p>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。</p>
</blockquote>
<p><strong>泛型的类型擦除原则</strong>是：</p>
<ul>
<li>消除类型参数声明，即删除<code>&lt;&gt;</code>及其包围的部分。</li>
<li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li>
<li>为了保证类型安全，必要时插入强制类型转换代码。</li>
<li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li>
</ul>
<p><strong>那么如何进行擦除的呢</strong>？</p>
<ul>
<li>擦除类定义中的类型参数 - 无限制类型擦除</li>
</ul>
<p>当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如<code>&lt;T&gt;</code>和<code>&lt;?&gt;</code>的类型参数都被替换为Object。</p>
<p><img src="https://www.pdai.tech/_images/java/java-basic-generic-1.png" alt="img"></p>
<ul>
<li>擦除类定义中的类型参数 - 有限制类型擦除</li>
</ul>
<p>当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如<code>&lt;T extends Number&gt;</code>和<code>&lt;? extends Number&gt;</code>的类型参数被替换为<code>Number</code>，<code>&lt;? super Number&gt;</code>被替换为Object。</p>
<p><img src="https://www.pdai.tech/_images/java/java-basic-generic-2.png" alt="img"></p>
<ul>
<li>擦除方法定义中的类型参数</li>
</ul>
<p>擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。</p>
<p><img src="https://www.pdai.tech/_images/java/java-basic-generic-3.png" alt="img"></p>
<h2 id="如何证明类型的擦除呢？"><a href="#如何证明类型的擦除呢？" class="headerlink" title="如何证明类型的擦除呢？"></a>如何证明类型的擦除呢？</h2><blockquote>
<p>我们通过两个例子证明Java类型的类型擦除</p>
</blockquote>
<ul>
<li>原始类型相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了两个ArrayList数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过list1对象和list2对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为true。说明泛型类型String和Integer都被擦除掉了，只剩下原始类型。</p>
<ul>
<li>通过反射添加其它类型元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);  <span class="comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span></span><br><span class="line"></span><br><span class="line">        list.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="string">&quot;asd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p>
<h2 id="如何理解类型擦除后保留的原始类型"><a href="#如何理解类型擦除后保留的原始类型" class="headerlink" title="如何理解类型擦除后保留的原始类型?"></a>如何理解类型擦除后保留的原始类型?</h2><blockquote>
<p>在上面，两次提到了原始类型，什么是原始类型？</p>
</blockquote>
<p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>
<ul>
<li>原始类型Object</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Pair的原始类型为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在<code>Pair&lt;T&gt;</code>中，<code>T</code> 是一个无限定的类型变量，所以用Object替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的Pair，如<code>Pair&lt;String&gt;</code>或<code>Pair&lt;Integer&gt;</code>，但是擦除类型后他们的就成为原始的Pair类型了，原始类型都是Object。</p>
<p>从上面章节，我们也可以明白ArrayList被擦除类型后，原始类型也变为Object，所以通过反射我们就可以存储字符串了。</p>
<p>如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。</p>
<p>比如: Pair这样声明的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>那么原始类型就是Comparable。</p>
<p>要区分原始类型和泛型变量的类型。</p>
<p>在调用泛型方法时，可以指定泛型，也可以不指定泛型:</p>
<ul>
<li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li>
<li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="keyword">int</span> i = Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        Number f = Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        Object o = Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="keyword">int</span> a = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="keyword">int</span> b = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        Number c = Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。</p>
<ul>
<li>Object泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();  </span><br><span class="line">    list.add(<span class="number">1</span>);  </span><br><span class="line">    list.add(<span class="string">&quot;121&quot;</span>);  </span><br><span class="line">    list.add(<span class="keyword">new</span> Date());  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="如何理解泛型的编译期检查？"><a href="#如何理解泛型的编译期检查？" class="headerlink" title="如何理解泛型的编译期检查？"></a>如何理解泛型的编译期检查？</h2><blockquote>
<p>既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p>
</blockquote>
<p>Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);  </span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">//编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p>
<p>那么，<strong>这个类型检查是针对谁的呢</strong>？我们先看看参数化类型和原始类型的兼容。</p>
<p>以 ArrayList举例子，以前的写法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();  </span><br></pre></td></tr></table></figure>
<p>现在的写法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList(); <span class="comment">//第一种 情况</span></span><br><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//第二种 情况</span></span><br></pre></td></tr></table></figure>
<p>这样是没有错误的，不过会有个编译时警告。</p>
<p>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p>
<p>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。</p>
<p>举例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList();  </span><br><span class="line">        list1.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        list1.add(<span class="number">1</span>); <span class="comment">//编译错误  </span></span><br><span class="line">        String str1 = list1.get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span></span><br><span class="line"></span><br><span class="line">        ArrayList list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">        list2.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        list2.add(<span class="number">1</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        Object object = list2.get(<span class="number">0</span>); <span class="comment">//返回类型就是Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="number">22</span>); <span class="comment">//编译错误  </span></span><br><span class="line"></span><br><span class="line">        String str2 = <span class="keyword">new</span> ArrayList&lt;String&gt;().get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>通过上面的例子，我们可以明白，<strong>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象</strong>。</p>
<p><strong>泛型中参数话类型为什么不考虑继承关系</strong>？</p>
<p>在Java中，像下面形式的引用传递是不允许的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;(); <span class="comment">//编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p>我们先看第一种情况，将第一种情况拓展成下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();  </span><br><span class="line">list1.add(<span class="keyword">new</span> Object());  </span><br><span class="line">list1.add(<span class="keyword">new</span> Object());  </span><br><span class="line">ArrayList&lt;String&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p>实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有<code>ClassCastException</code>了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p>
<p>再看第二种情况，将第二种情况拓展成下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">list1.add(<span class="keyword">new</span> String());  </span><br><span class="line">list1.add(<span class="keyword">new</span> String());</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Object&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p>没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。</p>
<p>我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？</p>
<p>所以，要格外注意，泛型中的引用传递的问题。</p>
<h2 id="如何理解泛型的多态？泛型的桥接方法"><a href="#如何理解泛型的多态？泛型的桥接方法" class="headerlink" title="如何理解泛型的多态？泛型的桥接方法"></a>如何理解泛型的多态？泛型的桥接方法</h2><blockquote>
<p>类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。</p>
</blockquote>
<p>现在有这样一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们想要一个子类继承它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在这个子类中，我们设定父类的泛型类型为<code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.value = value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的<code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p>
<p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>再看子类的两个重写的方法的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>.setValue(value);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class="line">        DateInter dateInter = <span class="keyword">new</span> DateInter();  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> Date());                  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> Object()); <span class="comment">//编译错误  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，却是是重写了，而不是重载了。</p>
<p><strong>为什么会这样呢</strong>？</p>
<p>原因是这样的，我们传入父类的泛型类型是Date，<code>Pair&lt;Date&gt;</code>，我们的本意是将泛型类变为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Date value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p>
<p>可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。</p>
<blockquote>
<p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。</p>
</blockquote>
<p>首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">tao</span>.<span class="title">test</span>.<span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">tao</span>.<span class="title">test</span>.<span class="title">Pair</span>&lt;<span class="title">java</span>.<span class="title">util</span>.<span class="title">Date</span>&gt; </span>&#123;  </span><br><span class="line">  com.tao.test.DateInter();  </span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       1: invokespecial #8                  // Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.util.Date)</span></span>;  <span class="comment">//我们重写的setValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       2: invokespecial #16                 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.<span class="function">Date <span class="title">getValue</span><span class="params">()</span></span>;    <span class="comment">//我们重写的getValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       1: invokespecial #23                 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span><br><span class="line">       4: checkcast     #26                 // class java/util/Date  </span><br><span class="line">       <span class="number">7</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getValue</span><span class="params">()</span></span>;     <span class="comment">//编译时由编译器生成的巧方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       1: invokevirtual #28                 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span><br><span class="line">       <span class="number">4</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.lang.Object)</span></span>;   <span class="comment">//编译时由编译器生成的巧方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       2: checkcast     #26                 // class java/util/Date  </span><br><span class="line">       5: invokevirtual #30                 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p>
<p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p>
<p>不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。</p>
<p>setValue方法是为了解决类型擦除与多态之间的冲突。</p>
<p>而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p>
<p>那么父类的setValue方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectgetValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而子类重写的方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。</p>
<p>并且，还有一点也许会有疑问，子类中的巧方法<code>Object getValue()</code>和<code>Date getValue()</code>是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p>
<h2 id="如何理解基本类型不能作为泛型类型？"><a href="#如何理解基本类型不能作为泛型类型？" class="headerlink" title="如何理解基本类型不能作为泛型类型？"></a>如何理解基本类型不能作为泛型类型？</h2><blockquote>
<p>比如，我们没有<code>ArrayList&lt;int&gt;</code>，只有<code>ArrayList&lt;Integer&gt;</code>, 为何？</p>
</blockquote>
<p>因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p>
<p>另外需要注意，我们能够使用<code>list.add(1)</code>是因为Java基础类型的自动装箱拆箱操作。</p>
<h2 id="如何理解泛型类型不能实例化？"><a href="#如何理解泛型类型不能实例化？" class="headerlink" title="如何理解泛型类型不能实例化？"></a>如何理解泛型类型不能实例化？</h2><blockquote>
<p>不能实例化泛型类型, 这本质上是由于类型擦除决定的：</p>
</blockquote>
<p>我们可以看到如下代码会在编译器中报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T test = <span class="keyword">new</span> T(); <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>
<p>因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于<code>T</code> 被擦除为 <code>Object</code>，如果可以 <code>new T()</code> 则就变成了 <code>new Object()</code>，失去了本意。   如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newTclass</span> <span class="params">(Class &lt; T &gt; clazz)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    T obj = clazz.newInstance();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型数组：能不能采用具体的泛型类型进行初始化？"><a href="#泛型数组：能不能采用具体的泛型类型进行初始化？" class="headerlink" title="泛型数组：能不能采用具体的泛型类型进行初始化？"></a>泛型数组：能不能采用具体的泛型类型进行初始化？</h2><p>我们先来看下Oracle官网提供的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.</span></span><br><span class="line">Object o = lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check</span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error ClassCastException.</span></span><br></pre></td></tr></table></figure>
<p>由于 JVM 泛型的擦除机制，所以上面代码可以给 <code>oa[1]</code> 赋值为 ArrayList 也不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现 <code>ClassCastException</code>，如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误，只有在运行时才会出错，但是泛型的出现就是为了消灭 <code>ClassCastException</code>，所以如果 Java 支持泛型数组初始化操作就是搬起石头砸自己的脚。</p>
<p>而对于下面的代码来说是成立的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.</span></span><br><span class="line">Object o = lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.</span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>所以说采用通配符的方式初始化泛型数组是允许的，因为对于通配符的方式最后取出数据是要做显式类型转换的，符合预期逻辑。综述就是说Java 的泛型数组初始化时数组类型不能是具体的泛型类型，只能是通配符的形式，因为具体类型会导致可存入任意类型对象，在取出时会发生类型转换异常，会与泛型的设计思想冲突，而通配符形式本来就需要自己强转，符合预期。</p>
<p>Oracle 官方文档：<a href="https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html(opens new window)</a></p>
<p>更进一步的，我们看看如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] list11 = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;String&gt;[] list12 = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，需要强转类型 </span></span><br><span class="line">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告 </span></span><br><span class="line">List&lt;?&gt;[] list14 = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;?&gt;[] list15 = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] list6 = <span class="keyword">new</span> ArrayList[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告  </span></span><br></pre></td></tr></table></figure>
<p>因为在 Java 中是不能创建一个确切的泛型类型的数组的，除非是采用通配符的方式且要做显式类型转换才可以。</p>
<h2 id="泛型数组：如何正确的初始化泛型数组实例？"><a href="#泛型数组：如何正确的初始化泛型数组实例？" class="headerlink" title="泛型数组：如何正确的初始化泛型数组实例？"></a>泛型数组：如何正确的初始化泛型数组实例？</h2><blockquote>
<p>这个无论我们通过<code>new ArrayList[10]</code> 的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的，也就是说仅仅语法合格，运行时潜在的风险需要我们自己来承担，因此那些方式初始化泛型数组都不是最优雅的方式。</p>
</blockquote>
<p>我们在使用到泛型数组的场景下应该尽量使用列表集合替换，此外也可以通过使用 <code>java.lang.reflect.Array.newInstance(Class&lt;T&gt; componentType, int length)</code> 方法来创建一个具有指定类型和维度的数组，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] create() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">ArrayWithTypeToken&lt;Integer&gt; arrayToken = <span class="keyword">new</span> ArrayWithTypeToken&lt;Integer&gt;(Integer.class, <span class="number">100</span>);</span><br><span class="line">Integer[] array = arrayToken.create();</span><br></pre></td></tr></table></figure>
<p>所以使用反射来初始化泛型数组算是优雅实现，因为泛型类型 <code>T</code>在运行时才能被确定下来，我们能创建泛型数组也必然是在 Java 运行时想办法，而运行时能起作用的技术最好的就是反射了。</p>
<h2 id="如何理解泛型类中的静态方法和静态变量？"><a href="#如何理解泛型类中的静态方法和静态变量？" class="headerlink" title="如何理解泛型类中的静态方法和静态变量？"></a>如何理解泛型类中的静态方法和静态变量？</h2><blockquote>
<p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p>
</blockquote>
<p>举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one;   <span class="comment">//编译错误    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title">show</span><span class="params">(T one)</span></span>&#123; <span class="comment">//编译错误    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p>
<p>但是要注意区分下面的一种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T &gt;<span class="function">T <span class="title">show</span><span class="params">(T one)</span></span>&#123; <span class="comment">//这是正确的    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。</p>
<h2 id="如何理解异常中使用泛型？"><a href="#如何理解异常中使用泛型？" class="headerlink" title="如何理解异常中使用泛型？"></a>如何理解异常中使用泛型？</h2><p><strong>不能抛出也不能捕获泛型类的对象</strong>。事实上，泛型类扩展Throwable都不合法。例如：下面的定义将不会通过编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么不能扩展Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，在看下面的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Integer&gt; e1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Number&gt; e2) &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>类型信息被擦除后，那么两个地方的catch都变为原始类型Object，那么也就是说，这两个地方的catch变的一模一样,就相当于下面的这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Object&gt; e1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Problem&lt;Object&gt; e2) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个当然就是不行的。</p>
<p><strong>不能再catch子句中使用泛型变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span>(T e) &#123; <span class="comment">//编译错误</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为泛型信息在编译的时候已经变味原始类型，也就是说上面的T会变为原始类型Throwable，那么如果可以再catch子句中使用泛型变量，那么，下面的定义呢：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(T e) &#123; <span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(IndexOutOfBounds e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;                         </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。即使你在使用该静态方法的使用T是<code>ArrayIndexOutofBounds</code>，在编译之后还是会变成Throwable，<code>ArrayIndexOutofBounds</code>是IndexOutofBounds的子类，违背了异常捕获的原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。</p>
<ul>
<li>但是在异常声明中可以使用类型变量。下面方法是合法的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable realCause) &#123;</span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>上面的这样使用是没问题的。</p>
<h2 id="如何获取泛型的参数类型？"><a href="#如何获取泛型的参数类型？" class="headerlink" title="如何获取泛型的参数类型？"></a>如何获取泛型的参数类型？</h2><blockquote>
<p>既然类型被擦除了，那么如何获取泛型的参数类型呢？可以通过反射（<code>java.lang.reflect.Type</code>）获取泛型</p>
</blockquote>
<p><code>java.lang.reflect.Type</code>是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericType&lt;String&gt; genericType = <span class="keyword">new</span> GenericType&lt;String&gt;() &#123;&#125;;</span><br><span class="line">        Type superclass = genericType.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="comment">//getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line">        Type type = ((ParameterizedType) superclass).getActualTypeArguments()[<span class="number">0</span>]; </span><br><span class="line">        System.out.println(type);<span class="comment">//class java.lang.String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ParameterizedType</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回当前class或interface声明的类型, 如List&lt;?&gt;返回List</span></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null </span></span><br><span class="line">    <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之注解</title>
    <url>/posts/7f462002/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它是框架学习和设计者必须掌握的基础</p>
</blockquote>
<a id="more"></a>

<h1 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h1><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>
</ul>
<p>这么来说是比较抽象的，我们具体看下注解的常见分类：</p>
<ul>
<li><strong>Java自带的标准注解</strong>，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li>
<li><strong>元注解</strong>，元注解是用于定义注解的注解，包括<code>@Retention</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Documented</code>，<code>@Retention</code>用于标明注解被保留的阶段，<code>@Target</code>用于标明注解使用的范围，<code>@Inherited</code>用于标明注解可继承，<code>@Documented</code>用于标明是否生成javadoc文档。</li>
<li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li>
</ul>
<p>接下来我们通过这个分类角度来理解注解。</p>
<h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><p>我们从最为常见的Java内置的注解开始说起，先看下下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 重载父类的test方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 被弃用的方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oldMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 忽略告警</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">processList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>Java 1.5开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>：</p>
<ul>
<li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li>
<li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li>
<li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li>
</ul>
<p>我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。</p>
<h3 id="内置注解-Override"><a href="#内置注解-Override" class="headerlink" title="内置注解 - @Override"></a>内置注解 - @Override</h3><p>我们先来看一下这个注解类型的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。</p>
<h3 id="内置注解-Deprecated"><a href="#内置注解-Deprecated" class="headerlink" title="内置注解 - @Deprecated"></a>内置注解 - @Deprecated</h3><p>这个注解的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p>
<h3 id="内置注解-SuppressWarnings"><a href="#内置注解-SuppressWarnings" class="headerlink" title="内置注解 - @SuppressWarnings"></a>内置注解 - @SuppressWarnings</h3><p>这个注解我们也比较常用到，先来看下它的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>原描述</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>抑制所有警告</td>
<td>to suppress all warnings</td>
</tr>
<tr>
<td>boxing</td>
<td>抑制装箱、拆箱操作时候的警告</td>
<td>to suppress warnings relative to boxing/unboxing operations</td>
</tr>
<tr>
<td>cast</td>
<td>抑制映射相关的警告</td>
<td>to suppress warnings relative to cast operations</td>
</tr>
<tr>
<td>dep-ann</td>
<td>抑制启用注释的警告</td>
<td>to suppress warnings relative to deprecated annotation</td>
</tr>
<tr>
<td>deprecation</td>
<td>抑制过期方法警告</td>
<td>to suppress warnings relative to deprecation</td>
</tr>
<tr>
<td>fallthrough</td>
<td>抑制确在switch中缺失breaks的警告</td>
<td>to suppress warnings relative to missing breaks in switch statements</td>
</tr>
<tr>
<td>finally</td>
<td>抑制finally模块没有返回的警告</td>
<td>to suppress warnings relative to finally block that don’t return</td>
</tr>
<tr>
<td>hiding</td>
<td>抑制与隐藏变数的区域变数相关的警告</td>
<td>to suppress warnings relative to locals that hide variable（）</td>
</tr>
<tr>
<td>incomplete-switch</td>
<td>忽略没有完整的switch语句</td>
<td>to suppress warnings relative to missing entries in a switch statement (enum case)</td>
</tr>
<tr>
<td>nls</td>
<td>忽略非nls格式的字符</td>
<td>to suppress warnings relative to non-nls string literals</td>
</tr>
<tr>
<td>null</td>
<td>忽略对null的操作</td>
<td>to suppress warnings relative to null analysis</td>
</tr>
<tr>
<td>rawtype</td>
<td>使用generics时忽略没有指定相应的类型</td>
<td>to suppress warnings relative to un-specific types when using</td>
</tr>
<tr>
<td>restriction</td>
<td>抑制与使用不建议或禁止参照相关的警告</td>
<td>to suppress warnings relative to usage of discouraged or</td>
</tr>
<tr>
<td>serial</td>
<td>忽略在serializable类中没有声明serialVersionUID变量</td>
<td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td>
</tr>
<tr>
<td>static-access</td>
<td>抑制不正确的静态访问方式警告</td>
<td>to suppress warnings relative to incorrect static access</td>
</tr>
<tr>
<td>synthetic-access</td>
<td>抑制子类没有按最优方法访问内部类的警告</td>
<td>to suppress warnings relative to unoptimized access from inner classes</td>
</tr>
<tr>
<td>unchecked</td>
<td>抑制没有进行类型检查操作的警告</td>
<td>to suppress warnings relative to unchecked operations</td>
</tr>
<tr>
<td>unqualified-field-access</td>
<td>抑制没有权限访问的域的警告</td>
<td>to suppress warnings relative to field access unqualified</td>
</tr>
<tr>
<td>unused</td>
<td>抑制没被使用过的代码的警告</td>
<td>to suppress warnings relative to unused code</td>
</tr>
</tbody></table>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：<code>@Target</code>，<code>@Retention</code>，<code>@Documented</code>，<code>@Inherited</code>, 在JDK 1.8中提供了两个元注解 <code>@Repeatable</code>和<code>@Native</code>。</p>
<h3 id="元注解-Target"><a href="#元注解-Target" class="headerlink" title="元注解 - @Target"></a>元注解 - @Target</h3><blockquote>
<p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。</p>
</blockquote>
<p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    TYPE, <span class="comment">// 类、接口、枚举类</span></span><br><span class="line"> </span><br><span class="line">    FIELD, <span class="comment">// 成员变量（包括：枚举常量）</span></span><br><span class="line"> </span><br><span class="line">    METHOD, <span class="comment">// 成员方法</span></span><br><span class="line"> </span><br><span class="line">    PARAMETER, <span class="comment">// 方法参数</span></span><br><span class="line"> </span><br><span class="line">    CONSTRUCTOR, <span class="comment">// 构造方法</span></span><br><span class="line"> </span><br><span class="line">    LOCAL_VARIABLE, <span class="comment">// 局部变量</span></span><br><span class="line"> </span><br><span class="line">    ANNOTATION_TYPE, <span class="comment">// 注解类</span></span><br><span class="line"> </span><br><span class="line">    PACKAGE, <span class="comment">// 可用于修饰：包</span></span><br><span class="line"> </span><br><span class="line">    TYPE_PARAMETER, <span class="comment">// 类型参数，JDK 1.8 新增</span></span><br><span class="line"> </span><br><span class="line">    TYPE_USE <span class="comment">// 使用类型的任何地方，JDK 1.8 新增</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元注解-Retention-amp-RetentionTarget"><a href="#元注解-Retention-amp-RetentionTarget" class="headerlink" title="元注解 - @Retention &amp; @RetentionTarget"></a>元注解 - @Retention &amp; @RetentionTarget</h3><blockquote>
<p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。</p>
</blockquote>
<p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    SOURCE,    <span class="comment">// 源文件保留</span></span><br><span class="line">    CLASS,       <span class="comment">// 编译期保留，默认值</span></span><br><span class="line">    RUNTIME   <span class="comment">// 运行期保留，可通过反射去获取注解信息</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SourcePolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClassPolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RuntimePolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>用定义好的三个注解类分别去注解一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetentionTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@SourcePolicy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sourcePolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@ClassPolicy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@RuntimePolicy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runtimePolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>通过执行 <code>javap -verbose RetentionTest</code>命令获取到的RetentionTest 的 class 字节码内容如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> retention.RetentionTest();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sourcePolicy</span><span class="params">()</span></span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classPolicy</span><span class="params">()</span></span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">    RuntimeInvisibleAnnotations:</span><br><span class="line">      0: #11()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runtimePolicy</span><span class="params">()</span></span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      0: #14()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 RetentionTest 的字节码内容我们可以得出以下两点结论：</p>
<ul>
<li>编译器并没有记录下 sourcePolicy() 方法的注解信息；</li>
<li>编译器分别使用了 <code>RuntimeInvisibleAnnotations</code> 和 <code>RuntimeVisibleAnnotations</code> 属性去记录了<code>classPolicy()</code>方法 和 <code>runtimePolicy()</code>方法 的注解信息；</li>
</ul>
<h3 id="元注解-Documented"><a href="#元注解-Documented" class="headerlink" title="元注解 - @Documented"></a>元注解 - @Documented</h3><blockquote>
<p>Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p>
</blockquote>
<p>以下代码在使用Javadoc工具可以生成<code>@TestDocAnnotation</code>注解信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestDocAnnotation &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;<span class="keyword">default</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestDocAnnotation(&quot;myMethodDoc&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDoc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h3 id="元注解-Inherited"><a href="#元注解-Inherited" class="headerlink" title="元注解 - @Inherited"></a>元注解 - @Inherited</h3><blockquote>
<p>Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
</blockquote>
<p>我们来测试下这个注解：</p>
<p>定义<code>@Inherited</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestInheritedAnnotation &#123;</span><br><span class="line">    String [] values();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">number</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>使用这个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestInheritedAnnotation(values = &#123;&quot;value&quot;&#125;, number = 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = Student.class;</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xxxxxxx.TestInheritedAnnotation(values=[value], number=<span class="number">10</span>)   </span><br></pre></td></tr></table></figure>
<p>即使Student类没有显示地被注解<code>@TestInheritedAnnotation</code>，但是它的父类Person被注解，而且<code>@TestInheritedAnnotation</code>被<code>@Inherited</code>注解，因此Student类自动有了该注解。</p>
<h3 id="元注解-Repeatable-Java8"><a href="#元注解-Repeatable-Java8" class="headerlink" title="元注解 - @Repeatable (Java8)"></a>元注解 - @Repeatable (Java8)</h3><p><code>@Repeatable</code>允许在同一申明类型(类，属性，或方法)的多次使用同一个注解</p>
<h3 id="元注解-Native-Java8"><a href="#元注解-Native-Java8" class="headerlink" title="元注解 - @Native (Java8)"></a>元注解 - @Native (Java8)</h3><p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p>
<h2 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h2><blockquote>
<p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p>
</blockquote>
<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口</p>
<ul>
<li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li>
</ul>
<p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p>
<ul>
<li><code>Annotation[] getAnnotations()</code></li>
</ul>
<p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p>
<ul>
<li><code>Annotation[] getDeclaredAnnotations()</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><blockquote>
<p>当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：</p>
</blockquote>
<p>定义自己的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.java.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMethodAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">title</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>使用注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.java.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMethodAnnotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@MyMethodAnnotation(title = &quot;toStringMethod&quot;, description = &quot;override toString method&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Override toString method&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@MyMethodAnnotation(title = &quot;old static method&quot;, description = &quot;deprecated old static method&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;old method, don&#x27;t use it.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@MyMethodAnnotation(title = &quot;test method&quot;, description = &quot;suppress warning static method&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">genericsTest</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        List l = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        l.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        oldMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>用反射接口获取注解信息</p>
<p>在TestMethodAnnotation中添加Main方法进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取所有methods</span></span><br><span class="line">        Method[] methods = TestMethodAnnotation.class.getClassLoader()</span><br><span class="line">                .loadClass((<span class="string">&quot;com.pdai.java.annotation.TestMethodAnnotation&quot;</span>))</span><br><span class="line">                .getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 方法上是否有MyMethodAnnotation注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyMethodAnnotation.class)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取并遍历方法上的所有注解</span></span><br><span class="line">                    <span class="keyword">for</span> (Annotation anno : method.getDeclaredAnnotations()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Annotation in Method &#x27;&quot;</span></span><br><span class="line">                                + method + <span class="string">&quot;&#x27; : &quot;</span> + anno);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取MyMethodAnnotation对象信息</span></span><br><span class="line">                    MyMethodAnnotation methodAnno = method</span><br><span class="line">                            .getAnnotation(MyMethodAnnotation.class);</span><br><span class="line"></span><br><span class="line">                    System.out.println(methodAnno.title());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>测试的输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Annotation in Method <span class="string">&#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27;</span> : <span class="meta">@java</span>.lang.Deprecated()</span><br><span class="line">Annotation in Method <span class="string">&#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27;</span> : <span class="meta">@com</span>.pdai.java.annotation.MyMethodAnnotation(title=old <span class="keyword">static</span> method, description=deprecated old <span class="keyword">static</span> method)</span><br><span class="line">old <span class="keyword">static</span> method</span><br><span class="line">Annotation in Method <span class="string">&#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.genericsTest() throws java.io.FileNotFoundException&#x27;</span> : <span class="meta">@com</span>.pdai.java.annotation.MyMethodAnnotation(title=test method, description=suppress warning <span class="keyword">static</span> method)</span><br><span class="line">test method</span><br><span class="line">Annotation in Method <span class="string">&#x27;public java.lang.String com.pdai.java.annotation.TestMethodAnnotation.toString()&#x27;</span> : <span class="meta">@com</span>.pdai.java.annotation.MyMethodAnnotation(title=toStringMethod, description=override toString method)</span><br><span class="line">toStringMethod</span><br></pre></td></tr></table></figure>
<h1 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h1><h2 id="Java8提供了哪些新的注解？"><a href="#Java8提供了哪些新的注解？" class="headerlink" title="Java8提供了哪些新的注解？"></a>Java8提供了哪些新的注解？</h2><ul>
<li><p><code>@Repeatable</code></p>
</li>
<li><p><code>ElementType.TYPE_USE</code></p>
</li>
<li><p><code>ElementType.TYPE_PARAMETER</code></p>
</li>
</ul>
<p><code>ElementType.TYPE_USE</code>(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了<code>ElementType.TYPE</code>(类、接口（包括注解类型）和枚举的声明)和<code>ElementType.TYPE_PARAMETER</code>(类型参数声明), 不妨再看个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义ElementType.TYPE_PARAMETER注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotEmpty &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义ElementType.TYPE_USE注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotNull &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeParameterAndTypeUseAnnotation</span>&lt;@<span class="title">MyNotEmpty</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_PARAMETER类型，会编译不通过</span></span><br><span class="line"><span class="comment">//		public @MyNotEmpty T test(@MyNotEmpty T a)&#123;</span></span><br><span class="line"><span class="comment">//			new ArrayList&lt;@MyNotEmpty String&gt;();</span></span><br><span class="line"><span class="comment">//				return a;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_USE类型，编译通过</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@MyNotNull</span> <span class="function">T <span class="title">test2</span><span class="params">(<span class="meta">@MyNotNull</span> T a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ArrayList&lt;<span class="meta">@MyNotNull</span> String&gt;();</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解支持继承吗？"><a href="#注解支持继承吗？" class="headerlink" title="注解支持继承吗？"></a>注解支持继承吗？</h2><blockquote>
<p>注解是不支持继承的</p>
</blockquote>
<p>不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.</p>
<p>虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p>
<p>区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
<h2 id="注解实现的原理？"><a href="#注解实现的原理？" class="headerlink" title="注解实现的原理？"></a>注解实现的原理？</h2><ul>
<li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li>
<li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li>
</ul>
<h1 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h1><h2 id="配置化到注解化-框架的演进"><a href="#配置化到注解化-框架的演进" class="headerlink" title="配置化到注解化 - 框架的演进"></a>配置化到注解化 - 框架的演进</h2><p>Spring 框架 配置化到注解化的转变。</p>
<h2 id="继承实现到注解实现-Junit3到Junit4"><a href="#继承实现到注解实现-Junit3到Junit4" class="headerlink" title="继承实现到注解实现 - Junit3到Junit4"></a>继承实现到注解实现 - Junit3到Junit4</h2><blockquote>
<p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p>
</blockquote>
<p>被测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;hello....&quot;</span>);</span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;world....&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>Junit 3 实现UT</p>
<p>通过继承 TestCase来实现，初始化是通过Override父类方法来进行，测试方式通过test的前缀方法获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> 		<span class="keyword">super</span>.setUp();</span><br><span class="line"> 		hw=<span class="keyword">new</span> HelloWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">//1.测试没有返回值</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			hw.sayHello();</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> 			System.out.println(<span class="string">&quot;发生异常.....&quot;</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		hw.sayWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//2.测试有返回值的方法</span></span><br><span class="line"> 	<span class="comment">// 返回字符串</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSay</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//返回对象</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObj</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"> 		assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>,<span class="keyword">new</span> String());</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> 		<span class="keyword">super</span>.tearDown();</span><br><span class="line"> 		hw=<span class="keyword">null</span>;</span><br><span class="line"> 	&#125;	</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>Junit 4 实现UT</p>
<p>通过定义@Before，@Test，@After等等注解来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldTest</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@Before</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		hw = <span class="keyword">new</span> HelloWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@Test(expected=NumberFormatException.class)</span></span><br><span class="line"> 	<span class="comment">// 1.测试没有返回值,有别于junit3的使用，更加方便</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		hw.sayHello();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		hw.sayWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="comment">// 2.测试有返回值的方法</span></span><br><span class="line"> 	<span class="comment">// 返回字符串</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="comment">// 返回对象</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"> 		assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>, <span class="keyword">new</span> String());</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@After</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> 		hw = <span class="keyword">null</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现通过注解的方式，我们实现单元测试时将更为优雅。如果你还期望了解Junit4是如何实现运行的呢？可以看这篇文章：<a href="https://blog.csdn.net/weixin_34043301/article/details/91799261">JUnit4源码分析运行原理 (opens new window)</a>。</p>
<h2 id="自定义注解和AOP-通过切面实现解耦"><a href="#自定义注解和AOP-通过切面实现解耦" class="headerlink" title="自定义注解和AOP - 通过切面实现解耦"></a>自定义注解和AOP - 通过切面实现解耦</h2><blockquote>
<p>最为常见的就是使用Spring AOP切面实现<strong>统一的操作日志管理</strong>，我这里找了一个开源项目中的例子（只展示主要代码），给你展示下如何通过注解实现解耦的。</p>
</blockquote>
<p>自定义Log注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.PARAMETER, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">title</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BusinessType <span class="title">businessType</span><span class="params">()</span> <span class="keyword">default</span> BusinessType.OTHER</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作人类别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OperatorType <span class="title">operatorType</span><span class="params">()</span> <span class="keyword">default</span> OperatorType.MANAGE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否保存请求的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSaveRequestData</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现日志的切面, 对自定义注解Log作切点进行拦截</p>
<p>即对注解了@Log的方法进行切点拦截，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置织入点 - 自定义注解的包路径</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.xxx.aspectj.lang.annotation.Log)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理完请求后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;logPointCut()&quot;, returning = &quot;jsonResult&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object jsonResult)</span> </span>&#123;</span><br><span class="line">        handleLog(joinPoint, <span class="keyword">null</span>, jsonResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截异常操作</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;logPointCut()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Exception e)</span> </span>&#123;</span><br><span class="line">        handleLog(joinPoint, e, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleLog</span><span class="params">(<span class="keyword">final</span> JoinPoint joinPoint, <span class="keyword">final</span> Exception e, Object jsonResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得注解</span></span><br><span class="line">            Log controllerLog = getAnnotationLog(joinPoint);</span><br><span class="line">            <span class="keyword">if</span> (controllerLog == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前的用户</span></span><br><span class="line">            User currentUser = ShiroUtils.getSysUser();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// *========数据库日志=========*//</span></span><br><span class="line">            OperLog operLog = <span class="keyword">new</span> OperLog();</span><br><span class="line">            operLog.setStatus(BusinessStatus.SUCCESS.ordinal());</span><br><span class="line">            <span class="comment">// 请求的地址</span></span><br><span class="line">            String ip = ShiroUtils.getIp();</span><br><span class="line">            operLog.setOperIp(ip);</span><br><span class="line">            <span class="comment">// 返回参数</span></span><br><span class="line">            operLog.setJsonResult(JSONObject.toJSONString(jsonResult));</span><br><span class="line"></span><br><span class="line">            operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());</span><br><span class="line">            <span class="keyword">if</span> (currentUser != <span class="keyword">null</span>) &#123;</span><br><span class="line">                operLog.setOperName(currentUser.getLoginName());</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotNull(currentUser.getDept())</span><br><span class="line">                        &amp;&amp; StringUtils.isNotEmpty(currentUser.getDept().getDeptName())) &#123;</span><br><span class="line">                    operLog.setDeptName(currentUser.getDept().getDeptName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                operLog.setStatus(BusinessStatus.FAIL.ordinal());</span><br><span class="line">                operLog.setErrorMsg(StringUtils.substring(e.getMessage(), <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置方法名称</span></span><br><span class="line">            String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">            String methodName = joinPoint.getSignature().getName();</span><br><span class="line">            operLog.setMethod(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置请求方式</span></span><br><span class="line">            operLog.setRequestMethod(ServletUtils.getRequest().getMethod());</span><br><span class="line">            <span class="comment">// 处理设置注解上的参数</span></span><br><span class="line">            getControllerMethodDescription(controllerLog, operLog);</span><br><span class="line">            <span class="comment">// 保存数据库</span></span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exp) &#123;</span><br><span class="line">            <span class="comment">// 记录本地异常日志</span></span><br><span class="line">            log.error(<span class="string">&quot;==前置通知异常==&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>, exp.getMessage());</span><br><span class="line">            exp.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注解中对方法的描述信息 用于Controller层注解</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> log 日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog 操作日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getControllerMethodDescription</span><span class="params">(Log log, OperLog operLog)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 设置action动作</span></span><br><span class="line">        operLog.setBusinessType(log.businessType().ordinal());</span><br><span class="line">        <span class="comment">// 设置标题</span></span><br><span class="line">        operLog.setTitle(log.title());</span><br><span class="line">        <span class="comment">// 设置操作人类别</span></span><br><span class="line">        operLog.setOperatorType(log.operatorType().ordinal());</span><br><span class="line">        <span class="comment">// 是否需要保存request，参数和值</span></span><br><span class="line">        <span class="keyword">if</span> (log.isSaveRequestData()) &#123;</span><br><span class="line">            <span class="comment">// 获取参数的信息，传入到数据库中。</span></span><br><span class="line">            setRequestValue(operLog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求的参数，放到log中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRequestValue</span><span class="params">(OperLog operLog)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String[]&gt; map = ServletUtils.getRequest().getParameterMap();</span><br><span class="line">        String params = JSONObject.toJSONString(map);</span><br><span class="line">        operLog.setOperParam(StringUtils.substring(params, <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在注解，如果存在就获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Log <span class="title">getAnnotationLog</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> method.getAnnotation(Log.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@Log注解</p>
<p>以一个简单的CRUD操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/system/dept&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String prefix = <span class="string">&quot;system/dept&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDeptService deptService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增保存部门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.INSERT)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:add&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult <span class="title">addSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;新增部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.insertDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.UPDATE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:edit&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/edit&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult <span class="title">editSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dept.getParentId().equals(dept.getDeptId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，上级部门不能是自己&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.updateDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.DELETE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:remove&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/remove/&#123;deptId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult <span class="title">remove</span><span class="params">(<span class="meta">@PathVariable(&quot;deptId&quot;)</span> Long deptId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (deptService.selectDeptCount(deptId) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;存在下级部门,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (deptService.checkDeptExistUser(deptId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;部门存在用户,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.deleteDeptById(deptId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样的，你也可以看到权限管理也是通过类似的注解（<code>@RequiresPermissions</code>）机制来实现的。所以我们可以看到，通过注解+AOP最终的目标是为了实现模块的解耦。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器之ArrayList</title>
    <url>/posts/147624c7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>本文主要对Collection - ArrayList进行源码解析</p>
</blockquote>
<a id="more"></a>

<h1 id="ArrayList-简介"><a href="#ArrayList-简介" class="headerlink" title="ArrayList 简介"></a>ArrayList 简介</h1><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li>
<li><code>ArrayList</code> 实现了 <code>java.io.Serializable </code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>
</ul>
<h1 id="底层结构分析"><a href="#底层结构分析" class="headerlink" title="底层结构分析"></a>底层结构分析</h1><p>底层数据结构为数组，数组的默认大小是10，如下图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1584520436652-6b883f16-1974-4a6e-babf-1855e38a5765.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认数组大小10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//数组使用的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//当前数组的大小，没有使用volatile 修饰，非线程安全的；</span></span><br><span class="line"><span class="comment">//数组存放的容器</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>


<h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>ArrayList提供了三种初始化方法，<strong>无参数直接初始化、指定大小初始化、指定初始数据初始化。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  无参数构造器，默认是空数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定大小初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                       initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定初始数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//elementData 是保存数组的容器，默认为 null</span></span><br><span class="line">  elementData = c.toArray();</span><br><span class="line">  <span class="comment">//如果给定的集合（c）数据有值，则进行拷贝赋值操作</span></span><br><span class="line">  <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果集合元素类型不是 Object 类型，才开始拷贝，否则不执行</span></span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class) &#123;</span><br><span class="line">      elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 给定集合（c）无值，则默认空数组</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：ArrayList 无参构造器初始化时，默认大小是空数组，跟HashMap一样，都是在第一次 add 的时候进行数组的初始化。</p>
<h2 id="新增和扩容实现"><a href="#新增和扩容实现" class="headerlink" title="新增和扩容实现"></a>新增和扩容实现</h2><h3 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a><code>add</code> 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加到数组尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//确保数组大小足够，不够需要扩容</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到指定位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  rangeCheckForAdd(index);</span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                   size - index);</span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  size++;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      src      the source array. 源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      srcPos   starting position in the source array. 源数组的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      dest     the destination array. 目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      destPos  starting position in the destination data. 目标数组的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      length   the number of array elements to be copied. 复制的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span> srcPos,Object dest, </span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>
</blockquote>
<h3 id="ensureCapacityInternal-方法"><a href="#ensureCapacityInternal-方法" class="headerlink" title="ensureCapacityInternal() 方法"></a><code>ensureCapacityInternal()</code> 方法</h3><p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>
<blockquote>
<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>
</blockquote>
<h3 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们来仔细分析一下：</p>
<ul>
<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>
<li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>
<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>
</ul>
<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>
<h3 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow() 方法"></a><code>grow()</code> 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p>
<blockquote>
<p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p>
</blockquote>
<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>
<ul>
<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>
<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>
<li>以此类推······</li>
</ul>
<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>
<ul>
<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>
<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>
<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>
<h3 id="ArrayList新增方法总结"><a href="#ArrayList新增方法总结" class="headerlink" title="ArrayList新增方法总结"></a>ArrayList新增方法总结</h3><p>1.<strong>添加到数组尾部</strong>：时间复杂度O（1），看代码可知，先判断是否需要扩容，如果需要执行扩容操作，然后进行赋值。</p>
<p>2.<strong>添加到指定位置</strong>： 时间复杂度O（n）</p>
<ul>
<li><p>rangeCheckForAdd 先判断下标是否正确</p>
</li>
<li><p>ensureCapacityInternal 判断是否需要扩容</p>
</li>
<li><p>arraycopy 将原数组从下标开始的数据全部往后移一位</p>
</li>
<li><p>给指定下标的位置赋值</p>
</li>
<li><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1584526517746-ba36f2ec-69cf-41ab-ada5-86c796dbf2b1.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h3 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a><code>hugeCapacity()</code> 方法</h3><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="System-arraycopy-和-Arrays-copyOf-方法"><a href="#System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="System.arraycopy() 和 Arrays.copyOf()方法"></a><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h2><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>
<h3 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy() 方法"></a><code>System.arraycopy()</code> 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们写一个简单的方法测试以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraycopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">99</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="Arrays-copyOf-方法"><a href="#Arrays-copyOf-方法" class="headerlink" title="Arrays.copyOf()方法"></a><code>Arrays.copyOf()</code>方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayscopyOfTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b.length&quot;</span>+b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="两者联系和区别"><a href="#两者联系和区别" class="headerlink" title="两者联系和区别"></a>两者联系和区别</h3><p><strong>联系：</strong></p>
<p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>
<p><strong>区别：</strong></p>
<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>
<h2 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a><code>ensureCapacity</code>方法</h2><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>
<p>我们通过下面的代码实际测试以下这个方法的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ensureCapacity方法前：&quot;</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用ensureCapacity方法前：<span class="number">2158</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">long</span> startTime1 = System.currentTimeMillis();</span><br><span class="line">        list.ensureCapacity(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ensureCapacity方法后：&quot;</span>+(endTime1 - startTime1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用ensureCapacity方法前：1773</span><br></pre></td></tr></table></figure>
<p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>
<h2 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h2><p>ArrayList 删除元素有很多种方式，比如<strong>根据数组索引删除、根据值删除或批量删除</strong>等等，原理和思路都差不多，我们选取根据值和下标删除方式来进行说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据数组下标去删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">      System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                       numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// 方便GC，防止造成内存溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按值删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果要删除的值是 null，找到第一个值是 null 的删除</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果要删除的值不为 null，找到第一个和要删除的值相等的删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="comment">// 这里是根据  equals 来判断值相等的，相等后再根据索引位置进行删除</span></span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1584527232591-ecf8826b-bcbf-4b6c-808b-d42f5b49866b.png" alt="image"></p>
<p>我们需要注意的是：</p>
<ul>
<li>在新增的时候我有提到是可以add null的，所以删除的时候也是允许删除 null 值的，只不过是删除找到的第一个null；</li>
<li>按值删除，需要先找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，就需要我们做 equals 的具体实现。</li>
</ul>
<p><strong>总结</strong>：我们可以看出其实新增和删除都涉及到了数组的复制，这也是为什么<strong>ArrayList适合查找，LinkedList适合新增删改</strong>，但是如果是直接添加到数组尾部的话，还是很快的。但是这是有条件的，也就是我们不指定位置直接添加元素时(add(E element))，元素会默认会添加在最后，不会触发底层数组的复制，不考虑底层数组自动扩容的话，时间复杂度为O(1) ，在指定位置添加元素(add(int index, E element))，需要复制底层数组，根据最坏打算，时间复杂度是O(n)。</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>我们都知道所有集合都是Collection接口的实现类，又因为Collection继承了Iterable接口，因此所有集合都是可迭代的。我们常常会采用集合的迭代器来遍历集合元素，我们来看看ArrayList对迭代器的实现，从而深入分析为什么对集合执行相关修改操作时为什么会抛出<strong>ConcurrentModificationException</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 实现 Iterator 接口</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代过程中，下一个元素的位置，从 0 开始，用来控制拿下一个元素</span></span><br><span class="line">    <span class="keyword">int</span> cursor; </span><br><span class="line">    <span class="comment">// 新增时表示上一次迭代过程中，索引的位置，删除成功时为 -1</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 迭代过程中期望数组修改版本号</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line">      ... 省略代码</span><br><span class="line">      <span class="comment">// 返回元素值</span></span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用自身的remove</span></span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        ... 省略代码</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对比迭代器的删除，你发现了什么？</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ... 省略代码</span><br><span class="line">    modCount++;</span><br><span class="line">    ... 省略代码</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该迭代器实现了Iterator接口并实现了相关方法，提供我们对集合的遍历能力。</p>
<p><strong>总结</strong>：ArrayList的迭代器默认是其内部类实现，实现一个自定义迭代器只需要实现Iterator接口并实现相关方法即可。而实现Iterable接口表示该实现类具有像for-each loop迭代遍历的能力。</p>
<p><strong>我们都知道，如果在迭代的过程中调用非迭代器内部的remove或者clear方法将会抛出ConcurrentModificationException异常，那到底是为什么呢</strong>？</p>
<p>首先这里涉及到两个很重要的变量，一个是<strong>expectedModCount</strong>,另一个是<strong>modCount</strong>，<strong>expectedModCount</strong>在集合内部迭代器中定义，就像上面源码所示，<strong>modCount</strong>在AbstractList中定义。默认迭代器初始化的时候<code>expectedModCount = modCount</code>说明两者是相等的，我们可以看到next方法和remove方法都会去判断，只有当不相等的情况下才会抛出异常。我们可以看到ArrayList自身的remove方法在删除元素的时候会将modCount++，虽然迭代器本质上也是<code>this.remove</code>，但它在删除之后执行了一行<code>expectedModCount = modCount</code>，以此保证了两个值的相等，这也是java.util下的集合类的快速失败机制的实现。</p>
<p><strong>总结</strong>： 迭代器迭代集合时不能对被迭代集合进行修改，原因是modCount和expectedModCount两个变量值不想等导致的！如果想删除需要调用Iterator.remove ()，另外快速失败机制并不能保证ArrayList是线程安全的。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="对-ArrayList-的理解"><a href="#对-ArrayList-的理解" class="headerlink" title="对 ArrayList 的理解"></a>对 ArrayList 的理解</h2><p><strong>说说你自己**</strong>对 ArrayList 的理解？**</p>
<p>ArrayList 底层数据结构是个数组，其 API 都做了一层对数组底层访问的封装，比如说 add 方法的过程是……（这里可以引用我们在 ArrayList 源码解析中 add 的过程）。</p>
<p><strong>ArrayList中elementData为什么被transient修饰？</strong></p>
<p>答：首先先说说transient，该关键字修饰的变量不是该对象序列化的一部分，即当一个对象被序列化的时候，transient修饰的变量的值不会被序列化。但是ArrayList又是可序列化的类，为了不在反序列化的时候丢失原先的元素，他重写了writeObject和readObject 方法，ArrayList在序列化的时候会调用writeObject ，直接将size和element写入ObjectOutputStream；反序列化的时候调用readObject 从ObjectInputStream获取size和element，再恢复到elementData。为什么不直接用elementData来序列化呢，原因在于elementDate是一个缓存数组，它通常会预留一些容量，等容量不足时在扩容，那么有些空间可能就没有实际存储元素，采用上述的方式实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</p>
<p>补充：把对象转换为字节序列的过程称为对象的序列化，把字节序列恢复为对象的过程称为对象的反序列化。序列化的主要作用是1.把对象的字节序列永久的保存到磁盘上，通常放在一个文件中，2.在网络上传送对象的字节序列。具体可以参考这篇文章 <a href="https://www.jianshu.com/p/89c2a19772e2">https://www.jianshu.com/p/89c2a19772e2</a></p>
<h2 id="扩容类问题"><a href="#扩容类问题" class="headerlink" title="扩容类问题"></a>扩容类问题</h2><p><strong>ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</strong></p>
<p>答：此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p>
<p><strong>如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</strong></p>
<p>答：这里的考查点就是扩容的公式，当增加到 11 的时候，此时希望数组的大小为 11，但实际上数组的最大容量只有 10，不够了就需要扩容，扩容的公式是：oldCapacity + (oldCapacity&gt;&gt; 1)，oldCapacity 表示数组现有大小，目前场景计算公式是：10 + 10 ／2 = 15，然后发现 15 已经够用了，所以数组的大小会被扩容到 15。</p>
<p><strong>数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？</strong></p>
<p>答：第一题中已经计算出来数组在加入一个值后，实际大小是 1，最大可用大小是 10 ，现在需要一下子加入 15 个值，那我们期望数组的大小值就是 16，此时数组最大可用大小只有 10，明显不够，需要扩容，扩容后的大小是：10 + 10 ／2 = 15，这时候发现扩容后的大小仍然不到我们期望的值 16，这时候源码中有一种策略如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newCapacity 本次扩容的大小，minCapacity 我们期望的数组最小大小</span></span><br><span class="line"><span class="comment">// 如果扩容后的值 &lt; 我们的期望值，我们的期望值就等于本次扩容的大小</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br></pre></td></tr></table></figure>
<p>所以最终数组扩容后的大小为 16。</p>
<p><strong>现在有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</strong></p>
<p>答：因为原数组比较大，如果新建新数组的时候，不指定数组大小的话，就会频繁扩容，频繁扩容就会有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，指定新数组的大小为 5k 即可。</p>
<p><strong>为什么说扩容会消耗性能？</strong></p>
<p>答：扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重。</p>
<p><strong>源码扩容过程有什么值得借鉴的地方？</strong></p>
<p>有两点：1.是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时，也可快速扩容。</p>
<p>2.扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</p>
<h2 id="删除类问题"><a href="#删除类问题" class="headerlink" title="删除类问题"></a>删除类问题</h2><p><strong>有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">      add(<span class="string">&quot;2&quot;</span>);add(<span class="string">&quot;3&quot;</span>);add(<span class="string">&quot;3&quot;</span>);add(<span class="string">&quot;3&quot;</span>);add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;3&quot;</span>.equals(list.get(i))) &#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：不能删除干净，最终删除的结果是 2、3、4，有一个 3 删除不掉。因为每次删除一个元素后，该元素后面的元素就会往前移动，而此时循环的 i 在不断地增长，最终会使每次删除 3 的后一个 3 被遗漏，导致删除不掉。</p>
<p><strong>还是上面的ArrayList集合，通过增强 for 循环进行删除，可以么？</strong></p>
<p>答：不可以，会报错。因为增强 for 循环过程其实调用的就是迭代器的 next () 方法，当你调用 list.remove () 方法进行删除时，modCount 的值会 +1，而这时候迭代器中的 expectedModCount 的值却没有变，导致在迭代器下次执行 next () 方法时，expectedModCount != modCount 就会报 ConcurrentModificationException 的错误。</p>
<p><strong>还是上面的**</strong>ArrayList**<strong>集合，如果删除时使用 Iterator.remove () 方法可以删除么，为什么？</strong></p>
<p>答：可以的，因为 Iterator.remove () 方法在执行的过程中，会把最新的 modCount 赋值给 expectedModCount，这样在下次循环过程中，modCount 和 expectedModCount 两者就会相等。代码如下：l</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator = list.iterator();<span class="comment">//创建迭代器</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;<span class="comment">//遍历</span></span><br><span class="line">    String str = (String) iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(str))&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：多线程的情况会出现安全问题，比如把不该删的删掉</p>
<p><strong>以上三个问题对于 LinkedList 也是同样的结果么？</strong></p>
<p>答：是的，虽然 LinkedList 底层结构是双向链表，但对于上述三个问题，结果和 ArrayList 是一致的。</p>
<h2 id="对比类问题"><a href="#对比类问题" class="headerlink" title="对比类问题"></a>对比类问题</h2><p><strong>ArrayList 和 LinkedList 有何不同？</strong></p>
<p>1.底层数据结构：最大的不同是两者底层的数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，两者的数据结构不同也导致了操作的 API 实现有所差异，</p>
<p>2.新增的实现：ArrayList 会先计算并决定是否扩容，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。</p>
<p>3.删除的实现：ArrayList将指定节点删除后，指定节点之后的节点需要向前移动，而LinkedList仅仅只是改变删除节点及其前后节点指向的关系即可</p>
<p>4.查询的实现：ArrayList只需通过下标就能找到对应的节点，而LinkedList需要通过遍历从头开始查找 （使用二分法折半查找）</p>
<p><strong>ArrayList 和 LinkedList 应用场景有何不同</strong></p>
<p>ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。</p>
<p><strong>ArrayList 和 LinkedList 两者有没有最大容量</strong></p>
<p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p>
<p><strong>ArrayList 和 LinkedList 是如何对 null 值进行处理的</strong></p>
<p>ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除（普通删除的时候也是，比如数组结构是[2, 3, 3, 3, 4]，remove(“3”)的话就变成[2,  3, 3, 4]，都是删找到的第一个指定元素）；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。</p>
<p><strong>ArrayList与LinkedList特殊情况时间复杂度比较</strong></p>
<p>当查询的是LinkedList的头与尾节点时，时间复杂度也能是O(1);</p>
<p>当增加删除的是ArrayList的尾节点时，时间复杂度也能是O(1)</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p><strong>ArrayList 和 LinedList 是线程安全的么，为什么？</strong></p>
<p>当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。</p>
<p>如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在当前循环的过程中，数组或链表的结构被其它线程修改了。</p>
<p><strong>如何解决线程安全问题？</strong></p>
<p>Java 源码中推荐使用 Collections#synchronizedList 进行解决，Collections.synchronizedList 的返回值是 List 的每个方法都加了 synchronized 锁，保证了在同一时刻，数组和链表只会被一个线程所修改；或者采用 CopyOnWriteArrayList 来解决，CopyOnWriteArrayList是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。</p>
<h2 id="其他类型题目"><a href="#其他类型题目" class="headerlink" title="其他类型题目"></a>其他类型题目</h2><p>你能描述下双向链表么？</p>
<p>答：双向链表中双向的意思是说前后节点之间互相有引用，链表的节点称为 Node。Node 有三个属性组成：其前一个节点，本身节点的值，其下一个节点，假设 A、B 节点相邻，A 节点的下一个节点就是 B，B 节点的上一个节点就是 A，两者互相引用，在链表的头部节点，我们称为头节点。头节点的前一个节点是 null，尾部称为尾节点，尾节点的后一个节点是 null，如果链表数据为空的话，头尾节点是同一个节点，本身是 null，指向前后节点的值也是 null。</p>
<p><strong>描述下双向链表的新增和删除</strong></p>
<p>新增：</p>
<p>新增头结点：将插入加点prev指向null，next指向原头结点head，原头结点prev指向新增节点</p>
<p>新增尾节点：将插入加点next指向null，prev指向尾头结点last，原尾结点next指向新增节点</p>
<p>新增节点到非空节点前：通过查询方法找到需要插入位置的节点的下一个非空节点succ。原succ的前一个节点的next指向新增节点，原succ的prev指向新增节点。然后新增节点prev指向原succ的前一个节点，next指向succ节点</p>
<p>删除：</p>
<p>与新增原理相似</p>
<h2 id="List去除重复数据的方法"><a href="#List去除重复数据的方法" class="headerlink" title="List去除重复数据的方法"></a>List去除重复数据的方法</h2><p>这里简单介绍几种</p>
<p><strong>1.通过HashSet踢除重复元素</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static List remove<span class="constructor">Duplicate(List <span class="params">list</span>)</span> &#123;   </span><br><span class="line">    HashSet h = <span class="keyword">new</span> <span class="constructor">HashSet(<span class="params">list</span>)</span>;   </span><br><span class="line">    <span class="built_in">list</span>.clear<span class="literal">()</span>;   </span><br><span class="line">    <span class="built_in">list</span>.add<span class="constructor">All(<span class="params">h</span>)</span>;   </span><br><span class="line">    return <span class="built_in">list</span>;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>2.删除ArrayList中重复元素，保持顺序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除ArrayList中重复元素，保持顺序     </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeDuplicateWithOrder</span><span class="params">(List list)</span> </span>&#123;    </span><br><span class="line">    Set set = <span class="keyword">new</span> HashSet();    </span><br><span class="line">     List newList = <span class="keyword">new</span> ArrayList();    </span><br><span class="line">   <span class="keyword">for</span> (Iterator iter = list.iterator(); iter.hasNext();) &#123;    </span><br><span class="line">         Object element = iter.next();    </span><br><span class="line">         <span class="keyword">if</span> (set.add(element))    </span><br><span class="line">            newList.add(element);    </span><br><span class="line">      &#125;     </span><br><span class="line">     list.clear();    </span><br><span class="line">     list.addAll(newList);    </span><br><span class="line">    System.out.println( <span class="string">&quot; remove duplicate &quot;</span> + list);    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.用JDK1.8 Stream中对List进行去重：list.stream().distinct();</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">a.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">List&lt;String&gt; b = <span class="keyword">new</span> ArrayList&lt;&gt; ();</span><br><span class="line">b.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">b.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">b.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">a.addAll(b);</span><br><span class="line">List list=(List) a.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(list);   </span><br></pre></td></tr></table></figure>
<h2 id="ArrayList初始化常规方式"><a href="#ArrayList初始化常规方式" class="headerlink" title="ArrayList初始化常规方式"></a>ArrayList初始化常规方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;T&gt; obj = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">obj.add(<span class="string">&quot;o1&quot;</span>);</span><br><span class="line">obj.add(<span class="string">&quot;o2&quot;</span>);</span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line">ArrayList&lt;T&gt; obj = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">List list = Arrays.asList(<span class="string">&quot;o1&quot;</span>,<span class="string">&quot;o2&quot;</span>,...);</span><br><span class="line">obj.addAll(list);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/posts/1bff3c65/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h1><ul>
<li>持久化：就是将程序的数据在持久状态和瞬时状态转化的过程</li>
<li>持久层：完成持久化工作的代码块，统称为Dao层</li>
<li>MyBatis：简化数据库连接和操作数据库的操作的半持久框架，是目前的主流</li>
<li><strong>官网：<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">mybatis.org/mybatis-3/z…</a></strong></li>
</ul>
<a id="more"></a>

<h1 id="第一个Mybatis项目"><a href="#第一个Mybatis项目" class="headerlink" title="第一个Mybatis项目"></a>第一个Mybatis项目</h1><h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>创建数据库，表，表数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">        `id` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,#id不为<span class="number">0</span>，自增</span><br><span class="line">        `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,#name默认<span class="keyword">null</span></span><br><span class="line">        `pwd` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,#pwd默认<span class="keyword">null</span></span><br><span class="line">        <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)#主键索引<span class="operator">=</span>id</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;狂神&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ul>
<li><h4 id="父工程导包"><a href="#父工程导包" class="headerlink" title="父工程导包"></a><strong>父工程导包</strong></h4></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis官网--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="子工程加载资源过滤器"><a href="#子工程加载资源过滤器" class="headerlink" title="子工程加载资源过滤器"></a>子工程加载资源过滤器</h4></li>
</ul>
<p>防止后缀为properties和xml配置文件无法加载</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--资源过滤器，防止导入资源失败问题，最好在父子pom.xml里都加入一下代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span>      </span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="配置resources-mybais-config-xml"><a href="#配置resources-mybais-config-xml" class="headerlink" title="配置resources /mybais-config.xml"></a>配置resources /mybais-config.xml</h4></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--连接数据库，全部都要被下来--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mapper注入mybatis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/ssl/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="编写工厂工具类"><a href="#编写工厂工具类" class="headerlink" title="编写工厂工具类"></a>编写工厂工具类</h4><ul>
<li>spring整合mybatis后，这个操作再mybats-config.xml中配置</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提升sqlSessionFactory作用域，便于全局使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用Mybatis第一步，获取sqlSessionFactory对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sqlSessionFactory对象获取SQLSession实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><ul>
<li>Pojo：User</li>
<li>Dao：接口；实现类变成了XXXMapper.xml文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    List<span class="tag">&lt;<span class="name">User</span>&gt;</span> getUserList();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace命名空间=要实现的dao接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ssl.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ssl.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>资源过滤异常，见上面的子工程配置资源过滤器</li>
<li>mapper注册失败异常:在mybatis-config.xml配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/ssl/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 获取是sqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="comment">//2 获取的是接口的.class，因为多态</span></span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = userMapper.getUserList();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3 建议：最后关闭sqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="namespace-接口全类名相同"><a href="#namespace-接口全类名相同" class="headerlink" title="namespace=接口全类名相同"></a>namespace=接口全类名相同</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ssl.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ssl.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b4557863bbc36?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>id:接口中的方法名</li>
<li>parameterType:返回结果</li>
<li>resultType:方法参数</li>
</ul>
<h2 id="insert-update-delete"><a href="#insert-update-delete" class="headerlink" title="insert/update/delete"></a>insert/update/delete</h2><ul>
<li><strong>增删改需要添加事务，返回值只有int，不用添加resultType</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ssl.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--增删改需要提交事务，没有指定的返回值，都是int，所以不用添加resultType--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--添加一个用户，对象中的属性可以直接取出来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ssl.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO mybatis.user(id,NAME,pwd) VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ssl.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        update mybatis.user set name = #&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from mybatis.user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ul>
<li>增删改sql语句写错</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 增加需要<span class="keyword">values</span> </span><br><span class="line">insert into mybatis.user(id,NAME,pwd) VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line"># 修改需要<span class="keyword">set</span></span><br><span class="line">update mybatis.user set name = #&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;</span><br><span class="line"># 删除需要<span class="keyword">from</span></span><br><span class="line">delete from mybatis.user where id=#&#123;id&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>出现bug，是从后往前看查看原因</li>
</ul>
<h2 id="万能map"><a href="#万能map" class="headerlink" title="万能map"></a>万能map</h2><ul>
<li>如果数据库字段太多，添加修改需要的bean太多，使用map来封装参数，</li>
<li>好处一：避免多余代码</li>
<li>好处二：跳过特定的Bean属性，可以随意命名key，保证value是字段的属性就行</li>
</ul>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--模糊查询1 不推荐--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getLikeUser1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ssl.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where name like #&#123;value&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--模糊查询2 建议写死--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getLikeUser2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ssl.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h1><h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis_config.xml"></a>mybatis_config.xml</h2><ul>
<li>在resource中创建mybatis_config.xml</li>
</ul>
<h2 id="mybatis中的配置属性"><a href="#mybatis中的配置属性" class="headerlink" title="mybatis中的配置属性"></a>mybatis中的配置属性</h2><ul>
<li><strong>properties（属性）</strong></li>
<li><strong>settings（设置）</strong></li>
<li><strong>typeAliases（类型别名）</strong></li>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）</li>
<li>environments（环境配置）</li>
<li>environment（环境变量）</li>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
<li>databaseIdProvider（数据库厂商标识）</li>
<li>mappers（映射器）</li>
</ul>
<h2 id="enviroments（环境）"><a href="#enviroments（环境）" class="headerlink" title="enviroments（环境）"></a>enviroments（环境）</h2><ol>
<li>事务管理器：transcationManager,默认“JDBC”</li>
<li>连接数据库：默认pooled</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--事务管理器:默认JDBC--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--连接数据源：默认POOLED--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="properties（属性）"><a href="#properties（属性）" class="headerlink" title="properties（属性）"></a>properties（属性）</h2><ul>
<li>db.properies</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
<h2 id="settings（设置）"><a href="#settings（设置）" class="headerlink" title="settings（设置）"></a>settings（设置）</h2><table>
<thead>
<tr>
<th>settings配置</th>
<th>解释说明</th>
<th>默认状态</th>
</tr>
</thead>
<tbody><tr>
<td>cacheEnabled（重要）</td>
<td>全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td>
<td>默认开启</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。</td>
<td>默认关闭</td>
</tr>
<tr>
<td>mapUnderscoreToCamelCase（重要）</td>
<td>是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td>
<td>默认关闭</td>
</tr>
<tr>
<td>logImpl（最重要）</td>
<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td>SLF4J、LOG4J、STDOUT_LOGGING等，默认关闭</td>
</tr>
</tbody></table>
<h2 id="typeAliases（类型别名）"><a href="#typeAliases（类型别名）" class="headerlink" title="typeAliases（类型别名）"></a>typeAliases（类型别名）</h2><ul>
<li>作用：mapper.xml配置resultType时，简化书写</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b455d7847409c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--给各种类取别名,简化使用配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式一：指定类</span></span><br><span class="line"><span class="comment">        &lt;typeAlias alias=&quot;User&quot; type=&quot;com.ssl.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式二；指定包，包中的小写作为别名</span></span><br><span class="line"><span class="comment">                    也可以更改小写名，在类上使用@value(“别名”)</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.ssl.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="plugins（插件）"><a href="#plugins（插件）" class="headerlink" title="plugins（插件）"></a>plugins（插件）</h2><p>后期需要加深学习的两大插件，使Mybatis配置更加简单</p>
<ul>
<li><strong>Mybatis-Plus</strong></li>
<li><strong>MyBatis Generator Core</strong></li>
</ul>
<h2 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h2><ol>
<li>在mybatis-config.xml中配置mapper映射器</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用resource相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>class和package绑定：接口和mapper配置文件必须同名，是否必须在同一个包下有待学习？</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用class映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用package+name将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="MyBatisUtil-参数作用域"><a href="#MyBatisUtil-参数作用域" class="headerlink" title="MyBatisUtil(参数作用域)"></a>MyBatisUtil(参数作用域)</h2><table>
<thead>
<tr>
<th>名称</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>SqlSessionFactoryBuilder</td>
<td>一旦创建就不再需要它了，作用域是局部变量=静态代码块先加载</td>
</tr>
<tr>
<td>SqlSessionFactory</td>
<td>运行期间一直存在，作用域是应用作用域，使用单例模式或者静态单例模式。</td>
</tr>
<tr>
<td>SqlSession</td>
<td>连接到数据库的请求，线程不安全，用完后马上关闭；作用域是方法或者请求中，用完就关闭，关闭操作十分重要</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0 提升第三步中sqlSessionFactory作用域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 获取mybatis配置文件</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="comment">//2 获取配置文件的输入流</span></span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            <span class="comment">//3 使用SqlSessionFactoryBuilder().build()创建sqlSessionFactory</span></span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 通过getSqlSession获取session</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="属性名和字段名不一致"><a href="#属性名和字段名不一致" class="headerlink" title="属性名和字段名不一致"></a>属性名和字段名不一致</h1><h2 id="更改User中的pwd-gt-password"><a href="#更改User中的pwd-gt-password" class="headerlink" title="更改User中的pwd-&gt;password"></a>更改User中的pwd-&gt;password</h2><ul>
<li>模拟实现这个过程，数据库中是pwd，更改Pojo中的User属性为pwd，导致不一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询结果：不一致的字段查询结果为null</span></span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">&#x27;狂神&#x27;</span>, password=<span class="string">&#x27;null&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li>更改pojo成员属性名 = 数据库字段名：使用起来太low，不推荐</li>
<li><strong>使用结果集映射=resultMap:哪个字段不一致，就使不一致的成员属性property映射到数据库的column</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b4562b9908e3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace命名空间=要实现的dao接口=原来的dao实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ssl.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--更改结果集映射，解决属性名和数据库列名不一致--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.ssl.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过id查询一个用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">            select * from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="开启日志"><a href="#开启日志" class="headerlink" title="开启日志"></a>开启日志</h1><h2 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h2><p>在setting中配置：name = logImpl 大小写和空格不能错</p>
<p><strong>LOG4J:必须掌握，步骤：setting配置，导包，配置pro，测试时加载</strong></p>
<ul>
<li><p><strong>setting配置，+导依赖包</strong></p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;log4j&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--log4j日志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>log4j.properties：需要时去网上找一份</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># log4j日志系统：通用配置</span></span><br><span class="line"><span class="comment"># Define the root logger with appender file</span></span><br><span class="line"><span class="comment"># log=D:\logs</span></span><br><span class="line">log4j.rootLogger = DEBUG, FILE, console</span><br><span class="line"><span class="comment"># 输出到当前目录文件下的log包中</span></span><br><span class="line">log4j.appender.FILE=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.FILE.File=./logs/log4j.log</span><br><span class="line"><span class="comment"># Set the immediate flush to true (default)</span></span><br><span class="line">log4j.appender.FILE.ImmediateFlush=<span class="literal">true</span></span><br><span class="line"><span class="comment"># Set the threshold to debug mode</span></span><br><span class="line">log4j.appender.FILE.Threshold=debug</span><br><span class="line"><span class="comment"># Set the threshold to debug mode</span></span><br><span class="line"><span class="comment"># 设置日志信息追加</span></span><br><span class="line">log4j.appender.FILE.Append=<span class="literal">true</span></span><br><span class="line"><span class="comment"># Set the maximum file size before rollover</span></span><br><span class="line"><span class="comment"># 30MB</span></span><br><span class="line">log4j.appender.FILE.MaxFileSize=5KB</span><br><span class="line"><span class="comment"># Set the backup index</span></span><br><span class="line">log4j.appender.FILE.MaxBackupIndex=2</span><br><span class="line"><span class="comment"># Define the layout for file appender</span></span><br><span class="line">log4j.appender.FILE.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.FILE.layout.conversionPattern=%m%n</span><br><span class="line"><span class="comment"># 将日志输出到控制台</span></span><br><span class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%d&#123;yyyy-MM-dd HH:mm:ss&#125;]-[%t]-[%F:%L]-[%p]-[%c]-%m%n</span><br><span class="line"><span class="comment">#log4j.appender.console.layout.ConversionPattern=[%d&#123;yyyy-MM-dd&#125;]-[%t]-[%x]-[%-5p]-[%-10c:%m%n]</span></span><br><span class="line">log4j.appender.console.encoding=UTF-8</span><br></pre></td></tr></table></figure></li>
<li><p>test中：<code>static Logger logger = Logger.getLogger(UserMapperTest.class);</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">//使用log4j</span></span><br><span class="line">    <span class="keyword">static</span> Logger logger = Logger.getLogger(UserMapperTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 获取是sqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="comment">//2 获取方式一：getMapper</span></span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        User user = userMapper.getUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//3 建议：最后关闭sqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>STDOUT_LOGGING ：掌握，不用导包，mybatis默认配置了，缺点就是只在控制台显示</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;log4j&quot;/&gt;--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>SLF4J</li>
<li>NO_LOGGING</li>
</ul>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><ul>
<li><strong>第一个参数：startIndex=开始分页的下标 = （第几页 - 1 ）* pageSize</strong></li>
<li><strong>第二个参数：pageSize=分页中每页的大小</strong></li>
<li><strong>只有一个参数：默认是从第一个元数到该index下标实现分页</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit startIndex,pageSize;# startIndex<span class="operator">=</span>（第几页<span class="number">-1</span>）<span class="operator">*</span>pageSize</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit index;# 默认从第一个元素到第index个用户</span><br></pre></td></tr></table></figure>
<h2 id="实现分页"><a href="#实现分页" class="headerlink" title="实现分页"></a>实现分页</h2><ul>
<li><strong>map和RowbBounds两者都可以实现分页：推荐使用map分页，因为默认key=#{key}</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id获取一个用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 指定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> User</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过map分页数据，推荐使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 常用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListUser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getLimitUser</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 了解，不推荐使用，通过RowBounds分页数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListUser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getLimitUserByRowBounds</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">                <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">                <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ssl.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--更改结果集映射，解决属性名和数据库列名不一致--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.ssl.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--map分页--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getLimitUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">         select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--RowBounds分页--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getLimitUserByRowBounds&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">         select * from mybatis.user ;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLimitUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserMapper userMapper = MyBatisUtil.getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//mapper.xml会自动寻找map中的key=#&#123;key&#125;</span></span><br><span class="line">        map.put(<span class="string">&quot;startIndex&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pageSize&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        List&lt;User&gt; limitUser = userMapper.getLimitUser(map);</span><br><span class="line">        <span class="keyword">for</span> (User user : limitUser) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLimitUserBrRowBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="comment">//老式的查询分页：使用RowBounds</span></span><br><span class="line">        RowBounds rowBounds = <span class="keyword">new</span> RowBounds(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//语法麻烦</span></span><br><span class="line">        List&lt;User&gt; usersList = sqlSession.selectList(<span class="string">&quot;com.ssl.dao.UserMapper.getLimitUserByRowBounds&quot;</span>,<span class="number">0</span>,rowBounds);</span><br><span class="line">        <span class="keyword">for</span> (User user : usersList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><p>自学Mybatis PageHelper插件，公司需要就去网站自学</p>
<h1 id="注解配置sql语句"><a href="#注解配置sql语句" class="headerlink" title="注解配置sql语句"></a>注解配置sql语句</h1><h2 id="mybaits-config-xml中配置映射器"><a href="#mybaits-config-xml中配置映射器" class="headerlink" title="mybaits-config.xml中配置映射器"></a>mybaits-config.xml中配置映射器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--绑定注解开发的接口 class--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.ssl.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>如果表中列名和成员属性名不一致，查出来就是null</p>
<h2 id="注解的CRUD"><a href="#注解的CRUD" class="headerlink" title="注解的CRUD"></a>注解的CRUD</h2><p>学习@param（非常重要）</p>
<ul>
<li><strong>基本类型、String建议都加上，引用类型不用加</strong></li>
<li><strong>(uid)中的就是sql中的#{uid}</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用注解开发，有局限性就是column 必须与 dao接口成员属性名一致，否知输出就是null，查不出来</span></span><br><span class="line"><span class="comment">     * 所以注解语句开发，便于使用简单场景</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id=uid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> User</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="meta">@Param(&quot;uid&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增删改自动提交事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//不推荐使用，建议手动提交commit</span></span><br><span class="line">       <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><h2 id="IDEA中安装Lombok插件"><a href="#IDEA中安装Lombok插件" class="headerlink" title="IDEA中安装Lombok插件"></a>IDEA中安装Lombok插件</h2><h2 id="maven安装依赖"><a href="#maven安装依赖" class="headerlink" title="maven安装依赖"></a>maven安装依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Data等注解"><a href="#Data等注解" class="headerlink" title="@Data等注解"></a>@Data等注解</h2><ul>
<li><strong>@Data：最常用，自动加上Setter Getter equals tostring,</strong></li>
<li><strong>@AllArgsConstructor:有参构造</strong></li>
<li><strong>@NoArgsConstructor:无参构造</strong></li>
</ul>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>虽然可以混合使用，但多重的构造器的构造器<strong>不能重载</strong></li>
<li>公司用就用，不用就少用，因为改变了java源码的书写习惯，不利于推广</li>
</ul>
<h1 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h1><ul>
<li>导入Lombok插件和依赖，减少pojo代码</li>
<li>新建实体类Student、Teacher和数据库表<ul>
<li>Student中有一个字段tid使用外键约束，关联Teacher</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tid` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">  KEY `fktid` (`tid`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fktid` <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (`tid`) <span class="keyword">REFERENCES</span> `teacher` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>
<ul>
<li>配置环境：pojo和mapper接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//需要关联一个老师类</span></span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//子查询</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//联表查询</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getStudents1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子查询-查询嵌套"><a href="#子查询-查询嵌套" class="headerlink" title="子查询=查询嵌套"></a>子查询=查询嵌套</h2><ul>
<li>mapper.xml<ul>
<li><strong>以下对于理解非常重要</strong></li>
<li><strong>javaType=“teacher”配置了别名，大小写都可以，去pojo路径中中找Teacher，然后使用其成员属性tid</strong></li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b4569d7a7146c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一：按照查询嵌套处理 = 子查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudents&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;resultStudents&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.student;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;resultStudents&quot;</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--association:属性是对象时使用--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--collection:属性是集合时候用--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeachers&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeachers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.teacher where id = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentMapper studentMapper = MyBatisUtil.getSqlSession().getMapper(StudentMapper.class);</span><br><span class="line">        List&lt;Student&gt; students = studentMapper.getStudents();</span><br><span class="line">        <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Student(id=1, name=小红, teacher=Teacher(id=1, name=秦老师))</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="联表查询-结果嵌套"><a href="#联表查询-结果嵌套" class="headerlink" title="联表查询=结果嵌套"></a>联表查询=结果嵌套</h2><ul>
<li>使用多表查询，避免写多个sql</li>
<li>mapper.xml</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b456d6e524bc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式二：按照结果嵌套处理 = 联表查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudents1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;resultStudents1&quot;</span>&gt;</span></span><br><span class="line">    select  s.id sid,s.name sname,t.name tname</span><br><span class="line">    from student s,teacher t</span><br><span class="line">    where s.tid = t.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;resultStudents1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试：与嵌套查询结果没变</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudents1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       StudentMapper studentMapper = MyBatisUtil.getSqlSession().getMapper(StudentMapper.class);</span><br><span class="line">       List&lt;Student&gt; students = studentMapper.getStudents1();</span><br><span class="line">       <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">           System.out.println(student);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           Student(id=1, name=小红, teacher=Teacher(id=0, name=秦老师))</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h1><ul>
<li>配置环境：pojo和dao下的mapper接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//一对多的集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TeacherMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子查询：按查询嵌套查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Teacher <span class="title">getTeacher</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> tid)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联表查询：按结果嵌套查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Teacher <span class="title">getTeacher1</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> tid)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-1：-子查询"><a href="#11-1：-子查询" class="headerlink" title="11.1： 子查询"></a>11.1： 子查询</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b4572173c5269?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--子查询：按查询嵌套查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;teacherToStudent&quot;</span>&gt;</span></span><br><span class="line">    select id, name from mybatis.teacher where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;teacherToStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  column=&quot;id&quot;是teacher表中的id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;List&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;student&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudentsByTeacherId&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentsByTeacherId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.student where tid = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTeacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TeacherMapper teacherMapper = MyBatisUtil.getSqlSession().getMapper(TeacherMapper.class);</span><br><span class="line">    Teacher teacher = teacherMapper.getTeacher(<span class="number">1</span>);</span><br><span class="line">    System.out.println(teacher);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果id=0怎么解决？就是collection中配置result property=&quot;id&quot; column=&quot;id&quot;</span></span><br><span class="line"><span class="comment">        Teacher(id=1, name=秦老师, students=[Student(id=1, name=小红, tid=1),Student(id=2, name=小明, tid=1)...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-2：-联表查询"><a href="#11-2：-联表查询" class="headerlink" title="11.2： 联表查询"></a>11.2： 联表查询</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--联表查询：按结果嵌套查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;teacherAndStudent&quot;</span>&gt;</span></span><br><span class="line">    select  s.id sid,s.name sname,t.name tname,t.id tid</span><br><span class="line">    from mybatis.teacher t,mybatis.student s</span><br><span class="line">    where s.tid=t.id and t.id =#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;teacherAndStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--集合对象用collection绑定，javaType是返回单个属性，不能返回集合,</span></span><br><span class="line"><span class="comment">返回属性是集合用ofType绑定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTeacher1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TeacherMapper teacherMapper = MyBatisUtil.getSqlSession().getMapper(TeacherMapper.class);</span><br><span class="line">    Teacher teacher = teacherMapper.getTeacher1(<span class="number">1</span>);</span><br><span class="line">    System.out.println(teacher);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Teacher(id=1, name=秦老师, students=[Student(id=1, name=小红, tid=1), Student(id=2, name=小明, tid=1)...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多表查询小结"><a href="#多表查询小结" class="headerlink" title="多表查询小结"></a>多表查询小结</h2><ul>
<li>多对一中的一:association</li>
<li>一对多中的多:collection</li>
<li>javaType &amp; ofType<ul>
<li>javaType:指定实体类中的属性的java返回值类型</li>
<li>ofType:映射List或某些指定的pojo泛型的类型，联想List中的泛型类型Student用ofType绑定</li>
</ul>
</li>
<li>注意点：<ul>
<li>保证SQL的可读性，建议使用联表查询</li>
</ul>
</li>
</ul>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><ul>
<li>概念：动态 SQL 是 MyBatis 的强大特性之一，简化了原生复杂SQL书写</li>
<li>四个判断条件：<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
</li>
<li>搭建数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> blog(</span><br><span class="line">	id <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客id&#x27;</span>,</span><br><span class="line">	title <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客标题&#x27;</span>,</span><br><span class="line">	author <span class="type">VARBINARY</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;博客作者&#x27;</span>,</span><br><span class="line">    # 数据库时间DateTime类型<span class="operator">=</span>pojo中的<span class="type">Date</span>类型</span><br><span class="line">    # 下划线命名调到pojo中的驼峰式命令，需要mybatis开启驼峰式命令</span><br><span class="line">	create_time DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">	views <span class="type">INT</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;浏览量&#x27;</span></span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>
<ul>
<li>pojo和驼峰式命名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下划线命名调到pojo中的驼峰式命令，需要mybatis开启驼峰式命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> views;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--解决驼峰命令，使用setting配置，只能用户数据库中的xx_xx编程bean中的驼峰式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Utils</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提升sqlSessionFactory作用域，便于全局使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用Mybatis第一步，获取sqlSessionFactory对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sqlSessionFactory对象获取SQLSession实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机产生数据库表中的views</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UUIDUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUUId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(UUIDUtils.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mapper接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addBlog</span><span class="params">(Blog blog)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Blog&gt; <span class="title">queryBlogByIf</span><span class="params">(Map map)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Blog&gt; <span class="title">queryBlogByWhere</span><span class="params">(Map map)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Blog&gt; <span class="title">queryBlogByForeach</span><span class="params">(Map map)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul>
<li>概念：sql常见的场景就是判断使用</li>
<li>方式一：通过&lt; if &gt;直接使用，或者&lt; include&gt;跳转sql使用时候，需要保证where成立，所以需要在sql语句中加上类似<code>where 1= 1</code> 或者 <code>where state = &#39;active&#39;</code>等语句<ul>
<li>这里使用了SQL片段复用，见后面讲解</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b4579015e930c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--if：通过include跳转到使用,缺点是必须写上判断条件成立 where 1=1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogByIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.blog where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>  <span class="attr">refid</span>=<span class="string">&quot;if_title_author_like&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;if_title_author_like&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title !=null&quot;</span>&gt;</span></span><br><span class="line">        and  title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author !=null&quot;</span>&gt;</span></span><br><span class="line">        and author like #&#123;author&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方式二：通过&lt; where &gt;和&lt; if &gt;混合使用，就不用手动加上<code>where 1= 1</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--if:通过where直接使用/直接使用if判断，但是不推荐。原理：如果test存在，就自动加上where --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogByWhere&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id !=null&quot;</span>&gt;</span></span><br><span class="line">            id like #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;views !=null&quot;</span>&gt;</span></span><br><span class="line">            and views like #&#123;views&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试：模糊查询需要封装通配符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryBlogByIf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">    BlogMapper blogMapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//模糊查询，使用map的好处</span></span><br><span class="line">    map.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;%my%&quot;</span>);</span><br><span class="line">    List&lt;Blog&gt; blogs = blogMapper.queryBlogByIf(map);</span><br><span class="line">    System.out.println(blogs);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryBlogByWhere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">    BlogMapper blogMapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//map.put(&quot;id&quot;,&quot;%4%&quot;);</span></span><br><span class="line">    map.put(<span class="string">&quot;views&quot;</span>, <span class="string">&quot;%2%&quot;</span>);</span><br><span class="line">    List&lt;Blog&gt; blogs = blogMapper.queryBlogByWhere(map);</span><br><span class="line">    System.out.println(blogs);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h2><ul>
<li>概念：有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</li>
<li>需求：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG</li>
<li>细节：choose只能满足其中一个when\otherwisw；使用<code>WHERE state = ‘ACTIVE’</code>等保证where成立</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--官网案例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><ul>
<li>单独使用&lt; if &gt; 的缺点：如果没有查询条件或者第一个条件没有满足，就会出现错误的sql语句：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>出现错误sql：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 没有条件成立</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"># 第一个条件没有成立</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">AND</span> title <span class="keyword">like</span> ‘someTitle’</span><br></pre></td></tr></table></figure>
<ul>
<li>使用&lt; where &gt;<ul>
<li><strong>优势：where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，*where* 元素也会将它们去除。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用自定义 trim 元素来定制 where 元素的功能<ul>
<li>与&lt; where&gt;等价的&lt; trim&gt;<ul>
<li>prefix=”WHERE”满足条件，自动添加的字段：prefixOverrides自动忽略的字段，细节：AND |OR 两者后面都包含了一个空格，这是正确sql的书写要点</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul>
<li>概念：用于动态update语句的叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列<ul>
<li>等价的trim语句，*<strong>set* 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）= 也就是说其实mybatis自动在update中set就给你加上了逗号，但是你自己手写加上了，&lt; set&gt; 也会给你忽略掉</strong></li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">复制代码</span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><ul>
<li>概念：动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）</li>
<li>原生：<code>SELECT * FROM blog WHERE 1=1 AND (id=1 OR id=2)；</code></li>
<li>细节：if &lt; where&gt; 多个条件成立时，就会忽略掉原生中and书写</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b457e53fe640c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogByForeach&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">   		<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">    		id=#&#123;id&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--官网案例：使用in时--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ul>
<li>回顾：前面的&lt; where &gt;结合&lt; if&gt;，我们将公共的SQL语句抽取出来，复用.</li>
<li>使用：&lt; sql id= &gt; 标签和&lt; include refid= &gt;引用</li>
<li>细节：<ul>
<li>最好基于单表使用sql片段，多表别的表不一定支持</li>
<li>使用sql片段复用，不要使用&lt; where &gt;标签，因为它内置了会忽略掉某些字段</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;if_title_author_like&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title !=null&quot;</span>&gt;</span></span><br><span class="line">        and  title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author !=null&quot;</span>&gt;</span></span><br><span class="line">        and author like #&#123;author&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogByIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.blog where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;if_title_author_like&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="bind-了解"><a href="#bind-了解" class="headerlink" title="bind(了解)"></a>bind(了解)</h2><ul>
<li>bind 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogsLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><ul>
<li>我们再次查询相同数据时候，直接走缓存，就不用再存了，解决速度问题</li>
<li>什么样的数据需要用到缓存？<ul>
<li>经常查询并且不经常改变的数据，可以使用缓存</li>
</ul>
</li>
</ul>
<h2 id="缓存原理图（重要）"><a href="#缓存原理图（重要）" class="headerlink" title="缓存原理图（重要）"></a>缓存原理图（重要）</h2><p>二级缓存工作原理：</p>
<ul>
<li>一次sqlsession是一级缓存，查询操作结束后，是默认保存在一级缓存中的</li>
<li>如果开启二级缓存，必须先关闭一级缓存，这时候的缓存数据会保存到二级缓存中</li>
<li>第二次查询时候，用户操作会嫌去二级缓存中查找</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b4582f2d53067?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><ul>
<li>默认情况下，只启用了本地的会话（一级）缓存，它仅仅对一个会话中的数据进行缓存。<ul>
<li>把一级缓存想象成一个会话中的map，便于理解</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b4585a48f3187?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>缓存失效<ul>
<li>增删改会把所有的sql缓存失效，下次会重写从数据库中查</li>
<li>查询不同的东西，查询不同的mapper.xml</li>
<li>手动清除缓存:<code>sqlSession.clearCache();</code></li>
</ul>
</li>
</ul>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><ul>
<li>mybatis-config,xml开启全局缓存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启全局缓存 默认是开启的，显示写便于可读--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>mappper.xml开启二级缓存：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>映射语句文件中的所有 select 语句的结果将会被缓存。</p>
</li>
<li><p>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</p>
</li>
<li><p>缓存会使用<strong>最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</strong></p>
</li>
<li><p><strong>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</strong></p>
</li>
<li><p><strong>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</strong></p>
</li>
<li><p>缓存会被视为读/写缓存</p>
<p>  ，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</p>
<ul>
<li>读写缓存需要pojo开启序列化操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>开启二级缓存时，可以指定参数</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;cache</span><br><span class="line">  eviction=&quot;FIFO&quot;</span><br><span class="line">  flushInterval=&quot;60000&quot;</span><br><span class="line">  size=&quot;512&quot;</span><br><span class="line">  readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>eviction:清楚算法，默认LRU<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
</li>
<li>flushInterval：刷新缓存间隔，默认无</li>
<li>size：最多缓存数量，默认1024</li>
<li>readOnly：只读缓存；写操作会不走缓存，直接从数据库查询，默认是读/写缓存</li>
</ul>
</li>
<li><p>使用二级缓存</p>
<ul>
<li>测试语句</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">        SqlSession sqlSession1 = MyBatisUtil.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        User user = mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//关闭上次sqlSession，如果开启二级缓存，就会把这次的一级缓存保存到二级缓存中</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">//如果开启二级缓存，下次相同mapper的查询操作会先重二级缓存中查找</span></span><br><span class="line">        User user1 = mapper1.queryUserById(<span class="number">1</span>);</span><br><span class="line">        sqlSession1.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b458aa85e97f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b458d78d07497?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="自定义缓存（了解）"><a href="#自定义缓存（了解）" class="headerlink" title="自定义缓存（了解）"></a>自定义缓存（了解）</h2><ul>
<li>概念：ehcache是一个分布式缓存，主要面向通用缓存</li>
<li>手写或者导入第三方的ehcache缓存依赖</li>
<li>所以可以自定义ehcache.xml配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在mapper.xml中配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.encache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在resource中创建ehcache.xml文件：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">updateCheck</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      &lt;defaultCache</span><br><span class="line">              eternal=&quot;false&quot;</span><br><span class="line">              maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">              overflowToDisk=&quot;false&quot;</span><br><span class="line">              diskPersistent=&quot;false&quot;</span><br><span class="line">              timeToIdleSeconds=&quot;1800&quot;</span><br><span class="line">              timeToLiveSeconds=&quot;259200&quot;</span><br><span class="line">              memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;cache</span><br><span class="line">              name=&quot;cloud_user&quot;</span><br><span class="line">              eternal=&quot;false&quot;</span><br><span class="line">              maxElementsInMemory=&quot;5000&quot;</span><br><span class="line">              overflowToDisk=&quot;false&quot;</span><br><span class="line">              diskPersistent=&quot;false&quot;</span><br><span class="line">              timeToIdleSeconds=&quot;1800&quot;</span><br><span class="line">              timeToLiveSeconds=&quot;1800&quot;</span><br><span class="line">              memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：</span></span><br><span class="line"><span class="comment">         user.home – 用户主目录</span></span><br><span class="line"><span class="comment">         user.dir  – 用户当前工作目录</span></span><br><span class="line"><span class="comment">         java.io.tmpdir – 默认临时文件路径</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir/Tmp_EhCache&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name:缓存名称。</span></span><br><span class="line"><span class="comment">        maxElementsInMemory:缓存最大数目</span></span><br><span class="line"><span class="comment">        maxElementsOnDisk：硬盘最大缓存个数。</span></span><br><span class="line"><span class="comment">        eternal:对象是否永久有效，一但设置了，timeout将不起作用。</span></span><br><span class="line"><span class="comment">        overflowToDisk:是否保存到磁盘，当系统当机时</span></span><br><span class="line"><span class="comment">        timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span></span><br><span class="line"><span class="comment">        timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</span></span><br><span class="line"><span class="comment">        diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</span></span><br><span class="line"><span class="comment">        diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</span></span><br><span class="line"><span class="comment">        diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</span></span><br><span class="line"><span class="comment">        memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</span></span><br><span class="line"><span class="comment">        clearOnFlush：内存数量最大时是否清除。</span></span><br><span class="line"><span class="comment">        memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</span></span><br><span class="line"><span class="comment">        FIFO，first in first out，这个是大家最熟的，先进先出。</span></span><br><span class="line"><span class="comment">        LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。</span></span><br><span class="line"><span class="comment">        LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器之ConcurrentHashMap</title>
    <url>/posts/fd983302/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>JDK1.7之前的ConcurrentHashMap使用分段锁机制实现，JDK1.8则使用数组+链表+红黑树数据结构和CAS原子操作实现ConcurrentHashMap</p>
</blockquote>
<a id="more"></a>

<h1 id="为什么HashTable慢"><a href="#为什么HashTable慢" class="headerlink" title="为什么HashTable慢"></a>为什么HashTable慢</h1><p>Hashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下。</p>
<h1 id="ConcurrentHashMap-JDK-1-7"><a href="#ConcurrentHashMap-JDK-1-7" class="headerlink" title="ConcurrentHashMap - JDK 1.7"></a>ConcurrentHashMap - JDK 1.7</h1><p>在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap.</p>
<p>简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可是实现多线程put操作。接下来分析JDK1.7版本中ConcurrentHashMap的实现原理。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。</p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-concurrent-hashmap-1.png" alt="img"></p>
<p><code>concurrencyLevel</code>: 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p>
<p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li>initialCapacity: 初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</li>
<li>loadFactor: 负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span></span><br><span class="line">    <span class="comment">// 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialCapacity 是设置整个 map 初始的大小，</span></span><br><span class="line">    <span class="comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span></span><br><span class="line">    <span class="comment">// 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span></span><br><span class="line">    <span class="comment">// 插入一个元素不至于扩容，插入第二个的时候才会扩容</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; </span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，</span></span><br><span class="line">    <span class="comment">// 并创建数组的第一个元素 segment[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    <span class="comment">// 往数组写入 segment[0]</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>初始化完成，我们得到了一个 Segment 数组。</p>
<p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后:</p>
<ul>
<li>Segment 数组长度为 16，不可以扩容</li>
<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>
<li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li>
<li>当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到</li>
</ul>
<h2 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h2><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1. 计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 根据 hash 值找到 Segment 数组中的位置 j</span></span><br><span class="line">    <span class="comment">//    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，</span></span><br><span class="line">    <span class="comment">//    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span></span><br><span class="line">    <span class="comment">// ensureSegment(j) 对 segment[j] 进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 3. 插入新值到 槽 s 中</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p>
<p>Segment 内部是由 <code>数组+链表</code> 组成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在往该 segment 写入前，需要先获取该 segment 的独占锁</span></span><br><span class="line">    <span class="comment">//    先看主流程，后面还会具体介绍这部分内容</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是 segment 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 再利用 hash 值，求应该放置的数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// first 是数组该位置处的链表的表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        <span class="comment">// 覆盖旧值</span></span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续顺着链表走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span></span><br><span class="line">                <span class="comment">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 扩容后面也会具体分析</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span></span><br><span class="line">                    <span class="comment">// 其实就是将新的节点设置成原链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p>
<p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p>
<h2 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h2><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p>
<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里看到为什么之前要初始化 segment[0] 了，</span></span><br><span class="line">        <span class="comment">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span></span><br><span class="line">        <span class="comment">// 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 segment[k] 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// 再次检查一遍该槽是否被其他线程初始化了。</span></span><br><span class="line"></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p>
<h3 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h3><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>
<p>下面我们来具体分析这个方法中是怎么控制加锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    <span class="comment">// 进到这里说明数组该位置的链表是空的，没有任何元素</span></span><br><span class="line">                    <span class="comment">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 顺着链表往下走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试次数如果超过 MAX_SCAN_RETRIES(单核1多核64)，那么不抢了，进入到阻塞队列等待锁</span></span><br><span class="line">        <span class="comment">//    lock() 是阻塞方法，直到获取锁后返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 <span class="comment">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span></span><br><span class="line">                 <span class="comment">//     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span></span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p>
<p>这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。</p>
<h2 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h2><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容，扩容后，容量为原来的 2 倍。</p>
<p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p>
<p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 2 倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// e 是链表的第一个元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算应该放置在新数组中的位置，</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">// 该位置处只有一个元素，那比较好办</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// e 是链表表头</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="comment">// idx 是当前链表的头结点 e 的新位置</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 下面的操作是处理 lastRun 之前的节点，</span></span><br><span class="line">                <span class="comment">//    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢?</p>
<p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p>
<p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。</p>
<h2 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h2><p>相对于 put 来说，get 真的不要太简单。</p>
<ul>
<li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li>
<li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li>
<li>到这里是链表了，顺着链表进行查找即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 1. hash 值</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 2. 根据 hash 找到对应的 segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 找到segment 内部数组相应位置的链表，遍历</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h2><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p>
<p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p>
<p>put 操作的线程安全性。</p>
<ul>
<li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li>
<li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li>
<li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li>
</ul>
<p>remove 操作的线程安全性。</p>
<ul>
<li>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</li>
<li>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</li>
<li>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</li>
<li>如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</li>
</ul>
<h1 id="ConcurrentHashMap-JDK-1-8"><a href="#ConcurrentHashMap-JDK-1-8" class="headerlink" title="ConcurrentHashMap - JDK 1.8"></a>ConcurrentHashMap - JDK 1.8</h1><p>在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。</p>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://www.pdai.tech/_images/thread/java-thread-x-concurrent-hashmap-2.png" alt="img"></p>
<p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p>
<h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这构造函数里，什么都不干</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p>
<p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p>
<h2 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h2><p>仔细地一行一行代码看下去:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组&quot;空&quot;，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组，后面会详细介绍</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span><br><span class="line">            <span class="comment">//          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 到这里就是说，f 是该位置的头结点，而且不为空</span></span><br><span class="line"></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">//    具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化数组-initTable"><a href="#初始化数组-initTable" class="headerlink" title="初始化数组: initTable"></a>初始化数组: initTable</h2><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p>
<p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 初始化数组，长度为 16 或初始化时提供的长度</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 如果 n 为 16 的话，那么这里 sc = 12</span></span><br><span class="line">                    <span class="comment">// 其实就是 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h2><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// MIN_TREEIFY_CAPACITY 为 64</span></span><br><span class="line">        <span class="comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 后面我们再详细分析这个方法</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b 是头结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">// 下面就是遍历链表，建立一颗红黑树</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将红黑树设置到数组相应位置中</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容: tryPresize</p>
<p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p>
<p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p>
<p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c: size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 0.75 * n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span><br><span class="line">                <span class="comment">//    此时 nextTab 不为 null</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">            <span class="comment">//     我是没看懂这个值真正的意义是什么? 不过可以计算出来的是，结果是一个比较大的负数</span></span><br><span class="line">            <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>
<p>所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。</p>
<h2 id="数据迁移-transfer"><a href="#数据迁移-transfer" class="headerlink" title="数据迁移: transfer"></a>数据迁移: transfer</h2><p>下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p>
<p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p>
<p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p>
<p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p>
<p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span></span><br><span class="line">    <span class="comment">// stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span></span><br><span class="line">    <span class="comment">//   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 nextTab 为 null，先进行一次初始化</span></span><br><span class="line">    <span class="comment">//    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span></span><br><span class="line">    <span class="comment">//       之后参与迁移的线程调用此方法时，nextTab 不会为 null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容量翻倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextTable 是 ConcurrentHashMap 中的属性</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ForwardingNode 翻译过来就是正在被迁移的 Node</span></span><br><span class="line">    <span class="comment">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span></span><br><span class="line">    <span class="comment">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span></span><br><span class="line">    <span class="comment">//    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span></span><br><span class="line">    <span class="comment">//    所以它其实相当于是一个标志。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 是位置索引，bound 是边界，注意是从后往前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这个 while 真的是不好理解</span></span><br><span class="line">        <span class="comment">// advance 为 true 表示可以进行下一个位置的迁移了</span></span><br><span class="line">        <span class="comment">//   简单理解结局: i 指向了 transferIndex，bound 指向了 transferIndex-stride</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 transferIndex 值赋给 nextIndex</span></span><br><span class="line">            <span class="comment">// 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 所有的迁移操作已经完成</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 将新的 nextTab 赋值给 table 属性，完成迁移</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 重新计算 sizeCtl: n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span><br><span class="line">            <span class="comment">// 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span></span><br><span class="line">            <span class="comment">// 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 任务结束，方法退出</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span></span><br><span class="line">                <span class="comment">// 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 头结点的 hash 大于 0，说明是链表的 Node 节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span></span><br><span class="line">                        <span class="comment">// 需要将链表一分为二，</span></span><br><span class="line">                        <span class="comment">//   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span><br><span class="line">                        <span class="comment">//   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其中的一个链表放在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 另一个链表放在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树的迁移</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 ln 放置在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 将 hn 放置在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p>
<p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p>
<h2 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h2><p>get 方法从来都是最简单的，这里也不例外:</p>
<p>计算 hash 值</p>
<p>根据 hash 值找到数组对应位置: (n - 1) &amp; h</p>
<p>根据该位置处结点性质进行相应查找</p>
<ul>
<li>如果该位置为 null，那么直接返回 null 就可以了</li>
<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>
<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li>
<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头结点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p>
<h1 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h1><ul>
<li><code>HashTable</code> : 使用了synchronized关键字对put等操作进行加锁;</li>
<li><code>ConcurrentHashMap JDK1.7</code>: 使用分段锁机制实现;</li>
<li><code>ConcurrentHashMap JDK1.8</code>: 则使用数组+链表+红黑树数据结构和CAS原子操作实现;</li>
</ul>
]]></content>
      <categories>
        <category>容器</category>
        <category>并发容器</category>
      </categories>
      <tags>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>并发关键字之synchronized</title>
    <url>/posts/86728370/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>并发关键字Synchronized的深入理解及其原理详解</p>
</blockquote>
<a id="more"></a>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。Synchronized的作用主要有三个：</p>
<blockquote>
<ol>
<li>原子性：确保线程互斥的访问同步代码；</li>
<li>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “<strong>对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值</strong>” 来保证的；</li>
<li>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；</li>
</ol>
</blockquote>
<p>从语法上讲，Synchronized可以把任何一个非null对象作为”锁”，在HotSpot JVM实现中，<strong>锁有个专门的名字：对象监视器（Object Monitor）</strong></p>
<p>Synchronized总共有三种用法：</p>
<blockquote>
<ol>
<li>当synchronized作用在实例方法时，监视器锁（monitor）便是对象实例（this）；</li>
<li>当synchronized作用在静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；</li>
<li>当synchronized作用在某一个对象实例时，监视器锁（monitor）便是括号括起来的对象实例；</li>
</ol>
</blockquote>
<p>注意，synchronized 内置锁 是一种 对象锁（锁的是对象而非引用变量），<strong>作用粒度是对象 ，可以用来实现对 临界资源的同步互斥访问 ，是 可重入 的。其可重入最大的作用是避免死锁</strong>，如：</p>
<blockquote>
<p><strong>子类同步方法调用了父类同步方法，如没有可重入的特性，则会发生死锁；</strong></p>
</blockquote>
<h1 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h1><p>数据同步需要依赖锁，那锁的同步又依赖谁？<strong>synchronized给出的答案是在软件层面依赖JVM，而j.u.c.Lock给出的答案是在硬件层面依赖特殊的CPU指令。</strong></p>
<p>当一个线程访问同步代码块时，首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Method 1 start&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看反编译后结果： </p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-b98084591219da8c.png" alt="img"></p>
<p>反编译结果</p>
<ol>
<li><p><strong>monitorenter</strong>：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<blockquote>
<ol>
<li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li>
<li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；</li>
<li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li>
</ol>
</blockquote>
</li>
<li><p>monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<blockquote>
<p>monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</p>
</blockquote>
</li>
</ol>
<p>通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理，<strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</strong></p>
<p>再来看一下同步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看反编译后结果： </p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-8b7734120fae6645.png" alt="img"></p>
<p>反编译结果 </p>
<p>从编译的结果来看，方法的同步并没有通过指令 <code>monitorenter</code> 和 <code>monitorexit</code> 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 <code>ACC_SYNCHRONIZED</code> 标示符。JVM就是根据该标示符来实现方法的同步的：</p>
<blockquote>
<p>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。<strong>在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</strong></p>
</blockquote>
<p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p>
<h1 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h1><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>在JVM中<strong>，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。</strong>如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-9a78f7ea7671a031.png" alt="img"> </p>
<ol>
<li>实例数据：存放类的属性数据信息，包括父类的属性信息；</li>
<li>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐；</li>
<li><strong>对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</strong></li>
</ol>
<p>Synchronized用的锁就是存在Java对象头里的，那么什么是Java对象头呢？Hotspot虚拟机的对象头主要包括两部分数据：<strong>Mark Word（标记字段）、</strong>Class Pointer（类型指针）。其中 Class Pointer是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。 Java对象头具体结构描述如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-2ab6edc7f91a1535.png" alt="img"></p>
<p>Java对象头结构组成</p>
<p>Mark Word用于存储对象自身的运行时数据，如：哈希码（HashCode）、GC分代年龄、<strong>锁状态标志</strong>、线程持有的锁、偏向线程 ID、偏向时间戳等。比如锁膨胀就是借助Mark Word的偏向的线程ID 参考：<a href="https://www.cnblogs.com/aspirant/p/11705068.html">JAVA锁的膨胀过程和优化(阿里)</a> 阿里也经常问的问题</p>
<p>下图是Java对象头 无锁状态下Mark Word部分的存储结构（32位虚拟机）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-063a9a5dc677cd12.png" alt="img"></p>
<p>Mark Word存储结构 </p>
<p>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，可能变化为存储以下4种数据：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-c63ff6c2d337ad5f.png" alt="img"></p>
<p>Mark Word可能存储4种数据</p>
<p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-5f6d3993ba018942.png" alt="img"></p>
<p>64位Mark Word存储结构</p>
<p>对象头的最后两位存储了锁的标志位，01是初始状态，未加锁，其对象头里存储的是对象本身的哈希码，随着锁级别的不同，对象头里会存储不同的内容。偏向锁存储的是当前占用此对象的线程ID；而轻量级则存储指向线程栈中锁记录的指针。从这里我们可以看到，“锁”这个东西，可能是个锁记录+对象头里的引用指针（判断线程是否拥有锁时将线程的锁记录地址和对象头里的指针地址比较)，也可能是对象头里的线程ID（判断线程是否拥有锁时将线程的ID和对象头里存储的线程ID比较）。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-36035cd1936bd2c6.png" alt="img"></p>
<p>HotSpot虚拟机对象头Mark Word</p>
<h2 id="对象头中Mark-Word与线程中Lock-Record"><a href="#对象头中Mark-Word与线程中Lock-Record" class="headerlink" title="对象头中Mark Word与线程中Lock Record"></a>对象头中Mark Word与线程中Lock Record</h2><p>在线程进入同步代码块的时候，如果此同步对象没有被锁定，即它的锁标志位是01，则虚拟机首先在当前线程的栈中创建我们称之为“锁记录（Lock Record）”的空间，用于存储锁对象的Mark Word的拷贝，官方把这个拷贝称为Displaced Mark Word。整个Mark Word及其拷贝至关重要。</p>
<p><strong>Lock Record是线程私有的数据结构</strong>，每一个线程都有一个可用Lock Record列表，同时还有一个全局的可用列表。每一个被锁住的对象Mark Word都会和一个Lock Record关联（对象头的MarkWord中的Lock Word指向Lock Record的起始地址），同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识（或者<code>object mark word</code>），表示该锁被这个线程占用。如下图所示为Lock Record的内部结构：</p>
<table>
<thead>
<tr>
<th>Lock Record</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Owner</td>
<td>初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</td>
</tr>
<tr>
<td>EntryQ</td>
<td>关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程；</td>
</tr>
<tr>
<td>RcThis</td>
<td>表示blocked或waiting在该monitor record上的所有线程的个数；</td>
</tr>
<tr>
<td>Nest</td>
<td>用来实现 重入锁的计数；</td>
</tr>
<tr>
<td>HashCode</td>
<td>保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</td>
</tr>
<tr>
<td>Candidate</td>
<td>用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</td>
</tr>
</tbody></table>
<h2 id="监视器（Monitor）"><a href="#监视器（Monitor）" class="headerlink" title="监视器（Monitor）"></a>监视器（Monitor）</h2><p>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。 </p>
<ol>
<li><strong>MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；</strong></li>
<li><strong>MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；</strong></li>
</ol>
<p>那什么是Monitor？可以把它理解为 一个同步工具，也可以描述为 一种同步机制，它通常被 描述为一个对象。</p>
<p>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，<strong>每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁</strong>。</p>
<p>也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（ 每个等待锁的线程都会被封装成ObjectWaiter对象 ），_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时：</p>
<blockquote>
<ol>
<li>首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1；</li>
<li>若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒；</li>
<li>若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；</li>
</ol>
</blockquote>
<p>同时<strong>，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</strong></p>
<p>监视器Monitor有两种同步方式：互斥与协作。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。</p>
<p>什么时候需要协作？ 比如：</p>
<blockquote>
<p>一个线程向缓冲区写数据，另一个线程从缓冲区读数据，如果读线程发现缓冲区为空就会等待，当写线程向缓冲区写入数据，就会唤醒读线程，这里读线程和写线程就是一个合作关系。JVM通过Object类的wait方法来使自己等待，在调用wait方法后，该线程会释放它持有的监视器，直到其他线程通知它才有执行的机会。一个线程调用notify方法通知在等待的线程，这个等待的线程并不会马上执行，而是要通知线程释放监视器后，它重新获取监视器才有执行的机会。如果刚好唤醒的这个线程需要的监视器被其他线程抢占，那么这个线程会继续等待。Object类中的notifyAll方法可以解决这个问题，它可以唤醒所有等待的线程，总有一个线程执行。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-d1cc81ebcf0e912b.png" alt="img"></p>
<p>如上图所示，一个线程通过1号门进入Entry Set(入口区)，如果在入口区没有线程等待，那么这个线程就会获取监视器成为监视器的Owner，然后执行监视区域的代码。如果在入口区中有其它线程在等待，那么新来的线程也会和这些线程一起等待。线程在持有监视器的过程中，有两个选择，一个是正常执行监视器区域的代码，释放监视器，通过5号门退出监视器；还有可能等待某个条件的出现，于是它会通过3号门到Wait Set（等待区）休息，直到相应的条件满足后再通过4号门进入重新获取监视器再执行。</p>
<p>注意：</p>
<blockquote>
<p>当一个线程释放监视器时，在入口区和等待区的等待线程都会去竞争监视器，如果入口区的线程赢了，会从2号门进入；如果等待区的线程赢了会从4号门进入。只有通过3号门才能进入等待区，在等待区中的线程只有通过4号门才能退出等待区，也就是说一个线程只有在持有监视器时才能执行wait操作，处于等待的线程只有再次获得监视器才能退出等待状态。</p>
</blockquote>
<h1 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h1><p>从JDK5引入了现代操作系统新增加的CAS原子操作（ JDK5中并没有对synchronized关键字做优化，而是体现在J.U.C中，所以在该版本concurrent包有更好的性能 ），从JDK6开始，就对synchronized的实现机制进行了较大调整，包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。由于此关键字的优化使得性能极大提高，同时语义清晰、操作简单、无需手动关闭，所以推荐在允许的情况下尽量使用此关键字，同时在性能上此关键字还有优化的空间。</p>
<p>锁主要存在四种状态，依次是<strong>：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</p>
<p>在 JDK 1.6 中默认是开启偏向锁和轻量级锁的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。</p>
<p>所以引入自旋锁，何谓自旋锁？ </p>
<p>所谓自旋锁，就是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。</p>
<p>自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了CPU处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p>
<p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整。</p>
<p>如果通过参数-XX:PreBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如多自旋一两次就可以获取锁），是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p>
<h2 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h2><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。那它如何进行适应性自旋呢？ </p>
<p><strong>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</strong></p>
<p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。</p>
<blockquote>
<p>锁消除的依据是逃逸分析的数据支持</p>
</blockquote>
<p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于程序员来说这还不清楚么？在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？虽然没有显示使用锁，但是在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是 为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p>
<p>在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。</p>
<p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</p>
<p>如上面实例：</p>
<blockquote>
<p><strong>vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</strong></p>
</blockquote>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</p>
<p>偏向锁是在单线程执行代码块时使用的机制，如果在多线程并发的环境下（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请），则一定会转化为轻量级锁或者重量级锁。</p>
<p>在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。如果并发数较大同时同步代码块执行时间较长，则被多个线程同时访问的概率就很大，就可以使用参数-XX:-UseBiasedLocking来禁止偏向锁(但这是个JVM参数，不能针对某个对象锁来单独设置)。</p>
<p>引入偏向锁主要目的是：为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗也必须小于节省下来的CAS原子指令的性能消耗）。</p>
<blockquote>
<p>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
</blockquote>
<p>那么偏向锁是如何来减少不必要的CAS操作呢？首先我们看下无竞争下锁存在什么问题：</p>
<blockquote>
<p><strong>现在几乎所有的锁都是可重入的，即已经获得锁的线程可以多次锁住/解锁监视对象，按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是 一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。</strong></p>
</blockquote>
<p>CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起，下图大概表明了SMP的结构：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-0f9f45797f3e732a.png" alt="img"></p>
<p>SMP（对称多处理器）架构</p>
<blockquote>
<p>其意思是 所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。</p>
</blockquote>
<p>而CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p>
<p>例如：Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。而当Core1和Core2中的值再次一致时，称为“Cache一致性”，从这个层面来说，锁设计的终极目标便是减少Cache一致性流量。</p>
<p>而CAS恰好会导致Cache一致性流量，如果有很多线程都共享同一个对象，当某个Core CAS成功时必然会引起总线风暴，这就是所谓的本地延迟，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。</p>
<p><em>Cache一致性：</em></p>
<blockquote>
<p>上面提到Cache一致性，其实是有协议支持的，现在通用的协议是MESI（最早由Intel开始支持），具体参考：<a href="http://en.wikipedia.org/wiki/MESI_protocol%E3%80%82">http://en.wikipedia.org/wiki/MESI_protocol。</a></p>
</blockquote>
<p><em>Cache一致性流量的例外情况：</em></p>
<blockquote>
<p>其实也不是所有的CAS都会导致总线风暴，这跟Cache一致性协议有关，具体参考：<a href="http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot">http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a></p>
</blockquote>
<p><em>NUMA(Non Uniform Memory Access Achitecture）架构：</em></p>
<blockquote>
<p>与SMP对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个Core有自己的内存，针对这种结构此处不做讨论。</p>
</blockquote>
<p>所以，当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要花费CAS操作来争夺锁资源，只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：</p>
<blockquote>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li>
<li>如果测试线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li>执行同步代码块；</li>
</ol>
</blockquote>
<p>偏向锁的释放采用了 一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要 等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<blockquote>
<ol>
<li>暂停拥有偏向锁的线程；</li>
<li>判断锁对象是否还处于被锁定状态，否，则恢复到无锁状态（01），以允许其余线程竞争。是，则挂起持有锁的当前线程，并将指向当前线程的锁记录地址的指针放入对象头Mark Word，升级为轻量级锁状态（00），然后恢复持有锁的当前线程，进入轻量级锁的竞争模式；</li>
</ol>
<p>注意：此处将 当前线程挂起再恢复的过程中并没有发生锁的转移，仍然在当前线程手中，只是穿插了个 “将对象头中的线程ID变更为指向锁记录地址的指针” 这么个事。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-b4873ca2e39c1db7.png" alt="img"></p>
<p>偏向锁的获取和释放过程</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>引入轻量级锁的主要目的是 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</p>
<ol>
<li>在线程进入同步块时，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。此时线程堆栈与对象头的状态如下图所示：</li>
</ol>
<pre><code>![img](https://upload-images.jianshu.io/upload_images/2062729-7e332020d9f252db.png)

轻量级锁CAS操作之前线程堆栈与对象的状态</code></pre>
<ol start="2">
<li><p>拷贝对象头中的Mark Word复制到锁记录（Lock Record）中；</p>
</li>
<li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象Mark Word中的Lock Word更新为指向当前线程Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）；</p>
</li>
<li><p>如果这个更新动作成功了，那么当前线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，此时线程堆栈与对象头的状态如下图所示：</p>
</li>
</ol>
<pre><code>![img](https://upload-images.jianshu.io/upload_images/2062729-5e935668eddb8fcd.png)

轻量级锁CAS操作之后线程堆栈与对象的状态</code></pre>
<ol start="5">
<li>如果这个更新操作失败了，虚拟机首先会检查对象Mark Word中的Lock Word是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，进入自旋执行（3），若自旋结束时仍未获得锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</li>
</ol>
<p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p>
<blockquote>
<ol>
<li>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word；</li>
<li>如果替换成功，整个同步过程就完成了，恢复到无锁状态（01）；</li>
<li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程；</li>
</ol>
</blockquote>
<p>对于轻量级锁，其性能提升的依据是 “对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-b952465daf77e896.png" alt="img"></p>
<p>轻量级锁的获取和释放过程</p>
<ol>
<li><p>为什么升级为轻量锁时要把对象头里的Mark Word复制到线程栈的锁记录中呢？</p>
<blockquote>
<p>因为在申请对象锁时 需要以该值作为CAS的比较条件，同时在升级到重量级锁的时候，能通过这个比较判定是否在持有锁的过程中此锁被其他线程申请过，如果被其他线程申请了，则在释放锁的时候要唤醒被挂起的线程。</p>
</blockquote>
</li>
<li><p>为什么会尝试CAS不成功以及什么情况下会不成功？</p>
<blockquote>
<p>CAS本身是不带锁机制的，其是通过比较而来。假设如下场景：线程A和线程B都在对象头里的锁标识为无锁状态进入，那么如线程A先更新对象头为其锁记录指针成功之后，线程B再用CAS去更新，就会发现此时的对象头已经不是其操作前的对象HashCode了，所以CAS会失败。也就是说，只有两个线程并发申请锁的时候会发生CAS失败。</p>
<p>然后线程B进行CAS自旋，等待对象头的锁标识重新变回无锁状态或对象头内容等于对象HashCode（因为这是线程B做CAS操作前的值），这也就意味着线程A执行结束（参见后面轻量级锁的撤销，只有线程A执行完毕撤销锁了才会重置对象头），此时线程B的CAS操作终于成功了，于是线程B获得了锁以及执行同步代码的权限。如果线程A的执行时间较长，线程B经过若干次CAS时钟没有成功，则锁膨胀为重量级锁，即线程B被挂起阻塞、等待重新调度。</p>
</blockquote>
</li>
</ol>
<p>此处，如何理解“轻量级”？“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。</p>
<blockquote>
<p>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，必然就会导致轻量级锁膨胀为重量级锁。</p>
</blockquote>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>Synchronized是通过对象内部的一个叫做 监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。</p>
<h2 id="重量级锁、轻量级锁和偏向锁之间转换"><a href="#重量级锁、轻量级锁和偏向锁之间转换" class="headerlink" title="重量级锁、轻量级锁和偏向锁之间转换"></a>重量级锁、轻量级锁和偏向锁之间转换</h2><p><img src="https://upload-images.jianshu.io/upload_images/2062729-5f1830874fd93080.png" alt="img"></p>
<p>重量级锁、轻量级锁和偏向锁之间转换</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-61dfb07d48d8588c.png" alt="img"></p>
<p>Synchronized偏向锁、轻量级锁及重量级锁转换流程</p>
<h1 id="锁的优劣"><a href="#锁的优劣" class="headerlink" title="锁的优劣"></a>锁的优劣</h1><p>各种锁并不是相互代替的，而是在不同场景下的不同选择，绝对不是说重量级锁就是不合适的。每种锁是只能升级，不能降级，即由偏向锁-&gt;轻量级锁-&gt;重量级锁，而这个过程就是开销逐渐加大的过程。</p>
<blockquote>
<ol>
<li>如果是单线程使用，那偏向锁毫无疑问代价最小，并且它就能解决问题，连CAS都不用做，仅仅在内存中比较下对象头就可以了；</li>
<li>如果出现了其他线程竞争，则偏向锁就会升级为轻量级锁；</li>
<li>如果其他线程通过一定次数的CAS尝试没有成功，则进入重量级锁；</li>
</ol>
</blockquote>
<p>在第3种情况下进入同步代码块就 要做偏向锁建立、偏向锁撤销、轻量级锁建立、升级到重量级锁，最终还是得靠重量级锁来解决问题，那这样的代价就比直接用重量级锁要大不少了。所以使用哪种技术，一定要看其所处的环境及场景，在绝大多数的情况下，偏向锁是有效的，这是基于HotSpot作者发现的“大多数锁只会由同一线程并发申请”的经验规律。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-c9740ab79f4d178c.png" alt="img"></p>
]]></content>
      <categories>
        <category>并发</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池之整体理解</title>
    <url>/posts/f168b730/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p><strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
</blockquote>
<a id="more"></a>

<h1 id="为什么要有线程池"><a href="#为什么要有线程池" class="headerlink" title="为什么要有线程池"></a>为什么要有线程池</h1><p>首先我们说说线程池的意义，线程是稀缺资源，它的创建与销毁是比较重且兄消耗资源的的操作。而java线程依赖于内核线程，创建线程需要进行操作系统状态切换，为避免资源过度消耗需要设法重用线程执行多个任务，线程池就是一个线程缓存，负责对线程进行统一分配、调优和监控。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h1 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p>
<blockquote>
<p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
</blockquote>
<p>Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。</p>
<h2 id="Executor-框架结构-主要由三大部分组成"><a href="#Executor-框架结构-主要由三大部分组成" class="headerlink" title="Executor 框架结构(主要由三大部分组成"></a>Executor 框架结构(主要由三大部分组成</h2><h3 id="1-任务-Runnable-Callable"><a href="#1-任务-Runnable-Callable" class="headerlink" title="1) 任务(Runnable /Callable)"></a>1) 任务(<code>Runnable</code> /<code>Callable</code>)</h3><p>执行任务需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>。*<em><code>Runnable</code> 接口*<em>或 \</em></em><code>Callable</code> 接口** 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p>
<h3 id="2-任务的执行-Executor"><a href="#2-任务的执行-Executor" class="headerlink" title="2) 任务的执行(Executor)"></a>2) 任务的执行(<code>Executor</code>)</h3><p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</p>
<p><strong>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</strong></p>
<blockquote>
<p><strong>注意：</strong> 通过查看 <code>ScheduledThreadPoolExecutor</code> 源代码我们发现 <code>ScheduledThreadPoolExecutor</code> 实际上是继承了 <code>ThreadPoolExecutor</code> 并实现了 ScheduledExecutorService ，而 <code>ScheduledExecutorService</code> 又实现了 <code>ExecutorService</code>，正如我们下面给出的类关系图显示的一样。</p>
</blockquote>
<p><strong><code>ThreadPoolExecutor</code> 类描述:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractExecutorService实现了ExecutorService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorServiceCopy</span> <span class="title">to</span> <span class="title">clipboardErrorCopied</span></span></span><br></pre></td></tr></table></figure>
<p><strong><code>ScheduledThreadPoolExecutor</code> 类描述:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ScheduledExecutorService继承ExecutorService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorServiceCopy</span> <span class="title">to</span> <span class="title">clipboardErrorCopied</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3.png" alt="任务的执行相关接口"></p>
<h3 id="3-异步计算的结果-Future"><a href="#3-异步计算的结果-Future" class="headerlink" title="3) 异步计算的结果(Future)"></a>3) 异步计算的结果(<code>Future</code>)</h3><p><strong><code>Future</code></strong> 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</p>
<p>当我们把 <strong><code>Runnable</code>接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）</p>
<h2 id="Executor-框架的使用示意图"><a href="#Executor-框架的使用示意图" class="headerlink" title="Executor 框架的使用示意图"></a>Executor 框架的使用示意图</h2><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Executor 框架的使用示意图"></p>
<ol>
<li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li>
<li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>
<li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>
<li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li>
</ol>
<h1 id="线程池的底层工作原理"><a href="#线程池的底层工作原理" class="headerlink" title="线程池的底层工作原理"></a>线程池的底层工作原理</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1587227106617-fb371590-1431-463b-9817-80d6f0e460e1.png" alt="image.png"></p>
<p>如图所示，corePoolSize=2；maximumPoolSize=3；队列缓冲数=5；</p>
<p>一个任务从提交到执行完毕经历过程如下：</p>
<p>1.当池中正在运行的线程数（包括空闲线程数）小于corePoolSize时，则每来一个任务，就会新建线程执行任务；</p>
<p>2.当池中正在运行的线程数（包括空闲线程数）大于等于corePoolSize时，新插入的任务进入workQueue排队(如workQueue长度允许)，等待空闲线程来执行。</p>
<p>3.当队列里的任务达到上限，并且池中正在进行的线程小于maxinumPoolSize，对于新加入的任务，新建线程。说明，相当于银行的开了临时窗口一样，这里新建的线程是进入队列排队，队列中的线程进入到临时窗口执行任务。</p>
<p>4.当队列里的任务达到上限，并且池中正在运行的线程等于*<strong>\</strong>*********maximumPoolSize，**********<em>**</em>对于新加入的任务，执行拒绝策略（线程池默认的策略是抛异常）。</p>
<p>如上图所示，当我们创建2个线程时，这时候他们在corePoolSize中执行，当我们的线程到3-7个时候，他们在队列排队，当到8个的时候，开1个临时窗口（临时窗口的数量+原来的corePoolSize数量等于最大数），这时候队列中的人来执行任务，第八个线程去排队，当到9个的时候，去拒绝策略了。</p>
<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量，一共32位，高3位存线程池状态runState（一共5种状态：Running，Shutdown，Stop，Tidying，Terminate），低29位存当前有效线程数workerCount。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>; <span class="comment">//COUNT_BITS=32</span></span><br><span class="line"><span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>; <span class="comment">//高3位000，低29位全为1</span></span><br><span class="line"><span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位111，低29位全为0</span></span><br><span class="line"><span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位000，低29位全为0</span></span><br><span class="line"><span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位001，低29位全为0</span></span><br><span class="line"><span class="keyword">int</span> STOPPING =  <span class="number">2</span> &lt;&lt; COUNT_BITS;   <span class="comment">//高3位010，低29位全为0</span></span><br><span class="line"><span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">//高3位011，低29位全为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到运行状态 </span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY; <span class="comment">//c 与 CAPACITY的取反</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到工作线程数量 </span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化ctl </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> rs | wc; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1587228091126-7a6f2438-d1a6-48b0-a096-4c8b0f310e1d.png" alt="image.png"></p>
<p>1.RUNNING</p>
<p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。</p>
<p>(2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>2.SHUTDOWN</p>
<p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</p>
<p>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p>
<p>3.STOP</p>
<p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</p>
<p>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p>4.TIDYING</p>
<p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。</p>
<p>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。</p>
<p>当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p>
<p>5.TERMINATED</p>
<p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。</p>
<p>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
<h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><h2 id="创建线程池的方法"><a href="#创建线程池的方法" class="headerlink" title="创建线程池的方法"></a>创建线程池的方法</h2><p>Executors工具类给我们提供了几种创建线程池的方法，分别是：</p>
<h3 id="newCachedThreadPool-ThreadPoolExecutor"><a href="#newCachedThreadPool-ThreadPoolExecutor" class="headerlink" title="newCachedThreadPool (ThreadPoolExecutor)"></a>newCachedThreadPool (ThreadPoolExecutor)</h3><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<h4 id="CachedThreadPool-实现"><a href="#CachedThreadPool-实现" class="headerlink" title="CachedThreadPool 实现"></a><code>CachedThreadPool</code> 实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>
<h4 id="执行任务过程介绍"><a href="#执行任务过程介绍" class="headerlink" title="执行任务过程介绍"></a>执行任务过程介绍</h4><p><strong>CachedThreadPool 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：</strong> <img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/CachedThreadPool-execute.png" alt="CachedThreadPool的execute()方法的执行示意图"></p>
<p><strong>上图说明：</strong></p>
<ol>
<li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤 2；</li>
<li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，execute 方法执行完成；</li>
</ol>
<h4 id="为什么不推荐使用CachedThreadPool？"><a href="#为什么不推荐使用CachedThreadPool？" class="headerlink" title="为什么不推荐使用CachedThreadPool？"></a>为什么不推荐使用<code>CachedThreadPool</code>？</h4><p><code>CachedThreadPool</code>允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</p>
<h3 id="newFixedThreadPool-ThreadPoolExecutor"><a href="#newFixedThreadPool-ThreadPoolExecutor" class="headerlink" title="newFixedThreadPool (ThreadPoolExecutor)"></a>newFixedThreadPool (ThreadPoolExecutor)</h3><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<h4 id="newFixedThreadPool的实现"><a href="#newFixedThreadPool的实现" class="headerlink" title="newFixedThreadPool的实现"></a>newFixedThreadPool的实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个可重用固定数量线程的线程池</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行流程："><a href="#运行流程：" class="headerlink" title="运行流程："></a>运行流程：</h4><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/FixedThreadPool.png" alt="FixedThreadPool的execute()方法运行示意图"></p>
<ol>
<li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li>
<li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li>
<li>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<h4 id="为什么不推荐使用fixedthreadpool？"><a href="#为什么不推荐使用fixedthreadpool？" class="headerlink" title="为什么不推荐使用fixedthreadpool？"></a>为什么不推荐使用fixedthreadpool？</h4><p><strong><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Intger.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</strong></p>
<ol>
<li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；</li>
<li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li>
<li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li>
<li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li>
</ol>
<h3 id="newSingleThreadExecutor-ThreadPoolExecutor"><a href="#newSingleThreadExecutor-ThreadPoolExecutor" class="headerlink" title="newSingleThreadExecutor (ThreadPoolExecutor)"></a>newSingleThreadExecutor (ThreadPoolExecutor)</h3><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<h4 id="SingleThreadExecutor-的实现"><a href="#SingleThreadExecutor-的实现" class="headerlink" title="SingleThreadExecutor 的实现"></a>SingleThreadExecutor 的实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回只有一个线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">         (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">         (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从上面源代码可以看出新创建的 <code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1.其他参数和 <code>FixedThreadPool</code> 相同。</p>
<h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><p><strong><code>SingleThreadExecutor</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：</strong> <img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/SingleThreadExecutor.png" alt="SingleThreadExecutor的运行示意图"></p>
<p><strong>上图说明;</strong></p>
<ol>
<li>如果当前运行的线程数少于 corePoolSize，则创建一个新的线程执行任务；</li>
<li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li>
<li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<h4 id="为什么不推荐使用SingleThreadExecutor"><a href="#为什么不推荐使用SingleThreadExecutor" class="headerlink" title="为什么不推荐使用SingleThreadExecutor"></a>为什么不推荐使用<code>SingleThreadExecutor</code></h4><p><code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点就是可能会导致 OOM，</p>
<h3 id="newScheduledThreadPool-ScheduledThreadPoolExecutor"><a href="#newScheduledThreadPool-ScheduledThreadPoolExecutor" class="headerlink" title="newScheduledThreadPool (ScheduledThreadPoolExecutor)"></a>newScheduledThreadPool (ScheduledThreadPoolExecutor)</h3><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<h3 id="newSingleThreadScheduledExecutor-ScheduledThreadPoolExecutor"><a href="#newSingleThreadScheduledExecutor-ScheduledThreadPoolExecutor" class="headerlink" title="newSingleThreadScheduledExecutor (ScheduledThreadPoolExecutor)"></a>newSingleThreadScheduledExecutor (ScheduledThreadPoolExecutor)</h3><p>创建一个单线程用于定时以及周期性执行任务的需求。</p>
<h3 id="newWorkStealingPool-1-8-ForkJoinPool"><a href="#newWorkStealingPool-1-8-ForkJoinPool" class="headerlink" title="newWorkStealingPool (1.8 ForkJoinPool)"></a>newWorkStealingPool (1.8 ForkJoinPool)</h3><p>创建一个工作窃取</p>
<h2 id="为什么线程池不允许使用Executors去创建"><a href="#为什么线程池不允许使用Executors去创建" class="headerlink" title="为什么线程池不允许使用Executors去创建?"></a>为什么线程池不允许使用Executors去创建?</h2><blockquote>
<p>注意：在阿里巴巴java开发手册中明确指出，不允许使用Executors创建线程池，容易造成内存溢出。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1054034/1587226456943-f38f53bb-5f54-4264-b578-7006750a8fc1.png" alt="image.png"></p>
<p>所以我们实际使用中，最好通过new ThreadPoolExecutor来创建线程池!</p>
<h4 id="推荐方式"><a href="#推荐方式" class="headerlink" title="推荐方式"></a>推荐方式</h4><p>首先引入：commons-lang3包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">        <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">&quot;example-schedule-pool-%d&quot;</span>).daemon(<span class="keyword">true</span>).build());</span><br></pre></td></tr></table></figure>
<h4 id="推荐方式-2"><a href="#推荐方式-2" class="headerlink" title="推荐方式 2"></a>推荐方式 2</h4><p>首先引入：com.google.guava包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Common Thread Pool</span></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line"><span class="comment">// excute</span></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//gracefully shutdown</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>
<h4 id="推荐方式-3"><a href="#推荐方式-3" class="headerlink" title="推荐方式 3"></a>推荐方式 3</h4><p>spring配置线程池方式：自定义线程工厂bean需要实现ThreadFactory，可参考该接口的其它默认实现类，使用方式直接注入bean调用execute(Runnable task)方法即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userThreadPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueCapacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;threadFactory&quot;</span> <span class="attr">value</span>= <span class="string">threadFactory</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//in code</span><br><span class="line">userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure>
<h3 id="监控线程池的状态"><a href="#监控线程池的状态" class="headerlink" title="监控线程池的状态"></a>监控线程池的状态</h3><p>可以使用ThreadPoolExecutor以下方法:</p>
<ul>
<li><code>getTaskCount()</code> Returns the approximate total number of tasks that have ever been scheduled for execution.</li>
<li><code>getCompletedTaskCount()</code> Returns the approximate total number of tasks that have completed execution. 返回结果少于getTaskCount()。</li>
<li><code>getLargestPoolSize()</code> Returns the largest number of threads that have ever simultaneously been in the pool. 返回结果小于等于maximumPoolSize</li>
<li><code>getPoolSize()</code> Returns the current number of threads in the pool.</li>
<li><code>getActiveCount()</code> Returns the approximate number of threads that are actively executing tasks.</li>
</ul>
<h2 id="线程池在生产环境中的配置"><a href="#线程池在生产环境中的配置" class="headerlink" title="线程池在生产环境中的配置"></a>线程池在生产环境中的配置</h2><p><strong>线程池数量的确定一直是困扰着程序员的一个难题，大部分程序员在设定线程池大小的时候就是随心而定。</strong></p>
<p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>
<blockquote>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<p><strong>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</strong></p>
<p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p>
<p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p>
<h3 id="线程池大小的配置"><a href="#线程池大小的配置" class="headerlink" title="线程池大小的配置"></a>线程池大小的配置</h3><p>1.计算密集型：顾名思义就是应用需要非常多的CPU计算资源，在多核CPU时代，我们要让每一个CPU核心都参与计算，将CPU的性能充分利用起来，这样才算是没有浪费服务器配置，如果在非常好的服务器配置上还运行着单线程程序那将是多么重大的浪费。对于计算密集型的应用，完全是靠CPU的核数来工作，所以为了让它的优势完全发挥出来，避免过多的线程上下文切换，比较理想方案是：</p>
<p>线程数 = CPU核数+1，也可以设置成CPU核数*2，但还要看JDK的版本以及CPU配置(服务器的CPU有超线程)。</p>
<p>一般设置CPU * 2即可。</p>
<p>2.IO密集型：我们现在做的开发大部分都是WEB应用，涉及到大量的网络传输，不仅如此，与数据库，与缓存间的交互也涉及到IO，一旦发生IO，线程就会处于等待状态，当IO结束，数据准备好后，线程才会继续执行。因此从这里可以发现，对于IO密集型的应用，我们可以多设置一些线程池中线程的数量，这样就能让在等待IO的这段时间内，线程可以去做其它事，提高并发处理效率。那么这个线程池的数据量是不是可以随便设置呢？当然不是的，请一定要记得，线程上下文切换是有代价的。目前总结了一套公式，对于IO密集型应用：</p>
<p>线程数 = CPU核心数/(1-阻塞系数) 这个阻塞系数一般为0.8~0.9之间，也可以取0.8或者0.9。</p>
<p>取0.9套用公式，理想的线程数就是CPU核心数的10倍左右，对于双核CPU来说，它比较理想的线程数就是20，当然这都不是绝对的，需要根据实际情况以及实际业务来调整：final int poolSize = (int)(cpuCore/(1-0.9))</p>
<h3 id="如何判断是-CPU-密集任务还是-IO-密集任务？"><a href="#如何判断是-CPU-密集任务还是-IO-密集任务？" class="headerlink" title="如何判断是 CPU 密集任务还是 IO 密集任务？"></a><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></h3><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h3 id="线程池相关参数配置"><a href="#线程池相关参数配置" class="headerlink" title="线程池相关参数配置"></a>线程池相关参数配置</h3><p>第一，配置时必须谨记，<strong>一定不要选择没有上限限制的配置项</strong>。</p>
<p>这也是为什么不建议使用<code>Executors</code> 中创建线程的方法。比如，<code>Executors.newCachedThreadPool</code>的设置与无界队列的设置因为某些不可预期的情况，线程池会出现系统异常，导致线程暴增的情况或者任务队列不断膨胀，内存耗尽导致系统崩溃和异常。 我们推荐使用自定义线程池来避免该问题，这也是在使用线程池规范的首要原则！ 小心无大错，千万别过度自信！</p>
<p>第二，合理设置线程数量、和线程空闲回收时间，根据具体的任务执行周期和时间去设定，避免频繁的回收和创建，虽然我们使用线程池的目的是为了提升系统性能和吞吐量，但是也要考虑下系统的稳定性，不然出现不可预期问题会很麻烦！</p>
<p>第三，根据实际场景，选择适用于自己的拒绝策略。进行补偿，不要乱用JDK支持的自动补偿机制！尽量采用自定义的拒绝策略去进行兜底！</p>
<p>第四，线程池拒绝策略，自定义拒绝策略可以实现RejectedExecutionHandler接口。</p>
<h3 id="利用Hook"><a href="#利用Hook" class="headerlink" title="利用Hook"></a>利用Hook</h3><p>利用Hook，留下线程池执行轨迹：ThreadPoolExecutor提供了protected类型可以被覆盖的钩子方法，允许用户在任务执行之前会执行之后做一些事情。我们可以通过它来实现比如初始化ThreadLocal、收集统计信息、如记录日志等操作。这类Hook如beforeExecute和afterExecute。另外还有一个Hook可以用来在任务被执行完的时候让用户插入逻辑，如rerminated 。如果hook方法执行失败，则内部的工作线程的执行将会失败或被中断。我们可以使用beforeExecute和afterExecute来记录线程之前前和后的一些运行情况，也可以直接把运行完成后的状态记录到ELK等日志系统。</p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>当线程池不在被引用并且工作线程数为0的时候，线程池将被终止。我们也可以调用shutdown来手动终止线程池。如果我们忘记调用shutdown，为了让线程资源被释放，我们还可以使用keepAliveTime和allowCoreThreadTimeOut来达到目的!</p>
<p>当然，稳妥的方式是使用虚拟机Runtime.getRuntime().addShutdownHook方法，手工去调用线程池的关闭方法！</p>
<h2 id="线程池的使用案例"><a href="#线程池的使用案例" class="headerlink" title="线程池的使用案例"></a>线程池的使用案例</h2><p>线程池核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步处理队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProcessQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Task 包装类&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 此类型的意义是记录可能会被 Executor 吃掉的异常&lt;br&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskWrapper</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger _LOGGER = LoggerFactory.getLogger(TaskWrapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable gift;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TaskWrapper</span><span class="params">(<span class="keyword">final</span> Runnable target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gift = target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 捕获异常，避免在 Executor 里面被吞掉了</span></span><br><span class="line">            <span class="keyword">if</span> (gift != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    gift.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    _LOGGER.error(<span class="string">&quot;Wrapped target execute exception.&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行指定的任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AsyncProcessor.executeTask(<span class="keyword">new</span> TaskWrapper(task));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AsyncProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认最大并发数&lt;br&gt; 可用的处理器个数*2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CONCURRENT = Runtime.getRuntime()</span><br><span class="line">        .availableProcessors() * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池名称格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_POOL_NAME = <span class="string">&quot;ExternalConvertProcessPool-%d&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程工厂名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory FACTORY = <span class="keyword">new</span> BasicThreadFactory.Builder()</span><br><span class="line">        .namingPattern(THREAD_POOL_NAME).daemon(<span class="keyword">true</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认线程存活时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_KEEP_ALIVE = <span class="number">60L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**NewEntryServiceImpl.java:689</span></span><br><span class="line"><span class="comment">     * Executor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Runnable&gt; executeQueue </span><br><span class="line">        = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(DEFAULT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Executor</span></span><br><span class="line">        <span class="comment">// 此处默认最大值改为处理器数量的 4 倍</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> ThreadPoolExecutor(DEFAULT_MAX_CONCURRENT, </span><br><span class="line">                    DEFAULT_MAX_CONCURRENT * <span class="number">4</span>, DEFAULT_KEEP_ALIVE,</span><br><span class="line">                    TimeUnit.SECONDS, executeQueue, FACTORY);</span><br><span class="line">            <span class="comment">// 关闭事件的挂钩</span></span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    AsyncProcessor.LOGGER.info(<span class="string">&quot;AsyncProcessor shutting down.&quot;</span>);</span><br><span class="line">                    executor.shutdown();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待1秒执行关闭</span></span><br><span class="line">                        <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                            AsyncProcessor.LOGGER.error(<span class="string">&quot;AsyncProcessor shutdown immediately due to wait timeout.&quot;</span>);</span><br><span class="line">                            executor.shutdownNow();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        AsyncProcessor.LOGGER.error(<span class="string">&quot;AsyncProcessor shutdown interrupted.&quot;</span>);</span><br><span class="line">                        executor.shutdownNow();</span><br><span class="line">                    &#125;</span><br><span class="line">                    AsyncProcessor.LOGGER.info(<span class="string">&quot;AsyncProcessor shutdown complete.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;AsyncProcessor init error.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此类型无法实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AsyncProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行任务，不管是否成功&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 其实也就是包装以后的 &#123;<span class="doctag">@link</span> Executer&#125; 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">executeTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Task executing was rejected.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交任务，并可以在稍后获取其执行情况&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 当提交失败时，会抛出 &#123;<span class="doctag">@link</span> &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submitTask</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> executor.submit(task);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Task executing was rejected.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Unable to submit the task, rejected.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AsyncProcessQueue.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="几个常见的对比"><a href="#几个常见的对比" class="headerlink" title="几个常见的对比"></a>几个常见的对比</h1><h2 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a><code>Runnable</code> vs <code>Callable</code></h2><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。*<em><code>Runnable</code> 接口<strong>不会返回结果或抛出检查异常，但是</strong><code>Callable</code> 接口*<em>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 \</em></em><code>Runnable</code> 接口**，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line">Callable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a><code>execute()</code> vs <code>submit()</code></h2><p><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></p>
<p><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong> ，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<p>我们以**<code>AbstractExecutorService</code>**接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看看<code>execute()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shutdown-VSshutdownNow"><a href="#shutdown-VSshutdownNow" class="headerlink" title="shutdown()VSshutdownNow()"></a><code>shutdown()</code>VS<code>shutdownNow()</code></h2><p><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</p>
<p><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</p>
<h2 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a><code>isTerminated()</code> VS <code>isShutdown()</code></h2><p><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</p>
<p><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</p>
<h2 id="Callable-ThreadPoolExecutor示例代码"><a href="#Callable-ThreadPoolExecutor示例代码" class="headerlink" title="Callable+ThreadPoolExecutor示例代码"></a><code>Callable</code>+<code>ThreadPoolExecutor</code>示例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyCallable.java</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line">CallableDemo.java</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;::&quot;</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Wed Nov 13 13:40:41 CST 2019::pool-1-thread-1</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-2</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-3</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-4</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-5</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-3</span><br><span class="line">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-2</span><br><span class="line">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-1</span><br><span class="line">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-4</span><br><span class="line">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-5</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>Executor</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器之ThreadLocal</title>
    <url>/posts/4195ab92/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>ThreadLocal是通过线程隔离的方式防止任务在共享资源上产生冲突, 线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储</p>
<p>官网解释：该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量(通过其 get 或 set 方法)的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 ID 或事务 ID)相关联</p>
</blockquote>
<a id="more"></a>

<h1 id="ThreadLocal理解"><a href="#ThreadLocal理解" class="headerlink" title="ThreadLocal理解"></a>ThreadLocal理解</h1><blockquote>
<p>提到ThreadLocal被提到应用最多的是session管理和数据库链接管理，这里以数据访问为例帮助你理解ThreadLocal：</p>
</blockquote>
<p>如下数据库管理类在单线程使用是没有任何问题的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connect = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connect != <span class="keyword">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</p>
<p>为了解决上述线程安全的问题，第一考虑：互斥同步</p>
<p>你可能会说，将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理，比如用Synchronized或者ReentrantLock互斥锁。</p>
<p>这里再抛出一个问题：这地方到底需不需要将connect变量进行共享?</p>
<p>事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。即改后的代码可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connect = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connect != <span class="keyword">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConnectionManager connectionManager = <span class="keyword">new</span> ConnectionManager();</span><br><span class="line">        Connection connection = connectionManager.openConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用connection进行操作</span></span><br><span class="line"></span><br><span class="line">        connectionManager.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不仅严重影响程序执行效率，还可能导致服务器压力巨大。</p>
<p>这时候ThreadLocal登场了</p>
<p>那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。下面就是网上出现最多的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; dbConnectionLocal = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DriverManager.getConnection(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dbConnectionLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再注意下ThreadLocal的修饰符</p>
<p>ThreaLocal的JDK文档中说明：ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread。如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。</p>
<blockquote>
<p>但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p>
</blockquote>
<h1 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h1><h2 id="ThreadLocal的数据结构"><a href="#ThreadLocal的数据结构" class="headerlink" title="ThreadLocal的数据结构"></a><code>ThreadLocal</code>的数据结构</h2><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/2.png" alt="img"></p>
<p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p>
<p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p>
<p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p>
<p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p>
<p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p>
<h2 id="如何实现线程隔离"><a href="#如何实现线程隔离" class="headerlink" title="如何实现线程隔离"></a>如何实现线程隔离</h2><p>主要是用到了Thread对象中的一个ThreadLocalMap类型的变量threadLocals, 负责存储当前线程的关于Connection的对象, dbConnectionLocal(以上述例子中为例) 这个变量为Key, 以新建的Connection对象为Value; 这样的话, 线程第一次读取的时候如果不存在就会调用ThreadLocal的initialValue方法创建一个Connection对象并且返回;</p>
<p>具体关于为线程分配变量副本的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先获取当前线程对象t, 然后从线程t中获取到ThreadLocalMap的成员属性threadLocals</li>
<li>如果当前线程的threadLocals已经初始化(即不为null) 并且存在以当前ThreadLocal对象为Key的值, 则直接返回当前线程要获取的对象(本例中为Connection);</li>
<li>如果当前线程的threadLocals已经初始化(即不为null)但是不存在以当前ThreadLocal对象为Key的的对象, 那么重新创建一个Connection对象, 并且添加到当前线程的threadLocals Map中,并返回</li>
<li>如果当前线程的threadLocals属性还没有被初始化, 则重新创建一个ThreadLocalMap对象, 并且创建一个Connection对象并添加到ThreadLocalMap对象中并返回。</li>
</ul>
<p>如果存在则直接返回很好理解, 那么对于如何初始化的代码又是怎样的呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先调用我们上面写的重载过后的initialValue方法, 产生一个Connection对象</li>
<li>继续查看当前线程的threadLocals是不是空的, 如果ThreadLocalMap已被初始化, 那么直接将产生的对象添加到ThreadLocalMap中, 如果没有初始化, 则创建并添加对象到其中;</li>
</ul>
<p>同时, ThreadLocal还提供了直接操作Thread对象中的threadLocals的方法set；</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/6.png" alt="img"></p>
<p><code>ThreadLocal</code>中的<code>set</code>方法原理如上图所示，很简单，主要是判断<code>ThreadLocalMap</code>是否存在，然后使用<code>ThreadLocal</code>中的<code>set</code>方法进行数据处理。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们也可以不实现initialValue, 将初始化工作放到DBConnectionFactory的getConnection方法中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection connection = dbConnectionLocal.get();</span><br><span class="line">    <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = DriverManager.getConnection(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            dbConnectionLocal.set(connection);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们看过代码之后就很清晰的知道了为什么ThreadLocal能够实现变量的多线程隔离了; 其实就是用了Map的数据结构给当前线程缓存了, 要使用的时候就从本线程的threadLocals对象中获取就可以了, key就是当前线程;</p>
<p>当然了在当前线程下获取当前线程里面的Map里面的对象并操作肯定没有线程并发问题了, 当然能做到变量的线程间隔离了。</p>
<h2 id="ThreadLocalMap对象"><a href="#ThreadLocalMap对象" class="headerlink" title="ThreadLocalMap对象"></a><code>ThreadLocalMap</code>对象</h2><p>本质上来讲, 它就是一个Map, 但是这个ThreadLocalMap与我们平时见到的Map有点不一样</p>
<ul>
<li>它没有实现Map接口;</li>
<li>它没有public的方法, 最多有一个default的构造方法, 因为这个ThreadLocalMap的方法仅仅在ThreadLocal类中调用, 属于静态内部类</li>
<li>ThreadLocalMap的Entry实现继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</li>
<li>该方法仅仅用了一个Entry数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;</li>
</ul>
<h3 id="ThreadLocalMap-Hash算法"><a href="#ThreadLocalMap-Hash算法" class="headerlink" title="ThreadLocalMap Hash算法"></a><code>ThreadLocalMap</code> Hash算法</h3><p>既然是<code>Map</code>结构，那么<code>ThreadLocalMap</code>当然也要实现自己的<code>hash</code>算法来解决散列表数组冲突问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><code>ThreadLocalMap</code>中<code>hash</code>算法很简单，这里<code>i</code>就是当前key在散列表中对应的数组下标位置。</p>
<p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当创建一个<code>ThreadLocal</code>对象，这个<code>ThreadLocal.nextHashCode</code> 这个值就会增长 <code>0x61c88647</code> 。</p>
<p>这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p>
<p>我们自己可以尝试下：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/8.png" alt="img"></p>
<p>可以看到产生的哈希码分布很均匀，这里不去细纠<strong>斐波那契</strong>具体算法，感兴趣的可以自行查阅相关资料。</p>
<h3 id="ThreadLocalMap-Hash冲突"><a href="#ThreadLocalMap-Hash冲突" class="headerlink" title="ThreadLocalMap Hash冲突"></a><code>ThreadLocalMap</code> Hash冲突</h3><blockquote>
<p><strong>注明：</strong> 下面所有示例图中，<strong>绿色块</strong><code>Entry</code>代表<strong>正常数据</strong>，<strong>灰色块</strong>代表<code>Entry</code>的<code>key</code>值为<code>null</code>，<strong>已被垃圾回收</strong>。<strong>白色块</strong>表示<code>Entry</code>为<code>null</code>。</p>
</blockquote>
<p>虽然<code>ThreadLocalMap</code>中使用了<strong>黄金分割数来</strong>作为<code>hash</code>计算因子，大大减少了<code>Hash</code>冲突的概率，但是仍然会存在冲突。</p>
<p><code>HashMap</code>中解决冲突的方法是在数组上构造一个<strong>链表</strong>结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成<strong>红黑树</strong>。</p>
<p>而<code>ThreadLocalMap</code>中并没有链表结构，所以这里不能适用<code>HashMap</code>解决冲突的方式了。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/7.png" alt="img"></p>
<p>如上图所示，如果我们插入一个<code>value=27</code>的数据，通过<code>hash</code>计算后应该落入第4个槽位中，而槽位4已经有了<code>Entry</code>数据。</p>
<p>此时就会线性向后查找，一直找到<code>Entry</code>为<code>null</code>的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了<code>Entry</code>不为<code>null</code>且<code>key</code>值相等的情况，还有<code>Entry</code>中的<code>key</code>值为<code>null</code>的情况等等都会有不同的处理，后面会一一详细讲解。</p>
<p>这里还画了一个<code>Entry</code>中的<code>key</code>为<code>null</code>的数据（<strong>Entry=2的灰色块数据</strong>），因为<code>key</code>值是<strong>弱引用</strong>类型，所以会有这种数据存在。在<code>set</code>过程中，如果遇到了<code>key</code>过期的<code>Entry</code>数据，实际上是会进行一轮<strong>探测式清理</strong>操作的，具体操作方式后面会讲到。</p>
<h3 id="ThreadLocalMap-set-详解"><a href="#ThreadLocalMap-set-详解" class="headerlink" title="ThreadLocalMap.set()详解"></a><code>ThreadLocalMap.set()</code>详解</h3><h4 id="ThreadLocalMap-set-原理图解"><a href="#ThreadLocalMap-set-原理图解" class="headerlink" title="ThreadLocalMap.set()原理图解"></a><code>ThreadLocalMap.set()</code>原理图解</h4><p>看完了<code>ThreadLocal</code> <strong>hash算法</strong>后，我们再来看<code>set</code>是如何实现的。</p>
<p>往<code>ThreadLocalMap</code>中<code>set</code>数据（<strong>新增</strong>或者<strong>更新</strong>数据）分为好几种情况，针对不同的情况我们画图来说说明。</p>
<p><strong>第一种情况：</strong> 通过<code>hash</code>计算后的槽位对应的<code>Entry</code>数据为空：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/9.png" alt="img"></p>
<p>这里直接将数据放到该槽位即可。</p>
<p><strong>第二种情况：</strong> 槽位数据不为空，<code>key</code>值与当前<code>ThreadLocal</code>通过<code>hash</code>计算获取的<code>key</code>值一致：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/10.png" alt="img"></p>
<p>这里直接更新该槽位的数据。</p>
<p><strong>第三种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，没有遇到<code>key</code>过期的<code>Entry</code>：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/11.png" alt="img"></p>
<p>遍历散列数组，线性往后查找，如果找到<code>Entry</code>为<code>null</code>的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了<strong>key值相等</strong>的数据，直接更新即可。</p>
<p><strong>第四种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，遇到<code>key</code>过期的<code>Entry</code>，如下图，往后遍历过程中，一到了<code>index=7</code>的槽位数据<code>Entry</code>的<code>key=null</code>：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/12.png" alt="img"></p>
<p>散列数组下标为7位置对应的<code>Entry</code>数据<code>key</code>为<code>null</code>，表明此数据<code>key</code>值已经被垃圾回收掉了，此时就会执行<code>replaceStaleEntry()</code>方法，该方法含义是<strong>替换过期数据的逻辑</strong>，以<strong>index=7</strong>位起点开始遍历，进行探测式数据清理工作。</p>
<p>初始化探测式清理过期数据扫描的开始位置：<code>slotToExpunge = staleSlot = 7</code></p>
<p>以当前<code>staleSlot</code>开始 向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标<code>slotToExpunge</code>。<code>for</code>循环迭代，直到碰到<code>Entry</code>为<code>null</code>结束。</p>
<p>如果找到了过期的数据，继续向前迭代，直到遇到<code>Entry=null</code>的槽位才停止迭代，如下图所示，<strong>slotToExpunge被更新为0</strong>：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/13.png" alt="img"></p>
<p>以当前节点(<code>index=7</code>)向前迭代，检测是否有过期的<code>Entry</code>数据，如果有则更新<code>slotToExpunge</code>值。碰到<code>null</code>则结束探测。以上图为例<code>slotToExpunge</code>被更新为0。</p>
<p>上面向前迭代的操作是为了更新探测清理过期数据的起始下标<code>slotToExpunge</code>的值，这个值在后面会讲解，它是用来判断当前过期槽位<code>staleSlot</code>之前是否还有过期元素。</p>
<p>接着开始以<code>staleSlot</code>位置(index=7)向后迭代，<strong>如果找到了相同key值的Entry数据：</strong></p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/14.png" alt="img"></p>
<p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，找到后更新<code>Entry</code>的值并交换<code>staleSlot</code>元素的位置(<code>staleSlot</code>位置为过期元素)，更新<code>Entry</code>数据，然后开始进行过期<code>Entry</code>的清理工作，如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f3ba9af057e1e?w=1336&h=361&f=png&s=63049" alt="Yu4oWT.png"></p>
<p><strong>向后遍历过程中，如果没有找到相同key值的Entry数据：</strong></p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/15.png" alt="img"></p>
<p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，直到<code>Entry</code>为<code>null</code>则停止寻找。通过上图可知，此时<code>table</code>中没有<code>key</code>值相同的<code>Entry</code>。</p>
<p>创建新的<code>Entry</code>，替换<code>table[stableSlot]</code>位置：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/16.png" alt="img"></p>
<p>替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：<code>expungeStaleEntry()</code>和<code>cleanSomeSlots()</code>，具体细节后面会讲到，请继续往后看。</p>
<h4 id="ThreadLocalMap-set-源码详解"><a href="#ThreadLocalMap-set-源码详解" class="headerlink" title="ThreadLocalMap.set()源码详解"></a><code>ThreadLocalMap.set()</code>源码详解</h4><p>上面已经用图的方式解析了<code>set()</code>实现的原理，其实已经很清晰了，我们接着再看下源码：</p>
<p><code>java.lang.ThreadLocal</code>.<code>ThreadLocalMap.set()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会通过<code>key</code>来计算在散列表中的对应位置，然后以当前<code>key</code>对应的桶的位置向后查找，找到可以使用的桶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry[] tab = table;</span><br><span class="line"><span class="keyword">int</span> len = tab.length;</span><br><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>什么情况下桶才是可以使用的呢？</p>
<ol>
<li><code>k = key</code> 说明是替换操作，可以使用</li>
<li>碰到一个过期的桶，执行替换逻辑，占用过期桶</li>
<li>查找过程中，碰到桶中<code>Entry=null</code>的情况，直接使用</li>
</ol>
<p>接着就是执行<code>for</code>循环遍历，向后查找，我们先看下<code>nextIndex()</code>、<code>prevIndex()</code>方法实现：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/17.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看剩下<code>for</code>循环中的逻辑：</p>
<ol>
<li>遍历当前<code>key</code>值对应的桶中<code>Entry</code>数据为空，这说明散列数组这里没有数据冲突，跳出<code>for</code>循环，直接<code>set</code>数据到对应的桶中</li>
<li>如果<code>key</code>值对应的桶中<code>Entry</code>数据不为空</li>
<li>1 如果<code>k = key</code>，说明当前<code>set</code>操作是一个替换操作，做替换逻辑，直接返回</li>
<li>2 如果<code>key = null</code>，说明当前桶位置的<code>Entry</code>是过期数据，执行<code>replaceStaleEntry()</code>方法(核心方法)，然后返回</li>
<li><code>for</code>循环执行完毕，继续往下执行说明向后迭代的过程中遇到了<code>entry</code>为<code>null</code>的情况</li>
<li>1 在<code>Entry</code>为<code>null</code>的桶中创建一个新的<code>Entry</code>对象</li>
<li>2 执行<code>++size</code>操作</li>
<li>调用<code>cleanSomeSlots()</code>做一次启发式清理工作，清理散列数组中<code>Entry</code>的<code>key</code>过期的数据</li>
<li>1 如果清理工作完成后，未清理到任何数据，且<code>size</code>超过了阈值(数组长度的2/3)，进行<code>rehash()</code>操作</li>
<li>2 <code>rehash()</code>中会先进行一轮探测式清理，清理过期<code>key</code>，清理完成后如果<strong>size &gt;= threshold - threshold / 4</strong>，就会执行真正的扩容逻辑(扩容逻辑往后看)</li>
</ol>
<p>接着重点看下<code>replaceStaleEntry()</code>方法，<code>replaceStaleEntry()</code>方法提供替换过期数据的功能，我们可以对应上面<strong>第四种情况</strong>的原理图来再回顾下，具体代码如下：</p>
<p><code>java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slotToExpunge<code>表示开始探测式清理过期数据的开始下标，默认从当前的</code>staleSlot<code>开始。以当前的</code>staleSlot<code>开始，向前迭代查找，找到没有过期的数据，</code>for<code>循环一直碰到</code>Entry<code>为</code>null<code>才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为i，即</code>slotToExpunge=i</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">     (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">     i = prevIndex(i, len))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着开始从<code>staleSlot</code>向后查找，也是碰到<code>Entry</code>为<code>null</code>的桶结束。 如果迭代过程中，<strong>碰到k == key</strong>，这说明这里是替换逻辑，替换新数据并且交换当前<code>staleSlot</code>位置。如果<code>slotToExpunge == staleSlot</code>，这说明<code>replaceStaleEntry()</code>一开始向前查找过期数据时并未找到过期的<code>Entry</code>数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的index，即<code>slotToExpunge = i</code>。最后调用<code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code>进行启发式过期数据清理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">    e.value = value;</span><br><span class="line"></span><br><span class="line">    tab[i] = tab[staleSlot];</span><br><span class="line">    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cleanSomeSlots()</code>和<code>expungeStaleEntry()</code>方法后面都会细讲，这两个是和清理相关的方法，一个是过期<code>key</code>相关<code>Entry</code>的启发式清理(<code>Heuristically scan</code>)，另一个是过期<code>key</code>相关<code>Entry</code>的探测式清理。</p>
<p><strong>如果k != key</strong>则会接着往下走，<code>k == null</code>说明当前遍历的<code>Entry</code>是一个过期数据，<code>slotToExpunge == staleSlot</code>说明，一开始的向前查找数据并未找到过期的<code>Entry</code>。如果条件成立，则更新<code>slotToExpunge</code> 为当前位置，这个前提是前驱节点扫描时未发现过期数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">    slotToExpunge = i;</span><br></pre></td></tr></table></figure>
<p>往后迭代的过程中如果没有找到<code>k == key</code>的数据，且碰到<code>Entry</code>为<code>null</code>的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到<code>table[staleSlot]</code> 对应的<code>slot</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br></pre></td></tr></table></figure>
<p>最后判断除了<code>staleSlot</code>以外，还发现了其他过期的<code>slot</code>数据，就要开启清理数据的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocalMap过期key的探测式清理流程"><a href="#ThreadLocalMap过期key的探测式清理流程" class="headerlink" title="ThreadLocalMap过期key的探测式清理流程"></a><code>ThreadLocalMap</code>过期key的探测式清理流程</h3><p>上面我们有提及<code>ThreadLocalMap</code>的两种过期<code>key</code>数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p>
<p>我们先讲下探测式清理，也就是<code>expungeStaleEntry</code>方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的<code>Entry</code>设置为<code>null</code>，沿途中碰到未过期的数据则将此数据<code>rehash</code>后重新在<code>table</code>数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的<code>Entry=null</code>的桶中，使<code>rehash</code>后的<code>Entry</code>数据距离正确的桶的位置更近一些。操作逻辑如下：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/18.png" alt="img"></p>
<p>如上图，<code>set(27)</code> 经过hash计算后应该落到<code>index=4</code>的桶中，由于<code>index=4</code>桶已经有了数据，所以往后迭代最终数据放入到<code>index=7</code>的桶中，放入后一段时间后<code>index=5</code>中的<code>Entry</code>数据<code>key</code>变为了<code>null</code></p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/19.png" alt="img"></p>
<p>如果再有其他数据<code>set</code>到<code>map</code>中，就会触发<strong>探测式清理</strong>操作。</p>
<p>如上图，执行<strong>探测式清理</strong>后，<code>index=5</code>的数据被清理掉，继续往后迭代，到<code>index=7</code>的元素时，经过<code>rehash</code>后发现该元素正确的<code>index=4</code>，而此位置已经已经有了数据，往后查找离<code>index=4</code>最近的<code>Entry=null</code>的节点(刚被探测式清理掉的数据：index=5)，找到后移动<code>index= 7</code>的数据到<code>index=5</code>中，此时桶的位置离正确的位置<code>index=4</code>更近了。</p>
<p>经过一轮探测式清理后，<code>key</code>过期的数据会被清理掉，没过期的数据经过<code>rehash</code>重定位后所处的桶位置理论上更接近<code>i= key.hashCode &amp; (tab.len - 1)</code>的位置。这种优化会提高整个散列表查询性能。</p>
<p>接着看下<code>expungeStaleEntry()</code>具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/20.png" alt="img"></p>
<p>我们假设<code>expungeStaleEntry(3)</code> 来调用此方法，如上图所示，我们可以看到<code>ThreadLocalMap</code>中<code>table</code>的数据情况，接着执行清理操作：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/21.png" alt="img"></p>
<p>第一步是清空当前<code>staleSlot</code>位置的数据，<code>index=3</code>位置的<code>Entry</code>变成了<code>null</code>。然后接着往后探测：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/22.png" alt="img"></p>
<p>执行完第二步后，index=4的元素挪到index=3的槽位中。</p>
<p>继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算<code>slot</code>位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/23.png" alt="img"></p>
<p>在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体<strong>实现源代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们还是以<code>staleSlot=3</code> 来做示例说明，首先是将<code>tab[staleSlot]</code>槽位的数据清空，然后设置<code>size--</code> 接着以<code>staleSlot</code>位置往后迭代，如果遇到<code>k==null</code>的过期数据，也是清空该槽位数据，然后<code>size--</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">    e.value = <span class="keyword">null</span>;</span><br><span class="line">    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>key</code>没有过期，重新计算当前<code>key</code>的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了<code>hash</code>冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放<code>entry</code>的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">        h = nextIndex(h, len);</span><br><span class="line"></span><br><span class="line">    tab[h] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是处理正常的产生<code>Hash</code>冲突的数据，经过迭代后，有过<code>Hash</code>冲突数据的<code>Entry</code>位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。</p>
<h3 id="ThreadLocalMap扩容机制"><a href="#ThreadLocalMap扩容机制" class="headerlink" title="ThreadLocalMap扩容机制"></a><code>ThreadLocalMap</code>扩容机制</h3><p>在``ThreadLocalMap.set()<code>方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中</code>Entry<code>的数量已经达到了列表的扩容阈值</code>(len*2/3)<code>，就开始执行</code>rehash()`逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>接着看下<code>rehash()</code>具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先是会进行探测式清理工作，从<code>table</code>的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，<code>table</code>中可能有一些<code>key</code>为<code>null</code>的<code>Entry</code>数据被清理掉，所以此时通过判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code> 来决定是否扩容。</p>
<p>我们还记得上面进行<code>rehash()</code>的阈值是<code>size &gt;= threshold</code>，所以当面试官套路我们<code>ThreadLocalMap</code>扩容机制的时候 我们一定要说清楚这两个步骤：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/24.png" alt="img"></p>
<p>接着看看具体的<code>resize()</code>方法，为了方便演示，我们以<code>oldTab.len=8</code>来举例：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/25.png" alt="img"></p>
<p>扩容后的<code>tab</code>的大小为<code>oldLen * 2</code>，然后遍历老的散列表，重新计算<code>hash</code>位置，然后放到新的<code>tab</code>数组中，如果出现<code>hash</code>冲突则往后寻找最近的<code>entry</code>为<code>null</code>的槽位，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到新的<code>tab</code>中了。重新计算<code>tab</code>下次扩容的<strong>阈值</strong>，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocalMap-get-详解"><a href="#ThreadLocalMap-get-详解" class="headerlink" title="ThreadLocalMap.get()详解"></a><code>ThreadLocalMap.get()</code>详解</h3><p>上面已经看完了<code>set()</code>方法的源码，其中包括<code>set</code>数据、清理数据、优化数据桶的位置等操作，接着看看<code>get()</code>操作的原理。</p>
<h4 id="ThreadLocalMap-get-图解"><a href="#ThreadLocalMap-get-图解" class="headerlink" title="ThreadLocalMap.get()图解"></a><code>ThreadLocalMap.get()</code>图解</h4><p><strong>第一种情况：</strong> 通过查找<code>key</code>值计算出散列表中<code>slot</code>位置，然后该<code>slot</code>位置中的<code>Entry.key</code>和查找的<code>key</code>一致，则直接返回：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/26.png" alt="img"></p>
<p><strong>第二种情况：</strong> <code>slot</code>位置中的<code>Entry.key</code>和要查找的<code>key</code>不一致：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/27.png" alt="img"></p>
<p>我们以<code>get(ThreadLocal1)</code>为例，通过<code>hash</code>计算后，正确的<code>slot</code>位置应该是4，而<code>index=4</code>的槽位已经有了数据，且<code>key</code>值不等于<code>ThreadLocal1</code>，所以需要继续往后迭代查找。</p>
<p>迭代到<code>index=5</code>的数据时，此时<code>Entry.key=null</code>，触发一次探测式数据回收操作，执行<code>expungeStaleEntry()</code>方法，执行完后，<code>index 5,8</code>的数据都会被回收，而<code>index 6,7</code>的数据都会前移，此时继续往后迭代，到<code>index = 6</code>的时候即找到了<code>key</code>值相等的<code>Entry</code>数据，如下图所示：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/28.png" alt="img"></p>
<h4 id="ThreadLocalMap-get-源码详解"><a href="#ThreadLocalMap-get-源码详解" class="headerlink" title="ThreadLocalMap.get()源码详解"></a><code>ThreadLocalMap.get()</code>源码详解</h4><p><code>java.lang.ThreadLocal.ThreadLocalMap.getEntry()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocalMap过期key的启发式清理流程"><a href="#ThreadLocalMap过期key的启发式清理流程" class="headerlink" title="ThreadLocalMap过期key的启发式清理流程"></a><code>ThreadLocalMap</code>过期key的启发式清理流程</h3><p>上面多次提及到<code>ThreadLocalMap</code>过期可以的两种清理方式：<strong>探测式清理(expungeStaleEntry())\</strong>、<strong>启发式清理(cleanSomeSlots())</strong></p>
<p>探测式清理是以当前<code>Entry</code> 往后清理，遇到值为<code>null</code>则结束清理，属于<strong>线性探测清理</strong>。</p>
<p>而启发式清理被作者定义为：<strong>Heuristically scan some cells looking for stale entries</strong>.</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/29.png" alt="img"></p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a><code>InheritableThreadLocal</code></h2><p>我们使用<code>ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p>
<p>为了解决这个问题，JDK中还有一个<code>InheritableThreadLocal</code>类，我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; ThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">        ThreadLocal.set(<span class="string">&quot;父类数据:threadLocal&quot;</span>);</span><br><span class="line">        inheritableThreadLocal.set(<span class="string">&quot;父类数据:inheritableThreadLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类`ThreadLocal`数据：&quot;</span> + `ThreadLocal`.get());</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类inheritableThreadLocal数据：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子线程获取父类`ThreadLocal`数据：<span class="keyword">null</span></span><br><span class="line">子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal</span><br></pre></td></tr></table></figure>
<p>实现原理是子线程是通过在父线程中通过调用<code>new Thread()</code>方法来创建子线程，<code>Thread#init</code>方法在<code>Thread</code>的构造方法中被调用。在<code>init</code>方法中拷贝父线程数据到子线程中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但<code>InheritableThreadLocal</code>仍然有缺陷，一般我们做异步化处理都是使用的线程池，而<code>InheritableThreadLocal</code>是在<code>new Thread</code>中的<code>init()</code>方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p>
<h1 id="ThreadLocal造成内存泄露的问题"><a href="#ThreadLocal造成内存泄露的问题" class="headerlink" title="ThreadLocal造成内存泄露的问题"></a>ThreadLocal造成内存泄露的问题</h1><p>网上有这样一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Long[] a = <span class="keyword">new</span> Long[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, TimeUnit.MINUTES,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;LocalVariable&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;LocalVariable&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// (3)</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span> * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">            poolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// (4)</span></span><br><span class="line">                    localVariable.set(<span class="keyword">new</span> LocalVariable());</span><br><span class="line">                    <span class="comment">// (5)</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;use local varaible&quot;</span> + localVariable.get());</span><br><span class="line">                    localVariable.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (6)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pool execute over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用线程池来操作ThreadLocal 对象确实会造成内存泄露, 因为对于线程池里面不会销毁的线程, 里面总会存在着<code>&lt;ThreadLocal, LocalVariable&gt;</code>的强引用, 因为final static 修饰的 ThreadLocal 并不会释放, 而ThreadLocalMap 对于 Key 虽然是弱引用, 但是强引用不会释放, 弱引用当然也会一直有值, 同时创建的LocalVariable对象也不会释放, 就造成了内存泄露; 如果LocalVariable对象不是一个大对象的话, 其实泄露的并不严重, <code>泄露的内存 = 核心线程数 * LocalVariable</code>对象的大小;</p>
<p>所以, 为了避免出现内存泄露的情况, ThreadLocal提供了一个清除线程中对象的方法, 即 remove, 其实内部实现就是调用 ThreadLocalMap 的remove方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到Key对应的Entry, 并且清除Entry的Key(ThreadLocal)置空, 随后清除过期的Entry即可避免内存泄露。</p>
<h2 id="GC-之后key是否为null？"><a href="#GC-之后key是否为null？" class="headerlink" title="GC 之后key是否为null？"></a>GC 之后key是否为null？</h2><p>回应开头的那个问题， <code>ThreadLocal</code> 的<code>key</code>是弱引用，那么在<code>ThreadLocal.get()</code>的时候,发生<code>GC</code>之后，<code>key</code>是否是<code>null</code>？</p>
<p>为了搞清楚这个问题，我们需要搞清楚<code>Java</code>的<strong>四种引用类型</strong>：</p>
<ul>
<li><strong>强引用</strong>：我们常常new出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用</strong>：使用SoftReference修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用</strong>：使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
<p>接着再来看下代码，我们使用反射的方式来看看<code>GC</code>后<code>ThreadLocal</code>中的数据情况：(下面代码来源自：<a href="https://blog.csdn.net/thewindkee/article/details/103726942%EF%BC%8C%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E6%BC%94%E7%A4%BAGC%E5%9B%9E%E6%94%B6%E5%9C%BA%E6%99%AF">https://blog.csdn.net/thewindkee/article/details/103726942，本地运行演示GC回收场景</a>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;test(<span class="string">&quot;abc&quot;</span>,<span class="keyword">false</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;--gc后--&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; test(<span class="string">&quot;def&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s,<span class="keyword">boolean</span> isGC)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;&gt;().set(s);</span><br><span class="line">            <span class="keyword">if</span> (isGC) &#123;</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            Class&lt;? extends Thread&gt; clz = t.getClass();</span><br><span class="line">            Field field = clz.getDeclaredField(<span class="string">&quot;threadLocals&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object ThreadLocalMap = field.get(t);</span><br><span class="line">            Class&lt;?&gt; tlmClass = ThreadLocalMap.getClass();</span><br><span class="line">            Field tableField = tlmClass.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">            tableField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object[] arr = (Object[]) tableField.get(ThreadLocalMap);</span><br><span class="line">            <span class="keyword">for</span> (Object o : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; entryClass = o.getClass();</span><br><span class="line">                    Field valueField = entryClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    Field referenceField = entryClass.getSuperclass().getSuperclass().getDeclaredField(<span class="string">&quot;referent&quot;</span>);</span><br><span class="line">                    valueField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    referenceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;弱引用key:%s,值:%s&quot;</span>, referenceField.get(o), valueField.get(o)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">弱引用key:java.lang.ThreadLocal@433619b6,值:abc</span><br><span class="line">弱引用key:java.lang.ThreadLocal@418a15e3,值:java.lang.ref.SoftReference<span class="meta">@bf97a12</span></span><br><span class="line">--gc后--</span><br><span class="line">弱引用key:<span class="keyword">null</span>,值:def</span><br></pre></td></tr></table></figure>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/3.png" alt="img"></p>
<p>如图所示，因为这里创建的<code>ThreadLocal</code>并没有指向任何值，也就是没有任何引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadLocal&lt;&gt;().set(s);</span><br></pre></td></tr></table></figure>
<p>所以这里在<code>GC</code>之后，<code>key</code>就会被回收，我们看到上面<code>debug</code>中的<code>referent=null</code>, 如果<strong>改动一下代码：</strong></p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/4.png" alt="img"></p>
<p>这个问题刚开始看，如果没有过多思考，<strong>弱引用</strong>，还有<strong>垃圾回收</strong>，那么肯定会觉得是<code>null</code>。</p>
<p>其实是不对的，因为题目说的是在做 <code>ThreadLocal.get()</code> 操作，证明其实还是有<strong>强引用</strong>存在的，所以 <code>key</code> 并不为 <code>null</code>，如下图所示，<code>ThreadLocal</code>的<strong>强引用</strong>仍然是存在的。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/5.png" alt="image.png"></p>
<p>如果我们的<strong>强引用</strong>不存在的话，那么 <code>key</code> 就会被回收，也就是会出现我们 <code>value</code> 没被回收，<code>key</code> 被回收，导致 <code>value</code> 永远存在，出现内存泄漏。</p>
<h1 id="再看ThreadLocal应用场景"><a href="#再看ThreadLocal应用场景" class="headerlink" title="再看ThreadLocal应用场景"></a>再看ThreadLocal应用场景</h1><p>除了上述的数据库管理类的例子，我们再看看其它一些应用：</p>
<h2 id="每个线程维护了一个“序列号”"><a href="#每个线程维护了一个“序列号”" class="headerlink" title="每个线程维护了一个“序列号”"></a>每个线程维护了一个“序列号”</h2><blockquote>
<p>再回想上文说的，如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。</p>
</blockquote>
<p>每个线程维护了一个“序列号”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNum</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The next serial number to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextSerialNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal serialNum = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(nextSerialNum++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) (serialNum.get())).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Session的管理"><a href="#Session的管理" class="headerlink" title="Session的管理"></a>Session的管理</h2><p>经典的另外一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;  </span><br><span class="line">    Session s = (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="在线程内部创建ThreadLocal"><a href="#在线程内部创建ThreadLocal" class="headerlink" title="在线程内部创建ThreadLocal"></a>在线程内部创建ThreadLocal</h2><p>还有一种用法是在线程类内部创建ThreadLocal，基本步骤如下：</p>
<ul>
<li>在多线程的类(如ThreadDemo类)中，创建一个ThreadLocal对象threadXxx，用来保存线程间需要隔离处理的对象xxx。</li>
<li>在ThreadDemo类中，创建一个获取要隔离访问的数据的方法getXxx()，在方法中判断，若ThreadLocal对象为null时候，应该new()一个隔离访问类型的对象，并强制转换为要应用的类型。</li>
<li>在ThreadDemo类的run()方法中，通过调用getXxx()方法获取要操作的数据，这样可以保证每个线程对应一个数据对象，在任何时刻都操作的是这个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ThreadLocal&lt;Student&gt; StudentThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String currentThreadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(currentThreadName + <span class="string">&quot; is running...&quot;</span>);</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> age = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(currentThreadName + <span class="string">&quot; is set age: &quot;</span>  + age);</span><br><span class="line">        Student Student = getStudentt(); <span class="comment">//通过这个方法，为每个线程都独立的new一个Studentt对象，每个线程的的Studentt对象都可以设置不同的值</span></span><br><span class="line">        Student.setAge(age);</span><br><span class="line">        System.out.println(currentThreadName + <span class="string">&quot; is first get age: &quot;</span> + Student.getAge());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( currentThreadName + <span class="string">&quot; is second get age: &quot;</span> + Student.getAge());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Student <span class="title">getStudentt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student Student = StudentThreadLocal.get();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == Student) &#123;</span><br><span class="line">            Student = <span class="keyword">new</span> Student();</span><br><span class="line">            StudentThreadLocal.set(Student);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocalTest t = <span class="keyword">new</span> ThreadLocalTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t,<span class="string">&quot;Thread A&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t,<span class="string">&quot;Thread B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="java-开发手册中推荐的-ThreadLocal"><a href="#java-开发手册中推荐的-ThreadLocal" class="headerlink" title="java 开发手册中推荐的 ThreadLocal"></a>java 开发手册中推荐的 ThreadLocal</h2><p>看看阿里巴巴 java 开发手册中推荐的 ThreadLocal 的用法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再要用到 DateFormat 对象的地方，这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateUtils.df.get().format(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>
<h2 id="ThreadLocal项目中使用实战"><a href="#ThreadLocal项目中使用实战" class="headerlink" title="ThreadLocal项目中使用实战"></a><code>ThreadLocal</code>项目中使用实战</h2><h3 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a><code>ThreadLocal</code>使用场景</h3><p>我们现在项目中日志记录用的是<code>ELK+Logstash</code>，最后在<code>Kibana</code>中进行展示和检索。</p>
<p>现在都是分布式系统统一对外提供服务，项目间调用的关系可以通过traceId来关联，但是不同项目之间如何传递<code>traceId</code>呢？</p>
<p>这里我们使用<code>org.slf4j.MDC</code>来实现此功能，内部就是通过<code>ThreadLocal</code>来实现的，具体实现如下：</p>
<p>当前端发送请求到<strong>服务A</strong>时，<strong>服务A</strong>会生成一个类似<code>UUID</code>的<code>traceId</code>字符串，将此字符串放入当前线程的<code>ThreadLocal</code>中，在调用<strong>服务B</strong>的时候，将<code>traceId</code>写入到请求的<code>Header</code>中，<strong>服务B</strong>在接收请求时会先判断请求的<code>Header</code>中是否有<code>traceId</code>，如果存在则写入自己线程的<code>ThreadLocal</code>中。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/30.png" alt="img"></p>
<p>图中的<code>requestId</code>即为我们各个系统链路关联的<code>traceId</code>，系统间互相调用，通过这个<code>requestId</code>即可找到对应链路，这里还有会有一些其他场景：</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/31.png" alt="img"></p>
<p>针对于这些场景，我们都可以有相应的解决方案，如下所示</p>
<h3 id="Feign远程调用解决方案"><a href="#Feign远程调用解决方案" class="headerlink" title="Feign远程调用解决方案"></a>Feign远程调用解决方案</h3><p><strong>服务发送请求：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignInvokeInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">        String requestId = MDC.get(<span class="string">&quot;requestId&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(requestId)) &#123;</span><br><span class="line">            template.header(<span class="string">&quot;requestId&quot;</span>, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>服务接收请求：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)</span> </span>&#123;</span><br><span class="line">        MDC.remove(<span class="string">&quot;requestId&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String requestId = request.getHeader(BaseConstant.REQUEST_ID_KEY);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(requestId)) &#123;</span><br><span class="line">            requestId = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MDC.put(<span class="string">&quot;requestId&quot;</span>, requestId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池异步调用，requestId传递"><a href="#线程池异步调用，requestId传递" class="headerlink" title="线程池异步调用，requestId传递"></a>线程池异步调用，requestId传递</h3><p>因为<code>MDC</code>是基于<code>ThreadLocal</code>去实现的，异步过程中，子线程并没有办法获取到父线程<code>ThreadLocal</code>存储的数据，所以这里可以自定义线程池执行器，修改其中的<code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolTaskExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolTaskExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; context = MDC.getCopyOfContextMap();</span><br><span class="line">        <span class="keyword">super</span>.execute(() -&gt; run(runnable, context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Runnable runnable, Map&lt;String, String&gt; context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            MDC.setContextMap(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MDC.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用MQ发送消息给第三方系统uide-docs-java-multi-thread-万字详解ThreadLocal关键字-id-使用mq发送消息给第三方系统"><a href="#使用MQ发送消息给第三方系统uide-docs-java-multi-thread-万字详解ThreadLocal关键字-id-使用mq发送消息给第三方系统" class="headerlink" title="使用MQ发送消息给第三方系统uide/#/docs/java/multi-thread/万字详解ThreadLocal关键字?id=使用mq发送消息给第三方系统)"></a>使用MQ发送消息给第三方系统uide/#/docs/java/multi-thread/万字详解ThreadLocal关键字?id=使用mq发送消息给第三方系统)</h3><p>在MQ发送的消息体中自定义属性<code>requestId</code>，接收方消费消息后，自己解析<code>requestId</code>使用即可。</p>
]]></content>
      <categories>
        <category>容器</category>
        <category>并发容器</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流之基础知识</title>
    <url>/posts/52b62e7d/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>IO流的基础知识 </p>
</blockquote>
<a id="more"></a>

<h1 id="IO流的四点明确"><a href="#IO流的四点明确" class="headerlink" title="IO流的四点明确"></a>IO流的四点明确</h1><p><strong>明确要操作的数据是数据源还是数据目的(要读还是要写)</strong>　　　　</p>
<p>源：<br>            <strong>InputStream　　Reader</strong></p>
<p>目的：<br>            <strong>OutputStream　　Writer</strong></p>
<p><strong>明确要操作的设备上的数据是字节还是文本</strong></p>
<p>源：    </p>
<p>　字节： <strong>InputStream</strong></p>
<p>　文本： <strong>Reader</strong></p>
<p>目的：</p>
<p>　字节： <strong>OutputStream</strong></p>
<p>　文本： <strong>Writer</strong></p>
<p><strong>明确数据所在的具体设备</strong></p>
<p>源设备：</p>
<p>　　硬盘：文件 <code>File</code>开头</p>
<p>　　内存：数组，字符串</p>
<p>　　键盘：<code>System.in</code></p>
<p>　　网络：<code>Socket</code></p>
<p>对应目的设备：　</p>
<p>​        硬盘：文件 <code>File</code>开头</p>
<p>　　内存：数组，字符串</p>
<p>　　屏幕：<code>System.out</code></p>
<p>　　网络：<code>Socket</code></p>
<p><strong>明确是否需要额外功能</strong></p>
<p>​        需要转换—— 转换流 <strong>InputStreamReader 、OutputStreamWriter</strong></p>
<p>　　需要高效—— 缓冲流<strong>Bufferedxxx</strong></p>
<p>　　多个源—— 序列流 <strong>SequenceInputStream</strong></p>
<p>　　对象序列化—— <strong>ObjectInputStream、ObjectOutputStream</strong></p>
<p>　　保证数据的输出形式—— 打印流<strong>PrintStream 、Printwriter</strong></p>
<p>　　操作基本数据，保证字节原样性——<strong>DataOutputStream、DataInputStream</strong></p>
<p>到这里，我们再来看看IO流的分类吧<br><img src="https://img-blog.csdnimg.cn/20191014111930276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>至于IO流，也就是输入输出流，从文件出发到文件结束，至始至终都离不开文件，所以IO流还得从文件File类讲起。</p>
<h2 id="File概述"><a href="#File概述" class="headerlink" title="File概述"></a>File概述</h2><p><code>java.io.File</code> 类是专门对文件进行操作的类，只能对文件本身进行操作，不能对文件内容进行操作。<br><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<p>怎么理解上面两句话？其实很简单！</p>
<p>第一句就是说File跟流无关，File类不能对文件进行读和写也就是输入和输出！<br>第二句就是说File主要表示类似<code>D:\\文件目录1</code>与<code>D:\\文件目录1\\文件.txt</code>,前者是文件夹（Directory）后者则是文件(file)，而File类就是操作这两者的类。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>在java中，一切皆是对象，File类也不例外，不论是哪个对象都应该从该对象的构造说起，所以博主来分析分析<code>File</code>类的构造方法。首先从API开始着手<br><img src="https://img-blog.csdnimg.cn/20191013095030887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们主要来学习一下比较常用的三个：</p>
<ol>
<li><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。</li>
<li><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li>
<li> <code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 一个File对象代表硬盘中实际存在的一个文件或者目录。</span><br><span class="line"><span class="number">2.</span>  File类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。</span><br><span class="line"><span class="comment">// 文件路径名 </span></span><br><span class="line">String path = <span class="string">&quot;D:\\123.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(path); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String path2 = <span class="string">&quot;D:\\1\\2.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path2);     -------------相当于D:\\<span class="number">1</span>\\<span class="number">2.</span>txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;F:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);  --------相当于F:\\aaa\\bbb.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;F:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child); --------相当于F:\\aaa\\bbb.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>File类的注意点：</p>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>File类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
</ol>
</blockquote>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>File的常用方法主要分为获取功能、获取绝对路径和相对路径、判断功能、创建删除功能的方法</p>
<h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><p>1、<code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。</p>
<p>2、<code>public String getPath()</code> ：将此File转换为路径名字符串。</p>
<p>3、<code>public String getName()</code> ：返回由此File表示的文件或目录的名称。</p>
<p>4、<code>public long length()</code> ：返回由此File表示的文件的长度。</p>
<p>以上方法测试，代码如下【注意测试以自己的电脑文件夹为准】：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">2116</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">3236</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>length()</code>，表示文件的长度。但是<code>File</code>对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><p><strong>绝对路径</strong>：一个完整的路径，以盘符开头，例如<code>F://aaa.txt</code>。<br><strong>相对路径</strong>：一个简化的路径，不以盘符开头,例如<code>//aaa.txt//b.txt</code>。</p>
<blockquote>
<p>1、<strong>路径是不区分大小写</strong><br>2、路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\java\bbb.java</span><br></pre></td></tr></table></figure>
<h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ol>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li>
</ol>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      	<span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li><code>public boolean createNewFile()</code> ：文件不存在，创建一个新的空文件并返回<code>true</code>，文件存在，不创建文件并返回<code>false</code>。</li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。</li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
</ul>
<p>其中，<code>mkdirs()</code>和<code>mkdir()</code>方法类似，但<code>mkdir()</code>，只能创建一级目录，<code>mkdirs()</code>可以创建多级目录比如<code>//a//b//c</code>，所以<strong>开发中一般用</strong><code>mkdirs()</code>;</p>
<blockquote>
<p>这些方法中值得注意的是<strong>createNewFile</strong>方法以及<strong>mkdir</strong>与<strong>mkdirs</strong>的区别</p>
</blockquote>
<p>方法测试，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// 以及创建过了所以再使用createNewFile返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2= <span class="keyword">new</span> File(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());	<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>delete</code>方法，如果此<code>File</code>表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h2 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h2><ul>
<li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
<li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;G:\光标&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">		String[] names = dir.list();</span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191013114927925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>listFiles</strong>在获取指定目录下的文件或者文件夹时必须满足下面两个条件</p>
<p>1，<strong>指定的目录必须存在</strong></p>
<p>2，<strong>指定的必须是目录。否则容易引发返回数组为null，出现NullPointerException异常</strong></p>
<h2 id="递归遍历文件夹下所有文件以及子文件"><a href="#递归遍历文件夹下所有文件以及子文件" class="headerlink" title="递归遍历文件夹下所有文件以及子文件"></a>递归遍历文件夹下所有文件以及子文件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归遍历文件夹下所有的文件</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RecursionDirectory</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">      File file=<span class="keyword">new</span> File(<span class="string">&quot;D:\\java专属IO测试&quot;</span>);</span><br><span class="line">        Recursion(file);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">Recursion</span>(<span class="params">File file</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1、判断传入的是否是目录</span></span><br><span class="line">        <span class="keyword">if</span>(!file.isDirectory())&#123;</span><br><span class="line">            <span class="comment">//不是目录直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经确保了传入的file是目录</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">//遍历files</span></span><br><span class="line">        <span class="keyword">for</span> (File f: files) &#123;</span><br><span class="line">            <span class="comment">//如果该目录下文件还是个文件夹就再进行递归遍历其子目录</span></span><br><span class="line">            <span class="keyword">if</span>(f.isDirectory())&#123;</span><br><span class="line">                <span class="comment">//递归</span></span><br><span class="line">                Recursion(f);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果该目录下文件是个文件，则打印对应的名字</span></span><br><span class="line">                System.out.println(f.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h2><p>我们可以把这种数据的传输，看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p>
<p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入也叫做读取数据，输出也叫做作写出数据</strong>。</p>
<h2 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong> 和 <strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。</li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li>
</ul>
<p>根据数据的类型分为：<strong>字节流</strong> 和 <strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<p><strong>分类之后对应的超类</strong>（V8提示：超类也就是父类的意思）</p>
<table>
<thead>
<tr>
<th></th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td>字节流</td>
<td>字节输入流 <strong>InputStream</strong></td>
<td>字节输出流 <strong>OutputStream</strong></td>
</tr>
<tr>
<td>字符流</td>
<td>字符输入流 <strong>Reader</strong></td>
<td>字符输出流 <strong>Writer</strong></td>
</tr>
</tbody></table>
<p><strong>注</strong>：<strong>由这四个类的子类名称基本都是以其父类名作为子类名的后缀</strong>。<br>如：InputStream的子类FileInputStream。<br>如：Reader的子类FileReader。<br><img src="https://img-blog.csdnimg.cn/20191013212051298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="关于IO的分流向说明"><a href="#关于IO的分流向说明" class="headerlink" title="关于IO的分流向说明"></a>关于IO的分流向说明</h2><p><img src="https://img-blog.csdnimg.cn/20191013151622369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191015144401127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="字节流OutputStream与InputStream"><a href="#字节流OutputStream与InputStream" class="headerlink" title="字节流OutputStream与InputStream"></a>字节流OutputStream与InputStream</h2><p>OutputStream与InputStream的继承关系<br><img src="https://img-blog.csdnimg.cn/20191015145625281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="文件的世界里一切皆为字节"><a href="#文件的世界里一切皆为字节" class="headerlink" title="文件的世界里一切皆为字节"></a>文件的世界里一切皆为字节</h3><p>我们必须明确一点的是，一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h3 id="字节输出流（OutputStream）"><a href="#字节输出流（OutputStream）" class="headerlink" title="字节输出流（OutputStream）"></a>字节输出流（OutputStream）</h3><p><code>java.io.OutputStream</code>抽象类是表示<strong>字节输出流</strong>的所有类的<strong>超类</strong>（父类），将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<p><strong>字节输出流的基本共性功能方法</strong>:</p>
<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li>
<li> <code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li>
<li> <code>public void write(byte[] b)</code>：将 b.length个字节从指定的字节数组写入此输出流。</li>
<li> <code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 <strong>也就是说从off个字节数开始读取一直到len个字节结束</strong></li>
<li> <code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
<blockquote>
<p><strong>以上五个方法则是字节输出流都具有的方法，由父类OutputStream定义提供，子类都会共享以上方法</strong></p>
</blockquote>
<h4 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h4><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类FileOutputStream开始。看名字就知道是文件输出流，用于将数据写出到文件。</p>
<h4 id="FileOutputStream构造方法"><a href="#FileOutputStream构造方法" class="headerlink" title="FileOutputStream构造方法"></a>FileOutputStream构造方法</h4><p>不管学啥子，只有是对象，就从构造方法开始！</p>
<ul>
<li><code>public FileOutputStream(File file)</code>：根据File对象为参数创建对象。</li>
<li> <code>public FileOutputStream(String name)</code>： 根据名称字符串为参数创建对象。</li>
</ul>
<p><strong>推荐第二种构造方法</strong>【开发常用】：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;abc.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>就以上面这句代码来讲，类似这样创建字节输出流对象都做了<strong>三件事情</strong>：<br>1、调用系统功能去创建文件【输出流对象才会自动创建】<br>2、创建outputStream对象<br>3、把foutputStream对象指向这个文件</p>
<blockquote>
<p>注意：<br>创建输出流对象的时候，系统会自动去对应位置创建对应文件，而创建输出流对象的时候，文件不存在则会报FileNotFoundException异常，也就是系统找不到指定的文件异常。</p>
</blockquote>
<p>当你创建一个流对象时，必须直接或者间接传入一个文件路径。比如现在我们创建一个<code>FileOutputStream</code>流对象，在该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。有兴趣的童鞋可以测试一下，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\自动创建的文件夹\\a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FileOutputStream写出字节数据"><a href="#FileOutputStream写出字节数据" class="headerlink" title="FileOutputStream写出字节数据"></a>FileOutputStream写出字节数据</h4><p>使用FileOutputStream写出字节数据主要通过<code>Write</code>方法，而<code>write</code>方法分如下三种</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">void</span> write(int b)</span><br><span class="line">public <span class="keyword">void</span> write(byte[] b)</span><br><span class="line">public <span class="keyword">void</span> write(byte[] b,int off,int len)  <span class="comment">//从`off`索引开始，`len`个字节</span></span><br></pre></td></tr></table></figure>
<p><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      	fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      	fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<p><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;麻麻我想吃烤山药&quot;</span>.getBytes();</span><br><span class="line">      	<span class="comment">// 写出字节数组数据</span></span><br><span class="line">      	fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">麻麻我想吃烤山药</span><br></pre></td></tr></table></figure>
<p><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从<code>off</code>索引开始，<code>len</code>个字节，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>
<h4 id="FileOutputStream实现数据追加续写、换行"><a href="#FileOutputStream实现数据追加续写、换行" class="headerlink" title="FileOutputStream实现数据追加续写、换行"></a>FileOutputStream实现数据追加续写、换行</h4><p>经过以上的代码测试，每次程序运行，每次创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续<strong>追加新数据</strong>呢？并且实现<strong>换行</strong>呢？其实很简单，这个时候我们又要再学习<code>FileOutputStream</code>的另外两个构造方法了，如下：</p>
<p>1、<code>public FileOutputStream(File file, boolean append)</code></p>
<p>2、<code>public FileOutputStream(String name, boolean append)</code></p>
<p>这两个构造方法，第二个参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示不追加也就是清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，至于Windows换行则是 <code>\n\r</code> ，下面将会详细讲到。</p>
<p>实现数据追加续写代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>
<p>Windows系统里，换行符号是<code>\r\n</code> ,具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      	<span class="comment">// 定义字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      	<span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>回车符</p>
  <figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\r</span></span><br></pre></td></tr></table></figure>

<p>  和换行符</p>
  <figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\n</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<pre><code>：

- 回车符：回到一行的开头（return）。
- 换行符：下一行（newline）。</code></pre>
<ul>
<li><p>系统中的换行：</p>
<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="字节输入流（InputStream）"><a href="#字节输入流（InputStream）" class="headerlink" title="字节输入流（InputStream）"></a>字节输入流（InputStream）</h3><p><code>java.io.InputStream</code>抽象类是表示<strong>字节输入流</strong>的所有类的<strong>超类</strong>（父类），可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<p><strong>字节输入流的基本共性功能方法</strong>:</p>
<blockquote>
<p>1、 <code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。<br>2、<code>public abstract int read()</code>： 从输入流读取数据的下一个字节。</p>
<p>3、 <code>public int read(byte[] b)</code>： 该方法返回的int值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1</p>
</blockquote>
<h4 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h4><p><code>java.io.FileInputStream</code>类是文件输入流，从文件中读取字节。</p>
<h4 id="FileInputStream的构造方法"><a href="#FileInputStream的构造方法" class="headerlink" title="FileInputStream的构造方法"></a>FileInputStream的构造方法</h4><blockquote>
<p>1、 <code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。<br>2、 <code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。</p>
</blockquote>
<p>同样的，推荐使用第二种构造方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FileInputStream读取字节数据"><a href="#FileInputStream读取字节数据" class="headerlink" title="FileInputStream读取字节数据"></a>FileInputStream读取字节数据</h4><p><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码测试如下【read.txt文件中内容为abcde】：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);<span class="comment">//read.txt文件中内容为abcde</span></span><br><span class="line">      	<span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">      	<span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       	read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>
<p><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// read.txt文件中内容为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>
<p>由于<code>read.txt</code>文件中内容为<code>abcde</code>，而错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全<strong>替换</strong>【注意是替换，看下图】，所以要通过<code>len</code> ，获取有效的字节<br><img src="https://img-blog.csdnimg.cn/20191015160242904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>
<p>在开发中一般强烈推荐使用数组读取文件，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">input2</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span> args[]</span>)</span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">            int len = <span class="number">0</span> ;</span><br><span class="line">            byte[] bys = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="built_in">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字节流FileInputstream复制图片"><a href="#字节流FileInputstream复制图片" class="headerlink" title="字节流FileInputstream复制图片"></a>字节流FileInputstream复制图片</h4><p><strong>复制图片原理</strong><br><img src="https://img-blog.csdnimg.cn/20191013204020152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>代码实现</strong></p>
<p>复制图片文件，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：<strong>复制文本、图片、mp3、视频等的方式一样</strong>。</p>
<h2 id="字符流Reader和Writer"><a href="#字符流Reader和Writer" class="headerlink" title="字符流Reader和Writer"></a>字符流Reader和Writer</h2><p><img src="https://img-blog.csdnimg.cn/20191015171311217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>字符流的由来：因为数据编码的不同，因而有了对字符进行高效操作的流对象，字符流本质其实就是基于字节流读取时，去查了指定的码表，而字节流直接读取数据会有乱码的问题（读中文会乱码）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">package IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">//FileInputStream为操作文件的字符输入流</span></span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//内容为哥敢摸屎</span></span><br><span class="line"></span><br><span class="line">        int len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.print((char)len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：   ??￥??￠????±</span><br></pre></td></tr></table></figure>
<p>具体现状分析<br><img src="https://img-blog.csdnimg.cn/20191014113505625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>字节流读取中文字符时，可能不会显示完整的字符，那是因为一个中文字符占用多个字节存储。</p>
</blockquote>
<p>那字节流就没办法了吗？不，字节流依旧有办法，只是麻烦了点，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        byte[] bytes = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">        int len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           System.out.print(<span class="keyword">new</span> <span class="built_in">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果： 哥敢摸屎</span><br></pre></td></tr></table></figure>
<p>这是为啥呢？没错解码的正是<code>String</code>，查看<code>new String()</code>的源码，<code>String</code>构造方法有解码功能，并且默认编码是<code>utf-8</code>，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line"> </span><br><span class="line"> 再点进decode，循序渐进发现，默认编码是UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>尽管字节流也能有办法决绝乱码问题，但是还是比较麻烦，于是java就有了字符流，<code>字符为单位</code>读写数据，字符流<code>专门用于处理文本</code>文件。如果处理纯文本的数据优先考虑字符流，其他情况就只能用字节流了（图片、视频、等等<code>只文本</code>例外）。</p>
<blockquote>
<p>从另一角度来说：<strong>字符流 = 字节流 + 编码表</strong></p>
</blockquote>
<h3 id="字符输入流（Reader）"><a href="#字符输入流（Reader）" class="headerlink" title="字符输入流（Reader）"></a>字符输入流（Reader）</h3><p><code>java.io.Reader</code>抽象类是<strong>字符输入流</strong>的所有类的<strong>超类</strong>（父类），可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<p><strong>字符输入流的共性方法</strong>：</p>
<blockquote>
<p>1、<code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。<br>2、 <code>public int read()</code>： 从输入流读取一个字符。<br>3、 <code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中</p>
</blockquote>
<h4 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h4><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote>
<p>1、<code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的<strong>File对象</strong>。<br>2、 <code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的<strong>字符串名称</strong>。</p>
</blockquote>
<p>构造方法的使用就算不写应该都很熟悉了吧，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FileReader读取字符数据"><a href="#FileReader读取字符数据" class="headerlink" title="FileReader读取字符数据"></a>FileReader读取字符数据</h4><ol>
<li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于读取的写法类似字节流的写法，只是读取单位不同罢了。</p>
<h3 id="字符输出流（Writer）"><a href="#字符输出流（Writer）" class="headerlink" title="字符输出流（Writer）"></a>字符输出流（Writer）</h3><p><code>java.io.Writer</code>抽象类是<strong>字符输出流</strong>的所有类的<strong>超类</strong>（父类），将指定的字符信息写出到目的地。它同样定义了字符输出流的基本共性功能方法。</p>
<p><strong>字符输出流的基本共性功能方法</strong>：</p>
<blockquote>
<p>1、<code>void write(int c)</code> 写入单个字符。<br>2、<code>void write(char[] cbuf)</code>写入字符数组。<br>3、 <code>abstract void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>4、 <code>void write(String str)</code>写入字符串。<br>5、<code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>6、<code>void flush()</code>刷新该流的缓冲。<br>7、<code>void close()</code> 关闭此流，但要先刷新它。</p>
</blockquote>
<h4 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h4><p><code>java.io.FileWriter</code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><p> <code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。</p>
<p><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</p>
<p>依旧是熟悉的构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 第一种：使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 第二种：使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FileWriter写出数据"><a href="#FileWriter写出数据" class="headerlink" title="FileWriter写出数据"></a>FileWriter写出数据</h4><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC</span><br></pre></td></tr></table></figure>
<blockquote>
<p>【注意】<strong>关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</strong></p>
</blockquote>
<h4 id="关闭close和刷新flush"><a href="#关闭close和刷新flush" class="headerlink" title="关闭close和刷新flush"></a>关闭close和刷新flush</h4><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<p><code>flush</code> ：刷新缓冲区，流对象可以继续使用。<br><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FlushDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">//源   也就是输入流【读取流】 读取a.txt文件</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>);  <span class="comment">//必须要存在a.txt文件，否则报FileNotFoundException异常</span></span><br><span class="line">        <span class="comment">//目的地  也就是输出流</span></span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);  <span class="comment">//系统会自动创建b.txt，因为它是输出流！</span></span><br><span class="line">        int len;</span><br><span class="line">        <span class="keyword">while</span>((len=fr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">           fw.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">   注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191014222100212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行效果是怎么样的呢？答案是b.txt文件中依旧是空的，是的并没有任何东西，为啥呢？上面用红色字体特别标注过了，就是这句话： 【注意】<strong>关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</strong>可见实践例子的重要性，<strong>编程就是这样，不去敲，永远学不会</strong>！！！</p>
<p>所以，我们在以上的代码中再添加下面三句代码，就完美了，b.txt文件就能复制到源文件的数据了！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fr.close();</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>flush()</code>这个函数是清空的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再用数据写到文件中，那么当你数据读完时，我们如果这时调用<code>close()</code>方法关闭读写流，这时就可能造成数据丢失，为什么呢？因为，读入数据完成时不代表写入数据完成，一部分数据可能会留在缓存区中，这个时候<code>flush()</code>方法就格外重要了。</p>
</blockquote>
<p>好了，接下来close使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
</blockquote>
<h3 id="FileWriter的续写和换行"><a href="#FileWriter的续写和换行" class="headerlink" title="FileWriter的续写和换行"></a>FileWriter的续写和换行</h3><p><strong>续写和换行</strong>：操作类似于FileOutputStream操作（上一篇博客讲到过），直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;哥敢&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">      	fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">  		fw.write(<span class="string">&quot;摸屎&quot;</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">哥敢</span><br><span class="line">摸屎</span><br></pre></td></tr></table></figure>
<h3 id="FileReader和FileWriter类完成文本文件复制"><a href="#FileReader和FileWriter类完成文本文件复制" class="headerlink" title="FileReader和FileWriter类完成文本文件复制"></a>FileReader和FileWriter类完成文本文件复制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\新建文件夹\\aa.txt&quot;</span>);<span class="comment">//文件不存在会抛出java.io.FileNotFoundException</span></span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\copyaa.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*创建输出流做的工作：</span></span><br><span class="line"><span class="comment">         *      1、调用系统资源创建了一个文件</span></span><br><span class="line"><span class="comment">         *      2、创建输出流对象</span></span><br><span class="line"><span class="comment">         *      3、把输出流对象指向文件        </span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//文本文件复制，一次读一个字符</span></span><br><span class="line">        copyMethod1(fr, fw);</span><br><span class="line">        <span class="comment">//文本文件复制，一次读一个字符数组</span></span><br><span class="line">        copyMethod2(fr, fw);</span><br><span class="line">        </span><br><span class="line">        fr.close();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> copyMethod1(FileReader fr, FileWriter fw) throws IOException &#123;</span><br><span class="line">        int ch;</span><br><span class="line">        <span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>) &#123;<span class="comment">//读数据</span></span><br><span class="line">            fw.write(ch);<span class="comment">//写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> copyMethod2(FileReader fr, FileWriter fw) throws IOException &#123;</span><br><span class="line">        char chs[]=<span class="keyword">new</span> char[<span class="number">1024</span>];</span><br><span class="line">        int len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len=fr.read(chs))!=-<span class="number">1</span>) &#123;<span class="comment">//读数据</span></span><br><span class="line">            fw.write(chs,<span class="number">0</span>,len);<span class="comment">//写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CopyFile</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191014213256773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>最后再次强调：<br>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流</strong></p>
</blockquote>
<h3 id="IO异常的处理"><a href="#IO异常的处理" class="headerlink" title="IO异常的处理"></a>IO异常的处理</h3><p>我们在学习的过程中可能习惯把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，格式代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;哥敢摸si&quot;</span>); <span class="comment">//哥敢摸si</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面主要写了一些基本的流作为IO流的入门。从这里开始将要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等，而这些强大的流都是在基本的流对象基础之上而来的！这些强大的流将伴随着我们今后的开发！</p>
<h2 id="缓冲流【掌握】"><a href="#缓冲流【掌握】" class="headerlink" title="缓冲流【掌握】"></a>缓冲流【掌握】</h2><h3 id="简要概述"><a href="#简要概述" class="headerlink" title="简要概述"></a>简要概述</h3><p>首先我们来认识认识一下缓冲流,也叫高效流，是对4个<code>FileXxx</code> 流的“增强流”。</p>
<p><strong>缓冲流的基本原理</strong>：</p>
<blockquote>
<p>1、使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内。<br>2、通过缓冲区的read()方法从缓冲区获取具体的字符数据，这样就提高了效率。<br>3、如果用read方法读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了readLine()功能。</p>
</blockquote>
<p>也就是说在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<p>缓冲书写格式为<code>BufferedXxx</code>，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code></li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>InputStream</strong>。</li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>OutputStream</strong>。</li>
</ul>
<p>构造举例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方式一： 创建字节缓冲输入流【但是开发中一般常用下面的格式申明】</span></span><br><span class="line">FileInputStream fps = <span class="keyword">new</span> FileInputStream(b.txt);</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fps)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方式一： 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">///构造方式二： 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="感受缓冲流的高效"><a href="#感受缓冲流的高效" class="headerlink" title="感受缓冲流的高效"></a>感受缓冲流的高效</h4><p>缓冲流读写方法与基本的流是一致的，我们通过复制370多MB的大文件，测试它的效率。</p>
<p>基本流，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>);<span class="comment">//exe文件够大</span></span><br><span class="line">        	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>)</span><br><span class="line">        )&#123;</span><br><span class="line">        	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">不好意思十分钟过去了还在玩命复制中...</span><br></pre></td></tr></table></figure>
<p>缓冲流，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">         BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>));</span><br><span class="line">	     BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缓冲流复制时间:<span class="number">8016</span> 毫秒</span><br></pre></td></tr></table></figure>
<p>想要更快可以使用数组的方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">      	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">		 BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;py.exe&quot;</span>));</span><br><span class="line">		 BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copyPy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">          	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">521</span> 毫秒  </span><br></pre></td></tr></table></figure>
<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><p>相同的来看看其构造，其格式以及原理和字节缓冲流是一样一样的！</p>
<ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>Reader</strong>。</li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>Writer</strong>。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="字符缓冲流特有方法"><a href="#字符缓冲流特有方法" class="headerlink" title="字符缓冲流特有方法"></a>字符缓冲流特有方法</h4><p>字符缓冲流的基本方法与普通字符流调用方式一致，这里不再阐述，我们来看字符缓冲流具备的<strong>特有</strong>方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: <strong>读一行数据</strong>。 读取到最后返回null</li>
<li>BufferedWriter：<code>public void newLine()</code>: <strong>换行</strong>,由系统属性定义符号。</li>
</ul>
<p><code>readLine</code>方法演示代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	 <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newLine</code>方法演示代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    	<span class="comment">// 创建流对象</span></span><br><span class="line">  	BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line">    	<span class="comment">// 写出数据</span></span><br><span class="line">      bw.write(<span class="string">&quot;这&quot;</span>);</span><br><span class="line">    	<span class="comment">// 写出换行</span></span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;是&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;第三行&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;下一行&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">  	<span class="comment">// 释放资源</span></span><br><span class="line">      bw.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">这</span><br><span class="line">是</span><br><span class="line">第三行</span><br><span class="line">下一行</span><br></pre></td></tr></table></figure>
<h3 id="字符缓冲流练习"><a href="#字符缓冲流练习" class="headerlink" title="字符缓冲流练习"></a>字符缓冲流练习</h3><p>字符缓冲流练习啥捏？先放松一下吧各位，先欣赏欣赏我写的下面的诗篇</p>
<blockquote>
<p>6.你说你的程序叫简单，我说我的代码叫诗篇<br>1.一想到你我就哦豁豁豁豁豁豁豁豁豁豁….哦nima个头啊，完全不理人家受得了受不了<br>8.Just 简单你和我 ，Just 简单程序员<br>3.约了地点却忘了见面 ，懂得寂寞才明白浩瀚<br>5.沉默是最大的发言权<br>2.总是喜欢坐在电脑前， 总是喜欢工作到很晚<br>7.向左走 又向右走，我们转了好多的弯<br>4.你从来就不问我，你还是不是那个程序员</p>
</blockquote>
<p>练习如何使用缓冲流的技术把上面的诗篇归顺序，都编过号了就是前面的1到8的编号</p>
<p>分析：首先用字符输入缓冲流创建个源，里面放没有排过序的文字，之后用字符输出缓冲流创建个目标接收，排序的过程就要自己写方法了哦，可以从每条诗词的共同点“.”符号下手！</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象  源</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//目标</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">            String key = String.valueOf(i);</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            String value = lineMap.get(key);</span><br><span class="line">          	<span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key+<span class="string">&quot;.&quot;</span>+value);</span><br><span class="line">          	<span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>一想到你我就哦豁豁豁豁豁豁豁豁豁豁…哦nima个头啊，完全不理人家受得了受不了</span><br><span class="line"><span class="number">2.</span>总是喜欢坐在电脑前， 总是喜欢工作到很晚</span><br><span class="line"><span class="number">3.</span>约了地点却忘了见面 ，懂得寂寞才明白浩瀚</span><br><span class="line"><span class="number">4.</span>你从来就不问我，你还是不是那个程序员</span><br><span class="line"><span class="number">5.</span>沉默是最大的发言权</span><br><span class="line"><span class="number">6.</span>你说你的程序叫简单，我说我的代码叫诗篇</span><br><span class="line"><span class="number">7.</span>向左走 又向右走，我们转了好多的弯</span><br><span class="line"><span class="number">8.</span>Just 简单你和我 ，Just 简单程序员</span><br></pre></td></tr></table></figure>
<h2 id="转换流【掌握】"><a href="#转换流【掌握】" class="headerlink" title="转换流【掌握】"></a>转换流【掌握】</h2><p>何谓转换流？为何由来？暂时带着问题让我们先来了解了解字符编码和字符集！<br><img src="https://img-blog.csdnimg.cn/2019101609401732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="字符编码与解码"><a href="#字符编码与解码" class="headerlink" title="字符编码与解码"></a>字符编码与解码</h3><p>众所周知，计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照<code>A</code>规则存储，同样按照<code>A</code>规则解析，那么就能显示正确的文本符号。反之，按照<code>A</code>规则存储，再按照<code>B</code>规则解析，就会导致乱码现象。</p>
<p>简单一点的说就是：</p>
<blockquote>
<p>编码:字符(能看懂的)–字节(看不懂的)</p>
<p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p>
</blockquote>
<p>代码解释则是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName):通过指定的字符集解码字节数组</span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName):使用指定的字符集合把字符串编码为字节数组</span><br><span class="line"></span><br><span class="line">编码:把看得懂的变成看不懂的</span><br><span class="line">String -- <span class="keyword">byte</span>[]</span><br><span class="line"></span><br><span class="line">解码:把看不懂的变成看得懂的</span><br><span class="line"><span class="keyword">byte</span>[] -- String</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>字符编码</strong> <code>Character Encoding</code>: 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>  而<strong>编码表</strong>则是生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li><strong>字符集</strong> <code>Charset</code>：也叫<strong>编码表</strong>。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有<code>ASCII</code>字符集、<code>GBK</code>字符集、<code>Unicode</code>字符集等。<br><img src="https://img-blog.csdnimg.cn/20191016090127127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<p><strong>ASCII字符集：</strong></p>
<ul>
<li><p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p>
</li>
<li><p>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</p>
</li>
</ul>
<p><strong>ISO-8859-1字符集：</strong></p>
<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
<p><strong>GBxxx字符集：</strong></p>
<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
<p><strong>Unicode字符集：</strong></p>
<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。</li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
<h3 id="编码问题导致乱码"><a href="#编码问题导致乱码" class="headerlink" title="编码问题导致乱码"></a>编码问题导致乱码</h3><p>在java开发工具IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：���</span><br></pre></td></tr></table></figure>
<p>那么如何读取GBK编码的文件呢？ 这个时候就得讲讲转换流了！</p>
<blockquote>
<p>从另一角度来讲：<strong>字符流=字节流+编码表</strong></p>
</blockquote>
<h3 id="InputStreamReader类—–-字节流到字符流的桥梁"><a href="#InputStreamReader类—–-字节流到字符流的桥梁" class="headerlink" title="InputStreamReader类—–(字节流到字符流的桥梁)"></a>InputStreamReader类—–(字节流到字符流的桥梁)</h3><p>转换流<code>java.io.InputStreamReader</code>，是<code>Reader</code>的子类，从字面意思可以看出它是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote>
<p><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。<br><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</p>
</blockquote>
<p>构造代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="使用转换流解决编码问题"><a href="#使用转换流解决编码问题" class="headerlink" title="使用转换流解决编码问题"></a>使用转换流解决编码问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        String FileName = <span class="string">&quot;C:\\A.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">      	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">		<span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">      	<span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read); <span class="comment">// �����ʺ      </span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 哥敢摸屎</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OutputStreamWriter类—–-字符流到字节流的桥梁"><a href="#OutputStreamWriter类—–-字符流到字节流的桥梁" class="headerlink" title="OutputStreamWriter类—–(字符流到字节流的桥梁)"></a>OutputStreamWriter类—–(字符流到字节流的桥梁)</h3><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，字面看容易混淆会误以为是转为字符流，其实不然，OutputStreamWriter为从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote>
<p><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。<br><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</p>
</blockquote>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="指定编码构造代码"><a href="#指定编码构造代码" class="headerlink" title="指定编码构造代码"></a>指定编码构造代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径</span></span><br><span class="line">        String FileName = <span class="string">&quot;C:\\s.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw.write(<span class="string">&quot;哥敢&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 定义文件路径</span></span><br><span class="line">		String FileName2 = <span class="string">&quot;D:\\A.txt&quot;</span>;</span><br><span class="line">     	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw2.write(<span class="string">&quot;摸屎&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191016100612927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了达到<strong>最高效率</strong>，可以考虑在 <code>BufferedReader</code> 内包装 <code>InputStreamReader</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">BufferedReader <span class="keyword">in</span> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))；</span><br></pre></td></tr></table></figure>
<h2 id="序列化流【理解】"><a href="#序列化流【理解】" class="headerlink" title="序列化流【理解】"></a>序列化流【理解】</h2><blockquote>
<p>(1)可以把对象写入文本文件或者在网络中传输<br>(2)如何实现序列化呢?<br>让被序列化的对象所属类实现序列化接口。<br>该接口是一个标记接口。没有功能需要实现。<br>(3)注意问题：<br>把数据写到文件后，在去修改类会产生一个问题。<br>如何解决该问题呢?<br>在类文件中，给出一个固定的序列化id值。<br>而且，这样也可以解决黄色警告线问题<br>(4)面试题：<br>什么时候序列化?<br>如何实现序列化?<br>什么是反序列化?</p>
</blockquote>
<h3 id="何谓序列化"><a href="#何谓序列化" class="headerlink" title="何谓序列化"></a>何谓序列化</h3><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化：<br><img src="https://img-blog.csdnimg.cn/20191016100818120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</p>
<p>构造代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aa.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>
<h4 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h4><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<p>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</p>
<p>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.写出对象方法</p>
<p><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">    	Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    	e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    	e.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">    	e.age = <span class="number">20</span>; </span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">      		<span class="comment">// 创建序列化流对象</span></span><br><span class="line">          ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;employee.txt&quot;</span>));</span><br><span class="line">        	<span class="comment">// 写出对象</span></span><br><span class="line">        	out.writeObject(e);</span><br><span class="line">        	<span class="comment">// 释放资源</span></span><br><span class="line">        	out.close();</span><br><span class="line">        	fileOut.close();</span><br><span class="line">        	System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>
<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。</p>
<h4 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream的ObjectInputStream。</p>
<h4 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h4><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;		</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">             ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        	<span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);	<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age: &quot;</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong></p>
<h4 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a>反序列化操作2</h4><p>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。发生这个异常的原因如下：</p>
<blockquote>
<p>1、该类的序列版本号与从流中读取的类描述符的版本号不匹配<br>2、该类包含未知数据类型<br>2、该类没有可访问的无参数构造方法</p>
</blockquote>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化集合练习"><a href="#序列化集合练习" class="headerlink" title="序列化集合练习"></a>序列化集合练习</h3><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h4 id="案例代码实现"><a href="#案例代码实现" class="headerlink" title="案例代码实现"></a>案例代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 学生对象</span></span><br><span class="line">		Student student = <span class="keyword">new</span> Student(<span class="string">&quot;老王&quot;</span>, <span class="string">&quot;laow&quot;</span>);</span><br><span class="line">		Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;老张&quot;</span>, <span class="string">&quot;laoz&quot;</span>);</span><br><span class="line">		Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;老李&quot;</span>, <span class="string">&quot;laol&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		arrayList.add(student);</span><br><span class="line">		arrayList.add(student2);</span><br><span class="line">		arrayList.add(student3);</span><br><span class="line">		<span class="comment">// 序列化操作</span></span><br><span class="line">		<span class="comment">// serializ(arrayList);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 反序列化  </span></span><br><span class="line">		ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">		ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line">		</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          	Student s = list.get(i);</span><br><span class="line">        	System.out.println(s.getName()+<span class="string">&quot;--&quot;</span>+ s.getPwd());</span><br><span class="line">      	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 序列化流 </span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 写出对象</span></span><br><span class="line">		oos.writeObject(arrayList);</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印流【掌握】"><a href="#打印流【掌握】" class="headerlink" title="打印流【掌握】"></a>打印流【掌握】</h2><h3 id="何谓打印流"><a href="#何谓打印流" class="headerlink" title="何谓打印流"></a>何谓打印流</h3><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，各位用了这么久的输出语句肯定没想过这两个方法都来自于<code>java.io.PrintStream</code>类吧，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<p><strong>打印流分类</strong>：</p>
<blockquote>
<p>字节打印流PrintStream，字符打印流PrintWriter</p>
</blockquote>
<p><strong>打印流特点</strong>：</p>
<blockquote>
<p>A:只操作目的地,不操作数据源<br>B:可以操作任意类型的数据<br>C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新<br>D:可以直接操作文件</p>
</blockquote>
<p>哪些流可以直接操作文件呢?答案很简单，<strong>如果该流的构造方法能够同时接收File和String类型的参数，一般都是可以直接操作文件的</strong>！</p>
<p>PrintStream是OutputStream的子类，PrintWriter是Writer的子类，两者处于对等的位置上，所以它们的API是非常相似的。二者区别无非一个是字节打印流，一个是字符打印流。</p>
<h3 id="字节输出打印流PrintStream复制文本文件"><a href="#字节输出打印流PrintStream复制文本文件" class="headerlink" title="字节输出打印流PrintStream复制文本文件"></a>字节输出打印流PrintStream复制文本文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;copy.txt&quot;</span>));</span><br><span class="line">        PrintStream ps=<span class="keyword">new</span> PrintStream(<span class="string">&quot;printcopy.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> line;</span><br><span class="line">        <span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            ps.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符输出打印流PrintWriter复制文本文件"><a href="#字符输出打印流PrintWriter复制文本文件" class="headerlink" title="字符输出打印流PrintWriter复制文本文件"></a>字符输出打印流PrintWriter复制文本文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用打印流复制文本文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;aa.txt&quot;</span>));</span><br><span class="line">        PrintWriter pw=<span class="keyword">new</span> PrintWriter(<span class="string">&quot;printcopyaa.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> line;</span><br><span class="line">        <span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            pw.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Properties属性类"><a href="#Properties属性类" class="headerlink" title="Properties属性类"></a>Properties属性类</h2><p>我想各位对这个Properties类多多少少也接触过了，首先Properties类并不在IO包下，那为啥要和IO流一起讲呢？原因很简单因为properties类经常和io流的联合一起使用。</p>
<blockquote>
<p>(1)是一个集合类，Hashtable的子类<br>(2)特有功能<br>A:public Object setProperty(String key,String value)<br>B:public String getProperty(String key)<br>C:public Set stringPropertyNames()<br>(3)和IO流结合的方法<br>把键值对形式的文本文件内容加载到集合中<br>public void load(Reader reader)<br>public void load(InputStream inStream)<br>把集合中的数据存储到文本文件中<br>public void store(Writer writer,String comments)<br>public void store(OutputStream out,String comments)</p>
</blockquote>
<h3 id="Properties概述"><a href="#Properties概述" class="headerlink" title="Properties概述"></a>Properties概述</h3><p><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>
<h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><h4 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public Properties()</code> :创建一个空的属性列表。</p>
<h4 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h4><ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。</li>
<li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>
<h4 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h4><p><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</p>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。现在文本数据格式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filename=Properties.txt</span><br><span class="line">length=<span class="number">123</span></span><br><span class="line">location=C:\Properties.txt</span><br></pre></td></tr></table></figure>
<p>加载代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Properties.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- Properties.txt</span><br><span class="line">length -- <span class="number">123</span></span><br><span class="line">location -- C:\Properties.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java基础</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之反射</title>
    <url>/posts/a2befa89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java反射机制在框架设计中极为广泛，需要深入理解。</p>
</blockquote>
<a id="more"></a>

<h1 id="反射基础"><a href="#反射基础" class="headerlink" title="反射基础"></a>反射基础</h1><p>RRIT（Run-Time Type Identification）运行时类型识别。在《Thinking in Java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</p>
<p>反射就是把java类中的各种成分映射成一个个的Java对象</p>
<p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>
<blockquote>
<p>这里我们首先需要理解 Class类，以及类的加载机制； 然后基于此我们如何通过反射获取Class类以及类中的成员变量、方法、构造方法等。</p>
</blockquote>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(“类名”)等方法获取class对象）。数组同样也被映射为为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ANNOTATION= <span class="number">0x00002000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENUM      = <span class="number">0x00004000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0x00001000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private constructor. Only the Java Virtual Machine creates Class objects.   //私有构造器，只有JVM才能调用创建Class对象</span></span><br><span class="line"><span class="comment">     * This constructor is not used and prevents the default constructor being</span></span><br><span class="line"><span class="comment">     * generated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initialize final field for classLoader.  The initialization value of non-null</span></span><br><span class="line">        <span class="comment">// prevents future JIT optimizations from assuming this final field is null.</span></span><br><span class="line">        classLoader = loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到这我们也就可以得出以下几点信息：</p>
<ul>
<li>Class类也是类的一种，与class关键字是不一样的。</li>
<li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li>
<li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li>
<li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li>
<li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li>
</ul>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类加载机制流程</p>
<p><img src="https://www.pdai.tech/_images/jvm/java_jvm_classload_2.png" alt="img"></p>
<p>类的加载</p>
<p><img src="https://www.pdai.tech/_images/java/java-basic-reflection-3.png" alt="img"></p>
<h1 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h1><p>基于此我们如何通过反射获取Class类对象以及类中的成员变量、方法、构造方法等</p>
<p>在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。</p>
<h2 id="Class类对象的获取"><a href="#Class类对象的获取" class="headerlink" title="Class类对象的获取"></a>Class类对象的获取</h2><p>在类加载的时候，jvm会创建一个class对象</p>
<p>class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种</p>
<ul>
<li>根据类名：类名.class</li>
<li>根据对象：对象.getClass()</li>
<li>根据全限定类名：Class.forName(全限定类名)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取Class对象的三种方式</span></span><br><span class="line">    logger.info(<span class="string">&quot;根据类名:  \t&quot;</span> + User.class);</span><br><span class="line">    logger.info(<span class="string">&quot;根据对象:  \t&quot;</span> + <span class="keyword">new</span> User().getClass());</span><br><span class="line">    logger.info(<span class="string">&quot;根据全限定类名:\t&quot;</span> + Class.forName(<span class="string">&quot;com.test.User&quot;</span>));</span><br><span class="line">    <span class="comment">// 常用的方法</span></span><br><span class="line">    logger.info(<span class="string">&quot;获取全限定类名:\t&quot;</span> + userClass.getName());</span><br><span class="line">    logger.info(<span class="string">&quot;获取类名:\t&quot;</span> + userClass.getSimpleName());</span><br><span class="line">    logger.info(<span class="string">&quot;实例化:\t&quot;</span> + userClass.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;init&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">根据类名:  	<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">test</span>.<span class="title">User</span></span></span><br><span class="line">根据对象:  	class com.test.User</span><br><span class="line">根据全限定类名:	<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">test</span>.<span class="title">User</span></span></span><br><span class="line">获取全限定类名:	com.test.User</span><br><span class="line">获取类名:	com.test.User</span><br><span class="line">实例化:	User [name=init, age=<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>再来看看 <strong>Class类的方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>forName()</td>
<td>(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。</td>
</tr>
<tr>
<td>(2)为了产生Class引用，forName()立即就进行了初始化。</td>
<td></td>
</tr>
<tr>
<td>Object-getClass()</td>
<td>获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。</td>
</tr>
<tr>
<td>getName()</td>
<td>取全限定的类名(包括包名)，即类的完整名字。</td>
</tr>
<tr>
<td>getSimpleName()</td>
<td>获取类名(不包括包名)</td>
</tr>
<tr>
<td>getCanonicalName()</td>
<td>获取全限定的类名(包括包名)</td>
</tr>
<tr>
<td>isInterface()</td>
<td>判断Class对象是否是表示一个接口</td>
</tr>
<tr>
<td>getInterfaces()</td>
<td>返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</td>
</tr>
<tr>
<td>getSupercalss()</td>
<td>返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。</td>
</tr>
<tr>
<td>newInstance()</td>
<td>返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。</td>
</tr>
<tr>
<td>getFields()</td>
<td>获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。</td>
</tr>
<tr>
<td>getDeclaredFields</td>
<td>获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mCellPublic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span>  <span class="title">Cell</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAnimalPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mAnimalProtected;</span><br><span class="line">    <span class="keyword">int</span> mAnimalDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mAnimalPublic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sAnimalPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> sAnimalProtected;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sAnimalDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sAnimalPublic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDogPrivate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mDogPublic;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mDogProtected;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDogDefault;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sDogPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> sDogProtected;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sDogDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sDogPublic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;Dog&gt; dog = Dog.class;</span><br><span class="line">        <span class="comment">//类名打印</span></span><br><span class="line">        System.out.println(dog.getName()); <span class="comment">//com.cry.Dog</span></span><br><span class="line">        System.out.println(dog.getSimpleName()); <span class="comment">//Dog</span></span><br><span class="line">        System.out.println(dog.getCanonicalName());<span class="comment">//com.cry.Dog</span></span><br><span class="line">        <span class="comment">//接口</span></span><br><span class="line">        System.out.println(dog.isInterface()); <span class="comment">//false</span></span><br><span class="line">        <span class="keyword">for</span> (Class iI : dog.getInterfaces()) &#123;</span><br><span class="line">            System.out.println(iI);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          interface com.cry.I1</span></span><br><span class="line"><span class="comment">          interface com.cry.I2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//父类</span></span><br><span class="line">        System.out.println(dog.getSuperclass());<span class="comment">//class com.cry.Animal</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Dog d = dog.newInstance();</span><br><span class="line">        <span class="comment">//字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field f : dog.getFields()) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            mDogPublic</span></span><br><span class="line"><span class="comment">            sDogPublic</span></span><br><span class="line"><span class="comment">            mAnimalPublic</span></span><br><span class="line"><span class="comment">            sAnimalPublic</span></span><br><span class="line"><span class="comment">            mCellPublic  //父类的父类的公共字段也打印出来了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field f : dog.getDeclaredFields()) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 只有自己类声明的字段</span></span><br><span class="line"><span class="comment">         mDogPrivate</span></span><br><span class="line"><span class="comment">         mDogPublic</span></span><br><span class="line"><span class="comment">         mDogProtected</span></span><br><span class="line"><span class="comment">         mDogDefault</span></span><br><span class="line"><span class="comment">         sDogPrivate</span></span><br><span class="line"><span class="comment">         sDogProtected</span></span><br><span class="line"><span class="comment">         sDogDefault</span></span><br><span class="line"><span class="comment">         sDogPublic</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getName、getCanonicalName与getSimpleName的区别</strong>：</p>
<ul>
<li>getSimpleName：只获取类名</li>
<li>getName：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName。</li>
<li>getCanonicalName：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cry;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="class"><span class="keyword">class</span> <span class="title">inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//普通类</span></span><br><span class="line">        System.out.println(Test.class.getSimpleName()); <span class="comment">//Test</span></span><br><span class="line">        System.out.println(Test.class.getName()); <span class="comment">//com.cry.Test</span></span><br><span class="line">        System.out.println(Test.class.getCanonicalName()); <span class="comment">//com.cry.Test</span></span><br><span class="line">        <span class="comment">//内部类</span></span><br><span class="line">        System.out.println(inner.class.getSimpleName()); <span class="comment">//inner</span></span><br><span class="line">        System.out.println(inner.class.getName()); <span class="comment">//com.cry.Test$inner</span></span><br><span class="line">        System.out.println(inner.class.getCanonicalName()); <span class="comment">//com.cry.Test.inner</span></span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        System.out.println(args.getClass().getSimpleName()); <span class="comment">//String[]</span></span><br><span class="line">        System.out.println(args.getClass().getName()); <span class="comment">//[Ljava.lang.String;</span></span><br><span class="line">        System.out.println(args.getClass().getCanonicalName()); <span class="comment">//java.lang.String[]</span></span><br><span class="line">        <span class="comment">//我们不能用getCanonicalName去加载类对象，必须用getName</span></span><br><span class="line">        <span class="comment">//Class.forName(inner.class.getCanonicalName()); 报错</span></span><br><span class="line">        Class.forName(inner.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h2><blockquote>
<p>Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。</p>
</blockquote>
<p>获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下：</p>
<table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Class&lt;?&gt;</td>
<td>forName(String className)</td>
<td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td>
</tr>
<tr>
<td>Constructor</td>
<td>getConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回指定参数类型、具有public访问权限的构造函数对象</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]</td>
<td>getConstructors()</td>
<td>返回所有具有public访问权限的构造函数的Constructor对象数组</td>
</tr>
<tr>
<td>Constructor</td>
<td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回指定参数类型、所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]</td>
<td>getDeclaredConstructor()</td>
<td>返回所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td>T</td>
<td>newInstance()</td>
<td>调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td>
</tr>
</tbody></table>
<p>下面看一个简单例子来了解Constructor对象的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructionTest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Class对象的引用</span></span><br><span class="line">        clazz = Class.forName(<span class="string">&quot;com.example.javabase.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常</span></span><br><span class="line">        User user = (User) clazz.newInstance();</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取带String参数的public构造函数</span></span><br><span class="line">        Constructor cs1 =clazz.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//创建User</span></span><br><span class="line">        User user1= (User) cs1.newInstance(<span class="string">&quot;hiway&quot;</span>);</span><br><span class="line">        user1.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1:&quot;</span>+user1.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取得指定带int和String参数构造函数,该方法是私有构造private</span></span><br><span class="line">        Constructor cs2=clazz.getDeclaredConstructor(<span class="keyword">int</span>.class,String.class);</span><br><span class="line">        <span class="comment">//由于是private必须设置可访问</span></span><br><span class="line">        cs2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//创建user对象</span></span><br><span class="line">        User user2= (User) cs2.newInstance(<span class="number">25</span>,<span class="string">&quot;hiway2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2:&quot;</span>+user2.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有构造包含private</span></span><br><span class="line">        Constructor&lt;?&gt; cons[] = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 查看每个构造方法需要的参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cons.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取构造函数参数类型</span></span><br><span class="line">            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();</span><br><span class="line">            System.out.println(<span class="string">&quot;构造函数[&quot;</span>+i+<span class="string">&quot;]:&quot;</span>+cons[i].toString() );</span><br><span class="line">            System.out.print(<span class="string">&quot;参数类型[&quot;</span>+i+<span class="string">&quot;]:(&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; clazzs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == clazzs.length - <span class="number">1</span>)</span><br><span class="line">                    System.out.print(clazzs[j].getName());</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.print(clazzs[j].getName() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* output </span></span><br><span class="line"><span class="comment">User&#123;age=20, name=&#x27;Jack&#x27;&#125;</span></span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"><span class="comment">user1:User&#123;age=22, name=&#x27;hiway&#x27;&#125;</span></span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"><span class="comment">user2:User&#123;age=25, name=&#x27;hiway2&#x27;&#125;</span></span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"><span class="comment">构造函数[0]:private com.example.javabase.User(int,java.lang.String)</span></span><br><span class="line"><span class="comment">参数类型[0]:(int,java.lang.String)</span></span><br><span class="line"><span class="comment">构造函数[1]:public com.example.javabase.User(java.lang.String)</span></span><br><span class="line"><span class="comment">参数类型[1]:(java.lang.String)</span></span><br><span class="line"><span class="comment">构造函数[2]:public com.example.javabase.User()</span></span><br><span class="line"><span class="comment">参数类型[2]:()</span></span><br></pre></td></tr></table></figure>
<p>关于<strong>Constructor类本身一些常用方法</strong>如下(仅部分，其他可查API)</p>
<table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td>getDeclaringClass()</td>
<td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td>
</tr>
<tr>
<td>Type[]</td>
<td>getGenericParameterTypes()</td>
<td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>以字符串形式返回此构造方法的名称。</td>
</tr>
<tr>
<td>Class&lt;?&gt;[]</td>
<td>getParameterTypes()</td>
<td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td>
</tr>
<tr>
<td>T</td>
<td>newInstance(Object… initargs)</td>
<td>使用此 Constructor对象表示的构造函数来创建新实例</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回描述此 Constructor 的字符串，其中包括类型参数。</td>
</tr>
</tbody></table>
<p>代码演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor cs3 = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class,String.class);</span><br><span class="line">System.out.println(<span class="string">&quot;-----getDeclaringClass-----&quot;</span>);</span><br><span class="line">Class uclazz=cs3.getDeclaringClass();</span><br><span class="line"><span class="comment">//Constructor对象表示的构造方法的类</span></span><br><span class="line">System.out.println(<span class="string">&quot;构造方法的类:&quot;</span>+uclazz.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----getGenericParameterTypes-----&quot;</span>);</span><br><span class="line"><span class="comment">//对象表示此 Constructor 对象所表示的方法的形参类型</span></span><br><span class="line">Type[] tps=cs3.getGenericParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Type tp:tps) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数名称tp:&quot;</span>+tp);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----getParameterTypes-----&quot;</span>);</span><br><span class="line"><span class="comment">//获取构造函数参数类型</span></span><br><span class="line">Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class claz:clazzs) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数名称:&quot;</span>+claz.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----getName-----&quot;</span>);</span><br><span class="line"><span class="comment">//以字符串形式返回此构造方法的名称</span></span><br><span class="line">System.out.println(<span class="string">&quot;getName:&quot;</span>+cs3.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----getoGenericString-----&quot;</span>);</span><br><span class="line"><span class="comment">//返回描述此 Constructor 的字符串，其中包括类型参数。</span></span><br><span class="line">System.out.println(<span class="string">&quot;getoGenericString():&quot;</span>+cs3.toGenericString());</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-----getDeclaringClass-----</span><br><span class="line">构造方法的类:com.example.javabase.User</span><br><span class="line">-----getGenericParameterTypes-----</span><br><span class="line">参数名称tp:<span class="keyword">int</span></span><br><span class="line">参数名称tp:<span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class">-----<span class="title">getParameterTypes</span>-----</span></span><br><span class="line">参数名称:int</span><br><span class="line">参数名称:java.lang.String</span><br><span class="line">-----getName-----</span><br><span class="line">getName:com.example.javabase.User</span><br><span class="line">-----getoGenericString-----</span><br><span class="line">getoGenericString():<span class="keyword">private</span> com.example.javabase.User(<span class="keyword">int</span>,java.lang.String)   </span><br></pre></td></tr></table></figure>
<h2 id="Field类及其用法"><a href="#Field类及其用法" class="headerlink" title="Field类及其用法"></a>Field类及其用法</h2><blockquote>
<p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p>
</blockquote>
<p>同样的道理，我们可以通过Class类的提供的方法来获取代表字段信息的Field对象，Class类与Field对象相关方法如下：</p>
<table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field</td>
<td>getDeclaredField(String name)</td>
<td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td>
</tr>
<tr>
<td>Field[]</td>
<td>getDeclaredField()</td>
<td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td>
</tr>
<tr>
<td>Field</td>
<td>getField(String name)</td>
<td>获取指定name名称、具有public修饰的字段，包含继承字段</td>
</tr>
<tr>
<td>Field[]</td>
<td>getField()</td>
<td>获取修饰符为public的字段，包含继承字段</td>
</tr>
</tbody></table>
<p>下面的代码演示了上述方法的使用过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段,</span></span><br><span class="line">        <span class="comment">// 否则抛NoSuchFieldException</span></span><br><span class="line">        Field field = clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;field:&quot;</span>+field);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取</span></span><br><span class="line">        Field fields[] = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f:&quot;</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================getDeclaredFields====================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前类所字段(包含private字段),注意不包含父类的字段</span></span><br><span class="line">        Field fields2[] = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2:&quot;</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段</span></span><br><span class="line">        Field field2 = clazz.getDeclaredField(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;field2:&quot;</span>+field2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      输出结果: </span></span><br><span class="line"><span class="comment">     field:public int reflect.Person.age</span></span><br><span class="line"><span class="comment">     f:public java.lang.String reflect.Student.desc</span></span><br><span class="line"><span class="comment">     f:public int reflect.Person.age</span></span><br><span class="line"><span class="comment">     f:public java.lang.String reflect.Person.name</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ================getDeclaredFields====================</span></span><br><span class="line"><span class="comment">     f2:public java.lang.String reflect.Student.desc</span></span><br><span class="line"><span class="comment">     f2:private int reflect.Student.score</span></span><br><span class="line"><span class="comment">     field2:public java.lang.String reflect.Student.desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField/getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField/getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过Field类本身的方法对指定类属性赋值，代码演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象引用</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">Student st= (Student) clazz.newInstance();</span><br><span class="line"><span class="comment">//获取父类public字段并赋值</span></span><br><span class="line">Field ageField = clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.set(st,<span class="number">18</span>);</span><br><span class="line">Field nameField = clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameField.set(st,<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//只获取当前类的字段,不获取父类的字段</span></span><br><span class="line">Field descField = clazz.getDeclaredField(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">descField.set(st,<span class="string">&quot;I am student&quot;</span>);</span><br><span class="line">Field scoreField = clazz.getDeclaredField(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="comment">//设置可访问，score是private的</span></span><br><span class="line">scoreField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">scoreField.set(st,<span class="number">88</span>);</span><br><span class="line">System.out.println(st.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：Student&#123;age=18, name=&#x27;Lily ,desc=&#x27;I am student&#x27;, score=88&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字段值</span></span><br><span class="line">System.out.println(scoreField.get(st));</span><br><span class="line"><span class="comment">// 88</span></span><br></pre></td></tr></table></figure>
<p>其中的set(Object obj, Object value)方法是Field类本身的方法，用于设置字段的值，而get(Object obj)则是获取字段的值，当然关于Field类还有其他常用的方法如下：</p>
<table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>set(Object obj, Object value)</td>
<td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td>
</tr>
<tr>
<td>Object</td>
<td>get(Object obj)</td>
<td>返回指定对象上此 Field 表示的字段的值</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getType()</td>
<td>返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td>
</tr>
<tr>
<td>boolean</td>
<td>isEnumConstant()</td>
<td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回一个描述此 Field（包括其一般类型）的字符串</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>返回此 Field 对象表示的字段的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getDeclaringClass()</td>
<td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td>
</tr>
<tr>
<td>void</td>
<td>setAccessible(boolean flag)</td>
<td>将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td>
</tr>
</tbody></table>
<p>上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如<code>setInt()/getInt()</code>、<code>setBoolean()/getBoolean</code>、<code>setChar()/getChar()</code>等等方法，这里就不全部列出了，需要时查API文档即可。需要特别注意的是被final关键字修饰的Field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。</p>
<h2 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h2><blockquote>
<p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。</p>
</blockquote>
<p>下面是Class类获取Method对象相关的方法：</p>
<table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method</td>
<td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td>
</tr>
<tr>
<td>Method[]</td>
<td>getDeclaredMethod()</td>
<td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td>
</tr>
<tr>
<td>Method</td>
<td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td>
</tr>
<tr>
<td>Method[]</td>
<td>getMethods()</td>
<td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td>
</tr>
</tbody></table>
<p>同样通过案例演示上述方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectMethod</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Circle&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据参数获取public的Method,包含继承自父类的方法</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;draw&quot;</span>,<span class="keyword">int</span>.class,String.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;method:&quot;</span>+method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有public的方法:</span></span><br><span class="line">        Method[] methods =clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methods)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m::&quot;</span>+m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前类的方法包含private,该方法无法获取继承自父类的method</span></span><br><span class="line">        Method method1 = clazz.getDeclaredMethod(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;method1::&quot;</span>+method1);</span><br><span class="line">        <span class="comment">//获取当前类的所有方法包含private,该方法无法获取继承自父类的method</span></span><br><span class="line">        Method[] methods1=clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methods1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m1::&quot;</span>+m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> count , String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw &quot;</span>+ name +<span class="string">&quot;,count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAllCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method:<span class="keyword">public</span> <span class="keyword">void</span> reflect.Shape.draw(<span class="keyword">int</span>,java.lang.String)</span><br><span class="line"></span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">int</span> reflect.Circle.getAllCount()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">void</span> reflect.Shape.draw()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">void</span> reflect.Shape.draw(<span class="keyword">int</span>,java.lang.String)</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>,<span class="keyword">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line">m::<span class="keyword">public</span> java.lang.String java.lang.Object.toString()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> java.lang.Object.hashCode()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line">m::<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line"></span><br><span class="line">=========================================</span><br><span class="line">method1::<span class="keyword">private</span> <span class="keyword">void</span> reflect.Circle.drawCircle()</span><br><span class="line"></span><br><span class="line">m1::<span class="keyword">public</span> <span class="keyword">int</span> reflect.Circle.getAllCount()</span><br><span class="line">m1::<span class="keyword">private</span> <span class="keyword">void</span> reflect.Circle.drawCircle() </span><br></pre></td></tr></table></figure>
<p>在通过getMethods方法获取Method对象时，会把父类的方法也获取到，如上的输出结果，把Object类的方法都打印出来了。而<code>getDeclaredMethod/getDeclaredMethods</code>方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;reflect.Circle&quot;</span>);</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">Circle circle = (Circle) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定参数的方法对象Method</span></span><br><span class="line">Method method = clazz.getMethod(<span class="string">&quot;draw&quot;</span>,<span class="keyword">int</span>.class,String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Method对象的invoke(Object obj,Object... args)方法调用</span></span><br><span class="line">method.invoke(circle,<span class="number">15</span>,<span class="string">&quot;圈圈&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对私有无参方法的操作</span></span><br><span class="line">Method method1 = clazz.getDeclaredMethod(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line"><span class="comment">//修改私有方法的访问标识</span></span><br><span class="line">method1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method1.invoke(circle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对有返回值得方法操作</span></span><br><span class="line">Method method2 =clazz.getDeclaredMethod(<span class="string">&quot;getAllCount&quot;</span>);</span><br><span class="line">Integer count = (Integer) method2.invoke(circle);</span><br><span class="line">System.out.println(<span class="string">&quot;count:&quot;</span>+count); </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">draw 圈圈,count=<span class="number">15</span></span><br><span class="line">drawCircle</span><br><span class="line">count:<span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中调用方法，使用了Method类的<code>invoke(Object obj,Object... args)</code>第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。</p>
<table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object</td>
<td>invoke(Object obj, Object… args)</td>
<td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getReturnType()</td>
<td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td>
</tr>
<tr>
<td>Type</td>
<td>getGenericReturnType()</td>
<td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td>
</tr>
<tr>
<td>Class&lt;?&gt;[]</td>
<td>getParameterTypes()</td>
<td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td>
</tr>
<tr>
<td>Type[]</td>
<td>getGenericParameterTypes()</td>
<td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td>
</tr>
<tr>
<td>boolean</td>
<td>isVarArgs()</td>
<td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回描述此 Method 的字符串，包括类型参数。</td>
</tr>
</tbody></table>
<p><code>getReturnType方法/getGenericReturnType方法</code>都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.8新增</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>getParameterTypes/getGenericParameterTypes</code>也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。</p>
<h1 id="反射机制执行的流程"><a href="#反射机制执行的流程" class="headerlink" title="反射机制执行的流程"></a>反射机制执行的流程</h1><blockquote>
<p>这部分主要参考自<a href="https://www.cnblogs.com/yougewe/p/10125073.html">https://www.cnblogs.com/yougewe/p/10125073.html</a></p>
</blockquote>
<p><strong>先看个例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 使用外部配置的实现，进行动态加载类</span></span><br><span class="line">            TempFunctionTest test = (TempFunctionTest)Class.forName(<span class="string">&quot;com.tester.HelloReflect&quot;</span>).newInstance();</span><br><span class="line">            test.sayHello(<span class="string">&quot;call directly&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象）</span></span><br><span class="line">            Object t2 = <span class="keyword">new</span> TempFunctionTest();</span><br><span class="line">            Method method = t2.getClass().getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">            method.invoke(test, <span class="string">&quot;method invoke&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,&quot;</span> + word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>来看执行流程</strong></p>
<p><img src="https://www.pdai.tech/_images/java/java-basic-reflection-1.png" alt="img"></p>
<h2 id="反射获取类实例"><a href="#反射获取类实例" class="headerlink" title="反射获取类实例"></a>反射获取类实例</h2><p>首先调用了 java.lang.Class 的静态方法，获取类信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader</span></span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 调用native方法进行获取class信息</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>forName()反射获取类信息，并没有将实现留给了java,而是交给了jvm去加载。</p>
<p>主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader.</p>
<p>最后，jvm又会回调 ClassLoader 进类加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sun.misc.Launcher</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="keyword">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">int</span> var3 = var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">        <span class="keyword">if</span>(var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">            SecurityManager var4 = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span>(var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">            Class var5 = <span class="keyword">this</span>.findLoadedClass(var1);</span><br><span class="line">            <span class="keyword">if</span>(var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(var2) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.resolveClass(var5);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> var5;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// java.lang.ClassLoader</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先获取锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 如果已经加载了的话，就不用再加载了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 双亲委托加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 父类没有加载到时，再自己加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getClassLoadingLock</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelLockMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 ConcurrentHashMap来保存锁</span></span><br><span class="line">        Object newLock = <span class="keyword">new</span> Object();</span><br><span class="line">        lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lock = newLock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看一下 newInstance() 的实现方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先肯定是 Class.newInstance</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the following code may not be strictly correct under</span></span><br><span class="line">    <span class="comment">// the current Java memory model.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor lookup</span></span><br><span class="line">    <span class="comment">// newInstance() 其实相当于调用类的无参构造函数，所以，首先要找到其无参构造器</span></span><br><span class="line">    <span class="keyword">if</span> (cachedConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == Class.class) &#123;</span><br><span class="line">            <span class="comment">// 不允许调用 Class 的 newInstance() 方法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(</span><br><span class="line">                <span class="string">&quot;Can not call newInstance() on the Class for java.lang.Class&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取无参构造器</span></span><br><span class="line">            Class&lt;?&gt;[] empty = &#123;&#125;;</span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);</span><br><span class="line">            <span class="comment">// Disable accessibility checks on the constructor</span></span><br><span class="line">            <span class="comment">// since we have to do the security check here anyway</span></span><br><span class="line">            <span class="comment">// (the stack depth is wrong for the Constructor&#x27;s</span></span><br><span class="line">            <span class="comment">// security check to work)</span></span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> java.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            cachedConstructor = c;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (InstantiationException)</span><br><span class="line">                <span class="keyword">new</span> InstantiationException(getName()).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Constructor&lt;T&gt; tmpConstructor = cachedConstructor;</span><br><span class="line">    <span class="comment">// Security check (same as in java.lang.reflect.Constructor)</span></span><br><span class="line">    <span class="keyword">int</span> modifiers = tmpConstructor.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(<span class="keyword">this</span>, modifiers)) &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (newInstanceCallerCache != caller) &#123;</span><br><span class="line">            Reflection.ensureMemberAccess(caller, <span class="keyword">this</span>, <span class="keyword">null</span>, modifiers);</span><br><span class="line">            newInstanceCallerCache = caller;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Run constructor</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用无参构造器</span></span><br><span class="line">        <span class="keyword">return</span> tmpConstructor.newInstance((Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Unsafe.getUnsafe().throwException(e.getTargetException());</span><br><span class="line">        <span class="comment">// Not reached</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>newInstance() 主要做了三件事：</p>
<ul>
<li>权限检测，如果不通过直接抛出异常；</li>
<li>查找无参构造器，并将其缓存起来；</li>
<li>调用具体方法的无参构造方法，生成实例并返回；</li>
</ul>
<p>下面是获取构造器的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Constructor&lt;T&gt; <span class="title">getConstructor0</span><span class="params">(Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> which)</span> <span class="keyword">throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有构造器</span></span><br><span class="line">    Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;T&gt; constructor : constructors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayContentsEq(parameterTypes,</span><br><span class="line">                            constructor.getParameterTypes())) &#123;</span><br><span class="line">            <span class="keyword">return</span> getReflectionFactory().copyConstructor(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(getName() + <span class="string">&quot;.&lt;init&gt;&quot;</span> + argumentTypesToString(parameterTypes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getConstructor0() 为获取匹配的构造方器；分三步：</p>
<ul>
<li>先获取所有的constructors, 然后通过进行参数类型比较；</li>
<li>找到匹配后，通过 ReflectionFactory copy一份constructor返回；</li>
<li>否则抛出 NoSuchMethodException;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前类所有的构造方法，通过jvm或者缓存</span></span><br><span class="line"><span class="comment">// Returns an array of &quot;root&quot; constructors. These Constructor</span></span><br><span class="line"><span class="comment">// objects must NOT be propagated to the outside world, but must</span></span><br><span class="line"><span class="comment">// instead be copied via ReflectionFactory.copyConstructor.</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;T&gt;[] privateGetDeclaredConstructors(<span class="keyword">boolean</span> publicOnly) &#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Constructor&lt;T&gt;[] res;</span><br><span class="line">    <span class="comment">// 调用 reflectionData(), 获取保存的信息，使用软引用保存，从而使内存不够可以回收</span></span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;</span><br><span class="line">        <span class="comment">// 存在缓存，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No cached value available; request value from VM</span></span><br><span class="line">    <span class="keyword">if</span> (isInterface()) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) <span class="keyword">new</span> Constructor&lt;?&gt;[<span class="number">0</span>];</span><br><span class="line">        res = temporaryRes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用native方法从jvm获取构造器</span></span><br><span class="line">        res = getDeclaredConstructors0(publicOnly);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后，将从jvm中读取的内容，存入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">            rd.publicConstructors = res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.declaredConstructors = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lazily create and cache ReflectionData</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title">reflectionData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="keyword">this</span>.reflectionData;</span><br><span class="line">    <span class="keyword">int</span> classRedefinedCount = <span class="keyword">this</span>.classRedefinedCount;</span><br><span class="line">    ReflectionData&lt;T&gt; rd;</span><br><span class="line">    <span class="keyword">if</span> (useCaches &amp;&amp;</span><br><span class="line">        reflectionData != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (rd = reflectionData.get()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> rd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else no SoftReference or cleared SoftReference or stale ReflectionData</span></span><br><span class="line">    <span class="comment">// -&gt; create and replace new instance</span></span><br><span class="line">    <span class="keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新创建缓存，保存反射信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title">newReflectionData</span><span class="params">(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> classRedefinedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCaches) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用cas保证更新的线程安全性，所以反射是保证线程安全的</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ReflectionData&lt;T&gt; rd = <span class="keyword">new</span> ReflectionData&lt;&gt;(classRedefinedCount);</span><br><span class="line">        <span class="comment">// try to CAS it...</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic.casReflectionData(<span class="keyword">this</span>, oldReflectionData, <span class="keyword">new</span> SoftReference&lt;&gt;(rd))) &#123;</span><br><span class="line">            <span class="keyword">return</span> rd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先使用CAS更新，如果更新成功，则立即返回，否则测查当前已被其他线程更新的情况，如果和自己想要更新的状态一致，则也算是成功了</span></span><br><span class="line">        oldReflectionData = <span class="keyword">this</span>.reflectionData;</span><br><span class="line">        classRedefinedCount = <span class="keyword">this</span>.classRedefinedCount;</span><br><span class="line">        <span class="keyword">if</span> (oldReflectionData != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (rd = oldReflectionData.get()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> rd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，privateGetDeclaredConstructors(), 获取所有的构造器主要步骤；</p>
<ul>
<li>先尝试从缓存中获取；</li>
<li>如果缓存没有，则从jvm中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；</li>
</ul>
<p>另外，使用 relactionData() 进行缓存保存；ReflectionData 的数据结构如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection data that might get invalidated when JVM TI RedefineClasses() is called</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Field[] declaredFields;</span><br><span class="line">    <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line">    <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">    <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">    <span class="comment">// Intermediate results for getFields and getMethods</span></span><br><span class="line">    <span class="keyword">volatile</span> Field[] declaredPublicFields;</span><br><span class="line">    <span class="keyword">volatile</span> Method[] declaredPublicMethods;</span><br><span class="line">    <span class="keyword">volatile</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value of classRedefinedCount when we created this ReflectionData instance</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> redefinedCount;</span><br><span class="line"></span><br><span class="line">    ReflectionData(<span class="keyword">int</span> redefinedCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.redefinedCount = redefinedCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，还有一个点，就是如何比较构造是否是要查找构造器，其实就是比较类型完成相等就完了，有一个不相等则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">arrayContentsEq</span><span class="params">(Object[] a1, Object[] a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a2 == <span class="keyword">null</span> || a2.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a1.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a1.length != a2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a1[i] != a2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.ReflectionFactory</span></span><br><span class="line"><span class="comment">/** Makes a copy of the passed constructor. The returned</span></span><br><span class="line"><span class="comment">    constructor is a &quot;child&quot; of the passed one; see the comments</span></span><br><span class="line"><span class="comment">    in Constructor.java for details. */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Constructor&lt;T&gt; <span class="title">copyConstructor</span><span class="params">(Constructor&lt;T&gt; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> langReflectAccess().copyConstructor(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.reflect.Constructor, copy 其实就是新new一个 Constructor 出来</span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This routine enables sharing of ConstructorAccessor objects</span></span><br><span class="line">    <span class="comment">// among Constructor objects which refer to the same underlying</span></span><br><span class="line">    <span class="comment">// method in the VM. (All of this contortion is only necessary</span></span><br><span class="line">    <span class="comment">// because of the &quot;accessibility&quot; bit in AccessibleObject,</span></span><br><span class="line">    <span class="comment">// which implicitly requires that new java.lang.reflect</span></span><br><span class="line">    <span class="comment">// objects be fabricated for each reflective call on Class</span></span><br><span class="line">    <span class="comment">// objects.)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Can not copy a non-root Constructor&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;T&gt; res = <span class="keyword">new</span> Constructor&lt;&gt;(clazz,</span><br><span class="line">                                           parameterTypes,</span><br><span class="line">                                           exceptionTypes, modifiers, slot,</span><br><span class="line">                                           signature,</span><br><span class="line">                                           annotations,</span><br><span class="line">                                           parameterAnnotations);</span><br><span class="line">    <span class="comment">// root 指向当前 constructor</span></span><br><span class="line">    res.root = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Might as well eagerly propagate this if already present</span></span><br><span class="line">    res.constructorAccessor = constructorAccessor;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面，获取到 Constructor 了。</p>
<p>接下来就只需调用其相应构造器的 newInstance()，即返回实例了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return tmpConstructor.newInstance((Object[])null); </span></span><br><span class="line"><span class="comment">// java.lang.reflect.Constructor</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">           IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">    ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ca = acquireConstructorAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T inst = (T) ca.newInstance(initargs);</span><br><span class="line">    <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.DelegatingConstructorAccessorImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Object[] args)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">         IllegalArgumentException,</span></span><br><span class="line"><span class="function">         InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.newInstance(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.NativeConstructorAccessorImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">           IllegalArgumentException,</span></span><br><span class="line"><span class="function">           InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can&#x27;t inflate a constructor belonging to a vm-anonymous class</span></span><br><span class="line">    <span class="comment">// because that kind of class can&#x27;t be referred to by name, hence can&#x27;t</span></span><br><span class="line">    <span class="comment">// be found from the generated bytecode.</span></span><br><span class="line">    <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">            &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;</span><br><span class="line">        ConstructorAccessorImpl acc = (ConstructorAccessorImpl)</span><br><span class="line">            <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                generateConstructor(c.getDeclaringClass(),</span><br><span class="line">                                    c.getParameterTypes(),</span><br><span class="line">                                    c.getExceptionTypes(),</span><br><span class="line">                                    c.getModifiers());</span><br><span class="line">        parent.setDelegate(acc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用native方法，进行调用 constructor</span></span><br><span class="line">    <span class="keyword">return</span> newInstance0(c, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回构造器的实例后，可以根据外部进行进行类型转换，从而使用接口或方法进行调用实例功能了。</p>
<h2 id="反射获取方法"><a href="#反射获取方法" class="headerlink" title="反射获取方法"></a>反射获取方法</h2><p><strong>第一步，先获取 Method</strong>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">    Method method = searchMethods(privateGetDeclaredMethods(<span class="keyword">false</span>), name, parameterTypes);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(getName() + <span class="string">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略第一个检查权限，剩下就只有两个动作了。</p>
<ul>
<li>获取所有方法列表；</li>
<li>根据方法名称和方法列表，选出符合要求的方法；</li>
<li>如果没有找到相应方法，抛出异常，否则返回对应方法；</li>
</ul>
<p>所以，先看一下怎样获取类声明的所有方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns an array of &quot;root&quot; methods. These Method objects must NOT</span></span><br><span class="line"><span class="comment">// be propagated to the outside world, but must instead be copied</span></span><br><span class="line"><span class="comment">// via ReflectionFactory.copyMethod.</span></span><br><span class="line"><span class="keyword">private</span> Method[] privateGetDeclaredMethods(<span class="keyword">boolean</span> publicOnly) &#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Method[] res;</span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No cached value available; request value from VM</span></span><br><span class="line">    res = Reflection.filterMethods(<span class="keyword">this</span>, getDeclaredMethods0(publicOnly));</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">            rd.declaredPublicMethods = res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.declaredMethods = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很相似，和获取所有构造器的方法很相似，都是先从缓存中获取方法，如果没有，则从jvm中获取。</p>
<p>不同的是，方法列表需要进行过滤 Reflection.filterMethods;当然后面看来，这个方法我们一般不会派上用场。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sun.misc.Reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Method[] filterMethods(Class&lt;?&gt; containingClass, Method[] methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (methodFilterMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Bootstrapping</span></span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Method[])filter(methods, methodFilterMap.get(containingClass));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以过滤指定的方法，一般为空，如果要指定过滤，可以调用 registerMethodsToFilter(), 或者...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Member[] filter(Member[] members, String[] filteredNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((filteredNames == <span class="keyword">null</span>) || (members.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> members;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numNewMembers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> shouldSkip = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String filteredName : filteredNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (member.getName() == filteredName) &#123;</span><br><span class="line">                shouldSkip = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip) &#123;</span><br><span class="line">            ++numNewMembers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Member[] newMembers =</span><br><span class="line">        (Member[])Array.newInstance(members[<span class="number">0</span>].getClass(), numNewMembers);</span><br><span class="line">    <span class="keyword">int</span> destIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> shouldSkip = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String filteredName : filteredNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (member.getName() == filteredName) &#123;</span><br><span class="line">                shouldSkip = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip) &#123;</span><br><span class="line">            newMembers[destIdx++] = member;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newMembers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二步，根据方法名和参数类型过滤指定方法返回</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">searchMethods</span><span class="params">(Method[] methods,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Class&lt;?&gt;[] parameterTypes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Method res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 使用常量池，避免重复创建String</span></span><br><span class="line">    String internedName = name.intern();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">        Method m = methods[i];</span><br><span class="line">        <span class="keyword">if</span> (m.getName() == internedName</span><br><span class="line">            &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())</span><br><span class="line">            &amp;&amp; (res == <span class="keyword">null</span></span><br><span class="line">                || res.getReturnType().isAssignableFrom(m.getReturnType())))</span><br><span class="line">            res = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (res == <span class="keyword">null</span> ? res : getReflectionFactory().copyMethod(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概意思看得明白，就是匹配到方法名，然后参数类型匹配，才可以。</p>
<ul>
<li>但是可以看到，匹配到一个方法，并没有退出for循环，而是继续进行匹配。</li>
<li>这里是匹配最精确的子类进行返回（最优匹配）</li>
<li>最后，还是通过 ReflectionFactory, copy 方法后返回。</li>
</ul>
<h2 id="调用-method-invoke-方法"><a href="#调用-method-invoke-方法" class="headerlink" title="调用 method.invoke() 方法"></a>调用 method.invoke() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invoke时，是通过 MethodAccessor 进行调用的，而 MethodAccessor 是个接口，在第一次时调用 acquireMethodAccessor() 进行新创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// probably make the implementation more scalable.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    MethodAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在缓存时，存入 methodAccessor，否则调用 ReflectionFactory 创建新的 MethodAccessor</span></span><br><span class="line">        methodAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</span><br><span class="line">        setMethodAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.reflect.ReflectionFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">            generateMethod(method.getDeclaringClass(),</span><br><span class="line">                           method.getName(),</span><br><span class="line">                           method.getParameterTypes(),</span><br><span class="line">                           method.getReturnType(),</span><br><span class="line">                           method.getExceptionTypes(),</span><br><span class="line">                           method.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NativeMethodAccessorImpl acc =</span><br><span class="line">            <span class="keyword">new</span> NativeMethodAccessorImpl(method);</span><br><span class="line">        DelegatingMethodAccessorImpl res =</span><br><span class="line">            <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</span><br><span class="line">        acc.setParent(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个Accessor详情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     NativeMethodAccessorImpl / DelegatingMethodAccessorImpl</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can&#x27;t inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;</span><br><span class="line">        setDelegate(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行 ma.invoke(obj, args); 调用时，调用 DelegatingMethodAccessorImpl.invoke();</p>
<p>最后被委托到 NativeMethodAccessorImpl.invoke(), 即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We can&#x27;t inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">    <span class="comment">// that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span></span><br><span class="line">    <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">    <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">            &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">            <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                generateMethod(method.getDeclaringClass(),</span><br><span class="line">                               method.getName(),</span><br><span class="line">                               method.getParameterTypes(),</span><br><span class="line">                               method.getReturnType(),</span><br><span class="line">                               method.getExceptionTypes(),</span><br><span class="line">                               method.getModifiers());</span><br><span class="line">        parent.setDelegate(acc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke0 是个 native 方法，由jvm进行调用业务方法。从而完成反射调用功能。</span></span><br><span class="line">    <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中， generateMethod() 是生成具体类的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** This routine is not thread-safe */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">generateMethod</span><span class="params">(Class&lt;?&gt; declaringClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String   name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Class&lt;?&gt;   returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Class&lt;?&gt;[] checkedExceptions,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> modifiers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (MethodAccessor) generate(declaringClass,</span><br><span class="line">                                     name,</span><br><span class="line">                                     parameterTypes,</span><br><span class="line">                                     returnType,</span><br><span class="line">                                     checkedExceptions,</span><br><span class="line">                                     modifiers,</span><br><span class="line">                                     <span class="keyword">false</span>,</span><br><span class="line">                                     <span class="keyword">false</span>,</span><br><span class="line">                                     <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** This routine is not thread-safe */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MagicAccessorImpl <span class="title">generate</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; declaringClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Class&lt;?&gt;   returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Class&lt;?&gt;[] checkedExceptions,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> modifiers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> isConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> forSerialization,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Class&lt;?&gt; serializationTargetClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteVector vec = ByteVectorFactory.create();</span><br><span class="line">    asm = <span class="keyword">new</span> ClassFileAssembler(vec);</span><br><span class="line">    <span class="keyword">this</span>.declaringClass = declaringClass;</span><br><span class="line">    <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">    <span class="keyword">this</span>.returnType = returnType;</span><br><span class="line">    <span class="keyword">this</span>.modifiers = modifiers;</span><br><span class="line">    <span class="keyword">this</span>.isConstructor = isConstructor;</span><br><span class="line">    <span class="keyword">this</span>.forSerialization = forSerialization;</span><br><span class="line"></span><br><span class="line">    asm.emitMagicAndVersion();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constant pool entries:</span></span><br><span class="line">    <span class="comment">// ( * = Boxing information: optional)</span></span><br><span class="line">    <span class="comment">// (+  = Shared entries provided by AccessorGenerator)</span></span><br><span class="line">    <span class="comment">// (^  = Only present if generating SerializationConstructorAccessor)</span></span><br><span class="line">    <span class="comment">//     [UTF-8] [This class&#x27;s name]</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//     [UTF-8] &quot;sun/reflect/&#123;MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl&#125;&quot;</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//     [UTF-8] [Target class&#x27;s name]</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// ^   [UTF-8] [Serialization: Class&#x27;s name in which to invoke constructor]</span></span><br><span class="line">    <span class="comment">// ^   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//     [UTF-8] target method or constructor name</span></span><br><span class="line">    <span class="comment">//     [UTF-8] target method or constructor signature</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method</span></span><br><span class="line">    <span class="comment">//     [UTF-8] &quot;invoke&quot; or &quot;newInstance&quot;</span></span><br><span class="line">    <span class="comment">//     [UTF-8] invoke or newInstance descriptor</span></span><br><span class="line">    <span class="comment">//     [UTF-8] descriptor for type of non-primitive parameter 1</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for type of non-primitive parameter 1</span></span><br><span class="line">    <span class="comment">//     ...</span></span><br><span class="line">    <span class="comment">//     [UTF-8] descriptor for type of non-primitive parameter n</span></span><br><span class="line">    <span class="comment">//     [CONSTANT_Class_info] for type of non-primitive parameter n</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/Exception&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/ClassCastException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/NullPointerException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/IllegalArgumentException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/InvocationTargetException&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;&lt;init&gt;&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;()V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for NullPointerException&#x27;s constructor</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;(Ljava/lang/String;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/String;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor taking a String</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;(Ljava/lang/Throwable;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/Throwable;)V&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for InvocationTargetException&#x27;s constructor</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for &quot;super()&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;java/lang/Object&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;toString&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;()Ljava/lang/String;&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_NameAndType_info] for &quot;toString()Ljava/lang/String;&quot;</span></span><br><span class="line">    <span class="comment">// +   [CONSTANT_Methodref_info] for Object&#x27;s toString method</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;Code&quot;</span></span><br><span class="line">    <span class="comment">// +   [UTF-8] &quot;Exceptions&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Boolean&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(Z)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;booleanValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()Z&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Byte&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(B)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;byteValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()B&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Character&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(C)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;charValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()C&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Double&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(D)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;doubleValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()D&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Float&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(F)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;floatValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()F&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Integer&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(I)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;intValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()I&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Long&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(J)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;longValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()J&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;java/lang/Short&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Class_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;(S)V&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;shortValue&quot;</span></span><br><span class="line">    <span class="comment">//  *  [UTF-8] &quot;()S&quot;</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_NameAndType_info] for above</span></span><br><span class="line">    <span class="comment">//  *  [CONSTANT_Methodref_info] for above</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;</span><br><span class="line">    <span class="keyword">boolean</span> usesPrimitives = usesPrimitiveTypes();</span><br><span class="line">    <span class="keyword">if</span> (usesPrimitives) &#123;</span><br><span class="line">        numCPEntries += NUM_BOXING_CPOOL_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">        numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add in variable-length number of entries to be able to describe</span></span><br><span class="line">    <span class="comment">// non-primitive parameter types and checked exceptions.</span></span><br><span class="line">    numCPEntries += (<span class="keyword">short</span>) (<span class="number">2</span> * numNonPrimitiveParameterTypes());</span><br><span class="line"></span><br><span class="line">    asm.emitShort(add(numCPEntries, S1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String generatedName = generateName(isConstructor, forSerialization);</span><br><span class="line">    asm.emitConstantPoolUTF8(generatedName);</span><br><span class="line">    asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">    thisClass = asm.cpi();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">            asm.emitConstantPoolUTF8</span><br><span class="line">                (<span class="string">&quot;sun/reflect/SerializationConstructorAccessorImpl&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            asm.emitConstantPoolUTF8(<span class="string">&quot;sun/reflect/ConstructorAccessorImpl&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;sun/reflect/MethodAccessorImpl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">    superClass = asm.cpi();</span><br><span class="line">    asm.emitConstantPoolUTF8(getClassName(declaringClass, <span class="keyword">false</span>));</span><br><span class="line">    asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">    targetClass = asm.cpi();</span><br><span class="line">    <span class="keyword">short</span> serializationTargetClassIdx = (<span class="keyword">short</span>) <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, <span class="keyword">false</span>));</span><br><span class="line">        asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">        serializationTargetClassIdx = asm.cpi();</span><br><span class="line">    &#125;</span><br><span class="line">    asm.emitConstantPoolUTF8(name);</span><br><span class="line">    asm.emitConstantPoolUTF8(buildInternalSignature());</span><br><span class="line">    asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());</span><br><span class="line">    <span class="keyword">if</span> (isInterface()) &#123;</span><br><span class="line">        asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (forSerialization) &#123;</span><br><span class="line">            asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            asm.emitConstantPoolMethodref(targetClass, asm.cpi());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    targetMethodRef = asm.cpi();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;newInstance&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    invokeIdx = asm.cpi();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8(<span class="string">&quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asm.emitConstantPoolUTF8</span><br><span class="line">            (<span class="string">&quot;(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    invokeDescriptorIdx = asm.cpi();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output class information for non-primitive parameter types</span></span><br><span class="line">    nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">        Class&lt;?&gt; c = parameterTypes[i];</span><br><span class="line">        <span class="keyword">if</span> (!isPrimitive(c)) &#123;</span><br><span class="line">            asm.emitConstantPoolUTF8(getClassName(c, <span class="keyword">false</span>));</span><br><span class="line">            asm.emitConstantPoolClass(asm.cpi());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor</span></span><br><span class="line">    emitCommonConstantPoolEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boxing entries</span></span><br><span class="line">    <span class="keyword">if</span> (usesPrimitives) &#123;</span><br><span class="line">        emitBoxingContantPoolEntries();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asm.cpi() != numCPEntries) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Adjust this code (cpi = &quot;</span> + asm.cpi() +</span><br><span class="line">                                <span class="string">&quot;, numCPEntries = &quot;</span> + numCPEntries + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access flags</span></span><br><span class="line">    asm.emitShort(ACC_PUBLIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This class</span></span><br><span class="line">    asm.emitShort(thisClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Superclass</span></span><br><span class="line">    asm.emitShort(superClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interfaces count and interfaces</span></span><br><span class="line">    asm.emitShort(S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields count and fields</span></span><br><span class="line">    asm.emitShort(S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods count and methods</span></span><br><span class="line">    asm.emitShort(NUM_METHODS);</span><br><span class="line"></span><br><span class="line">    emitConstructor();</span><br><span class="line">    emitInvoke();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Additional attributes (none)</span></span><br><span class="line">    asm.emitShort(S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load class</span></span><br><span class="line">    vec.trim();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = vec.getData();</span><br><span class="line">    <span class="comment">// Note: the class loader is the only thing that really matters</span></span><br><span class="line">    <span class="comment">// here -- it&#x27;s important to get the generated code into the</span></span><br><span class="line">    <span class="comment">// same namespace as the target class. Since the generated code</span></span><br><span class="line">    <span class="comment">// is privileged anyway, the protection domain probably doesn&#x27;t</span></span><br><span class="line">    <span class="comment">// matter.</span></span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> PrivilegedAction&lt;MagicAccessorImpl&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> MagicAccessorImpl <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (MagicAccessorImpl)</span><br><span class="line">                    ClassDefiner.defineClass</span><br><span class="line">                            (generatedName,</span><br><span class="line">                             bytes,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             bytes.length,</span><br><span class="line">                             declaringClass.getClassLoader()).newInstance();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>咱们主要看这一句：<code>ClassDefiner.defineClass(xx, declaringClass.getClassLoader()).newInstance()</code>;</p>
<p>在<code>ClassDefiner.defineClass</code>方法实现中，每被调用一次都会生成一个DelegatingClassLoader类加载器对象 ，这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载。</p>
<p>而反射生成的类，有时候可能用了就可以卸载了，所以使用其独立的类加载器，从而使得更容易控制反射类的生命周期。</p>
<h2 id="反射调用流程小结"><a href="#反射调用流程小结" class="headerlink" title="反射调用流程小结"></a>反射调用流程小结</h2><p>最后，用几句话总结反射的实现原理：</p>
<ol>
<li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li>
<li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li>
<li>反射也是考虑了线程安全的，放心使用；</li>
<li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li>
<li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li>
<li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li>
<li>调度反射方法，最终是由jvm执行invoke0()执行；</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之基础汇总</title>
    <url>/posts/b4b275a6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>本文主要对Java基础知识点进行总结</p>
</blockquote>
<a id="more"></a>

<h1 id="Java-基本功"><a href="#Java-基本功" class="headerlink" title="Java 基本功"></a>Java 基本功</h1><h2 id="Java-入门（基础概念与常识）"><a href="#Java-入门（基础概念与常识）" class="headerlink" title="Java 入门（基础概念与常识）"></a>Java 入门（基础概念与常识）</h2><h3 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点?"></a>Java 语言有哪些特点?</h3><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<blockquote>
<p>修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544">issue#544</a>）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p>
</blockquote>
<h3 id="关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="关于 JVM JDK 和 JRE 最详细通俗的解答"></a>关于 JVM JDK 和 JRE 最详细通俗的解答</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java程序运行过程"></p>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p><strong>总结：</strong></p>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<h4 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h4><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h3><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p>
<p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>
<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ol>
<li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence</a> 。</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<h3 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++的区别?"></a>Java 和 C++的区别?</h3><ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符<code>&#39;\0&#39;</code>来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li>
</ul>
<h3 id="import-java-和-javax-有什么区别？"><a href="#import-java-和-javax-有什么区别？" class="headerlink" title="import java 和 javax 有什么区别？"></a>import java 和 javax 有什么区别？</h3><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
<h3 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h3><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p>
<h2 id="Java-语法"><a href="#Java-语法" class="headerlink" title="Java 语法"></a>Java 语法</h2><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h3><ol>
<li><p>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的 0 个或若干个字符</p>
</li>
<li><p>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</p>
</li>
<li><p>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>),</p>
<blockquote>
<p>字符封装类 <code>Character</code> 有一个成员常量 <code>Character.SIZE</code> 值为 16,单位是<code>bits</code>,该值除以 8(<code>1byte=8bits</code>)后就可以得到 2 个字节</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>java 编程思想第四版：2.2.2 节 <img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg" alt="img"></p>
</blockquote>
<h3 id="关于注释？"><a href="#关于注释？" class="headerlink" title="关于注释？"></a>关于注释？</h3><p>Java 中的注释有三种：</p>
<ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释。</li>
</ol>
<p>在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。</p>
<p>《Clean Code》这本书明确指出：</p>
<blockquote>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>
<p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p>
<p>举个例子：</p>
<p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check to see if the employee is eligible for full benefits</span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="number">65</span>))</span><br></pre></td></tr></table></figure>

<p>应替换为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a>标识符和关键字的区别是什么？</h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。</p>
<h3 id="Java-中有哪些常见的关键字？"><a href="#Java-中有哪些常见的关键字？" class="headerlink" title="Java 中有哪些常见的关键字？"></a>Java 中有哪些常见的关键字？</h3><table>
<thead>
<tr>
<th>访问控制</th>
<th>private</th>
<th>protected</th>
<th>public</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td></td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>null</td>
<td>true</td>
<td>false</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p>
<p>++和–运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。</p>
<h3 id="continue、break、和-return-的区别是什么"><a href="#continue、break、和-return-的区别是什么" class="headerlink" title="continue、break、和 return 的区别是什么"></a>continue、break、和 return 的区别是什么</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>
<ol>
<li>continue ：指跳出当前的这一次循环，继续下一次循环。</li>
<li>break ：指跳出整个循环体，继续执行循环下面的语句。</li>
</ol>
<p>return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>
<ol>
<li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li>
</ol>
<h3 id="Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h3><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p><strong>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class="line">Method add = clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加，是可以的</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list)</span><br></pre></td></tr></table></figure>
<p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p>
<p><strong>泛型类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何实例化泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>
<p><strong>泛型接口</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>泛型方法</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure>
<p><strong>常用的通配符为： T，E，K，V，？</strong></p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个 java 类型</li>
<li>K V (key value) 分别代表 java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<p>更多关于 Java 泛型中的通配符可以查看这篇文章：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9">《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》</a></p>
<h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="==和 equals 的区别"></a>==和 equals 的区别</h3><p><strong><code>==</code></strong> : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(<strong>基本数据类型==比较的是值，引用数据类型==比较的是内存地址</strong>)</p>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<p><code>Object</code>类<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 <code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li>情况 2：类覆盖了 <code>equals()</code>方法。一般，我们都覆盖 <code>equals()</code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</li>
<li>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</li>
</ul>
<p><code>String</code>类<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode()与 equals()"></a>hashCode()与 equals()</h3><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p>
<p><strong>1)hashCode()介绍:</strong></p>
<p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p><strong>2)为什么要有 hashCode？</strong></p>
<p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p>
<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p>
<blockquote>
<p><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p>
<p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>
<p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p>
<p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p>
<p>更多关于 <code>hashcode()</code> 和 <code>equals()</code> 的内容可以查看：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a></p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"><a href="#Java-中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？" class="headerlink" title="Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"></a>Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</h3><p>Java<strong>中</strong>有 8 种基本数据类型，分别为：</p>
<ol>
<li>6 种数字类型 ：byte、short、int、long、float、double</li>
<li>1 种字符类型：char</li>
<li>1 种布尔型：boolean。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>32</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>8</td>
<td>0L</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>4</td>
<td>0f</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>8</td>
<td>0d</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td></td>
<td>false</td>
</tr>
</tbody></table>
<p>对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
<p>注意：</p>
<ol>
<li>Java 里使用 long 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析：</li>
<li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号</li>
</ol>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>更多内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></p>
<h3 id="种基本类型的包装类和常量池"><a href="#种基本类型的包装类和常量池" class="headerlink" title="种基本类型的包装类和常量池"></a>种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？（<a href="https://github.com/Snailclimb/JavaGuide/issues/461">参见 issue/461</a>）性能和资源之间的权衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<p><strong>Integer 缓存源代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>应用场景：</strong></p>
<ol>
<li>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li>
<li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure>
<p><strong>Integer 比较更丰富的一个例子:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));</span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="type">i1</span><span class="operator">=</span><span class="type">i2</span>   <span class="keyword">true</span></span><br><span class="line"><span class="type">i1</span><span class="operator">=</span><span class="type">i2</span>+<span class="type">i3</span>   <span class="keyword">true</span></span><br><span class="line"><span class="type">i1</span><span class="operator">=</span><span class="type">i4</span>   <span class="keyword">false</span></span><br><span class="line"><span class="type">i4</span><span class="operator">=</span><span class="type">i5</span>   <span class="keyword">false</span></span><br><span class="line"><span class="type">i4</span><span class="operator">=</span><span class="type">i5</span>+<span class="type">i6</span>   <span class="keyword">true</span></span><br><span class="line"><span class="number">40</span><span class="operator">=</span><span class="type">i5</span>+<span class="type">i6</span>   <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>
<h2 id="方法（函数"><a href="#方法（函数" class="headerlink" title="方法（函数"></a>方法（函数</h2><h3 id="什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>什么是方法的返回值?返回值在类的方法里的作用是什么?</h3><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p>
<h3 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h3><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p>
<p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>
<p><strong>下面通过 3 个例子来给大家说明</strong></p>
<blockquote>
<p><strong>example 1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">a</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">b</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">num1</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">num2</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><strong>解析：</strong></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg" alt="example 1 "></p>
<p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>
<blockquote>
<p><strong>example 2</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>解析：</strong></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg" alt="example 2"></p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>
<p><strong>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>
<blockquote>
<p><strong>example 3</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">        Student temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x:</span>小李</span><br><span class="line"><span class="symbol">y:</span>小张</span><br><span class="line"><span class="symbol">s1:</span>小张</span><br><span class="line"><span class="symbol">s2:</span>小李</span><br></pre></td></tr></table></figure>
<p><strong>解析：</strong></p>
<p>交换之前：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg" alt="img"></p>
<p>交换之后：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg" alt="img"></p>
<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>
<blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。</p>
<p>下面再总结一下 Java 中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<p><strong>重载：</strong></p>
<p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>下面是《Java 核心技术》对重载这个概念的介绍：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktopjava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg" alt="img"></p>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<p><strong>重写：</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p>
<p>暖心的 Guide 哥最后再来个图表总结一下！</p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》,<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892</a> ）：</p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ 关于 <strong>重写的返回值类</strong>型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超人&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hero <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperSuperMan</span> <span class="keyword">extends</span> <span class="title">SuperMan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;超级超级英雄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SuperMan <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuperMan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝-vs-浅拷贝"><a href="#深拷贝-vs-浅拷贝" class="headerlink" title="深拷贝 vs 浅拷贝"></a>深拷贝 vs 浅拷贝</h3><ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p>
<h3 id="方法的四种类型"><a href="#方法的四种类型" class="headerlink" title="方法的四种类型"></a>方法的四种类型</h3><p>1、无参数无返回值的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;无参数无返回值的方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、有参数无返回值的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有参数无返回值的方法</span></span><br><span class="line"><span class="comment">* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> a, String b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;--&gt;&quot;</span> + b + <span class="string">&quot;--&gt;&quot;</span> + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、有返回值无参数的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;有返回值无参数的方法&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、有返回值有参数的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有返回值有参数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、return 在无返回值方法的特殊使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return在无返回值方法的特殊使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<p>参见 issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431">面向过程 ：面向过程性能比面向对象高？？</a></p>
<blockquote>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p>
</blockquote>
<h3 id="构造器-Constructor-是否可被-override"><a href="#构造器-Constructor-是否可被-override" class="headerlink" title="构造器 Constructor 是否可被 override?"></a>构造器 Constructor 是否可被 override?</h3><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h3 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h3><ol>
<li>从语法形式上看:成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h3 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h3><ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h3 id="在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h3><p>帮助子类做初始化工作。</p>
<h3 id="对象的相等与指向他们的引用相等-两者有什么不同"><a href="#对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="对象的相等与指向他们的引用相等,两者有什么不同?"></a>对象的相等与指向他们的引用相等,两者有什么不同?</h3><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置name的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的?"></a>在一个静态方法内调用一个非静态成员为什么是非法的?</h3><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h3 id="静态方法和实例方法有何不同"><a href="#静态方法和实例方法有何不同" class="headerlink" title="静态方法和实例方法有何不同"></a>静态方法和实例方法有何不同</h3><ol>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ol>
<h2 id="其它重要知识点"><a href="#其它重要知识点" class="headerlink" title="其它重要知识点"></a>其它重要知识点</h2><h3 id="String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h3><p><strong>可变性</strong></p>
<p>简单的来说：<code>String</code> 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。</p>
<blockquote>
<p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675">issue 675</a>）：在 Java 9 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>
</blockquote>
<p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的构造方法都是调用父类构造方法也就是<code>AbstractStringBuilder</code> 实现的，大家可以自行查阅源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractStringBuilder.java</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="Object-类的常见方法总结"><a href="#Object-类的常见方法总结" class="headerlink" title="Object 类的常见方法总结"></a>Object 类的常见方法总结</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="与-equals-重要"><a href="#与-equals-重要" class="headerlink" title="== 与 equals(重要)"></a>== 与 equals(重要)</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<h3 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h3><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p>
<h4 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。**<code>hashCode()</code>在散列表中才有用，在其它情况下没用**。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<h4 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h4><ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<p>推荐阅读：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a></p>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h3 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h3><p>方法 1：通过 Scanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>
<p>方法 2：通过 BufferedReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>
<h1 id="Java-核心技术"><a href="#Java-核心技术" class="headerlink" title="Java 核心技术"></a>Java 核心技术</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>
<h3 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h3><ul>
<li><strong>静态编译：</strong> 在编译时确定类型，绑定对象</li>
<li><strong>动态编译：</strong> 运行时确定类型，绑定对象</li>
</ul>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li>
</ul>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p><strong>反射是框架设计的灵魂。</strong></p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ol>
<li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li>
<li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li>
<li>动态配置实例的属性；</li>
<li>……</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Java-异常类层次结构图"><a href="#Java-异常类层次结构图" class="headerlink" title="Java 异常类层次结构图"></a>Java 异常类层次结构图</h3><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="img"></p>
<p>图片来自：<a href="https://simplesnippets.tech/exception-handling-in-java-part-1/">https://simplesnippets.tech/exception-handling-in-java-part-1/</a></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png" alt="img"></p>
<p>图片来自：<a href="https://chercher.tech/java-programming/exceptions-java">https://chercher.tech/java-programming/exceptions-java</a></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p><strong>受检查异常</strong></p>
<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/check-exception.png" alt="check-exception"></p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p>
<p><strong>不受检查异常</strong></p>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointExecrption</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h3 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h3><ul>
<li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>在 <code>try</code> 或 <code>finally </code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190%E3%80%82">https://github.com/Snailclimb/JavaGuide/issues/190。</a></p>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h3 id="使用-try-with-resources-来代替try-catch-finally"><a href="#使用-try-with-resources-来代替try-catch-finally" class="headerlink" title="使用 try-with-resources 来代替try-catch-finally"></a>使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3><ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 final 的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<p>《Effecitve Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">             BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h3><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h3 id="线程有哪些基本状态"><a href="#线程有哪些基本状态" class="headerlink" title="线程有哪些基本状态?"></a>线程有哪些基本状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程的状态"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p>
<p>由上图可以看出：</p>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h2 id="文件与-I-O-流"><a href="#文件与-I-O-流" class="headerlink" title="文件与 I\O 流"></a>文件与 I\O 流</h2><h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="IO-操作方式分类"></p>
<p>按操作对象分类结构图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png" alt="IO-操作对象分类"></p>
<h4 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h4><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h4 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h4><ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>线程池之Fork/Join框架</title>
    <url>/posts/6c9bbedc/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能</p>
</blockquote>
<a id="more"></a>

<h1 id="Fork-Join框架简介"><a href="#Fork-Join框架简介" class="headerlink" title="Fork/Join框架简介"></a>Fork/Join框架简介</h1><p>Fork/Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。</p>
<h2 id="三个模块及关系"><a href="#三个模块及关系" class="headerlink" title="三个模块及关系"></a>三个模块及关系</h2><p>Fork/Join框架主要包含三个模块:</p>
<ul>
<li>任务对象: <code>ForkJoinTask</code> (包括<code>RecursiveTask</code>、<code>RecursiveAction</code> 和 <code>CountedCompleter</code>)</li>
<li>执行Fork/Join任务的线程: <code>ForkJoinWorkerThread</code></li>
<li>线程池: <code>ForkJoinPool</code></li>
</ul>
<p>这三者的关系是: ForkJoinPool可以通过池中的ForkJoinWorkerThread来处理ForkJoinTask任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from 《A Java Fork/Join Framework》Dong Lea</span></span><br><span class="line"><span class="function">Result <span class="title">solve</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (problem is small)</span><br><span class="line"> 		directly solve problem</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		split problem into independent parts</span><br><span class="line"> 		fork <span class="keyword">new</span> subtasks to solve each part</span><br><span class="line"> 		join all subtasks</span><br><span class="line"> 		compose result from subresults</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkJoinPool 只接收 ForkJoinTask 任务(在实际使用中，也可以接收 Runnable/Callable 任务，但在真正运行时，也会把这些任务封装成 ForkJoinTask 类型的任务)，RecursiveTask 是 ForkJoinTask 的子类，是一个可以递归执行的 ForkJoinTask，RecursiveAction 是一个无返回值的 RecursiveTask，CountedCompleter 在任务完成执行后会触发执行一个自定义的钩子函数。</p>
<p>在实际运用中，我们一般都会继承 <code>RecursiveTask</code> 、<code>RecursiveAction</code> 或 <code>CountedCompleter</code> 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。</p>
<h2 id="核心思想-分治算法-Divide-and-Conquer"><a href="#核心思想-分治算法-Divide-and-Conquer" class="headerlink" title="核心思想: 分治算法(Divide-and-Conquer)"></a>核心思想: 分治算法(Divide-and-Conquer)</h2><p>分治算法(Divide-and-Conquer)把任务递归的拆分为各个子任务，这样可以更好的利用系统资源，尽可能的使用所有可用的计算能力来提升应用性能。首先看一下 Fork/Join 框架的任务运行机制:</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-forkjoin-2.png" alt="img"></p>
<h2 id="核心思想-work-stealing-工作窃取-算法"><a href="#核心思想-work-stealing-工作窃取-算法" class="headerlink" title="核心思想: work-stealing(工作窃取)算法"></a>核心思想: work-stealing(工作窃取)算法</h2><p>work-stealing(工作窃取)算法: 线程池内的所有工作线程都尝试找到并执行已经提交的任务，或者是被其他活动任务创建的子任务(如果不存在就阻塞等待)。这种特性使得 ForkJoinPool 在运行多个可以产生子任务的任务，或者是提交的许多小任务时效率更高。尤其是构建异步模型的 ForkJoinPool 时，对不需要合并(join)的事件类型任务也非常适用。</p>
<p>在 ForkJoinPool 中，线程池中每个工作线程(ForkJoinWorkerThread)都对应一个任务队列(WorkQueue)，工作线程优先处理来自自身队列的任务(LIFO或FIFO顺序，参数 mode 决定)，然后以FIFO的顺序随机窃取其他队列中的任务。</p>
<p>具体思路如下:</p>
<ul>
<li>每个线程都有自己的一个WorkQueue，该工作队列是一个双端队列。</li>
<li>队列支持三个功能push、pop、poll</li>
<li>push/pop只能被队列的所有者线程调用，而poll可以被其他线程调用。</li>
<li>划分的子任务调用fork时，都会被push到自己的队列中。</li>
<li>默认情况下，工作线程从自己的双端队列获出任务并执行。</li>
<li>当自己的队列为空时，线程随机从另一个线程的队列末尾调用poll方法窃取任务。</li>
</ul>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-forkjoin-3.png" alt="img"></p>
<h2 id="Fork-Join-框架的执行流程"><a href="#Fork-Join-框架的执行流程" class="headerlink" title="Fork/Join 框架的执行流程"></a>Fork/Join 框架的执行流程</h2><p>上图可以看出ForkJoinPool 中的任务执行分两种:</p>
<ul>
<li>直接通过 FJP 提交的外部任务(external/submissions task)，存放在 workQueues 的偶数槽位；</li>
<li>通过内部 fork 分割的子任务(Worker task)，存放在 workQueues 的奇数槽位。</li>
</ul>
<p>那Fork/Join 框架的执行流程是什么样的?</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-forkjoin-5.png" alt="img"></p>
<h1 id="Fork-Join类关系"><a href="#Fork-Join类关系" class="headerlink" title="Fork/Join类关系"></a>Fork/Join类关系</h1><h2 id="ForkJoinPool继承关系"><a href="#ForkJoinPool继承关系" class="headerlink" title="ForkJoinPool继承关系"></a>ForkJoinPool继承关系</h2><p><img src="https://www.pdai.tech/_images/thread/java-thread-x-forkjoin-1.png" alt="img"></p>
<p>内部类介绍:</p>
<ul>
<li>ForkJoinWorkerThreadFactory: 内部线程工厂接口，用于创建工作线程ForkJoinWorkerThread</li>
<li>DefaultForkJoinWorkerThreadFactory: ForkJoinWorkerThreadFactory 的默认实现类</li>
<li>InnocuousForkJoinWorkerThreadFactory: 实现了 ForkJoinWorkerThreadFactory，无许可线程工厂，当系统变量中有系统安全管理相关属性时，默认使用这个工厂创建工作线程。</li>
<li>EmptyTask: 内部占位类，用于替换队列中 join 的任务。</li>
<li>ManagedBlocker: 为 ForkJoinPool 中的任务提供扩展管理并行数的接口，一般用在可能会阻塞的任务(如在 Phaser 中用于等待 phase 到下一个generation)。</li>
<li>WorkQueue: ForkJoinPool 的核心数据结构，本质上是work-stealing 模式的双端任务队列，内部存放 ForkJoinTask 对象任务，使用 @Contented 注解修饰防止伪共享。<ul>
<li>工作线程在运行中产生新的任务(通常是因为调用了 fork())时，此时可以把 WorkQueue 的数据结构视为一个栈，新的任务会放入栈顶(top 位)；工作线程在处理自己工作队列的任务时，按照 LIFO 的顺序。</li>
<li>工作线程在处理自己的工作队列同时，会尝试窃取一个任务(可能是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的队列任务)，此时可以把 WorkQueue 的数据结构视为一个 FIFO 的队列，窃取的任务位于其他线程的工作队列的队首(base位)。</li>
</ul>
</li>
<li>伪共享状态: 缓存系统中是以缓存行(cache line)为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</li>
</ul>
<h2 id="ForkJoinTask继承关系"><a href="#ForkJoinTask继承关系" class="headerlink" title="ForkJoinTask继承关系"></a>ForkJoinTask继承关系</h2><p><img src="https://www.pdai.tech/_images/thread/java-thread-x-forkjoin-4.png" alt="img"></p>
<p>ForkJoinTask 实现了 Future 接口，说明它也是一个可取消的异步运算任务，实际上ForkJoinTask 是 Future 的轻量级实现，主要用在纯粹是计算的函数式任务或者操作完全独立的对象计算任务。fork 是主运行方法，用于异步执行；而 join 方法在任务结果计算完毕之后才会运行，用来合并或返回计算结果。 其内部类都比较简单，ExceptionNode 是用于存储任务执行期间的异常信息的单向链表；其余四个类是为 Runnable/Callable 任务提供的适配器类，用于把 Runnable/Callable 转化为 ForkJoinTask 类型的任务(因为 ForkJoinPool 只可以运行 ForkJoinTask 类型的任务)。</p>
<h1 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h1><blockquote>
<p>分析思路: 在对类层次结构有了解以后，我们先看下内部核心参数，然后分析上述流程图。会分4个部分:</p>
</blockquote>
<ul>
<li>首先介绍任务的提交流程 - 外部任务(external/submissions task)提交</li>
<li>然后介绍任务的提交流程 - 子任务(Worker task)提交</li>
<li>再分析任务的执行过程(ForkJoinWorkerThread.run()到ForkJoinTask.doExec()这一部分)；</li>
<li>最后介绍任务的结果获取(ForkJoinTask.join()和ForkJoinTask.invoke())</li>
</ul>
<h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><p>在后面的源码解析中，我们会看到大量的位运算，这些位运算都是通过我们接下来介绍的一些常量参数来计算的。</p>
<p>例如，如果要更新活跃线程数，使用公式(UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; c)；c 代表当前 ctl，UC_MASK 和 SP_MASK 分别是高位和低位掩码，AC_UNIT 为活跃线程的增量数，使用(UC_MASK &amp; (c + AC_UNIT))就可以计算出高32位，然后再加上低32位(SP_MASK &amp; c)，就拼接成了一个新的ctl。</p>
<p>这些运算的可读性很差，看起来有些复杂。在后面源码解析中有位运算的地方我都会加上注释，大家只需要了解它们的作用即可。</p>
<p>ForkJoinPool 与 内部类 WorkQueue 共享的一些常量:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Constants shared across ForkJoinPool and WorkQueue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK = <span class="number">0xffff</span>;        <span class="comment">//  低位掩码，也是最大索引位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP = <span class="number">0x7fff</span>;        <span class="comment">//  工作线程最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EVENMASK = <span class="number">0xfffe</span>;        <span class="comment">//  偶数低位掩码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK = <span class="number">0x007e</span>;        <span class="comment">//  workQueues 数组最多64个槽位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl 子域和 WorkQueue.scanState 的掩码和标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCANNING = <span class="number">1</span>;             <span class="comment">// 标记是否正在运行任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INACTIVE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 失活状态  负数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SS_SEQ = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;       <span class="comment">// 版本戳，防止ABA问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForkJoinPool.config 和 WorkQueue.config 的配置信息标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK = <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// 模式掩码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE = <span class="number">0</span>; <span class="comment">//LIFO队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;<span class="comment">//FIFO队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 共享模式队列，负数</span></span><br></pre></td></tr></table></figure>
<p>ForkJoinPool 中的相关常量和实例字段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  低位和高位掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SP_MASK = <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UC_MASK = ~SP_MASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活跃线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AC_SHIFT = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_UNIT = <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT; <span class="comment">//活跃线程数增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_MASK = <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT; <span class="comment">//活跃线程数掩码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TC_SHIFT = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_UNIT = <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT; <span class="comment">//工作线程数增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_MASK = <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT; <span class="comment">//掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>);  <span class="comment">// 创建工作线程标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RSLOCK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RSIGNAL = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> ctl;                   <span class="comment">// 主控制参数</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;               <span class="comment">// 运行状态锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> config;                    <span class="comment">// 并行度|模式</span></span><br><span class="line"><span class="keyword">int</span> indexSeed;                       <span class="comment">// 用于生成工作线程索引</span></span><br><span class="line"><span class="keyword">volatile</span> WorkQueue[] workQueues;     <span class="comment">// 主对象注册信息，workQueue</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThreadFactory factory;<span class="comment">// 线程工厂</span></span><br><span class="line"><span class="keyword">final</span> UncaughtExceptionHandler ueh;  <span class="comment">// 每个工作线程的异常信息</span></span><br><span class="line"><span class="keyword">final</span> String workerNamePrefix;       <span class="comment">// 用于创建工作线程的名称</span></span><br><span class="line"><span class="keyword">volatile</span> AtomicLong stealCounter;    <span class="comment">// 偷取任务总数，也可作为同步监视器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 静态初始化字段 */</span></span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;</span><br><span class="line"><span class="comment">//启动或杀死线程的方法调用者的权限</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission modifyThreadPermission;</span><br><span class="line"><span class="comment">// 公共静态pool</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ForkJoinPool common;</span><br><span class="line"><span class="comment">//并行度，对应内部common池</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> commonParallelism;</span><br><span class="line"><span class="comment">//备用线程数，在tryCompensate中使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> commonMaxSpares;</span><br><span class="line"><span class="comment">//创建workerNamePrefix(工作线程名称前缀)时的序号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> poolNumberSequence;</span><br><span class="line"><span class="comment">//线程阻塞等待新的任务的超时值(以纳秒为单位)，默认2秒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> IDLE_TIMEOUT = <span class="number">2000L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>; <span class="comment">// 2sec</span></span><br><span class="line"><span class="comment">//空闲超时时间，防止timer未命中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMEOUT_SLOP = <span class="number">20L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;  <span class="comment">// 20ms</span></span><br><span class="line"><span class="comment">//默认备用线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_COMMON_MAX_SPARES = <span class="number">256</span>;</span><br><span class="line"><span class="comment">//阻塞前自旋的次数，用在在awaitRunStateLock和awaitWork中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS  = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//indexSeed的增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEED_INCREMENT = <span class="number">0x9e3779b9</span>;</span><br></pre></td></tr></table></figure>
<p>说明: ForkJoinPool 的内部状态都是通过一个64位的 long 型 变量ctl来存储，它由四个16位的子域组成:</p>
<ul>
<li>AC: 正在运行工作线程数减去目标并行度，高16位</li>
<li>TC: 总工作线程数减去目标并行度，中高16位</li>
<li>SS: 栈顶等待线程的版本计数和状态，中低16位</li>
<li>ID: 栈顶 WorkQueue 在池中的索引(poolIndex)，低16位</li>
</ul>
<p>在后面的源码解析中，某些地方也提取了ctl的低32位(sp=(int)ctl)来检查工作线程状态，例如，当sp不为0时说明当前还有空闲工作线程。</p>
<h3 id="ForkJoinPool-WorkQueue-中的相关属性"><a href="#ForkJoinPool-WorkQueue-中的相关属性" class="headerlink" title="ForkJoinPool.WorkQueue 中的相关属性:"></a>ForkJoinPool.WorkQueue 中的相关属性:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始队列容量，2的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"><span class="comment">//最大队列容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    <span class="comment">// Woker状态, &lt;0: inactive; odd:scanning</span></span><br><span class="line"><span class="keyword">int</span> stackPred;             <span class="comment">// 记录前一个栈顶的ctl</span></span><br><span class="line"><span class="keyword">int</span> nsteals;               <span class="comment">// 偷取任务数</span></span><br><span class="line"><span class="keyword">int</span> hint;                  <span class="comment">// 记录偷取者索引，初始为随机索引</span></span><br><span class="line"><span class="keyword">int</span> config;                <span class="comment">// 池索引和模式</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">//下一个poll操作的索引(栈底/队列头)</span></span><br><span class="line"><span class="keyword">int</span> top;                   <span class="comment">//  下一个push操作的索引(栈顶/队列尾)</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// 任务数组</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// 当前工作队列的工作线程，共享模式下为null</span></span><br><span class="line"><span class="keyword">volatile</span> Thread parker;    <span class="comment">// 调用park阻塞期间为owner，其他情况为null</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// 记录被join过来的任务</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// 记录从其他工作队列偷取过来的任务</span></span><br></pre></td></tr></table></figure>
<h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><h3 id="核心参数-1"><a href="#核心参数-1" class="headerlink" title="核心参数"></a>核心参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 任务运行状态 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status; <span class="comment">// 任务运行状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONE_MASK   = <span class="number">0xf0000000</span>;  <span class="comment">// 任务完成状态标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL      = <span class="number">0xf0000000</span>;  <span class="comment">// must be negative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">0xc0000000</span>;  <span class="comment">// must be &lt; NORMAL</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">0x80000000</span>;  <span class="comment">// must be &lt; CANCELLED</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL      = <span class="number">0x00010000</span>;  <span class="comment">// must be &gt;= 1 &lt;&lt; 16 等待信号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK       = <span class="number">0x0000ffff</span>;  <span class="comment">//  低位掩码</span></span><br></pre></td></tr></table></figure>
<h1 id="Fork-Join框架源码解析"><a href="#Fork-Join框架源码解析" class="headerlink" title="Fork/Join框架源码解析"></a>Fork/Join框架源码解析</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                    UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">            checkFactory(factory),</span><br><span class="line">            handler,</span><br><span class="line">            asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">            <span class="string">&quot;ForkJoinPool-&quot;</span> + nextPoolId() + <span class="string">&quot;-worker-&quot;</span>);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 在 ForkJoinPool 中我们可以自定义四个参数:</p>
<ul>
<li>parallelism: 并行度，默认为CPU数，最小为1</li>
<li>factory: 工作线程工厂；</li>
<li>handler: 处理工作线程运行任务时的异常情况类，默认为null；</li>
<li>asyncMode: 是否为异步模式，默认为 false。如果为true，表示子任务的执行遵循 FIFO 顺序并且任务不能被合并(join)，这种模式适用于工作线程只运行事件类型的异步任务。</li>
</ul>
<p>在多数场景使用时，如果没有太强的业务需求，我们一般直接使用 ForkJoinPool 中的common池，在JDK1.8之后提供了ForkJoinPool.commonPool()方法可以直接使用common池，来看一下它的构造:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    ForkJoinWorkerThreadFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    UncaughtExceptionHandler handler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// ignore exceptions in accessing/parsing</span></span><br><span class="line">        String pp = System.getProperty</span><br><span class="line">                (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;</span>);<span class="comment">//并行度</span></span><br><span class="line">        String fp = System.getProperty</span><br><span class="line">                (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.threadFactory&quot;</span>);<span class="comment">//线程工厂</span></span><br><span class="line">        String hp = System.getProperty</span><br><span class="line">                (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.exceptionHandler&quot;</span>);<span class="comment">//异常处理类</span></span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="keyword">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory) ClassLoader.</span><br><span class="line">                    getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="keyword">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler) ClassLoader.</span><br><span class="line">                    getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">            factory = defaultForkJoinWorkerThreadFactory;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">            factory = <span class="keyword">new</span> InnocuousForkJoinWorkerThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">            (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;<span class="comment">//默认并行度为1</span></span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">            <span class="string">&quot;ForkJoinPool.commonPool-worker-&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用common pool的优点就是我们可以通过指定系统参数的方式定义“并行度、线程工厂和异常处理类”；并且它使用的是同步模式，也就是说可以支持任务合并(join)。</p>
<h2 id="执行流程-外部任务-external-submissions-task-提交"><a href="#执行流程-外部任务-external-submissions-task-提交" class="headerlink" title="执行流程 - 外部任务(external/submissions task)提交"></a>执行流程 - 外部任务(external/submissions task)提交</h2><p>向 ForkJoinPool 提交任务有三种方式:</p>
<ul>
<li>invoke()会等待任务计算完毕并返回计算结果；</li>
<li>execute()是直接向池提交一个任务来异步执行，无返回结果；</li>
<li>submit()也是异步执行，但是会返回提交的任务，在适当的时候可通过task.get()获取执行结果。</li>
</ul>
<p>这三种提交方式都都是调用externalPush()方法来完成，所以接下来我们将从externalPush()方法开始逐步分析外部任务的执行过程。</p>
<h3 id="externalPush-ForkJoinTask-lt-gt-task"><a href="#externalPush-ForkJoinTask-lt-gt-task" class="headerlink" title="externalPush(ForkJoinTask&lt;?&gt; task)"></a>externalPush(ForkJoinTask&lt;?&gt; task)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加给定任务到submission队列中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    WorkQueue q;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();<span class="comment">//探针值，用于计算WorkQueue槽位索引</span></span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp; <span class="comment">//获取随机偶数槽位的workQueue</span></span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//锁定workQueue</span></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">        <span class="keyword">int</span> am, n, s;</span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;<span class="comment">//计算任务索引位置</span></span><br><span class="line">            U.putOrderedObject(a, j, task);<span class="comment">//任务入列</span></span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);<span class="comment">//更新push slot</span></span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);<span class="comment">//解除锁定</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                signalWork(ws, q);<span class="comment">//任务数小于1时尝试创建或激活一个工作线程</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//解除锁定</span></span><br><span class="line">    &#125;</span><br><span class="line">    externalSubmit(task);<span class="comment">//初始化workQueues及相关属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先说明一下externalPush和externalSubmit两个方法的联系: 它们的作用都是把任务放到队列中等待执行。不同的是，externalSubmit可以说是完整版的externalPush，在任务首次提交时，需要初始化workQueues及其他相关属性，这个初始化操作就是externalSubmit来完成的；而后再向池中提交的任务都是通过简化版的externalSubmit-externalPush来完成。</p>
<p>externalPush的执行流程很简单: 首先找到一个随机偶数槽位的 workQueue，然后把任务放入这个 workQueue 的任务数组中，并更新top位。如果队列的剩余任务数小于1，则尝试创建或激活一个工作线程来运行任务(防止在externalSubmit初始化时发生异常导致工作线程创建失败)。</p>
<h3 id="externalSubmit-ForkJoinTask-lt-gt-task"><a href="#externalSubmit-ForkJoinTask-lt-gt-task" class="headerlink" title="externalSubmit(ForkJoinTask&lt;?&gt; task)"></a>externalSubmit(ForkJoinTask&lt;?&gt; task)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务提交</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化调用线程的探针值，用于计算WorkQueue索引</span></span><br><span class="line">    <span class="keyword">int</span> r;                                    <span class="comment">// initialize caller&#x27;s probe</span></span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        WorkQueue[] ws;</span><br><span class="line">        WorkQueue q;</span><br><span class="line">        <span class="keyword">int</span> rs, m, k;</span><br><span class="line">        <span class="keyword">boolean</span> move = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;<span class="comment">// 池已关闭</span></span><br><span class="line">            tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化workQueues</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">            rs = lockRunState();<span class="comment">//锁定runState</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//初始化stealCounter</span></span><br><span class="line">                    U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> AtomicLong());</span><br><span class="line">                    <span class="comment">//创建workQueues，容量为2的幂次方</span></span><br><span class="line">                    <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                    <span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                    <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">                    n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);<span class="comment">//解锁并更新runState</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123;<span class="comment">//获取随机偶数槽位的workQueue</span></span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//锁定 workQueue</span></span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;<span class="comment">//当前workQueue的全部任务</span></span><br><span class="line">                <span class="keyword">int</span> s = q.top;</span><br><span class="line">                <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                            (a = q.growArray()) != <span class="keyword">null</span>) &#123;<span class="comment">//扩容</span></span><br><span class="line">                        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task);<span class="comment">//放入给定任务</span></span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);<span class="comment">//修改push slot</span></span><br><span class="line">                        submitted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//解除锁定</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;<span class="comment">//任务提交成功，创建或激活工作线程</span></span><br><span class="line">                    signalWork(ws, q);<span class="comment">//创建或激活一个工作线程来运行任务</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move on failure 操作失败，重新获取探针值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">            q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">                ws[k] = q;                 <span class="comment">// 更新索引k位值的workQueue</span></span><br><span class="line">            <span class="comment">//else terminated</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);<span class="comment">//重新获取线程探针值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: externalSubmit是externalPush的完整版本，主要用于第一次提交任务时初始化workQueues及相关属性，并且提交给定任务到队列中。具体执行步骤如下:</p>
<ul>
<li>如果池为终止状态(runState&lt;0)，调用tryTerminate来终止线程池，并抛出任务拒绝异常；</li>
<li>如果尚未初始化，就为 FJP 执行初始化操作: 初始化stealCounter、创建workerQueues，然后继续自旋；</li>
<li>初始化完成后，执行在externalPush中相同的操作: 获取 workQueue，放入指定任务。任务提交成功后调用signalWork方法创建或激活线程；</li>
<li>如果在步骤3中获取到的 workQueue 为null，会在这一步中创建一个 workQueue，创建成功继续自旋执行第三步操作；</li>
<li>如果非上述情况，或者有线程争用资源导致获取锁失败，就重新获取线程探针值继续自旋。</li>
</ul>
<h3 id="signalWork-WorkQueue-ws-WorkQueue-q"><a href="#signalWork-WorkQueue-ws-WorkQueue-q" class="headerlink" title="signalWork(WorkQueue[] ws, WorkQueue q)"></a>signalWork(WorkQueue[] ws, WorkQueue q)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">int</span> sp, i;</span><br><span class="line">    WorkQueue v;</span><br><span class="line">    Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>) c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                tryAddWorker(c);<span class="comment">//工作线程太少，添加新的工作线程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="keyword">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//计算ctl，加上版本戳SS_SEQ避免ABA问题</span></span><br><span class="line">        <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="comment">//计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(p);<span class="comment">//唤醒阻塞线程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>说明: 新建或唤醒一个工作线程，在externalPush、externalSubmit、workQueue.push、scan中调用。如果还有空闲线程，则尝试唤醒索引到的 WorkQueue 的parker线程；如果工作线程过少((ctl &amp; ADD_WORKER) != 0L)，则调用tryAddWorker添加一个新的工作线程。</p>
<h3 id="tryAddWorker-long-c"><a href="#tryAddWorker-long-c" class="headerlink" title="tryAddWorker(long c)"></a>tryAddWorker(long c)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryAddWorker</span><span class="params">(<span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);<span class="comment">//释放锁</span></span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                createWorker();<span class="comment">//创建工作线程</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="keyword">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 尝试添加一个新的工作线程，首先更新ctl中的工作线程数，然后调用createWorker()创建工作线程。</p>
<h3 id="createWorker"><a href="#createWorker" class="headerlink" title="createWorker()"></a>createWorker()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    ForkJoinWorkerThread wt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="keyword">null</span> &amp;&amp; (wt = fac.newThread(<span class="keyword">this</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    deregisterWorker(wt, ex);<span class="comment">//线程创建失败处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: createWorker首先通过线程工厂创一个新的ForkJoinWorkerThread，然后启动这个工作线程(wt.start())。如果期间发生异常，调用deregisterWorker处理线程创建失败的逻辑(deregisterWorker在后面再详细说明)。</p>
<p>ForkJoinWorkerThread 的构造函数如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="string">&quot;aForkJoinWorkerThread&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>可以看到 ForkJoinWorkerThread 在构造时首先调用父类 Thread 的方法，然后为工作线程注册pool和workQueue，而workQueue的注册任务由ForkJoinPool.registerWorker来完成。</p>
<h3 id="registerWorker"><a href="#registerWorker" class="headerlink" title="registerWorker()"></a>registerWorker()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    wt.setDaemon(<span class="keyword">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="keyword">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);<span class="comment">//构造新的WorkQueue</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">    <span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line">    <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws;</span><br><span class="line">        <span class="keyword">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//生成新建WorkQueue的索引</span></span><br><span class="line">            <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">            <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// Worker任务放在奇数索引位 odd-numbered indices</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// collision 已存在，重新计算索引位</span></span><br><span class="line">                <span class="keyword">int</span> probes = <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//查找可用的索引位</span></span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;<span class="comment">//所有索引位都被占用，对workQueues进行扩容</span></span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);<span class="comment">//workQueues 扩容</span></span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: registerWorker是 ForkJoinWorkerThread 构造器的回调函数，用于创建和记录工作线程的 WorkQueue。比较简单，就不多赘述了。注意在此为工作线程创建的 WorkQueue 是放在奇数索引的(代码行: i = ((s &lt;&lt; 1) | 1) &amp; m;)</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>OK，外部任务的提交流程就先讲到这里。在createWorker()中启动工作线程后(wt.start())，当为线程分配到CPU执行时间片之后会运行 ForkJoinWorkerThread 的run方法开启线程来执行任务。工作线程执行任务的流程我们在讲完内部任务提交之后会统一讲解。</p>
<h2 id="执行流程-子任务-Worker-task-提交"><a href="#执行流程-子任务-Worker-task-提交" class="headerlink" title="执行流程: 子任务(Worker task)提交"></a>执行流程: 子任务(Worker task)提交</h2><p>子任务的提交相对比较简单，由任务的fork()方法完成。通过上面的流程图可以看到任务被分割(fork)之后调用了ForkJoinPool.WorkQueue.push()方法直接把任务放到队列中等待被执行。</p>
<h3 id="ForkJoinTask-fork"><a href="#ForkJoinTask-fork" class="headerlink" title="ForkJoinTask.fork()"></a>ForkJoinTask.fork()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 如果当前线程是 Worker 线程，说明当前任务是fork分割的子任务，通过ForkJoinPool.workQueue.push()方法直接把任务放到自己的等待队列中；否则调用ForkJoinPool.externalPush()提交到一个随机的等待队列中(外部任务)。</p>
<h3 id="ForkJoinPool-WorkQueue-push"><a href="#ForkJoinPool-WorkQueue-push" class="headerlink" title="ForkJoinPool.WorkQueue.push()"></a>ForkJoinPool.WorkQueue.push()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    ForkJoinPool p;</span><br><span class="line">    <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="keyword">int</span> m = a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;<span class="comment">//首次提交，创建或唤醒一个工作线程</span></span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 首先把任务放入等待队列并更新top位；如果当前 WorkQueue 为新建的等待队列(top-base&lt;=1)，则调用signalWork方法为当前 WorkQueue 新建或唤醒一个工作线程；如果 WorkQueue 中的任务数组容量过小，则调用growArray()方法对其进行两倍扩容，growArray()方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt;[] growArray() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] oldA = array;<span class="comment">//获取内部任务列表</span></span><br><span class="line">    <span class="keyword">int</span> size = oldA != <span class="keyword">null</span> ? oldA.length &lt;&lt; <span class="number">1</span> : INITIAL_QUEUE_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAXIMUM_QUEUE_CAPACITY)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Queue capacity exceeded&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> oldMask, t, b;</span><br><span class="line">    <span class="comment">//新建一个两倍容量的任务数组</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array = <span class="keyword">new</span> ForkJoinTask&lt;?&gt;[size];</span><br><span class="line">    <span class="keyword">if</span> (oldA != <span class="keyword">null</span> &amp;&amp; (oldMask = oldA.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (t = top) - (b = base) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mask = size - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从老数组中拿出数据，放到新的数组中</span></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// emulate poll from old array, push to new array</span></span><br><span class="line">            ForkJoinTask&lt;?&gt; x;</span><br><span class="line">            <span class="keyword">int</span> oldj = ((b &amp; oldMask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="keyword">int</span> j = ((b &amp; mask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            x = (ForkJoinTask&lt;?&gt;) U.getObjectVolatile(oldA, oldj);</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(oldA, oldj, x, <span class="keyword">null</span>))</span><br><span class="line">                U.putObjectVolatile(a, j, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (++b != t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>到此，两种任务的提交流程都已经解析完毕，下一节我们来一起看看任务提交之后是如何被运行的。</p>
<h2 id="执行流程-任务执行"><a href="#执行流程-任务执行" class="headerlink" title="执行流程: 任务执行"></a>执行流程: 任务执行</h2><p>回到我们开始时的流程图，在ForkJoinPool .createWorker()方法中创建工作线程后，会启动工作线程，系统为工作线程分配到CPU执行时间片之后会执行 ForkJoinWorkerThread 的run()方法正式开始执行任务。</p>
<h4 id="ForkJoinWorkerThread-run"><a href="#ForkJoinWorkerThread-run" class="headerlink" title="ForkJoinWorkerThread.run()"></a>ForkJoinWorkerThread.run()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="keyword">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onStart();<span class="comment">//钩子方法，可自定义扩展</span></span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onTermination(exception);<span class="comment">//钩子方法，可自定义扩展</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                pool.deregisterWorker(<span class="keyword">this</span>, exception);<span class="comment">//处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 方法很简单，在工作线程运行前后会调用自定义钩子函数(onStart和onTermination)，任务的运行则是调用了ForkJoinPool.runWorker()。如果全部任务执行完毕或者期间遭遇异常，则通过ForkJoinPool.deregisterWorker关闭工作线程并处理异常信息(deregisterWorker方法我们后面会详细讲解)。</p>
<h4 id="ForkJoinPool-runWorker-WorkQueue-w"><a href="#ForkJoinPool-runWorker-WorkQueue-w" class="headerlink" title="ForkJoinPool.runWorker(WorkQueue w)"></a>ForkJoinPool.runWorker(WorkQueue w)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="keyword">int</span> seed = w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="keyword">int</span> r = (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="keyword">null</span>)<span class="comment">//扫描任务执行</span></span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        r ^= r &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: runWorker是 ForkJoinWorkerThread 的主运行方法，用来依次执行当前工作线程中的任务。函数流程很简单: 调用scan方法依次获取任务，然后调用WorkQueue .runTask运行任务；如果未扫描到任务，则调用awaitWork等待，直到工作线程/线程池终止或等待超时。</p>
<h4 id="ForkJoinPool-scan-WorkQueue-w-int-r"><a href="#ForkJoinPool-scan-WorkQueue-w-int-r" class="headerlink" title="ForkJoinPool.scan(WorkQueue w, int r)"></a>ForkJoinPool.scan(WorkQueue w, int r)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ss = w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">        <span class="comment">//初始扫描起点，自旋扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>; ; ) &#123;</span><br><span class="line">            WorkQueue q;</span><br><span class="line">            ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">            ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="keyword">int</span> b, n;</span><br><span class="line">            <span class="keyword">long</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;<span class="comment">//获取workQueue</span></span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (a = q.array) != <span class="keyword">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                    <span class="comment">//计算偏移量</span></span><br><span class="line">                    <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                            U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp; <span class="comment">//取base位置任务</span></span><br><span class="line">                            q.base == b) &#123;<span class="comment">//stable</span></span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;  <span class="comment">//scanning</span></span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;<span class="comment">//</span></span><br><span class="line">                                q.base = b + <span class="number">1</span>;<span class="comment">//更新base位</span></span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                    signalWork(ws, q);<span class="comment">//创建或唤醒工作线程来运行任务</span></span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate 尝试激活工作线程</span></span><br><span class="line">                                w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>) c], AC_UNIT);<span class="comment">//唤醒栈顶工作线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//base位置任务为空或base位置偏移，随机移位重新扫描</span></span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    r ^= r &gt;&gt;&gt; <span class="number">3</span>;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;<span class="comment">//队列任务为空，记录base位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新索引k 继续向后查找</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                <span class="comment">//运行到这里说明已经扫描了全部的 workQueues，但并未扫描到任务</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                        oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">// 已经被灭活或终止,跳出循环</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对当前WorkQueue进行灭活操作</span></span><br><span class="line">                    <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                            (UC_MASK &amp; ((c = ctl) - AC_UNIT)));<span class="comment">//计算ctl为INACTIVE状态并减少活跃线程数</span></span><br><span class="line">                    w.stackPred = (<span class="keyword">int</span>) c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);<span class="comment">//修改scanState为inactive状态</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))<span class="comment">//更新scanState为灭活状态</span></span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;<span class="comment">//重置checkSum，继续循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 扫描并尝试偷取一个任务。使用w.hint进行随机索引 WorkQueue，也就是说并不一定会执行当前 WorkQueue 中的任务，而是偷取别的Worker的任务来执行。</p>
<p>函数的大概执行流程如下:</p>
<ul>
<li><p>取随机位置的一个 WorkQueue；</p>
</li>
<li><p>获取base位的 ForkJoinTask，成功取到后更新base位并返回任务；如果取到的 WorkQueue 中任务数大于1，则调用signalWork创建或唤醒其他工作线程；</p>
</li>
<li><p>如果当前工作线程处于不活跃状态(INACTIVE)，则调用tryRelease尝试唤醒栈顶工作线程来执行。</p>
<p>  tryRelease源码如下:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">long</span> c, WorkQueue v, <span class="keyword">long</span> inc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sp = (<span class="keyword">int</span>) c, vs = (sp + SS_SEQ) &amp; ~INACTIVE;</span><br><span class="line">    Thread p;</span><br><span class="line">    <span class="comment">//ctl低32位等于scanState，说明可以唤醒parker线程</span></span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v.scanState == sp) &#123;          <span class="comment">// v is at top of stack</span></span><br><span class="line">        <span class="comment">//计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + inc)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;</span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(p);<span class="comment">//唤醒线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>如果base位任务为空或发生偏移，则对索引位进行随机移位，然后重新扫描；</p>
</li>
<li><p>如果扫描整个workQueues之后没有获取到任务，则设置当前工作线程为INACTIVE状态；然后重置checkSum，再次扫描一圈之后如果还没有任务则跳出循环返回null。</p>
</li>
</ul>
<h4 id="ForkJoinPool-awaitWork-WorkQueue-w-int-r"><a href="#ForkJoinPool-awaitWork-WorkQueue-w-int-r" class="headerlink" title="ForkJoinPool.awaitWork(WorkQueue w, int r)"></a>ForkJoinPool.awaitWork(WorkQueue w, int r)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">awaitWork</span><span class="params">(WorkQueue w, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pred = w.stackPred, spins = SPINS, ss; ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)<span class="comment">//正在扫描，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>;</span><br><span class="line">            r ^= r &gt;&gt;&gt; <span class="number">21</span>;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                WorkQueue v;</span><br><span class="line">                WorkQueue[] ws;</span><br><span class="line">                <span class="keyword">int</span> s, j;</span><br><span class="line">                AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                        (v = ws[j]) != <span class="keyword">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                        (v.parker == <span class="keyword">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// 当前workQueue已经终止，返回false recheck after spins</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;<span class="comment">//判断线程是否被中断，并清除中断状态</span></span><br><span class="line">            <span class="keyword">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="keyword">int</span> ac = (<span class="keyword">int</span>) ((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);<span class="comment">//活跃线程数</span></span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>)) || <span class="comment">//无active线程，尝试终止</span></span><br><span class="line">                    (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="keyword">int</span>) c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                <span class="comment">//计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="keyword">int</span> t = (<span class="keyword">short</span>) (c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))<span class="comment">//总线程过量</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                <span class="comment">//计算空闲超时时间</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            Thread wt = Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            w.parker = wt;<span class="comment">//设置parker，准备阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, parkTime);<span class="comment">//阻塞指定的时间</span></span><br><span class="line"></span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="keyword">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)<span class="comment">//正在扫描，说明等到任务，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                    deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))<span class="comment">//未等到任务，更新ctl，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 回到runWorker方法，如果scan方法未扫描到任务，会调用awaitWork等待获取任务。函数的具体执行流程大家看源码，这里简单说一下:</p>
<ul>
<li>在等待获取任务期间，如果工作线程或线程池已经终止则直接返回false。如果当前无 active 线程，尝试终止线程池并返回false，如果终止失败并且当前是最后一个等待的 Worker，就阻塞指定的时间(IDLE_TIMEOUT)；等到届期或被唤醒后如果发现自己是scanning(scanState &gt;= 0)状态，说明已经等到任务，跳出等待返回true继续 scan，否则的更新ctl并返回false。</li>
</ul>
<h3 id="WorkQueue-runTask"><a href="#WorkQueue-runTask" class="headerlink" title="WorkQueue.runTask()"></a>WorkQueue.runTask()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">        (currentSteal = task).doExec();<span class="comment">//更新currentSteal并执行任务</span></span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="keyword">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">        execLocalTasks();<span class="comment">//依次执行本地任务</span></span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            transferStealCount(pool);<span class="comment">//增加偷取任务数</span></span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();<span class="comment">//执行钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>说明: 在scan方法扫描到任务之后，调用WorkQueue.runTask()来执行获取到的任务，大概流程如下:</p>
<ul>
<li><p>标记scanState为正在执行状态；</p>
</li>
<li><p>更新currentSteal为当前获取到的任务并执行它，任务的执行调用了ForkJoinTask.doExec()方法，源码如下:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ForkJoinTask.doExec()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();<span class="comment">//执行我们定义的任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用execLocalTasks依次执行当前WorkerQueue中的任务，源码如下:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行并移除所有本地任务</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execLocalTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = base, m, s;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array;</span><br><span class="line">    <span class="keyword">if</span> (b - (s = top - <span class="number">1</span>) &lt;= <span class="number">0</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((config &amp; FIFO_QUEUE) == <span class="number">0</span>) &#123;<span class="comment">//FIFO模式</span></span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;) U.getAndSetObject</span><br><span class="line">                        (a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, <span class="keyword">null</span>)) == <span class="keyword">null</span>)<span class="comment">//FIFO执行，取top任务</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                t.doExec();<span class="comment">//执行</span></span><br><span class="line">                <span class="keyword">if</span> (base - (s = top - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            pollAndExecAll();<span class="comment">//LIFO模式执行，取base任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>更新偷取任务数；</p>
</li>
<li><p>还原scanState并执行钩子函数。</p>
</li>
</ul>
<h3 id="ForkJoinPool-deregisterWorker-ForkJoinWorkerThread-wt-Throwable-ex"><a href="#ForkJoinPool-deregisterWorker-ForkJoinWorkerThread-wt-Throwable-ex" class="headerlink" title="ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)"></a>ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deregisterWorker</span><span class="params">(ForkJoinWorkerThread wt, Throwable ex)</span> </span>&#123;</span><br><span class="line">    WorkQueue w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//1.移除workQueue</span></span><br><span class="line">    <span class="keyword">if</span> (wt != <span class="keyword">null</span> &amp;&amp; (w = wt.workQueue) != <span class="keyword">null</span>) &#123;<span class="comment">//获取ForkJoinWorkerThread的等待队列</span></span><br><span class="line">        WorkQueue[] ws;                           <span class="comment">// remove index from array</span></span><br><span class="line">        <span class="keyword">int</span> idx = w.config &amp; SMASK;<span class="comment">//计算workQueue索引</span></span><br><span class="line">        <span class="keyword">int</span> rs = lockRunState();<span class="comment">//获取runState锁和当前池运行状态</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w)</span><br><span class="line">            ws[idx] = <span class="keyword">null</span>;<span class="comment">//移除workQueue</span></span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);<span class="comment">//解除runState锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.减少CTL数</span></span><br><span class="line">    <span class="keyword">long</span> c;                                       <span class="comment">// decrement counts</span></span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!U.compareAndSwapLong</span><br><span class="line">                 (<span class="keyword">this</span>, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                                       (TC_MASK &amp; (c - TC_UNIT)) |</span><br><span class="line">                                       (SP_MASK &amp; c))));</span><br><span class="line">    <span class="comment">//3.处理被移除workQueue内部相关参数</span></span><br><span class="line">    <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        w.qlock = -<span class="number">1</span>;                             <span class="comment">// ensure set</span></span><br><span class="line">        w.transferStealCount(<span class="keyword">this</span>);</span><br><span class="line">        w.cancelAll();                            <span class="comment">// cancel remaining tasks</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.如果线程未终止，替换被移除的workQueue并唤醒内部线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                    <span class="comment">// possibly replace</span></span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> m, sp;</span><br><span class="line">        <span class="comment">//尝试终止线程池</span></span><br><span class="line">        <span class="keyword">if</span> (tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>) || w == <span class="keyword">null</span> || w.array == <span class="keyword">null</span> ||</span><br><span class="line">            (runState &amp; STOP) != <span class="number">0</span> || (ws = workQueues) == <span class="keyword">null</span> ||</span><br><span class="line">            (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)              <span class="comment">// already terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//唤醒被替换的线程，依赖于下一步</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>) &#123;         <span class="comment">// wake up replacement</span></span><br><span class="line">            <span class="keyword">if</span> (tryRelease(c, ws[sp &amp; m], AC_UNIT))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建工作线程替换</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ex != <span class="keyword">null</span> &amp;&amp; (c &amp; ADD_WORKER) != <span class="number">0L</span>) &#123;</span><br><span class="line">            tryAddWorker(c);                      <span class="comment">// create replacement</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                      <span class="comment">// don&#x27;t need replacement</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="keyword">null</span>)                               <span class="comment">// help clean on way out</span></span><br><span class="line">        ForkJoinTask.helpExpungeStaleExceptions();</span><br><span class="line">    <span class="keyword">else</span>                                          <span class="comment">// rethrow</span></span><br><span class="line">        ForkJoinTask.rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: deregisterWorker方法用于工作线程运行完毕之后终止线程或处理工作线程异常，主要就是清除已关闭的工作线程或回滚创建线程之前的操作，并把传入的异常抛给 ForkJoinTask 来处理。具体步骤见源码注释。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>本节我们对任务的执行流程进行了说明，后面我们将继续介绍任务的结果获取(join/invoke)。</p>
<h2 id="获取任务结果-ForkJoinTask-join-ForkJoinTask-invoke"><a href="#获取任务结果-ForkJoinTask-join-ForkJoinTask-invoke" class="headerlink" title="获取任务结果 - ForkJoinTask.join() / ForkJoinTask.invoke()"></a>获取任务结果 - ForkJoinTask.join() / ForkJoinTask.invoke()</h2><p><strong>join() :</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并任务结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//join, get, quietlyJoin的主实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>invoke() :</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行任务，并等待任务完成并返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//invoke, quietlyInvoke的主实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">    <span class="keyword">return</span> (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (wt = (ForkJoinWorkerThread)t).pool.</span><br><span class="line">        awaitJoin(wt.workQueue, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: join()方法一把是在任务fork()之后调用，用来获取(或者叫“合并”)任务的执行结果。</p>
<p>ForkJoinTask的join()和invoke()方法都可以用来获取任务的执行结果(另外还有get方法也是调用了doJoin来获取任务结果，但是会响应运行时异常)，它们对外部提交任务的执行方式一致，都是通过externalAwaitDone方法等待执行结果。不同的是invoke()方法会直接执行当前任务；而join()方法则是在当前任务在队列 top 位时(通过tryUnpush方法判断)才能执行，如果当前任务不在 top 位或者任务执行失败调用ForkJoinPool.awaitJoin方法帮助执行或阻塞当前 join 任务。(所以在官方文档中建议了我们对ForkJoinTask任务的调用顺序，一对 fork-join操作一般按照如下顺序调用: a.fork(); b.fork(); b.join(); a.join();。因为任务 b 是后面进入队列，也就是说它是在栈顶的(top 位)，在它fork()之后直接调用join()就可以直接执行而不会调用ForkJoinPool.awaitJoin方法去等待。)</p>
<p>在这些方法中，join()相对比较全面，所以之后的讲解我们将从join()开始逐步向下分析，首先看一下join()的执行流程:</p>
<p><img src="https://www.pdai.tech/_images/thread/java-thread-x-forkjoin-6.png" alt="img"></p>
<p>后面的源码分析中，我们首先讲解比较简单的外部 join 任务(externalAwaitDone)，然后再讲解内部 join 任务(从ForkJoinPool.awaitJoin()开始)。</p>
<h3 id="ForkJoinTask-externalAwaitDone"><a href="#ForkJoinTask-externalAwaitDone" class="headerlink" title="ForkJoinTask.externalAwaitDone()"></a>ForkJoinTask.externalAwaitDone()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">externalAwaitDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">int</span> s = ((<span class="keyword">this</span> <span class="keyword">instanceof</span> CountedCompleter) ? <span class="comment">// try helping</span></span><br><span class="line">             ForkJoinPool.common.externalHelpComplete(  <span class="comment">// CountedCompleter任务</span></span><br><span class="line">                 (CountedCompleter&lt;?&gt;)<span class="keyword">this</span>, <span class="number">0</span>) :</span><br><span class="line">             ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>) ? doExec() : <span class="number">0</span>);  <span class="comment">// ForkJoinTask任务</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; (s = status) &gt;= <span class="number">0</span>) &#123;<span class="comment">//执行失败，进入等待</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;  <span class="comment">//更新state</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;<span class="comment">//SIGNAL 等待信号</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(<span class="number">0L</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                            interrupted = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 如果当前join为外部调用，则调用此方法执行任务，如果任务执行失败就进入等待。方法本身是很简单的，需要注意的是对不同的任务类型分两种情况:</p>
<ul>
<li><p>如果我们的任务为 CountedCompleter 类型的任务，则调用externalHelpComplete方法来执行任务。</p>
</li>
<li><p>其他类型的 ForkJoinTask 任务调用tryExternalUnpush来执行，源码如下:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为外部提交者提供 tryUnpush 功能(给定任务在top位时弹出任务)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryExternalUnpush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    WorkQueue w;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    <span class="keyword">int</span> m, s;</span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (w = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (a = w.array) != <span class="keyword">null</span> &amp;&amp; (s = w.top) != w.base) &#123;</span><br><span class="line">        <span class="keyword">long</span> j = (((a.length - <span class="number">1</span>) &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;  <span class="comment">//取top位任务</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(w, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;  <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">if</span> (w.top == s &amp;&amp; w.array == a &amp;&amp;</span><br><span class="line">                    U.getObject(a, j) == task &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;  <span class="comment">//符合条件，弹出</span></span><br><span class="line">                U.putOrderedInt(w, QTOP, s - <span class="number">1</span>);  <span class="comment">//更新top</span></span><br><span class="line">                U.putOrderedInt(w, QLOCK, <span class="number">0</span>); <span class="comment">//解锁，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            U.compareAndSwapInt(w, QLOCK, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//当前任务不在top位，解锁返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>  tryExternalUnpush的作用就是判断当前任务是否在top位，如果是则弹出任务，然后在externalAwaitDone中调用doExec()执行任务。</p>
</li>
</ul>
<h3 id="ForkJoinPool-awaitJoin"><a href="#ForkJoinPool-awaitJoin" class="headerlink" title="ForkJoinPool.awaitJoin()"></a>ForkJoinPool.awaitJoin()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">awaitJoin</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;  <span class="comment">//获取给定Worker的join任务</span></span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);  <span class="comment">//把currentJoin替换为给定任务</span></span><br><span class="line">        <span class="comment">//判断是否为CountedCompleter类型的任务</span></span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task <span class="keyword">instanceof</span> CountedCompleter) ?</span><br><span class="line">                (CountedCompleter&lt;?&gt;) task : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)  <span class="comment">//已经完成|取消|异常 跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cc != <span class="keyword">null</span>)<span class="comment">//CountedCompleter任务由helpComplete来完成join</span></span><br><span class="line">                helpComplete(w, cc, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w.base == w.top || w.tryRemoveAndExec(task))  <span class="comment">//尝试执行</span></span><br><span class="line">                helpStealer(w, task);  <span class="comment">//队列为空或执行失败，任务可能被偷，帮助偷取者执行该任务</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>) <span class="comment">//已经完成|取消|异常，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//计算任务等待时间</span></span><br><span class="line">            <span class="keyword">long</span> ms, ns;</span><br><span class="line">            <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ns = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tryCompensate(w)) &#123;<span class="comment">//执行补偿操作</span></span><br><span class="line">                task.internalWait(ms);<span class="comment">//补偿执行成功，任务等待指定时间</span></span><br><span class="line">                U.getAndAddLong(<span class="keyword">this</span>, CTL, AC_UNIT);<span class="comment">//更新活跃线程数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);<span class="comment">//循环结束，替换为原来的join任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 如果当前 join 任务不在Worker等待队列的top位，或者任务执行失败，调用此方法来帮助执行或阻塞当前 join 的任务。函数执行流程如下:</p>
<ul>
<li><p>由于每次调用awaitJoin都会优先执行当前join的任务，所以首先会更新currentJoin为当前join任务；</p>
</li>
<li><p>进入自旋:</p>
<ul>
<li><p>首先检查任务是否已经完成(通过task.status &lt; 0判断)，如果给定任务执行完毕|取消|异常 则跳出循环返回执行状态s；</p>
</li>
<li><p>如果是 CountedCompleter 任务类型，调用helpComplete方法来完成join操作(后面笔者会开新篇来专门讲解CountedCompleter，本篇暂时不做详细解析)；</p>
</li>
<li><p>非 CountedCompleter 任务类型调用WorkQueue.tryRemoveAndExec尝试执行任务；</p>
</li>
<li><p>如果给定 WorkQueue 的等待队列为空或任务执行失败，说明任务可能被偷，调用helpStealer帮助偷取者执行任务(也就是说，偷取者帮我执行任务，我去帮偷取者执行它的任务)；</p>
</li>
<li><p>再次判断任务是否执行完毕(task.status &lt; 0)，如果任务执行失败，计算一个等待时间准备进行补偿操作；</p>
</li>
<li><p>调用tryCompensate方法为给定 WorkQueue 尝试执行补偿操作。在执行补偿期间，如果发现 资源争用|池处于unstable状态|当前Worker已终止，则调用ForkJoinTask.internalWait()方法等待指定的时间，任务唤醒之后继续自旋，ForkJoinTask.internalWait()源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">internalWait</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// force completer to issue notify</span></span><br><span class="line">        U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;<span class="comment">//更新任务状态为SIGNAL(等待唤醒)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123; wait(timeout); &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在awaitJoin中，我们总共调用了三个比较复杂的方法: tryRemoveAndExec、helpStealer和tryCompensate，下面我们依次讲解。</p>
</li>
</ul>
</li>
</ul>
<h3 id="WorkQueue-tryRemoveAndExec-ForkJoinTask-lt-gt-task"><a href="#WorkQueue-tryRemoveAndExec-ForkJoinTask-lt-gt-task" class="headerlink" title="WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)"></a>WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRemoveAndExec</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    <span class="keyword">int</span> m, s, b, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((n = (s = top) - (b = base)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//从top往下自旋查找</span></span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; ; ) &#123;      <span class="comment">// traverse from s to b</span></span><br><span class="line">                <span class="keyword">long</span> j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;<span class="comment">//计算任务索引</span></span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;) U.getObject(a, j)) == <span class="keyword">null</span>) <span class="comment">//获取索引到的任务</span></span><br><span class="line">                    <span class="keyword">return</span> s + <span class="number">1</span> == top;     <span class="comment">// shorter than expected</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == task) &#123; <span class="comment">//给定任务为索引任务</span></span><br><span class="line">                    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s + <span class="number">1</span> == top) &#123;      <span class="comment">// pop</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123; <span class="comment">//弹出任务</span></span><br><span class="line">                            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s); <span class="comment">//更新top</span></span><br><span class="line">                            removed = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base == b)      <span class="comment">// replace with proxy</span></span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                                a, j, task, <span class="keyword">new</span> EmptyTask()); <span class="comment">//join任务已经被移除，替换为一个占位任务</span></span><br><span class="line">                    <span class="keyword">if</span> (removed)</span><br><span class="line">                        task.doExec(); <span class="comment">//执行</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.status &lt; <span class="number">0</span> &amp;&amp; s + <span class="number">1</span> == top) &#123; <span class="comment">//给定任务不是top任务</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) <span class="comment">//弹出任务</span></span><br><span class="line">                        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);<span class="comment">//更新top</span></span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// was cancelled</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>) <span class="comment">//遍历结束</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>) <span class="comment">//任务执行完毕</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 从top位开始自旋向下找到给定任务，如果找到把它从当前 Worker 的任务队列中移除并执行它。注意返回的参数: 如果任务队列为空或者任务未执行完毕返回true；任务执行完毕返回false。</p>
<h3 id="ForkJoinPool-helpStealer-WorkQueue-w-ForkJoinTask-lt-gt-task"><a href="#ForkJoinPool-helpStealer-WorkQueue-w-ForkJoinTask-lt-gt-task" class="headerlink" title="ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)"></a>ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helpStealer</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws = workQueues;</span><br><span class="line">    <span class="keyword">int</span> oldSum = <span class="number">0</span>, checkSum, m;</span><br><span class="line">    <span class="keyword">if</span> (ws != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;                                       <span class="comment">// restart point</span></span><br><span class="line">            checkSum = <span class="number">0</span>;                          <span class="comment">// for stability check</span></span><br><span class="line">            ForkJoinTask&lt;?&gt; subtask;</span><br><span class="line">            WorkQueue j = w, v;                    <span class="comment">// v is subtask stealer</span></span><br><span class="line">            descent:</span><br><span class="line">            <span class="keyword">for</span> (subtask = task; subtask.status &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">                <span class="comment">//1. 找到给定WorkQueue的偷取者v</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = j.hint | <span class="number">1</span>, k = <span class="number">0</span>, i; ; k += <span class="number">2</span>) &#123;<span class="comment">//跳两个索引，因为Worker在奇数索引位</span></span><br><span class="line">                    <span class="keyword">if</span> (k &gt; m)                     <span class="comment">// can&#x27;t find stealer</span></span><br><span class="line">                        <span class="keyword">break</span> descent;</span><br><span class="line">                    <span class="keyword">if</span> ((v = ws[i = (h + k) &amp; m]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v.currentSteal == subtask) &#123;<span class="comment">//定位到偷取者</span></span><br><span class="line">                            j.hint = i;<span class="comment">//更新stealer索引</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        checkSum += v.base;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2. 帮助偷取者v执行任务</span></span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;                         <span class="comment">// help v or descend</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt;[] a;            <span class="comment">//偷取者内部的任务</span></span><br><span class="line">                    <span class="keyword">int</span> b;</span><br><span class="line">                    checkSum += (b = v.base);</span><br><span class="line">                    ForkJoinTask&lt;?&gt; next = v.currentJoin;<span class="comment">//获取偷取者的join任务</span></span><br><span class="line">                    <span class="keyword">if</span> (subtask.status &lt; <span class="number">0</span> || j.currentJoin != subtask ||</span><br><span class="line">                            v.currentSteal != subtask) <span class="comment">// stale</span></span><br><span class="line">                        <span class="keyword">break</span> descent; <span class="comment">// stale，跳出descent循环重来</span></span><br><span class="line">                    <span class="keyword">if</span> (b - v.top &gt;= <span class="number">0</span> || (a = v.array) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((subtask = next) == <span class="keyword">null</span>)   <span class="comment">//偷取者的join任务为null，跳出descent循环</span></span><br><span class="line">                            <span class="keyword">break</span> descent;</span><br><span class="line">                        j = v;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//偷取者内部任务为空，可能任务也被偷走了；跳出本次循环，查找偷取者的偷取者</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;<span class="comment">//获取base偏移地址</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt; t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                            U.getObjectVolatile(a, i));<span class="comment">//获取偷取者的base任务</span></span><br><span class="line">                    <span class="keyword">if</span> (v.base == b) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="keyword">null</span>)             <span class="comment">// stale</span></span><br><span class="line">                            <span class="keyword">break</span> descent; <span class="comment">// stale，跳出descent循环重来</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;<span class="comment">//弹出任务</span></span><br><span class="line">                            v.base = b + <span class="number">1</span>;         <span class="comment">//更新偷取者的base位</span></span><br><span class="line">                            ForkJoinTask&lt;?&gt; ps = w.currentSteal;<span class="comment">//获取调用者偷来的任务</span></span><br><span class="line">                            <span class="keyword">int</span> top = w.top;</span><br><span class="line">                            <span class="comment">//首先更新给定workQueue的currentSteal为偷取者的base任务，然后执行该任务</span></span><br><span class="line">                            <span class="comment">//然后通过检查top来判断给定workQueue是否有自己的任务，如果有，</span></span><br><span class="line">                            <span class="comment">// 则依次弹出任务(LIFO)-&gt;更新currentSteal-&gt;执行该任务(注意这里是自己偷自己的任务执行)</span></span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">                                t.doExec();        <span class="comment">// clear local tasks too</span></span><br><span class="line">                            &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    w.top != top &amp;&amp; <span class="comment">//内部有自己的任务，依次弹出执行</span></span><br><span class="line">                                    (t = w.pop()) != <span class="keyword">null</span>);</span><br><span class="line">                            U.putOrderedObject(w, QCURRENTSTEAL, ps);<span class="comment">//还原给定workQueue的currentSteal</span></span><br><span class="line">                            <span class="keyword">if</span> (w.base != w.top)<span class="comment">//给定workQueue有自己的任务了，帮助结束，返回</span></span><br><span class="line">                                <span class="keyword">return</span>;            <span class="comment">// can&#x27;t further help</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp; oldSum != (oldSum = checkSum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 如果队列为空或任务执行失败，说明任务可能被偷，调用此方法来帮助偷取者执行任务。基本思想是: 偷取者帮助我执行任务，我去帮助偷取者执行它的任务。 函数执行流程如下:</p>
<p>循环定位偷取者，由于Worker是在奇数索引位，所以每次会跳两个索引位。定位到偷取者之后，更新调用者 WorkQueue 的hint为偷取者的索引，方便下次定位； 定位到偷取者后，开始帮助偷取者执行任务。从偷取者的base索引开始，每次偷取一个任务执行。在帮助偷取者执行任务后，如果调用者发现本身已经有任务(w.top != top)，则依次弹出自己的任务(LIFO顺序)并执行(也就是说自己偷自己的任务执行)。</p>
<h3 id="ForkJoinPool-tryCompensate-WorkQueue-w"><a href="#ForkJoinPool-tryCompensate-WorkQueue-w" class="headerlink" title="ForkJoinPool.tryCompensate(WorkQueue w)"></a>ForkJoinPool.tryCompensate(WorkQueue w)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行补偿操作: 尝试缩减活动线程量，可能释放或创建一个补偿线程来准备阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCompensate</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> canBlock;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">int</span> m, pc, sp;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span> ||           <span class="comment">// caller terminating</span></span><br><span class="line">            (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span> ||</span><br><span class="line">            (pc = config &amp; SMASK) == <span class="number">0</span>)           <span class="comment">// parallelism disabled</span></span><br><span class="line">        canBlock = <span class="keyword">false</span>; <span class="comment">//调用者已终止</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>) (c = ctl)) != <span class="number">0</span>)      <span class="comment">// release idle worker</span></span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], <span class="number">0L</span>);<span class="comment">//唤醒等待的工作线程</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//没有空闲线程</span></span><br><span class="line">        <span class="keyword">int</span> ac = (<span class="keyword">int</span>) (c &gt;&gt; AC_SHIFT) + pc; <span class="comment">//活跃线程数</span></span><br><span class="line">        <span class="keyword">int</span> tc = (<span class="keyword">short</span>) (c &gt;&gt; TC_SHIFT) + pc;<span class="comment">//总线程数</span></span><br><span class="line">        <span class="keyword">int</span> nbusy = <span class="number">0</span>;                        <span class="comment">// validate saturation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;        <span class="comment">// two passes of odd indices</span></span><br><span class="line">            WorkQueue v;</span><br><span class="line">            <span class="keyword">if</span> ((v = ws[((i &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m]) != <span class="keyword">null</span>) &#123;<span class="comment">//取奇数索引位</span></span><br><span class="line">                <span class="keyword">if</span> ((v.scanState &amp; SCANNING) != <span class="number">0</span>)<span class="comment">//没有正在运行任务，跳出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++nbusy;<span class="comment">//正在运行任务，添加标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nbusy != (tc &lt;&lt; <span class="number">1</span>) || ctl != c)</span><br><span class="line">            canBlock = <span class="keyword">false</span>;                 <span class="comment">// unstable or stale</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= pc &amp;&amp; ac &gt; <span class="number">1</span> &amp;&amp; w.isEmpty()) &#123;<span class="comment">//总线程数大于并行度 &amp;&amp; 活动线程数大于1 &amp;&amp; 调用者任务队列为空，不需要补偿</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                    (~AC_MASK &amp; c));       <span class="comment">// uncompensated</span></span><br><span class="line">            canBlock = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);<span class="comment">//更新活跃线程数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= MAX_CAP ||</span><br><span class="line">                (<span class="keyword">this</span> == common &amp;&amp; tc &gt;= pc + commonMaxSpares))<span class="comment">//超出最大线程数</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(</span><br><span class="line">                    <span class="string">&quot;Thread limit exceeded replacing blocked worker&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;                                <span class="comment">// similar to tryAddWorker</span></span><br><span class="line">            <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> rs;      <span class="comment">// CAS within lock</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; c) |</span><br><span class="line">                    (TC_MASK &amp; (c + TC_UNIT)));<span class="comment">//计算总线程数</span></span><br><span class="line">            <span class="keyword">if</span> (((rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);<span class="comment">//更新总线程数</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="comment">//运行到这里说明活跃工作线程数不足，需要创建一个新的工作线程来补偿</span></span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); <span class="comment">// throws on exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 具体的执行看源码及注释，这里我们简单总结一下需要和不需要补偿的几种情况:</p>
<p><strong>需要补偿</strong> :</p>
<ul>
<li>调用者队列不为空，并且有空闲工作线程，这种情况会唤醒空闲线程(调用tryRelease方法)</li>
<li>池尚未停止，活跃线程数不足，这时会新建一个工作线程(调用createWorker方法)</li>
</ul>
<p><strong>不需要补偿</strong> :</p>
<ul>
<li>调用者已终止或池处于不稳定状态</li>
<li>总线程数大于并行度 &amp;&amp; 活动线程数大于1 &amp;&amp; 调用者任务队列为空</li>
</ul>
<h1 id="Fork-Join的陷阱与注意事项"><a href="#Fork-Join的陷阱与注意事项" class="headerlink" title="Fork/Join的陷阱与注意事项"></a>Fork/Join的陷阱与注意事项</h1><p>使用Fork/Join框架时，需要注意一些陷阱, 在下面 <code>斐波那契数列</code>例子中你将看到示例:</p>
<h2 id="避免不必要的fork"><a href="#避免不必要的fork" class="headerlink" title="避免不必要的fork()"></a>避免不必要的fork()</h2><p>划分成两个子任务后，不要同时调用两个子任务的fork()方法。</p>
<p>表面上看上去两个子任务都fork()，然后join()两次似乎更自然。但事实证明，直接调用compute()效率更高。因为直接调用子任务的compute()方法实际上就是在当前的工作线程进行了计算(线程重用)，这比“将子任务提交到工作队列，线程又从工作队列中拿任务”快得多。</p>
<blockquote>
<p>当一个大任务被划分成两个以上的子任务时，尽可能使用前面说到的三个衍生的invokeAll方法，因为使用它们能避免不必要的fork()。</p>
</blockquote>
<h2 id="注意fork-、compute-、join-的顺序"><a href="#注意fork-、compute-、join-的顺序" class="headerlink" title="注意fork()、compute()、join()的顺序"></a>注意fork()、compute()、join()的顺序</h2><p>为了两个任务并行，三个方法的调用顺序需要万分注意。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">right.fork(); <span class="comment">// 计算右边的任务</span></span><br><span class="line"><span class="keyword">long</span> leftAns = left.compute(); <span class="comment">// 计算左边的任务(同时右边任务也在计算)</span></span><br><span class="line"><span class="keyword">long</span> rightAns = right.join(); <span class="comment">// 等待右边的结果</span></span><br><span class="line"><span class="keyword">return</span> leftAns + rightAns;</span><br></pre></td></tr></table></figure>
<p>如果我们写成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">left.fork(); <span class="comment">// 计算完左边的任务</span></span><br><span class="line"><span class="keyword">long</span> leftAns = left.join(); <span class="comment">// 等待左边的计算结果</span></span><br><span class="line"><span class="keyword">long</span> rightAns = right.compute(); <span class="comment">// 再计算右边的任务</span></span><br><span class="line"><span class="keyword">return</span> leftAns + rightAns;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> rightAns = right.compute(); <span class="comment">// 计算完右边的任务</span></span><br><span class="line">left.fork(); <span class="comment">// 再计算左边的任务</span></span><br><span class="line"><span class="keyword">long</span> leftAns = left.join(); <span class="comment">// 等待左边的计算结果</span></span><br><span class="line"><span class="keyword">return</span> leftAns + rightAns;</span><br></pre></td></tr></table></figure>
<p>这两种实际上都没有并行。</p>
<h2 id="选择合适的子任务粒度"><a href="#选择合适的子任务粒度" class="headerlink" title="选择合适的子任务粒度"></a>选择合适的子任务粒度</h2><p>选择划分子任务的粒度(顺序执行的阈值)很重要，因为使用Fork/Join框架并不一定比顺序执行任务的效率高: 如果任务太大，则无法提高并行的吞吐量；如果任务太小，子任务的调度开销可能会大于并行计算的性能提升，我们还要考虑创建子任务、fork()子任务、线程调度以及合并子任务处理结果的耗时以及相应的内存消耗。</p>
<p>官方文档给出的粗略经验是: 任务应该执行<code>100~10000</code>个基本的计算步骤。决定子任务的粒度的最好办法是实践，通过实际测试结果来确定这个阈值才是“上上策”。</p>
<blockquote>
<p>和其他Java代码一样，Fork/Join框架测试时需要“预热”或者说执行几遍才会被JIT(Just-in-time)编译器优化，所以测试性能之前跑几遍程序很重要。</p>
</blockquote>
<h2 id="避免重量级任务划分与结果合并"><a href="#避免重量级任务划分与结果合并" class="headerlink" title="避免重量级任务划分与结果合并"></a>避免重量级任务划分与结果合并</h2><p>Fork/Join的很多使用场景都用到数组或者List等数据结构，子任务在某个分区中运行，最典型的例子如并行排序和并行查找。拆分子任务以及合并处理结果的时候，应该尽量避免System.arraycopy这样耗时耗空间的操作，从而最小化任务的处理开销。</p>
<h1 id="再深入理解"><a href="#再深入理解" class="headerlink" title="再深入理解"></a>再深入理解</h1><h2 id="有哪些JDK源码中使用了Fork-Join思想"><a href="#有哪些JDK源码中使用了Fork-Join思想" class="headerlink" title="有哪些JDK源码中使用了Fork/Join思想?"></a>有哪些JDK源码中使用了Fork/Join思想?</h2><p>我们常用的数组工具类 Arrays 在JDK 8之后新增的并行排序方法(parallelSort)就运用了 ForkJoinPool 的特性，还有 ConcurrentHashMap 在JDK 8之后添加的函数式方法(如forEach等)也有运用。</p>
<h2 id="使用Executors工具类创建ForkJoinPool"><a href="#使用Executors工具类创建ForkJoinPool" class="headerlink" title="使用Executors工具类创建ForkJoinPool"></a>使用Executors工具类创建ForkJoinPool</h2><p>Java8在Executors工具类中新增了两个工厂方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parallelism定义并行级别</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span></span>;</span><br><span class="line"><span class="comment">// 默认并行级别为JVM可用的处理器个数</span></span><br><span class="line"><span class="comment">// Runtime.getRuntime().availableProcessors()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="关于Fork-Join异常处理"><a href="#关于Fork-Join异常处理" class="headerlink" title="关于Fork/Join异常处理"></a>关于Fork/Join异常处理</h2><p>Java的受检异常机制一直饱受诟病，所以在ForkJoinTask的invoke()、join()方法及其衍生方法中都没有像get()方法那样抛出个ExecutionException的受检异常。</p>
<p>所以你可以在ForkJoinTask中看到内部把受检异常转换成了运行时异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rethrow</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">        ForkJoinTask.&lt;RuntimeException&gt;uncheckedThrow(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">uncheckedThrow</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T)t; <span class="comment">// rely on vacuous cast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Java你不知道的10件事中已经指出，JVM实际并不关心这个异常是受检异常还是运行时异常，受检异常这东西完全是给Java编译器用的: 用于警告程序员这里有个异常没有处理。</p>
<p>但不可否认的是invoke、join()仍可能会抛出运行时异常，所以ForkJoinTask还提供了两个不提取结果和异常的方法quietlyInvoke()、quietlyJoin()，这两个方法允许你在所有任务完成后对结果和异常进行处理。</p>
<p>使用quitelyInvoke()和quietlyJoin()时可以配合isCompletedAbnormally()和isCompletedNormally()方法使用。</p>
<h1 id="一些Fork-Join例子"><a href="#一些Fork-Join例子" class="headerlink" title="一些Fork/Join例子"></a>一些Fork/Join例子</h1><h2 id="采用Fork-Join来异步计算1-2-3-…-10000的结果"><a href="#采用Fork-Join来异步计算1-2-3-…-10000的结果" class="headerlink" title="采用Fork/Join来异步计算1+2+3+…+10000的结果"></a>采用Fork/Join来异步计算1+2+3+…+10000的结果</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> start; <span class="comment">//开始计算的数</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> end; <span class="comment">//最后计算的数</span></span><br><span class="line">		</span><br><span class="line">		SumTask(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">			<span class="keyword">this</span>.start = start;</span><br><span class="line">			<span class="keyword">this</span>.end = end;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//如果计算量小于1000，那么分配一个线程执行if中的代码块，并返回执行结果</span></span><br><span class="line">			<span class="keyword">if</span>(end - start &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行: &quot;</span> + start + <span class="string">&quot;-&quot;</span> + end);</span><br><span class="line">				<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">					sum += i;</span><br><span class="line">				<span class="keyword">return</span> sum;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果计算量大于1000，那么拆分为两个任务</span></span><br><span class="line">			SumTask task1 = <span class="keyword">new</span> SumTask(start, (start + end) / <span class="number">2</span>);</span><br><span class="line">			SumTask task2 = <span class="keyword">new</span> SumTask((start + end) / <span class="number">2</span> + <span class="number">1</span>, end);</span><br><span class="line">			<span class="comment">//执行任务</span></span><br><span class="line">			task1.fork();</span><br><span class="line">			task2.fork();</span><br><span class="line">			<span class="comment">//获取任务执行的结果</span></span><br><span class="line">			<span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">		ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">		ForkJoinTask&lt;Integer&gt; task = <span class="keyword">new</span> SumTask(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">		pool.submit(task);</span><br><span class="line">		System.out.println(task.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> 开始执行: <span class="number">1</span>-<span class="number">625</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">7</span> 开始执行: <span class="number">6251</span>-<span class="number">6875</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">6</span> 开始执行: <span class="number">5626</span>-<span class="number">6250</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">10</span> 开始执行: <span class="number">3751</span>-<span class="number">4375</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">13</span> 开始执行: <span class="number">2501</span>-<span class="number">3125</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">8</span> 开始执行: <span class="number">626</span>-<span class="number">1250</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">11</span> 开始执行: <span class="number">5001</span>-<span class="number">5625</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span> 开始执行: <span class="number">7501</span>-<span class="number">8125</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">14</span> 开始执行: <span class="number">1251</span>-<span class="number">1875</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">4</span> 开始执行: <span class="number">9376</span>-<span class="number">10000</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">8</span> 开始执行: <span class="number">8126</span>-<span class="number">8750</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span> 开始执行: <span class="number">1876</span>-<span class="number">2500</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">12</span> 开始执行: <span class="number">4376</span>-<span class="number">5000</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">5</span> 开始执行: <span class="number">8751</span>-<span class="number">9375</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">7</span> 开始执行: <span class="number">6876</span>-<span class="number">7500</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> 开始执行: <span class="number">3126</span>-<span class="number">3750</span></span><br><span class="line"><span class="number">50005000</span></span><br></pre></td></tr></table></figure>
<h2 id="实现斐波那契数列"><a href="#实现斐波那契数列" class="headerlink" title="实现斐波那契数列"></a>实现斐波那契数列</h2><blockquote>
<p>斐波那契数列: 1、1、2、3、5、8、13、21、34、…… 公式 : F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)(n&gt;=3，n∈N*)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>); <span class="comment">// 最大并发数4</span></span><br><span class="line">    Fibonacci fibonacci = <span class="keyword">new</span> Fibonacci(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    Integer result = forkJoinPool.invoke(fibonacci);</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下为官方API文档示例</span></span><br><span class="line"><span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line">    Fibonacci(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">        f1.fork(); </span><br><span class="line">        Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> f2.compute() + f1.join(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以两个任务都fork，要注意的是两个任务都fork的情况，必须按照f1.fork()，f2.fork()， f2.join()，f1.join()这样的顺序，不然有性能问题，详见上面注意事项中的说明。</p>
<p>官方API文档是这样写到的，所以平日用invokeAll就好了。invokeAll会把传入的任务的第一个交给当前线程来执行，其他的任务都fork加入工作队列，这样等于利用当前线程也执行任务了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">    Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    invokeAll(f1,f2);</span><br><span class="line">    <span class="keyword">return</span> f2.join() + f1.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt;... tasks)</span> </span>&#123;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> last = tasks.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>)</span><br><span class="line">                ex = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>)   <span class="comment">//除了第一个都fork</span></span><br><span class="line">            t.fork();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.doInvoke() &lt; NORMAL &amp;&amp; ex == <span class="keyword">null</span>)  <span class="comment">//留一个自己执行</span></span><br><span class="line">            ex = t.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= last; ++i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">                t.cancel(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t.doJoin() &lt; NORMAL)</span><br><span class="line">                ex = t.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">        rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>Fork/Join</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/posts/ae0f95e0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>      

<blockquote>
<ul>
<li>Spring:IOC和AOP必须掌握</li>
<li>SpringMVC:执行流程必须掌握</li>
<li><strong>官网：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html">docs.spring.io/spring/docs…</a></strong></li>
</ul>
</blockquote>
<a id="more"></a>

<h1 id="MVC设计概述"><a href="#MVC设计概述" class="headerlink" title="MVC设计概述"></a>MVC设计概述</h1><h2 id="Model1"><a href="#Model1" class="headerlink" title="Model1"></a><strong>Model1</strong></h2><p>在早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 <strong>Model1：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7896890-7b3f9cd59394b017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/963/format/webp" alt="img"></p>
<p><strong>出现的弊端：</strong></p>
<ul>
<li>JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起</li>
<li>要求开发者不仅要掌握 Java ，还要有高超的前端水平</li>
<li>前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试</li>
<li>代码难以复用</li>
</ul>
<h2 id="Model2"><a href="#Model2" class="headerlink" title="Model2"></a>Model2</h2><p>正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型<strong>（Model2）</strong>就像下图这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7896890-403a273b08fec826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/985/format/webp" alt="img"></p>
<p>首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。</p>
<ul>
<li><strong>M 代表 模型（Model）</strong><br>  模型是什么呢？ 模型就是数据，就是 dao,bean</li>
<li><strong>V 代表 视图（View）</strong><br>  视图是什么呢？ 就是网页, JSP，用来展示模型中的数据</li>
<li><strong>C 代表 控制器（controller)</strong><br>  控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。</li>
</ul>
<h2 id="Spring-MVC-的架构"><a href="#Spring-MVC-的架构" class="headerlink" title="Spring MVC 的架构"></a>Spring MVC 的架构</h2><p>为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7896890-a25782fb05f315de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1176/format/webp" alt="img"></p>
<p><strong>传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。</strong> 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。</p>
<ul>
<li><strong>特点：</strong><br>  结构松散，几乎可以在 Spring MVC 中使用各类视图<br>  松耦合，各个模块分离<br>  与 Spring 无缝集成</li>
</ul>
<h2 id="回顾Servlet创建"><a href="#回顾Servlet创建" class="headerlink" title="回顾Servlet创建"></a>回顾Servlet创建</h2><ol>
<li><h3 id="创建maven-父工程：pom-xml"><a href="#创建maven-父工程：pom-xml" class="headerlink" title="创建maven,父工程：pom.xml"></a>创建maven,父工程：pom.xml</h3></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ssl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父工程导入依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--资源过滤器，防止导入资源失败问题，最好在父子pom.xml里都加入一下代码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><h3 id="创建子工程，idea右键Add-Framwork-Support添加web支持"><a href="#创建子工程，idea右键Add-Framwork-Support添加web支持" class="headerlink" title="创建子工程，idea右键Add Framwork Support添加web支持"></a>创建子工程，idea右键Add Framwork Support添加web支持</h3></li>
<li><h3 id="实现HelloServlet继承HttpServlet接口，并创建-WEB-INF-jsp-test-jsp"><a href="#实现HelloServlet继承HttpServlet接口，并创建-WEB-INF-jsp-test-jsp" class="headerlink" title="实现HelloServlet继承HttpServlet接口，并创建/WEB-INF/jsp/test.jsp"></a>实现HelloServlet继承HttpServlet接口，并创建/WEB-INF/jsp/test.jsp</h3></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1 获得参数</span></span><br><span class="line">        <span class="comment">//2 调用业务层</span></span><br><span class="line">        <span class="comment">//3 视图转发或者重定向</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><h3 id="web-xml中注册HelloServlet-测试跳转：http-localhost-8080-springmvc-01-servlet-helloServlet"><a href="#web-xml中注册HelloServlet-测试跳转：http-localhost-8080-springmvc-01-servlet-helloServlet" class="headerlink" title="web.xml中注册HelloServlet,测试跳转：http://localhost:8080/springmvc_01_servlet//helloServlet"></a>web.xml中注册HelloServlet,测试跳转：<a href="http://localhost:8080/springmvc_01_servlet//helloServlet">http://localhost:8080/springmvc_01_servlet//helloServlet</a></h3></li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b4370ebc42833?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.ssl.web.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="SpringMVC程序搭建过程"><a href="#SpringMVC程序搭建过程" class="headerlink" title="SpringMVC程序搭建过程"></a>SpringMVC程序搭建过程</h1><blockquote>
<ul>
<li>概念：SpringMVC是Spring框架中的一个分支，是基于Java实现MVC的轻量级Web框架</li>
<li>核心：Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计的。</li>
</ul>
</blockquote>
<h2 id="SpringMVC的核心组件"><a href="#SpringMVC的核心组件" class="headerlink" title="SpringMVC的核心组件"></a>SpringMVC的核心组件</h2><ul>
<li>DispatcherServlet：前端控制器，是整个流程控制的核心，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li>
<li>Handler：后端控制器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li>
<li>HandlerMapping：处理器映射器，DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li>
<li>HandlerInterceptor：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li>
<li>HandlerExecutionChain：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li>
<li>HandlerAdapter：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li>
<li>ModelAndView：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li>
<li>ViewResolver：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li>
</ul>
<h2 id="springMVC的执行原理"><a href="#springMVC的执行原理" class="headerlink" title="springMVC的执行原理"></a>springMVC的执行原理</h2><ol>
<li><strong>DispatcherServlet</strong>表示前端控制器，是整个SpringMVC的控制中心。用户发出请求，<strong>DispatcherServlet</strong>接收请求并拦截请求。</li>
<li>假设url为 : <a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></li>
<li>服务器域名：<a href="http://localhost:8080/">http://localhost:8080</a></li>
<li>web站点：/SpringMVC</li>
<li>hello表示控制器：/hello</li>
<li><strong>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</strong></li>
<li><strong>HandlerMapping</strong>为处理器映射。<strong>DispatcherServlet</strong>调用<strong>HandlerMapping</strong>,<strong>HandlerMapping</strong>根据请求url查找<strong>Handler</strong>。</li>
<li><strong>HandlerExecution</strong>表示具体的<strong>Handler</strong>,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</li>
<li><strong>HandlerExecution</strong>将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</li>
<li><strong>HandlerAdapter</strong>表示处理器适配器，其按照特定的规则去执行Handler。</li>
<li><strong>Handler</strong>让具体的<strong>Controller</strong>执行。</li>
<li><strong>Controller</strong>将具体的执行信息返回给<strong>HandlerAdapter</strong>,如<strong>ModelAndView</strong>。</li>
<li><strong>HandlerAdapter</strong>将视图逻辑名或模型传递给<strong>DispatcherServlet</strong>。</li>
<li><strong>DispatcherServlet</strong>调用视图解析器(<strong>ViewResolver</strong>)来解析<strong>HandlerAdapter</strong>传递的逻辑视图名。</li>
<li>视图解析器将解析的逻辑视图名传给<strong>DispatcherServlet</strong>。</li>
<li><strong>DispatcherServlet</strong>根据视图解析器解析的视图结果，调用具体的视图。</li>
<li>最终视图呈现给用户。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b438813a5c2e5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="不使用注解开发"><a href="#不使用注解开发" class="headerlink" title="不使用注解开发"></a>不使用注解开发</h2><blockquote>
<p>了解具体的执行过程=面试谈资。虽然开发中不会这么麻烦的使用，但必须看完-理解-继续学习</p>
</blockquote>
<h3 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h3><ul>
<li>完成DispatcherServlet，关联resource配置文件</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b43912e246aa0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置DispatcherServlet:SpringMVC核心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联一个SpringMvc的resource配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMvc_servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动级别--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--匹配所有的请求： / :只匹配请求，不包含所有的.jsp</span></span><br><span class="line"><span class="comment">                      /*:匹配所有的请求，包括jsp页面</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-配置springMvc-servlet-xml"><a href="#2-配置springMvc-servlet-xml" class="headerlink" title="2 配置springMvc_servlet.xml"></a>2 配置springMvc_servlet.xml</h3><ul>
<li>获得视图解析器、映射器、适配器，绑定跳转url</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--处理器映射器HandlerMapping:查找访问的url控制器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--处理器适配器HandlerAdapter：controller将处理好的数据返回给HandlerAdapter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--视图解析器ViewResolver：将后端处理好的数据和视图传给DispatchServlet，DS再交给ViewResolver先解析一遍，确认无误再传给前端</span></span><br><span class="line"><span class="comment">        必须熟悉，以后还要学模版引擎Thymeleaf/Freemarker...</span></span><br><span class="line"><span class="comment">        1 获取ModeAndView的数据</span></span><br><span class="line"><span class="comment">        2 解析ModeAndView的视图名字</span></span><br><span class="line"><span class="comment">        3 拼接视图名字，找到对应的视图 WEB-INF/jsp/hello.jsp</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--BeanNameUrlHandlerMapping处理器：绑定跳转的url=页面访问的网址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ssl.controller.HelloController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-WEB-INF-jsp-hello-jsp"><a href="#3-WEB-INF-jsp-hello-jsp" class="headerlink" title="3 /WEB-INF/jsp/hello.jsp"></a>3 /WEB-INF/jsp/hello.jsp</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--接受传递的参数--%&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-HelloController实现Controller"><a href="#4-HelloController实现Controller" class="headerlink" title="4 HelloController实现Controller"></a>4 HelloController实现Controller</h3><ul>
<li>访问：<a href="http://localhost:8080/springmvc_02_hellomvc/hello">http://localhost:8080/springmvc_02_hellomvc/hello</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1 创建modelAndView</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//2 调用业务层，这里没有，就不写</span></span><br><span class="line">        <span class="comment">//3 封装对象，放在mv中添加</span></span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Hello SpringMvc&quot;</span>);</span><br><span class="line">        <span class="comment">//4 封装要跳转的视图，WEB-INF/jsp/hello.jsp</span></span><br><span class="line">        mv.setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-SpringMVC原理回顾"><a href="#5-SpringMVC原理回顾" class="headerlink" title="==5 SpringMVC原理回顾=="></a>==5 SpringMVC原理回顾==</h3><ul>
<li><strong>反复观看，理解原理！</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b4398c71b57a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--与前面一样--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMvc_servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="springMvc-servlet-xml"><a href="#springMvc-servlet-xml" class="headerlink" title="springMvc_servlet.xml"></a>springMvc_servlet.xml</h3><ul>
<li>注解省略了映射器、适配器，专注于写视图解析器；跳转的Controller也不用配置进Spring</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b439d72e3c3b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssl.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--让SpringMvc不处理静态资源。让.css,.js等不进视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注解加载映射器、适配器，不用之前那么麻烦配置了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="WEB-INF-jsp-hello-jsp"><a href="#WEB-INF-jsp-hello-jsp" class="headerlink" title="/WEB-INF/jsp/hello.jsp"></a>/WEB-INF/jsp/hello.jsp</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="HelloController"><a href="#HelloController" class="headerlink" title="HelloController"></a>HelloController</h3><ul>
<li>简化了实现的接口，使用@注解配置映射器</li>
<li>访问：<a href="http://localhost:8080/springmvc_03_annotation/hello">http://localhost:8080/springmvc_03_annotation/hello</a></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/26/171b43a6d567ec30?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model 模型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被视图解析器处理：访问&quot;/WEB-INF/jsp/hello.jsp资源</span></span><br><span class="line"><span class="comment">     * 访问的url:RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//封装数据</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Hello SpringMvc_annotation&quot;</span>);</span><br><span class="line">        <span class="comment">//被视图解析器处理：访问&quot;/WEB-INF/jsp/hello.jsp资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充：-和-以及-do的区别及原理"><a href="#补充：-和-以及-do的区别及原理" class="headerlink" title="补充：/ 和 /* 以及 *.do的区别及原理"></a>补充：/ 和 /* 以及 *.do的区别及原理</h2><table>
<thead>
<tr>
<th></th>
<th>*..html</th>
<th>*.jsp</th>
<th>访问项目中controller类</th>
</tr>
</thead>
<tbody><tr>
<td>/*</td>
<td>x</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>/</td>
<td>x</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>*.do</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h3 id="原因解释"><a href="#原因解释" class="headerlink" title="原因解释"></a>原因解释</h3><blockquote>
<ul>
<li><p>首先应该了解匹配优先级：/ * &gt; *.do &gt; /；</p>
</li>
<li><p>其次是在tomcat自带的web.xml配置文件中配置了关于/和 *.jsp以及 *.jspx；分别表示匹配静态资源，匹配jsp资源以及jspx资源；</p>
</li>
<li><p>在服务器加载配置文件时，首先会加载tomcat的配置文件，再加载我们编写的配置文件；</p>
</li>
</ul>
</blockquote>
<p>当我们使用/的匹配规则时，会覆盖掉tomcat里的/也就是静态资源的的配置；因此会导致所有的静态资源都无法加载；由于它的优先级低于.jsp匹配规则，因此仍然可以加载jsp文件；如果我们配置的是 /* ,因为它的优先级最高，会覆盖tomcat的全部匹配规则，即会拦截所有请求。</p>
<h3 id="静态资源无法访问的解决途径"><a href="#静态资源无法访问的解决途径" class="headerlink" title="静态资源无法访问的解决途径"></a>静态资源无法访问的解决途径</h3><h4 id="方案一：激活Tomcat的defaultServlet来处理静态文件-按后缀名逐个配置"><a href="#方案一：激活Tomcat的defaultServlet来处理静态文件-按后缀名逐个配置" class="headerlink" title="方案一：激活Tomcat的defaultServlet来处理静态文件,按后缀名逐个配置"></a><strong>方案一：激活Tomcat的defaultServlet来处理静态文件,按后缀名逐个配置</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.js<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.css<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="方案二：-在spring3-0-4以后版本提供了mvc-resources"><a href="#方案二：-在spring3-0-4以后版本提供了mvc-resources" class="headerlink" title="方案二： 在spring3.0.4以后版本提供了mvc:resources"></a><strong>方案二： 在spring3.0.4以后版本提供了mvc:resources</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>/images /**映射到 <code>ResourceHttpRequestHandler </code>进行处理，location指定静态资源的位置.可以是web application根目录下、jar包里面，这样可以把静态资源压缩到jar包中。cache-period可以使得静态资源进行web cache。</p>
<p>如果出现下面的错误，可能是没有配置<code> &lt;mvc:annotation-driven /&gt;</code> 的原因。 报错<strong>WARNING: No mapping found for HTTP request with URI [/mvc/user/findUser/lisi/770] in DispatcherServlet with name ‘springMVC’</strong></p>
<p>使用 <a href="mvc:resources/">mvc:resources/</a> 元素,把 mapping 的 URI 注册到 <strong>SimpleUrlHandlerMapping</strong>的urlMap 中,key 为 mapping 的 URI pattern值,而value为 <strong>ResourceHttpRequestHandler</strong>,这样就巧妙的把对静态资源的访问由 <strong>HandlerMapping</strong> 转到<strong>ResourceHttpRequestHandler</strong> 处理并返回,所以就支持 classpath 目录, jar 包内静态资源的访问.另外需要注意的一点是,不要对 <strong>SimpleUrlHandlerMapping</strong> 设置 <strong>defaultHandler</strong>. 因为对 static uri 的 <strong>defaultHandler</strong> 就是<strong>ResourceHttpRequestHandler</strong>,否则无法处理``static<code> </code>resources<code> </code>request`.</p>
<p><strong>mapping</strong>：映射 location：本地资源路径，注意必须是webapp根目录下的路径。 两个*，它表示映射resources/下所有的URL，包括子路径（即接多个/） 陷阱： 配置的location一定要是webapp根目录下才行，如果你将资源目录，放置到``webapp/WEB-INF`下面的话，则就会访问失败。这个问题常常会犯。</p>
<p>WEB-INF目录作用 WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。 如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 当然，你非要放在WEB-INF中，则必须修改resources映射，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;BACKGROUND-COLOR: #ffff33&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/WEB</span></span></span><br></pre></td></tr></table></figure>
<h4 id="方案三-，使用mvc-default-servlet-handler"><a href="#方案三-，使用mvc-default-servlet-handler" class="headerlink" title="方案三 ，使用mvc:default-servlet-handler/"></a><strong>方案三 ，使用<a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a></strong></h4><p><a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a>会把 “/<strong>“ url,注册到 **SimpleUrlHandlerMapping</strong> 的 urlMap 中,把对静态资源的访问由 HandlerMapping 转到<code>org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler </code>处理并返回.<strong>DefaultServletHttpRequestHandler</strong> 使用就是各个 Servlet 容器自己的默认 Servlet.</p>
<p>补充说明：多个HandlerMapping的执行顺序问题： DefaultAnnotationHandlerMapping 的 order 属性值是：0 &lt;mvc:resources/ &gt;自动注册的 SimpleUrlHandlerMapping 的 order 属性值是： 2147483646 <a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a>自动注册的 SimpleUrlHandlerMapping 的 order 属性值是：2147483647 spring 会先执行 order 值比较小的。当访问一个 a.jpg 图片文件时，先通过 DefaultAnnotationHandlerMapping 来找处理器，一定是找不到的，我们没有叫 a.jpg 的 Action。再按 order 值升序找，由于最后一个 SimpleUrlHandlerMapping 是匹配 “/**” 的，所以一定会匹配上，再响应图片。</p>
<h1 id="controller与RestFul"><a href="#controller与RestFul" class="headerlink" title="controller与RestFul"></a>controller与RestFul</h1><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@<strong>RequestMapping</strong></h3><ul>
<li>解将 URL 请求与业务方法进行映射，在 Handler 的类定义处以及方法定义处都可以添加 @RequestMapping ，在类定义处添加，相当于客户端多了一层访问路径。</li>
<li>访问：<a href="http://localhost:8080/springmvc_04_controller/controller/demo1">http://localhost:8080/springmvc_04_controller/controller/demo1</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerDemo3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/demo1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;demo1&quot;</span>, <span class="string">&quot;demo1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@<strong>Controller</strong></h3><ul>
<li><p>在类定义处添加，将该类交个 IoC 容器来管理（结合 springmvc.xml 的自动扫描配置使用），同时使其成为一个控制器，可以接收客户端请求。</p>
</li>
<li><p>访问：<a href="http://localhost:8080/springmvc_04_controller/demo2">http://localhost:8080/springmvc_04_controller/demo2</a></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerDemo2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/demo2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;demo2&quot;</span>, <span class="string">&quot;demo2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestMapping-1"><a href="#RequestMapping-1" class="headerlink" title="@RequestMapping"></a>@<strong>RequestMapping</strong></h3><h3 id="value：指定-URL-请求的实际地址，是-RequestMapping-的默认值。"><a href="#value：指定-URL-请求的实际地址，是-RequestMapping-的默认值。" class="headerlink" title="value：指定 URL 请求的实际地址，是 @RequestMapping 的默认值。"></a>value：指定 URL 请求的实际地址，是 @RequestMapping 的默认值。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了index...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/index&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了index...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="method：指定请求的-method-类型，GET、POST、PUT、DELET（枚举）。"><a href="#method：指定请求的-method-类型，GET、POST、PUT、DELET（枚举）。" class="headerlink" title="method：指定请求的 method 类型，GET、POST、PUT、DELET（枚举）。"></a>method：指定请求的 method 类型，GET、POST、PUT、DELET（枚举）。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了index...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码表示 index 方法只能接收 GET 请求。</p>
<h3 id="params：指定请求中必须包含某些参数，否则无法调用该方法。"><a href="#params：指定请求中必须包含某些参数，否则无法调用该方法。" class="headerlink" title="params：指定请求中必须包含某些参数，否则无法调用该方法。"></a>params：指定请求中必须包含某些参数，否则无法调用该方法。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET,params = &#123;&quot;name&quot;,&quot;id=10&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了index...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码表示请求中必须包含 name 和 id 两个参数，同时 id 的值必须是 10。</p>
<p>关于参数绑定，在形参列表中通过添加 @RequestParam 注解完成 HTTP 请求参数与业务方法形参的映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET,params = &#123;&quot;name&quot;,&quot;id=10&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String str,<span class="meta">@RequestParam(&quot;id&quot;)</span> <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了index...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码表示将请求的参数 name 和 id 分别赋给了形参 str 和 age ，同时自动完成了数据类型转换，将 “10” 转为了 int 类型的 10，再赋给 age，这些工作都是由 HandlerAdapter 来完成的。</p>
<h2 id="Spring-MVC-也支持-RESTful-风格的-URL。"><a href="#Spring-MVC-也支持-RESTful-风格的-URL。" class="headerlink" title="Spring MVC 也支持 RESTful 风格的 URL。"></a>Spring MVC 也支持 RESTful 风格的 URL。</h2><blockquote>
<p>REST：Representational State Transfer，资源表现层状态转换，是目前比较主流的一种互联网软件架构，它结构清晰、标准规范、易于理解、便于扩展。</p>
</blockquote>
<ul>
<li><h4 id="资源（Resource）"><a href="#资源（Resource）" class="headerlink" title="资源（Resource）"></a><strong>资源（Resource）</strong></h4></li>
</ul>
<p>网络上的一个实体，或者说网络中存在的一个具体信息，一段文本、一张图片、一首歌曲、一段视频等等，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每个资源都有对应的一个特定的 URI，要获取该资源时，只需要访问对应的 URI 即可。</p>
<ul>
<li><h4 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a><strong>表现层（Representation）</strong></h4></li>
</ul>
<p>资源具体呈现出来的形式，比如文本可以用 txt 格式表示，也可以用 HTML、XML、JSON等格式来表示。</p>
<ul>
<li><h4 id="状态转换（State-Transfer）"><a href="#状态转换（State-Transfer）" class="headerlink" title="状态转换（State Transfer）"></a><strong>状态转换（State Transfer）</strong></h4></li>
</ul>
<p>客户端如果希望操作服务器中的某个资源，就需要通过某种方式让服务端发生状态转换，而这种转换是建立在表现层之上的，所有叫做”表现层状态转换”。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>最大的优势是安全，看不出源代码的参数和意义</strong></li>
<li><strong>实现地址复用，使得get和post访问url相同，框架会自动进行类型转换</strong></li>
<li><strong>高效：支持缓存</strong></li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点：</strong></h4><ul>
<li>不像原生的url见名知意，url理解不直观</li>
</ul>
<h4 id="如何使用："><a href="#如何使用：" class="headerlink" title="如何使用："></a>如何使用：</h4><blockquote>
<p>REST 具体操作就是 HTTP 协议中四个表示操作方式的动词分别对应 CRUD 基本操作。</p>
</blockquote>
<ul>
<li><p>GET 用来表示获取资源。</p>
</li>
<li><p>POST 用来表示新建资源。</p>
</li>
<li><p>PUT 用来表示修改资源。</p>
</li>
<li><p>DELETE 用来表示删除资源。</p>
</li>
</ul>
<p>实现方式：</p>
<ol>
<li>url <code>@GetMapping(&quot;/addRest/&#123;a&#125;/&#123;b&#125;&quot;)</code> + 参数<code>@PathVariable int a, @PathVariable int b</code></li>
</ol>
<p>访问：<a href="http://localhost:8080/springmvc_04_controller/addRest/1/2">http://localhost:8080/springmvc_04_controller/addRest/1/2</a></p>
<ol start="2">
<li>url <code>@PostMapping(&quot;/addRest/&#123;a&#125;/&#123;b&#125;&quot;)</code>+  参数不变<code>@PathVariable int a, @PathVariable int b</code></li>
</ol>
<p>使用Postman中的post访问：<a href="http://localhost:8080/springmvc_04_controller/addRest/1/2">http://localhost:8080/springmvc_04_controller/addRest/1/2</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原生的url：http://localhost:8080/springmvc_04/add?a=1&amp;b=1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAdd1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = a + b;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;原生的url：结果为&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;add&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RestFul方式一：method = get</span></span><br><span class="line"><span class="comment">     * RequestMapping(&quot;/addRest/&#123;a&#125;/&#123;b&#125;&quot; method=requestMethod.GET) = <span class="doctag">@GetMapping</span>()</span></span><br><span class="line"><span class="comment">     * http://localhost:8080/springmvc_04/addRest/1/1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/addRest/&#123;a&#125;/&#123;b&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAdd2</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> a, <span class="meta">@PathVariable</span> <span class="keyword">int</span> b, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = a + b;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;Rest的url：结果为&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;addRest&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复用相同的url</span></span><br><span class="line"><span class="comment">     * RestFul方式二：method=post，使用RestFul的话，请求的url和GET就一样了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/addRest/&#123;a&#125;/&#123;b&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAdd3</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> a, <span class="meta">@PathVariable</span> <span class="keyword">int</span> b, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = a + b;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;Rest的url：结果为&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;addRest&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p><strong>将url中的{}包起参数和形参进行绑定</strong></p>
<h2 id="重定向和转发"><a href="#重定向和转发" class="headerlink" title="重定向和转发"></a>重定向和转发</h2><ul>
<li>可以使用原生的request转发或者response重定向</li>
<li>推荐使用SpringMvc的<code>return “forward:xxx”/&quot;redirect:xxx&quot;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原生的转发：返回值是void，没有经过视图解析器；原生的重定向同样如此，都不走视图解析器，直接重定向</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String id = request.getSession().getId();</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;index.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SpringMvc转发：测试结果是不走视图解析器，url没变是转发</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;demo1&quot;</span>,<span class="string">&quot;这是test2中的Spring转发&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/jsp/demo1.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SpringMvc重定向：测试结果是不走视图解析器</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;跳转回首页index.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参数绑定及数据回显"><a href="#参数绑定及数据回显" class="headerlink" title="参数绑定及数据回显"></a>参数绑定及数据回显</h1><h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><blockquote>
<p>数据绑定：在后端的业务方法中直接获取客户端 HTTP 请求中的参数，将请求参数映射到业务方法的形参中，Spring MVC 中数据绑定的工作是由 HandlerAdapter 来完成的。</p>
</blockquote>
<h3 id="默认支持的参数类型"><a href="#默认支持的参数类型" class="headerlink" title="默认支持的参数类型"></a>默认支持的参数类型</h3><ul>
<li><p>HttpServletRequest </p>
</li>
<li><p>HttpServletResponse </p>
</li>
<li><p>HttpSession </p>
</li>
<li><p>Model</p>
</li>
</ul>
<hr>
<h3 id="映射-Cookie"><a href="#映射-Cookie" class="headerlink" title="映射 Cookie"></a>映射 Cookie</h3><p>Spring MVC 通过映射可以直接在业务方法中获取 Cookie 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/cookie&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cookie</span><span class="params">(<span class="meta">@CookieValue(value = &quot;JSESSIONID&quot;)</span> String sessionId)</span></span>&#123;</span><br><span class="line">    System.out.println(sessionId);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-JavaBean-绑定参数"><a href="#使用-JavaBean-绑定参数" class="headerlink" title="使用 JavaBean 绑定参数"></a>使用 JavaBean 绑定参数</h3><p>Spring MVC 会根据请求参数名和 JavaBean 属性名进行自动匹配，自动为对象填充属性值，同时支持及联属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: southwind</span><br><span class="line">  Date: <span class="number">2019</span>-<span class="number">03</span>-<span class="number">13</span></span><br><span class="line">  Time: <span class="number">15</span>:<span class="number">33</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/hello/save&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        用户id：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户地址：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;address.value&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;注册&quot;</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/save&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/baseType&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">baseType</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id+<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ResponseBody 表示 Spring MVC 会直接将业务方法的返回值响应给客户端，如果不加 @ResponseBody 注解，Spring MVC 会将业务方法的放回值传递给 DispatcherServlet，再由 DisptacherServlet 调用 ViewResolver 对返回值进行解析，映射到一个 JSP 资源。</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/packageType&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">packageType</span><span class="params">(<span class="meta">@RequestParam(value = &quot;num&quot;,required = false,defaultValue = &quot;0&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id+<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包装类可以接收 null，当 HTTP 请求没有参数时，使用包装类定义形参的数据类型，程序不会抛出异常。</p>
<p>@RequestParam</p>
<p>value = “num”：将 HTTP 请求中名为 num 的参数赋给形参 id。</p>
<p>requried：设置 num 是否为必填项，true 表示必填，false 表示非必填，可省略。</p>
<p>defaultValue = “0”：如果 HTTP 请求中没有 num 参数，默认值为0.</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBindHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/array&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">array</span><span class="params">(String[] name)</span></span>&#123;</span><br><span class="line">        String str = Arrays.toString(name);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@RestController 表示该控制器会直接将业务方法的返回值响应给客户端，不进行视图解析。</p>
<p>@Controller 表示该控制器的每一个业务方法的返回值都会交给视图解析器进行解析，如果只需要将数据响应给客户端，而不需要进行视图解析，则需要在对应的业务方法定义处添加 @ResponseBody。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBindHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/array&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">array</span><span class="params">(String[] name)</span></span>&#123;</span><br><span class="line">        String str = Arrays.toString(name);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBindHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/array&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">array</span><span class="params">(String[] name)</span></span>&#123;</span><br><span class="line">        String str = Arrays.toString(name);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Spring MVC 不支持 List 类型的直接转换，需要对 List 集合进行包装。</p>
<p>集合封装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSP</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: southwind</span><br><span class="line">  Date: <span class="number">2019</span>-<span class="number">03</span>-<span class="number">14</span></span><br><span class="line">  Time: 09:<span class="number">12</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/data/list&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        用户<span class="number">1</span>编号：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[0].id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">1</span>名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[0].name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">2</span>编号：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[1].id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">2</span>名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[1].name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">3</span>编号：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[2].id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">3</span>名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[2].name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>业务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(UserList userList)</span></span>&#123;</span><br><span class="line">    StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>(User user:userList.getUsers())&#123;</span><br><span class="line">        str.append(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理 @ResponseBody 中文乱码，在 springmvc.xml 中配置消息转换器。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">    &lt;!-- 消息转换器 --&gt;</span><br><span class="line">    &lt;mvc:message-converters register-defaults=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br><span class="line">            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/html;charset=UTF-8&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/mvc:message-converters&gt;</span><br><span class="line">&lt;/mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>自定义封装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,User&gt; users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/map&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(UserMap userMap)</span></span>&#123;</span><br><span class="line">    StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>(String key:userMap.getUsers().keySet())&#123;</span><br><span class="line">        User user = userMap.getUsers().get(key);</span><br><span class="line">        str.append(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSP</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: southwind</span><br><span class="line">  Date: <span class="number">2019</span>-<span class="number">03</span>-<span class="number">14</span></span><br><span class="line">  Time: 09:<span class="number">12</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/data/map&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        用户<span class="number">1</span>编号：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[&#x27;a&#x27;].id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">1</span>名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[&#x27;a&#x27;].name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">2</span>编号：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[&#x27;b&#x27;].id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">2</span>名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[&#x27;b&#x27;].name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">3</span>编号：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[&#x27;c&#x27;].id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        用户<span class="number">3</span>名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;users[&#x27;c&#x27;].name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="数据回显（模型数据解析）"><a href="#数据回显（模型数据解析）" class="headerlink" title="数据回显（模型数据解析）"></a>数据回显（模型数据解析）</h2><blockquote>
<p>JSP 四大作用域对应的内置对象：pageContext、request、session、application。</p>
<p>模型数据的绑定是由 ViewResolver 来完成的，实际开发中，我们需要先添加模型数据，再交给 ViewResolver 来绑定。</p>
</blockquote>
<p>Spring MVC 提供了以下几种方式添加模型数据：</p>
<ul>
<li>Map</li>
<li>Model</li>
<li>ModelAndView</li>
<li>@SessionAttribute</li>
<li>@ModelAttribute</li>
</ul>
<h3 id="将模式数据绑定到-request-对象。"><a href="#将模式数据绑定到-request-对象。" class="headerlink" title="将模式数据绑定到 request 对象。"></a>将模式数据绑定到 request 对象。</h3><h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/map&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(Map&lt;String,User&gt; map)</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;view&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSP</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: southwind</span><br><span class="line">  Date: <span class="number">2019</span>-<span class="number">03</span>-<span class="number">14</span></span><br><span class="line">  Time: <span class="number">11</span>:<span class="number">36</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    $&#123;requestScope.user&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/model&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">model</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;view&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/modelAndView&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">modelAndView</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/modelAndView2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">modelAndView2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    View view = <span class="keyword">new</span> InternalResourceView(<span class="string">&quot;/view.jsp&quot;</span>);</span><br><span class="line">    modelAndView.setView(view);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/modelAndView3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">modelAndView3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/modelAndView4&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">modelAndView4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    View view = <span class="keyword">new</span> InternalResourceView(<span class="string">&quot;/view.jsp&quot;</span>);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(view);</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/modelAndView5&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">modelAndView5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    Map&lt;String,User&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;view&quot;</span>,map);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/modelAndView6&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">modelAndView6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    Map&lt;String,User&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    View view = <span class="keyword">new</span> InternalResourceView(<span class="string">&quot;/view.jsp&quot;</span>);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(view,map);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/modelAndView7&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">modelAndView7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;view&quot;</span>,<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/modelAndView8&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">modelAndView8</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    View view = <span class="keyword">new</span> InternalResourceView(<span class="string">&quot;/view.jsp&quot;</span>);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(view,<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/request&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;view&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><ul>
<li>定义一个方法，该方法专门用来返回要填充到模型数据中的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">(Map&lt;String,User&gt; map)</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>业务方法中无需再处理模型数据，只需返回视图即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/modelAttribute&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">modelAttribute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;view&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将模型数据绑定到-session-对象"><a href="#将模型数据绑定到-session-对象" class="headerlink" title="将模型数据绑定到 session 对象"></a>将模型数据绑定到 session 对象</h3><h4 id="直接使用原生的-Servlet-API。"><a href="#直接使用原生的-Servlet-API。" class="headerlink" title="直接使用原生的 Servlet API。"></a>直接使用原生的 Servlet API。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/session&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">session</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;view&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/session2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">session2</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;view&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes(value = &#123;&quot;user&quot;,&quot;address&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHandler</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 ViewHandler 中的所有业务方法，只要向 request 中添加了 key = “user”、key = “address” 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存 key 不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes(types = &#123;User.class,Address.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHandler</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 ViewHandler 中的所有业务方法，只要向 request 中添加了数据类型是 User 、Address 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存 key 不变。</p>
<h3 id="将模型数据绑定到-application-对象"><a href="#将模型数据绑定到-application-对象" class="headerlink" title="将模型数据绑定到 application 对象"></a>将模型数据绑定到 application 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/application&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">application</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    ServletContext application = request.getServletContext();</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    application.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;view&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p><strong>方法一：web.xml里面配置的SpringMvc自带的过滤器<code>CharacterEncodingFilter</code></strong></p>
<ul>
<li><strong><code>&lt;url-pattern&gt;/\*&lt;/url-pattern&gt;</code>：因为要跳转到xxx.jsp页面，所以url是/*(≠/)</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置SpringMVC--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring_mvc_servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--web容器解决中文乱码问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encode<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encode<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>方法二：一劳永逸，但需要重启Tomcat服务器，修改Tomcat里面的server.xml配置文件：<code>URIEncoding = &quot;UTF-8&quot;</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span> = <span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Spring-MVC-自定义数据转换器"><a href="#Spring-MVC-自定义数据转换器" class="headerlink" title="Spring MVC 自定义数据转换器"></a>Spring MVC 自定义数据转换器</h2><blockquote>
<p>数据转换器是指将客户端 HTTP 请求中的参数转换为业务方法中定义的形参，自定义表示开发者可以自主设计转换的方式，HandlerApdter 已经提供了通用的转换，String 转 int，String 转 double，表单数据的封装等，但是在特殊的业务场景下，HandlerAdapter 无法进行转换，就需要开发者自定义转换器。</p>
</blockquote>
<p>客户端输入 String 类型的数据 “2019-03-03”，自定义转换器将该数据转为 Date 类型的对象。</p>
<h3 id="创建-DateConverter-转换器，实现-Conveter-接口。"><a href="#创建-DateConverter-转换器，实现-Conveter-接口。" class="headerlink" title="创建 DateConverter 转换器，实现 Conveter 接口。"></a>创建 DateConverter 转换器，实现 Conveter 接口。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateConverter</span><span class="params">(String pattern)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="keyword">this</span>.pattern);</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = simpleDateFormat.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="springmvc-xml-配置转换器。"><a href="#springmvc-xml-配置转换器。" class="headerlink" title="springmvc.xml 配置转换器。"></a>springmvc.xml 配置转换器。</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自定义转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.southwind.converter.DateConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyy-MM-dd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 消息转换器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span> <span class="attr">value</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置fastjson --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JSP</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: southwind</span><br><span class="line">  Date: <span class="number">2019</span>-<span class="number">03</span>-<span class="number">14</span></span><br><span class="line">  Time: <span class="number">14</span>:<span class="number">47</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/converter/date&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        请输入日期:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;date&quot;</span>/&gt;(yyyy-MM-dd)&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Handler</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/converter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/date&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">date</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String 转 Student</p>
<p>StudentConverter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] args = s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setId(Long.parseLong(args[<span class="number">0</span>]));</span><br><span class="line">        student.setName(args[<span class="number">1</span>]);</span><br><span class="line">        student.setAge(Integer.parseInt(args[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="springmvc-xml"><a href="#springmvc-xml" class="headerlink" title="springmvc.xml"></a>springmvc.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自定义转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.southwind.converter.DateConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyy-MM-dd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.southwind.converter.StudentConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 消息转换器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span> <span class="attr">value</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置fastjson --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSP</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: southwind</span><br><span class="line">  Date: <span class="number">2019</span>-<span class="number">03</span>-<span class="number">14</span></span><br><span class="line">  Time: <span class="number">15</span>:<span class="number">23</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/converter/student&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        请输入学生信息：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;student&quot;</span>/&gt;(id-name-age)&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>Handler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/student&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">student</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> student.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<ul>
<li><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4></li>
</ul>
<p>客户端发生 JSON 格式的数据，直接通过 Spring MVC 绑定到业务方法的形参中。</p>
<p>处理 Spring MVC 无法加载静态资源，在 web.xml 中添加配置即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.js<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSP</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: southwind</span><br><span class="line">  Date: <span class="number">2019</span>-<span class="number">03</span>-<span class="number">14</span></span><br><span class="line">  Time: <span class="number">10</span>:<span class="number">35</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        $(function()&#123;</span><br><span class="line">           <span class="keyword">var</span> user = &#123;</span><br><span class="line">               <span class="string">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">               <span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">           &#125;;</span><br><span class="line">           $.ajax(&#123;</span><br><span class="line">               url:<span class="string">&quot;/data/json&quot;</span>,</span><br><span class="line">               data:JSON.stringify(user),</span><br><span class="line">               type:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">               contentType:<span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><br><span class="line">               dataType:<span class="string">&quot;JSON&quot;</span>,</span><br><span class="line">               success:function(data)&#123;</span><br><span class="line">                   alter(data.id+<span class="string">&quot;---&quot;</span>+data.name);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>业务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/json&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">json</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    user.setId(<span class="number">6</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张六&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring MVC 中的 JSON 和 JavaBean 的转换需要借助于 fastjson，pom.xml 引入相关依赖。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.32&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>springmvc.xml 添加 fastjson 配置。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">    &lt;!-- 消息转换器 --&gt;</span><br><span class="line">    &lt;mvc:message-converters register-defaults=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br><span class="line">            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/html;charset=UTF-8&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">        &lt;!-- 配置fastjson --&gt;</span><br><span class="line">        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;/mvc:message-converters&gt;</span><br><span class="line">&lt;/mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure>
<h1 id="JSON-1"><a href="#JSON-1" class="headerlink" title="JSON"></a>JSON</h1><h2 id="前端初识Json"><a href="#前端初识Json" class="headerlink" title="前端初识Json"></a>前端初识Json</h2><p>前端展示两者数据，学会js和json互相转换</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;json&lt;/title&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        <span class="comment">//user是一个js对象</span></span><br><span class="line">        <span class="keyword">var</span> user = &#123;</span><br><span class="line">            name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">            age: <span class="number">18</span>,</span><br><span class="line">            sex: <span class="string">&quot;男&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//后端传的json其实是一个字符串，前端将后端传的json转换成js对象渲染在页面上</span></span><br><span class="line">        <span class="comment">//jsonUser:模拟后端传的json数据</span></span><br><span class="line">        <span class="comment">//js转换成json</span></span><br><span class="line">        <span class="keyword">var</span> jsonUser = JSON.stringify(user);</span><br><span class="line">        console.log(jsonUser);</span><br><span class="line">        <span class="comment">//jsUser：js是一个对象</span></span><br><span class="line">        <span class="comment">//json转换成js</span></span><br><span class="line">        <span class="keyword">var</span> jsUser = JSON.parse(jsonUser);</span><br><span class="line">        console.log(jsUser)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Jackson-Databind"><a href="#Jackson-Databind" class="headerlink" title="Jackson Databind"></a>Jackson Databind</h2><blockquote>
<p><strong>使用 Jackson Databind可以快速生成json数据</strong></p>
</blockquote>
<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure>
<p><strong>json=一个字符串，所以会有中文乱码问题，需要在springmvc.xml配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssl.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--让SpringMvc不处理静态资源。让.css,.js等不进视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注解加载映射器、适配器，解决Json数据中文乱码问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器，明确json数据不走数据解析器，直接传给前端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h3><ul>
<li>@RestControoler:该类下所有方法不走视图解析器，返回一个json数据</li>
<li>@ResponseBody：该方法不走视图解析器，返回一个json数据</li>
<li>访问：<a href="http://localhost:8080/springmvc_05_json/t1%EF%BC%8C%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AAjson%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8D%E7%BB%8F%E8%BF%87%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8">http://localhost:8080/springmvc_05_json/t1，页面显示一个json数据，不经过视图解析器</a></li>
<li>回顾日期：<code>new SimpleDateFormat(&quot;yyyy-MM-dd:HH:mm:ss&quot;)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*  概念：前后端分离的项目，后端代码不走视图解析器，后端传给前端的是json数据</span></span><br><span class="line"><span class="comment">        方法上：注解@ResponseBody指定该方法不走视图解析器，会直接返回一个String=json数据就是一个字符串</span></span><br><span class="line"><span class="comment">        类上：注解@RestController指定该类下的所有方法都不走视图解析器</span></span><br><span class="line"><span class="comment">        Json返回一个对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/t1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">json1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        ObjectMapper jacksonMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String str_user = jacksonMapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">//user.toString()是自己指定的String但是公司通常是允许的，通常是使用第三方工具来返回String</span></span><br><span class="line">        <span class="comment">//str_user有中文乱码问题，springMvc可以统一配置</span></span><br><span class="line">        <span class="keyword">return</span> str_user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Json返回一个List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/t2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">json2</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        User user3 = <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        User user4 = <span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(user1);</span><br><span class="line">        list.add(user2);</span><br><span class="line">        list.add(user3);</span><br><span class="line">        list.add(user4);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjectMapper().writeValueAsString(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  json返回一个日期格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/t3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">json3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">//方式一：原始纯java日期转换：推荐使用</span></span><br><span class="line">        <span class="comment">// String date = new SimpleDateFormat(&quot;yyyy-MM-dd:HH-mm-ss&quot;).format(new Date());</span></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">//方式二：使用mapper来制定日期格式，先关闭时间戳表示</span></span><br><span class="line">        objectMapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">        objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd:HH:mm:ss&quot;</span>));</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">return</span> objectMapper.writeValueAsString(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DateTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传统的java日期格式转换</span></span><br><span class="line">        String date = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd:HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h2><blockquote>
<p><strong>阿里巴巴官方提供的，实现Json数据的另一个工具，比JackSon Databind更方便</strong></p>
</blockquote>
<h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="编写Controller-1"><a href="#编写Controller-1" class="headerlink" title="编写Controller"></a>编写Controller</h3><p>比Jackson使用更方便</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/t4&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">json4</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">       User user1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">       User user2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">21</span>);</span><br><span class="line">       User user3 = <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">22</span>);</span><br><span class="line">       User user4 = <span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">       List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(user1);</span><br><span class="line">       list.add(user2);</span><br><span class="line">       list.add(user3);</span><br><span class="line">       list.add(user4);</span><br><span class="line">       String jsonString = JSON.toJSONString(list);</span><br><span class="line">       <span class="keyword">return</span> jsonString;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>数据独立性：Servlet中的是过滤器，而拦截器是SpringMVC框架独有的，独享request和response</li>
<li>拦截器只会拦截访问的控制器方法，如果访问的是jsp/html/css等式不会拦截的</li>
<li>拦截器是基于AOP思想的，和AOP实现是一样的，在application.xml中配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--拦截器配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                /**是拦截之后所有的请求，比如/admin/a1/2131</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.ssl.config.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p><strong>实现 HandlerInterceptor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//return true：执行下一个拦截器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========处理前,这里进行拦截处理=================&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===========处理后，通常进行日志管理=================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===========清洁中=================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>applica.xml配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--拦截器配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                /**是拦截之后所有的请求，比如/admin/a1/2131</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.ssl.config.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="登录验证判断"><a href="#登录验证判断" class="headerlink" title="登录验证判断"></a>登录验证判断</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        request.getRequestURL();</span><br><span class="line">        <span class="comment">//URL:http://localhost:8080/springmvc_07_interceptor/user//main</span></span><br><span class="line">        System.out.println(<span class="string">&quot;URL:&quot;</span> + request.getRequestURL());</span><br><span class="line">        <span class="comment">//URI:/springmvc_07_interceptor/user//main</span></span><br><span class="line">        System.out.println(<span class="string">&quot;URI:&quot;</span> + request.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(<span class="string">&quot;username&quot;</span>) == <span class="keyword">null</span> || session.getAttribute(<span class="string">&quot;password&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/login.jsp&quot;</span>).forward(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (session.getAttribute(<span class="string">&quot;username&quot;</span>).equals(<span class="string">&quot;admin&quot;</span>) &amp;&amp; session.getAttribute(<span class="string">&quot;password&quot;</span>).equals(<span class="string">&quot;123456&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.getRequestURI().contains(<span class="string">&quot;ogin&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/login.jsp&quot;</span>).forward(request, response);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/main&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//沒登陸就不等進入首頁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/goLogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">goLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, HttpSession session, Model model)</span> </span>&#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/outUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">outUser</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件上传与下载"><a href="#文件上传与下载" class="headerlink" title="文件上传与下载"></a>文件上传与下载</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><strong>前端form添加enctype=”multipart/form-data”,method=”post”</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p><strong>后端pom导包</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--导入高版本的api--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Spring自带的文件上传,application.xml配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--4 文件上传配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最大上传大小：单位是1字节--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/upFile&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置文件保存路径</span></span><br><span class="line">        String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;path:&quot;</span> + path);</span><br><span class="line">        File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (!realPath.exists()) &#123;</span><br><span class="line">            realPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;上传的文件地址：&quot;</span> + realPath);</span><br><span class="line">        <span class="comment">//CommonsMultipartFile的方法写文件，简化</span></span><br><span class="line">        file.transferTo(<span class="keyword">new</span> File(realPath + <span class="string">&quot;/&quot;</span> + file.getOriginalFilename()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p><strong>方式一：写方法下载</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/download&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">downLoad</span><span class="params">(HttpServletResponse response, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//手动设置，要下载的图片地址</span></span><br><span class="line">      String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">      String fileName = <span class="string">&quot;1.png&quot;</span>;</span><br><span class="line">      <span class="comment">//设置响应头</span></span><br><span class="line">      response.reset();<span class="comment">//设置页面不缓存，清空buffer</span></span><br><span class="line">      response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">      response.setContentType(<span class="string">&quot;multipart/form-data&quot;</span>);<span class="comment">//二进制传输数据</span></span><br><span class="line">      response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;fileName=&quot;</span> + URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">      File file = <span class="keyword">new</span> File(path, fileName);</span><br><span class="line">      <span class="comment">//读取文件-输入流</span></span><br><span class="line">      InputStream input = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      <span class="comment">//写入文件-输出流</span></span><br><span class="line">      OutputStream out = response.getOutputStream();</span><br><span class="line">      <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((index = input.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">          out.write(buff,<span class="number">0</span>,index);</span><br><span class="line">          out.flush();</span><br><span class="line">      &#125;</span><br><span class="line">      input.close();</span><br><span class="line">      out.close();</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>方式二：标签直接web下静态获取</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/static/1.png&quot;</span>&gt;</span>图片下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="校验理解"><a href="#校验理解" class="headerlink" title="校验理解"></a>校验理解</h3><p>项目中，通常使用较多的是前端的校验，比如页面中<code>js</code>校验。对于安全要求较高建议在服务端进行校验。服务端校验有：</p>
<ul>
<li>控制层：校验页面请求的参数的合法性。在服务端校验不区分客户端（pc、手机、远程调用），其校验是一致的。</li>
<li>业务层（<strong>使用较多</strong>）：主要校验关键的业务参数，仅限于<code>service</code>接口中使用的参数。</li>
<li>持久层：一般是不校验的。</li>
</ul>
<h3 id="springmvc-校验"><a href="#springmvc-校验" class="headerlink" title="springmvc 校验"></a>springmvc 校验</h3><ul>
<li>**<code>springmvc</code>**使用<code>hibernate</code>的校验框架<code>validation</code>（和<code>hibernate</code>没有关系）。</li>
<li>思路<br>   页面提交请求的参数，请求到<code>Controller</code>方法中，使用<code>validation</code>进行校验。如果校验出错，需要将错误信息展示到页面。</li>
<li>具体需求<br>   商品修改，添加校验（检验商品名称长度，生成日期的非空校验）如果校验出错，在商品修改页面显示错误信息。</li>
</ul>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>添加相关校验包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JSR-303 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboss-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h2><p>Spring MVC 提供了两种数据校验的方式：1、基于 Validator 接口。2、使用 Annotation JSR - 303 标准进行校验。</p>
<p>基于 Validator 接口的方式需要自定义 Validator 验证器，每一条数据的验证规则需要开发者手动完成，使用 Annotation JSR - 303 标准则不需要自定义验证器，通过注解的方式可以直接在实体类中添加每个属性的验证规则，这种方式更加方便，实际开发中推荐使用。</p>
<h3 id="基于-Validator-接口"><a href="#基于-Validator-接口" class="headerlink" title="基于 Validator 接口"></a>基于 Validator 接口</h3><ul>
<li>实体类 Account</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义验证器 AccountValidator，实现 Validator 接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.validator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.Account;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Errors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.ValidationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Account.class.equals(aClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object o, Errors errors)</span> </span>&#123;</span><br><span class="line">        ValidationUtils.rejectIfEmpty(errors,<span class="string">&quot;name&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;姓名不能为空&quot;</span>);</span><br><span class="line">        ValidationUtils.rejectIfEmpty(errors,<span class="string">&quot;password&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;密码不能为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>控制器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.Account;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/validator&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;account&quot;</span>,<span class="keyword">new</span> Account());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@Validated</span> Account account, BindingResult bindingResult)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>springmvc.xml 配置验证器。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountValidator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.southwind.validator.AccountValidator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">validator</span>=<span class="string">&quot;accountValidator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JSP</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: southwind</span><br><span class="line">  Date: <span class="number">2019</span>-<span class="number">03</span>-<span class="number">18</span></span><br><span class="line">  Time: <span class="number">10</span>:<span class="number">31</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;form&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;from&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form:form modelAttribute=<span class="string">&quot;account&quot;</span> action=<span class="string">&quot;/validator/login&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;form:input path=&quot;name&quot;/&gt;&lt;from:errors path=&quot;name&quot;&gt;&lt;/from:errors&gt;&lt;br/&gt;</span><br><span class="line">        密码：&lt;form:input path=&quot;password&quot;/&gt;&lt;from:errors path=&quot;password&quot;&gt;&lt;/from:errors&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>/&gt;</span><br><span class="line">    &lt;/form:form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>Annotation JSR - 303 标准</p>
</blockquote>
<h3 id="配置校验器"><a href="#配置校验器" class="headerlink" title="配置校验器"></a>配置校验器</h3><p><strong><code>springmvc.xml</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验器 ，LocalValidatorFactoryBean是spring提供的一个校验接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;validator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hibernate校验器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;providerClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.hibernate.validator.HibernateValidator&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下的ValidationMessages.properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationMessageSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;messageSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 校验错误信息配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 资源文件名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basenames&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:CustomValidationMessages<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 资源文件编码格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileEncodings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对资源文件内容缓存时间，单位秒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheSeconds&quot;</span> <span class="attr">value</span>=<span class="string">&quot;120&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong>配置的相关详细信息在文件中已经标明。</p>
<h3 id="将校验器注入到处理器适配器中"><a href="#将校验器注入到处理器适配器中" class="headerlink" title="将校验器注入到处理器适配器中"></a>将校验器注入到处理器适配器中</h3><p><strong><code>springmvc.xml</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">validator</span>=<span class="string">&quot;validator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong>这种配置方式比较简单，如果我们的适配器和映射器是分开配置的，那么在配置校验器的时候就比较麻烦：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义webBinder --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customBinder&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validator&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;validator&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 注解适配器 --&gt;</span></span><br><span class="line">    &lt;bean</span><br><span class="line">        class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;webBindingInitializer&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;customBinder&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在pojo中添加校验规则"><a href="#在pojo中添加校验规则" class="headerlink" title="在pojo中添加校验规则"></a>在pojo中添加校验规则</h3><p><strong><code>Items.java</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验名称：1到30字符，message就是校验出错的提示信息，</span></span><br><span class="line"><span class="meta">@Size(min=1, max=30, message=&quot;&#123;items.name.length.error&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Float price;</span><br><span class="line"><span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非空校验</span></span><br><span class="line"><span class="meta">@NotNull(message=&quot;&#123;items.createtime.isNull&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date createtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String detail;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong>这里我们对名字和生产日期进行了校验配置，当然校验的出错信息我们肯定不能写死，需要放在一个配置文件中。<br> <strong><code>config/CustomValidationMessages.properties</code></strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1925650-73aabdbeac051274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/458/format/webp" alt="img"></p>
<h3 id="在Controller方法中配置使用"><a href="#在Controller方法中配置使用" class="headerlink" title="在Controller方法中配置使用"></a>在Controller方法中配置使用</h3><p><strong><code>editItemsSubmit.java</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/editItemsSubmit&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItemsSubmit</span><span class="params">(Model model, HttpServletRequest request, Integer id, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Validated</span> ItemsCustom itemsCustom, BindingResult bindingResult)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取校验的错误信息</span></span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        <span class="comment">//输出错误信息</span></span><br><span class="line">        List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors();</span><br><span class="line">        <span class="keyword">for</span>(ObjectError error : allErrors)&#123;</span><br><span class="line">            <span class="comment">//输出错误信息</span></span><br><span class="line">            System.out.println(error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;allErrors&quot;</span>, allErrors);<span class="comment">//将错误信息传递到页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;items/editItems&quot;</span>;<span class="comment">//出错后回到修改页面</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    itemsService.updateItems(id, itemsCustom);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:queryItems.action&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong>在需要校验的<code>pojo</code>前面添加<code>@Validated</code>，在需要校验的<code>pojo</code>后边添加<code>BindingResult</code>来接收检验出错的信息。然后我们可以从<code>BindingResult</code>获得相关的校验错误信息，当然最后我们还需要将错误信息返回到页面中。<br> <strong>注意：</strong><code>@Validated</code>和<code>BindingResult</code>必须是配对出现的，并且形参顺序是固定的（一前一后）。</p>
<h3 id="校验错误信息在页面中展示"><a href="#校验错误信息在页面中展示" class="headerlink" title="校验错误信息在页面中展示"></a>校验错误信息在页面中展示</h3><p><strong><code>editItems.jsp</code></strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 显示错误信息 --&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;allErrors != null&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;allErrors&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;error&quot;</span>&gt;</span><br><span class="line">        $&#123;error.defaultMessage &#125;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong>这里我们直接将错误信息显示在了页面顶部。</p>
<h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在<code>pojo</code>中定义校验规则，但是<code>pojo</code>是被多个<code>Controller</code>所公用，当不同的<code>Controller</code>需要对同一个<code>pojo</code>进行校验，但是每个<code>Controller</code>方法需要不同的校验规则。<br> <strong>解决方法：</strong>定义多个校验分组（其实是一个接口），分组中定义了有哪些校验规则。每个<code>Controller</code>方法使用不同的校验分组。</p>
<h3 id="校验分组"><a href="#校验分组" class="headerlink" title="校验分组"></a>校验分组</h3><p>我们定义两个校验组，注意：校验组就是两个接口，没有任何方法，只是用来标识不同的分组。<br> <strong><code>ValidationGroup1.java</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.ssm.controller.validation;</span><br><span class="line"><span class="comment">//一个校验分组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationGroup1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接口中不需要定义任何方法，仅仅是对不同的校验规则进行分组</span></span><br><span class="line">    <span class="comment">//此分组只校验商品名称的长度</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>ValidationGroup2.java</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.ssm.controller.validation;</span><br><span class="line"><span class="comment">//一个校验分组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationGroup2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此分组校验商品名称长度和生产日期非空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在校验的pojo中添加分组"><a href="#在校验的pojo中添加分组" class="headerlink" title="在校验的pojo中添加分组"></a>在校验的pojo中添加分组</h3><p><strong><code>Items.java</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="comment">//校验名称：1到30字符，message就是校验出错的提示信息，groups标识此校验属于哪个分组，可以定义多个</span></span><br><span class="line"><span class="meta">@Size(min=1, max=30, message=&quot;&#123;items.name.length.error&#125;&quot;, groups=&#123;ValidationGroup1.class&#125;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Float price;</span><br><span class="line"><span class="keyword">private</span> String pic;</span><br><span class="line"><span class="comment">//非空校验</span></span><br><span class="line"><span class="meta">@NotNull(message=&quot;&#123;items.createtime.isNull&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date createtime;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong>可以看到我们将名字校验分在<code>ValidationGroup1</code>这个组中，当然我们可以添加多个分组，<strong>但是找了一下，没找到如何为一个校验字段添加多个分组。这里说明一下，之后再解决。</strong></p>
<h3 id="Controller方法中使用分组"><a href="#Controller方法中使用分组" class="headerlink" title="Controller方法中使用分组"></a>Controller方法中使用分组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/editItemsSubmit&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItemsSubmit</span><span class="params">(Model model, HttpServletRequest request, Integer id, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Validated(value=&#123;ValidationGroup1.class&#125;)</span> ItemsCustom itemsCustom, BindingResult bindingResult)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取校验的错误信息</span></span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        <span class="comment">//输出错误信息</span></span><br><span class="line">        List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors();</span><br><span class="line">        <span class="keyword">for</span>(ObjectError error : allErrors)&#123;</span><br><span class="line">            <span class="comment">//输出错误信息</span></span><br><span class="line">            System.out.println(error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;allErrors&quot;</span>, allErrors);<span class="comment">//将错误信息传递到页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;items/editItems&quot;</span>;<span class="comment">//出错后回到修改页面</span></span><br><span class="line">    &#125;</span><br><span class="line">    itemsService.updateItems(id, itemsCustom);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:queryItems.action&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong>这里我们可以看到在注解<code>@Validated</code>中使用<code>value</code>指定校验分组。当然这里我们可以指定多个分组，如：<code>@Validated(value=&#123;ValidGroup1.class，ValidGroup2.class &#125;)</code></p>
<p><strong>校验规则详解：</strong></p>
<p>@Null                    被注解的元素必须为null</p>
<p>@NotNull                  被注解的元素不能为null</p>
<p>@Min(value)                 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</p>
<p>@Max(value)                被注解的元素必须是一个数字，其值必须小于于等于指定的最大值</p>
<p>@Email                     被注解的元素必须是电子邮箱地址</p>
<p>@Pattern                  被注解的元素必须符合对应的正则表达式</p>
<p>@Length                   被注解的元素的大小必须在指定的范围内</p>
<p>@NotEmpty                  被注解的字符串的值必须非空</p>
<p>Null 和 Empty 是不同的结果，String str = null，str 是 null，String str = “”，str 不是 null，其值为空</p>
<hr>
<h1 id="表单标签库（作为补充前端知识）"><a href="#表单标签库（作为补充前端知识）" class="headerlink" title="表单标签库（作为补充前端知识）"></a>表单标签库（作为补充前端知识）</h1><ul>
<li>Handler</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;tag&quot;</span>);</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="number">1L</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;student&quot;</span>,student);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JSP</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: southwind</span><br><span class="line">  Date: <span class="number">2019</span>-<span class="number">03</span>-<span class="number">15</span></span><br><span class="line">  Time: <span class="number">10</span>:<span class="number">53</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;form&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;学生信息&lt;/h1&gt;</span><br><span class="line">    &lt;form:form modelAttribute=<span class="string">&quot;student&quot;</span>&gt;</span><br><span class="line">        学生ID：&lt;form:input path=<span class="string">&quot;id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        学生姓名：&lt;form:input path=<span class="string">&quot;name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        学生年龄：&lt;form:input path=<span class="string">&quot;age&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">    &lt;/form:form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>JSP 页面导入 Spring MVC 表单标签库，与导入 JSTL 标签库的语法非常相似，前缀 prefix 可以自定义，通常定义为 from。</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;form&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<p><strong>将 form 表单与模型数据进行绑定，通过 modelAttribute 属性完成绑定，将 modelAttribute 的值设置为模型数据对应的 key 值。</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">Handeler:modelAndView.addObject(<span class="string">&quot;student&quot;</span>,student);</span><br><span class="line">JSP:&lt;form:form modelAttribute=<span class="string">&quot;student&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>form 表单完成绑定之后，将模型数据的值取出绑定到不同的标签中，通过设置标签的 path 属性完成，将 path 属性的值设置为模型数据对应的属性名即可。</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">学生ID：&lt;form:input path=<span class="string">&quot;id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">学生姓名：&lt;form:input path=<span class="string">&quot;name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">学生年龄：&lt;form:input path=<span class="string">&quot;age&quot;</span>/&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="常用的表单标签"><a href="#常用的表单标签" class="headerlink" title="常用的表单标签"></a>常用的表单标签</h4><p>from</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form:from modelAttribute=<span class="string">&quot;student&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的是 HTML 中的<code>&lt;form&gt;&lt;/from&gt;</code>，通过 modelAttribute 属性绑定具体的模型数据。</p>
<p>input</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form:input path=<span class="string">&quot;name&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的是 HTML 中的 <code>&lt;input type=&quot;text&quot;/&gt;</code>，from 标签绑定的是模型数据，input 标签绑定的是模型数据中的属性值，通过 path 属性可以与模型数据中的属性名对应，并且支持及联操作。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;from:input path=<span class="string">&quot;address.name&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>password</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form:password path=<span class="string">&quot;password&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的是 HTML 中的 <code>&lt;input type=&quot;password&quot;/&gt;</code>，通过 path 属性与模型数据的属性值进行绑定，password 标签的值不会在页面显示。</p>
<p>checkbox</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form:checkbox path=<span class="string">&quot;hobby&quot;</span> value=<span class="string">&quot;读书&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.setFlag(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">checkbox：&lt;form:checkbox path=&quot;flag&quot; value=&quot;flag&quot;&gt;&lt;/form:checkbox&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的是 HTML 中的 <code>&lt;input type=&quot;checkbox&quot;/&gt;</code>，通过 path 与模型数据的属性值进行绑定，可以绑定 boolean、数组和集合。</p>
<p>如果绑定 boolean 值，若该变量的值为 true，则表示该复选框选中，否则表示不选中。</p>
<p>如果绑定数组或者集合，数组/集合中的元素等于 checkbox 的 value 值，则选中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.setHobby(Arrays.asList(<span class="string">&quot;读书&quot;</span>,<span class="string">&quot;看电影&quot;</span>,<span class="string">&quot;玩游戏&quot;</span>));</span><br><span class="line">modelAndView.addObject(<span class="string">&quot;student&quot;</span>,student);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">爱好：&lt;form:checkbox path=&quot;hobby&quot; value=&quot;摄影&quot;&gt;&lt;/form:checkbox&gt;摄影&lt;br/&gt;</span><br><span class="line">&lt;form:checkbox path=&quot;hobby&quot; value=&quot;读书&quot;&gt;&lt;/form:checkbox&gt;读书&lt;br/&gt;</span><br><span class="line">&lt;form:checkbox path=&quot;hobby&quot; value=&quot;听音乐&quot;&gt;&lt;/form:checkbox&gt;听音乐&lt;br/&gt;</span><br><span class="line">&lt;form:checkbox path=&quot;hobby&quot; value=&quot;看电影&quot;&gt;&lt;/form:checkbox&gt;看电影&lt;br/&gt;</span><br><span class="line">&lt;form:checkbox path=&quot;hobby&quot; value=&quot;旅游&quot;&gt;&lt;/form:checkbox&gt;旅游&lt;br/&gt;</span><br><span class="line">&lt;form:checkbox path=&quot;hobby&quot; value=&quot;玩游戏&quot;&gt;&lt;/form:checkbox&gt;玩游戏&lt;br/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>checkboxes</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form:checkboxes items=$&#123;student.hobby&#125; path=<span class="string">&quot;selecHobby&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的是 HTML 中的一组 <code>&lt;input type=&quot;checkbox&quot;/&gt;</code>，是对 <code>&lt;form:checkbox/&gt;</code> 的一种简化，需要结合 items 和 path 属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的集合或数组，可以这样理解，items 为全部可选集合，path 为默认的选中集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.setHobby(Arrays.asList(<span class="string">&quot;摄影&quot;</span>,<span class="string">&quot;读书&quot;</span>,<span class="string">&quot;听音乐&quot;</span>,<span class="string">&quot;看电影&quot;</span>,<span class="string">&quot;旅游&quot;</span>,<span class="string">&quot;玩游戏&quot;</span>));</span><br><span class="line">student.setSelectHobby(Arrays.asList(<span class="string">&quot;摄影&quot;</span>,<span class="string">&quot;读书&quot;</span>,<span class="string">&quot;听音乐&quot;</span>));</span><br><span class="line">modelAndView.addObject(<span class="string">&quot;student&quot;</span>,student);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">爱好：&lt;form:checkboxes path=<span class="string">&quot;selectHobby&quot;</span> items=<span class="string">&quot;$&#123;student.hobby&#125;&quot;</span>/&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 path 可以直接绑定模型数据的属性值，items 则需要通过 EL 表达式的形式从域对象中获取数据，不能直接写属性名。</p>
<p>rabiobutton</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;from:radiobutton path=<span class="string">&quot;radioId&quot;</span> value=<span class="string">&quot;0&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的是 HTML 中的一个 <code>&lt;input type=&quot;radio&quot;/&gt;</code>，绑定的数据与标签的 value 值相等则为选中，否则不选中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.setRadioId(<span class="number">1</span>);</span><br><span class="line">modelAndView.addObject(<span class="string">&quot;student&quot;</span>,student);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">radiobutton:&lt;form:radiobutton path=<span class="string">&quot;radioId&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;radiobutton&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<p>radiobuttons</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form:radiobuttons itmes=<span class="string">&quot;$&#123;student.grade&#125;&quot;</span> path=<span class="string">&quot;selectGrade&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的是 HTML 中的一组 <code>&lt;input type=&quot;radio&quot;/&gt;</code>，这里需要结合 items 和 path 两个属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的值，items 为全部的可选类型，path 为默认选中的选项，用法与 <code>&lt;form:checkboxes/&gt;</code> 一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; gradeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">gradeMap.put(<span class="number">1</span>,<span class="string">&quot;一年级&quot;</span>);</span><br><span class="line">gradeMap.put(<span class="number">2</span>,<span class="string">&quot;二年级&quot;</span>);</span><br><span class="line">gradeMap.put(<span class="number">3</span>,<span class="string">&quot;三年级&quot;</span>);</span><br><span class="line">gradeMap.put(<span class="number">4</span>,<span class="string">&quot;四年级&quot;</span>);</span><br><span class="line">gradeMap.put(<span class="number">5</span>,<span class="string">&quot;五年级&quot;</span>);</span><br><span class="line">gradeMap.put(<span class="number">6</span>,<span class="string">&quot;六年级&quot;</span>);</span><br><span class="line">student.setGradeMap(gradeMap);</span><br><span class="line">student.setSelectGrade(<span class="number">3</span>);</span><br><span class="line">modelAndView.addObject(<span class="string">&quot;student&quot;</span>,student);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">学生年级：&lt;form:radiobuttons items=<span class="string">&quot;$&#123;student.gradeMap&#125;&quot;</span> path=<span class="string">&quot;selectGrade&quot;</span>/&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<p>select</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form:select items=<span class="string">&quot;$&#123;student.citys&#125;&quot;</span> path=<span class="string">&quot;selectCity&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>渲染的是 HTML 中的一个 <code>&lt;select/&gt;</code> 标签，需要结合 items 和 path 两个属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的值，用法与 <code>&lt;from:radiobuttons/&gt;</code>一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; cityMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">cityMap.put(<span class="number">1</span>,<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">cityMap.put(<span class="number">2</span>,<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">cityMap.put(<span class="number">3</span>,<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">cityMap.put(<span class="number">4</span>,<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">student.setCityMap(cityMap);</span><br><span class="line">student.setSelectCity(<span class="number">3</span>);</span><br><span class="line">modelAndView.addObject(<span class="string">&quot;student&quot;</span>,student);</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">所在城市：&lt;form:select items=&quot;$&#123;student.cityMap&#125;&quot; path=&quot;selectCity&quot;&gt;&lt;/form:select&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<p>options</p>
<p><code>form:select</code> 结合 <code>form:options</code> 的使用，<code>from:select</code> 只定义 path 属性，在 <code>form:select</code> 标签内部添加一个子标签 <code>form:options</code> ，设置 items 属性，获取被遍历的集合。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">所在城市：&lt;form:select path=<span class="string">&quot;selectCity&quot;</span>&gt;</span><br><span class="line">  				&lt;form:options items=&quot;$&#123;student.cityMap&#125;&quot;&gt;&lt;/form:options&gt;</span><br><span class="line">				&lt;/form:select&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<p>option</p>
<p><code>form:select</code> 结合 <code>form:option</code> 的使用，<code>from:select</code> 定义 path 属性，给每一个 <code>form:option</code> 设置 value 值，path 的值与哪个 value 值相等，该项默认选中。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">所在城市：&lt;form:select path=<span class="string">&quot;selectCity&quot;</span>&gt;</span><br><span class="line">            &lt;form:option value=&quot;1&quot;&gt;杭州&lt;/form:option&gt;</span><br><span class="line">            &lt;form:option value=&quot;2&quot;&gt;成都&lt;/form:option&gt;</span><br><span class="line">            &lt;form:option value=&quot;3&quot;&gt;西安&lt;/form:option&gt;</span><br><span class="line">        &lt;/form:select&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<p>textarea</p>
<p>渲染的是 HTML 中的一个 <code>&lt;textarea/&gt;</code> ，path 绑定模型数据的属性值，作为文本输入域的默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.setIntroduce(<span class="string">&quot;你好，我是...&quot;</span>);</span><br><span class="line">modelAndView.addObject(<span class="string">&quot;student&quot;</span>,student);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">信息：&lt;form:textarea path=<span class="string">&quot;introduce&quot;</span>/&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>
<p>errors</p>
<p>处理错误信息，一般用在数据校验，该标签需要结合 Spring MVC 的验证器结合起来使用。</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学技术之电子计算机</title>
    <url>/posts/e554ef1e/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>简单了解一下组成电子计算机大脑的电子元件（<strong>控制电子流动的开关</strong>）的概念及其发展：</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>组成电子计算机大脑的电子元件（<strong>控制电子流动的开关</strong>）的发展：</p>
<p>​        继电器  –&gt;  真空管  –&gt;  晶体管</p>
</blockquote>
<h1 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a>继电器</h1><blockquote>
<p><strong>定义</strong>：用电控制的<strong>机械开关。</strong>继电器里，有根”控制线路”，控制电路是开还是关。</p>
<p>控制线路用于控制电路的开关，它连接着一个线圈，当线圈通电时，会产生感应磁场，由此能够吸引上方的金属臂，从而闭合电路，得到高电平。</p>
</blockquote>
<p>1937年最大的机电计算机之一是哈佛的马克一号，是IBM在1944年给二战同盟国建造的。该机器的大脑是由<strong>继电器（relay）</strong>构成的，存在大约3500个继电器。</p>
<p>继电器采用<strong>机械结构</strong>，机械臂本身有质量，无法快速开关。</p>
<p><strong>代表</strong>：1937年最大的机电计算机之一是<strong>哈佛</strong>的<strong>马克一号</strong>，是<strong>IBM</strong>在<strong>1944</strong>年给二战同盟国建造的。</p>
<p><strong>性能：</strong>1940年一个好的继电器1秒能翻转50次。哈佛马克一号1秒能做3次加减法运算，一次乘法需要6秒，除法需要15秒，三角函数需要一分钟以上。</p>
<p><strong>限制</strong>：</p>
<ul>
<li><strong>速度慢</strong></li>
<li>齿轮<strong>易磨损</strong></li>
<li>吸引昆虫——&gt;<strong>BUG</strong></li>
</ul>
<h1 id="三极真空管"><a href="#三极真空管" class="headerlink" title="三极真空管"></a>三极真空管</h1><p>1904 年，英国物理学家John Ambrose Fleming开发了新的电子组件——<strong>热电子管</strong>，是世界上第一个<strong>真空管</strong>。</p>
<blockquote>
<p><strong>热电子管：</strong>把两个电极装在一个气密的真空玻璃灯泡中。其中一个电极A可以加热，从而发射电子，称为<strong>热电子发射（Thermionic emission）</strong>；另一个电极B会吸引电子，来形成电流。但只有当电极B带正电时才能吸引电子，否则当电极B带负电荷或者中性电荷时，电子就无法跨越真空区域。</p>
<p><strong>真空管</strong>定义：和继电器一样，也是<strong>开关</strong>，控制电路开闭。向”控制”电极施加正电荷，则允许电子流动；施加负电荷，则组织电子流动。</p>
</blockquote>
<p>1906年，美国发明家Lee de Forest在此基础上加入了第三个控制电极。通过向控制电极施加正电荷，就能吸引电子，从而闭合电路；而通过施加负电荷，就能闭合电路。</p>
<p><strong>二极管</strong>（电流只能单向流动的电子部件）改进为<strong>三极管</strong>（加入了第三个 “控制” 电极）。</p>
<p><strong>性能：</strong>每秒可开闭数千次。</p>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>更少的磨损</strong>：真空管内部没有运动的机械部件</li>
<li><strong>每秒可以开闭数千次</strong></li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>真空管有点<strong>脆弱</strong>，容易故障（玻璃制成，易碎，且像灯泡一样会烧坏</li>
</ul>
<p><strong>真空管的出现，</strong>==<strong>标志着计算机从机电转向电子</strong>==</p>
<p><strong>代表1：</strong>第一个大规模使用真空管的计算机是<strong>巨人1号</strong>，由工程师Tommy Flowers设计并于<strong>1943</strong>年12月完工。</p>
<ul>
<li>诞生于英国的”布莱切利园”, 用于破解纳粹通信</li>
<li><strong>第一个可编程的电子计算机</strong>。但是编程的方法是把几百根电线插入插板，有点像老电话交换机</li>
<li><strong>编程麻烦，还要配置</strong>。</li>
</ul>
<p><strong>代表2：</strong> <strong>电子数值积分计算机ENIAC</strong>，在<strong>1946</strong>年于<strong>宾夕法尼亚大学</strong>设计制造</p>
<ul>
<li><strong>第一个真正的通用，可编程，电子计算机</strong></li>
<li>每秒可执行 5000 次十位数加减法</li>
</ul>
<h1 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h1><p>1947 年，发明于<strong>贝尔实验室</strong>，标志着一个全新的计算机时代的诞生</p>
<p>涉及量子力学</p>
<blockquote>
<p><strong>晶体管</strong>：类似于继电器和真空管，晶体管也是一个用于控制电路闭合断开的开关。晶体管有两个电极，这两个电极之间通过半导体材料隔开。这里通过控制连接到半导体的电极电荷数，可以控制半导体的导电性，由此来控制电流是否流动。当控制线路通电时，两个电极接通，否则两个电极断开。</p>
</blockquote>
<p>晶体管两极之间有一种材料隔开它们，这种材料有时候导电，有时候不导电，称为<strong>半导体</strong>。</p>
<p><strong>通过控制半导体材料的导电性，来控制电流的流动。</strong></p>
<p><strong>性能：</strong>每秒可开关10000次。</p>
<p><strong>优势：</strong></p>
<ul>
<li><strong>速度快：每秒可以开关 10,000 次，现在**</strong>每秒可以切换上百万次**</li>
<li><strong>可靠性高</strong>：晶体管是固态的，比起玻璃的真空管更可靠，能工作几十年</li>
<li><strong>降低了成本和大小</strong>：晶体管可以远远小于继电器或真空管，导致更小更便宜的计算机</li>
</ul>
<p><strong>代表</strong>：第一个消费者可购买的，完全由晶体管构成的计算机是<strong>1957</strong>年发布的<strong>IBM</strong> <strong>608</strong></p>
<ul>
<li>有 3000 个晶体管，每秒执行 4500 次加法</li>
<li>每秒能执行 80 次左右的乘除法</li>
</ul>
<p><strong>硅谷</strong>：很多晶体管和半导体开发在圣克拉拉谷，位于旧金山和圣河西之间，由于制造半导体最常见的材料是硅，由此这个地方被称为“硅谷”。并且William Shockley搬过去创建了<strong>肖克利半导体</strong>，里面的员工后来成立了<strong>仙童半导体</strong>，而这里面的员工后来创立了<strong>英特尔</strong>。</p>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
      <tags>
        <tag>继电器</tag>
        <tag>真空管</tag>
        <tag>晶体管</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学技术之计算机早期历史</title>
    <url>/posts/18730745/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>简单了解一下计算机的演变历史</p>
</blockquote>
<a id="more"></a>

<h1 id="计算机早期历史-Early-Computing"><a href="#计算机早期历史-Early-Computing" class="headerlink" title="计算机早期历史 Early Computing"></a><strong>计算机早期历史 Early Computing</strong></h1><p>按时间顺序：</p>
<p><strong>算盘</strong></p>
<ul>
<li>约公元前 2500 年，发明于”美索不达米亚”</li>
<li>公认<strong>最早的计算设备</strong></li>
<li>基础版算盘只是<strong>存储</strong>着当前的<strong>计算状态</strong>，类似于如今的硬盘</li>
<li>每行代表 10 的不同次方（<strong>十进制</strong>）</li>
</ul>
<p>各种巧妙的<strong>计算设备 computing devices</strong></p>
<ul>
<li>星盘：让船只可以在海上计算纬度</li>
</ul>
<p>计算尺：帮助计算乘法和除法</p>
<ul>
<li>时钟：算日出，潮汐，天体的位置，或纯粹拿来计时</li>
</ul>
<p><strong>computer</strong></p>
<ul>
<li>最早使用 “computer” 一词指计算者，即负责计算的人，指代职业</li>
</ul>
<p><strong>步进计算器</strong></p>
<ul>
<li><strong>第一台能完成 加减乘除 全部四种运算的机器</strong></li>
</ul>
<p><strong>计算表</strong></p>
<ul>
<li>类似于查字典找答案</li>
</ul>
<p><strong>差分机</strong></p>
<ul>
<li><strong>能近似多项式</strong></li>
<li>多项式描述了几个变量之间的关系，比如射程和大气压力，或者 Carrie Anne 要吃多少披萨才开心</li>
<li>多项式也可以用于近似对数和三角函数</li>
</ul>
<p><strong>分析机</strong></p>
<ul>
<li><strong>通用计算机</strong> general purpose computer（以往设备只能做特定运算）</li>
<li> 提出”<strong>自动计算机</strong>“ 的概念，计算机可以自动完成一系列操作，<strong>预示着计算机程序的诞生</strong></li>
<li>过于超前，没有建成</li>
</ul>
<p><strong>打孔卡片制表机</strong> </p>
<ul>
<li>解决美国政府在 1890 年的人口普查中面临的问题：10年一次的人口普查却要13年才要完成。</li>
<li>缩短为2年完成。</li>
<li>纸卡打孔→针穿过孔→针泡入汞→电路连通→驱动电机→齿轮使计数+1</li>
<li><strong>IBM</strong> 前身</li>
</ul>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之从二进制到CPU</title>
    <url>/posts/a6e7dd8e/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>让我们从“0”开始完成一个CPU吧</p>
</blockquote>
<a id="more"></a>

<h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><blockquote>
<p>二进制，即只用 <strong>开/关</strong> 两种状态也可以代表信息。只需要表示 true 和 false，两个值就够了。电路闭合，电流流过，代表 “真”；电路断开，无电流流过，代表”假”。</p>
</blockquote>
<p>计算机最早的是机电设备，一般使用十进制计数，比如用齿轮数来代表十进制。但是其实只用开/关两种状态已经足够表示信息了，将其称为<strong>二进制（Binary）</strong>。</p>
<p>计算机使用二进制的原因：</p>
<ul>
<li>状态越多，越难<strong>区分信号</strong>，且容易受电噪音干扰。每秒百万次变化的晶体管会让这个问题变得更糟。 只用”开”和”关”两种状态，可以尽可能减少这类问题。</li>
<li>有<strong>布尔代数</strong>这一数学分支存在，专门处理”真”和”假”，已经解决了所有法则和运算。</li>
</ul>
<h2 id="二进制原理"><a href="#二进制原理" class="headerlink" title="二进制原理"></a>二进制原理</h2><p>eg. 十进制的183，用二进制表示是10110111</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596442241118-00e3ce1a-8ca0-44ef-b39e-87670d987ebf.png" alt="image.png"></p>
<h2 id="二进制加法"><a href="#二进制加法" class="headerlink" title="二进制加法"></a>二进制加法</h2><p>eg. 十进制数183和19相加，即二进制数10110111和10011相加</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596442411028-3ebaedf5-2007-4c99-aa7d-e7b8f2e9c1b1.png" alt="image.png"></p>
<h2 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h2><p>二进制中，一个1或0称为一个<strong>位（bit）</strong>。对于8位二进制数，最小为0，最大为255。由于8位二进制数太过常见，因此将其称为<strong>字节（byte）</strong>。而32位和64位操作系统，指的是操作系统是一块块处理数据的，而每块大小是32位或者64位。</p>
<table>
<thead>
<tr>
<th>位 <strong>bit</strong></th>
<th>字节 <strong>byte</strong></th>
<th>千字节 <strong>KB</strong></th>
<th>兆字节/百万字节 <strong>MB</strong></th>
<th>千兆字节/十亿字节 <strong>GB</strong></th>
<th>太字节 <strong>TB</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1 byte = <strong>8</strong> bits</td>
<td>1 KB = <strong>1024</strong> bytes</td>
<td>1 MB = 1024 KB</td>
<td>1 GB = 1024 MB</td>
<td></td>
</tr>
</tbody></table>
<h2 id="负数的表示"><a href="#负数的表示" class="headerlink" title="负数的表示"></a>负数的表示</h2><p>大部分计算机用第一位表示正负，1 是负，0 是正，剩下的位数表示数字（32位数就是31位，64位数就是63位）</p>
<h2 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h2><p>除了负数和正数，计算机也要处理非整数，这些称为<strong>浮点数（Floating Point Numbers）</strong>，因为小数点可以在数字间浮动。有好几种表示浮点数的方法，最常见的是<strong>IEEE 754标准</strong>，它使用类似科学计数法的方法来存十进制数，比如625.9可以写成 <img src="https://www.zhihu.com/equation?tex=0.6259%5Ctimes10%5E3" alt="[公式]"> ，其中0.6259称为<strong>有效位数（Significand）</strong>，3称为<strong>指数（Exponent）</strong>。在32位浮点数中，第一位表示数字的正负，接下来的8位存储指数，剩下的23位存储有效位数</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596443948036-2aef5e7c-873b-4d8c-9b4d-6059b581aab4.png" alt="image.png"></p>
<h2 id="ASCII码——美国信息交换标准代码"><a href="#ASCII码——美国信息交换标准代码" class="headerlink" title="ASCII码——美国信息交换标准代码"></a>ASCII码——美国信息交换标准代码</h2><p>1963年发明了<strong>ASCII（美国信息交换标准代码）</strong>，当时为7位二进制数，能够存放128个不同的值，可以用来表示大小写字母、数字、标点符号等等，并且其中存储了特殊字符，比如换行符、制表符等等。</p>
<p>但是ASCII有个限制，它是为英语设计的。但是幸运的是一个字节有8位。之前的ASCII只编码了0-127中表示的字符，而128-255的字符是空着的，这些值可以给每个国家保留使用。在美国，这些额外的数字主要用于编码附加符号；在俄罗斯，他们用这些额外的字符表示西里尔字符等等。但是这种方法也存在<strong>缺点：</strong>1. 如果在土耳其电脑上打开拉脱维亚语写的电子邮件，就会出现乱码；2. 像中文和日语这种包含数千字符的语言，根本无法使用8位二进制数来表示所有字符。为了解决这个问题，每个国家发明了<strong>多字节编码方案</strong>，可以使用多个字节来编码字符，但各个国建之间的编码方案不互相兼容。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a><strong>总结</strong>:</h3><p><strong>7 位代码，可存 128 个不同值</strong></p>
<p>可以表示大、小写字母，数字，特殊符号等</p>
<p>限制：为英语设计，表示其他文字存在问题</p>
<ul>
<li><p>问题：</p>
</li>
<li><ul>
<li><ul>
<li>各个国家的标准不同，如果在 土耳其 电脑上打开 拉脱维亚语 写的电子邮件就会乱码<ul>
<li>中文和日文这样的语言有数千个字符，根本没办法用 8 位来表示所有字符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>不完全解决办法：一个字节有8位，而不是7位，128 到 255 的字符给各个国家保留使用</p>
<h2 id="UNICODE-统一码"><a href="#UNICODE-统一码" class="headerlink" title="UNICODE 统一码"></a>UNICODE 统一码</h2><p>由此出现了<strong>Unicode</strong>来统一所有编码的标准，设计于1992年，解决了不同国家不同标准的问题。最常见的Unicode是16位的，有超过一百万个位置来编码字符，编码所有语言的所有字符都足够了，并且还有位置放数学符号、Emoji等等。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul>
<li>是<strong>字符编码标准</strong>，最常见的 Unicode 是 16 位的，有超过一百万个位置，对所有语言的每个字符都够了。</li>
<li><strong>解决了ASCII码不够表达所有语言的问题</strong></li>
</ul>
<h1 id="布尔逻辑和逻辑门-Boolean-Logic-amp-Logic-Gates"><a href="#布尔逻辑和逻辑门-Boolean-Logic-amp-Logic-Gates" class="headerlink" title="布尔逻辑和逻辑门 Boolean Logic &amp; Logic Gates"></a>布尔逻辑和逻辑门 Boolean Logic &amp; Logic Gates</h1><p>使用晶体管实现门控时，可以将控制线作为<strong>输入</strong>，将底部的电极当做<strong>输出</strong>，而上端电极始终保持高电平状态。这样当输入开启时，就会使得两个电极接通，使得输出也会开启；如果输入关闭时，两个电极是断开状态，就会使得输出还是保持关闭状态。</p>
<p><img src="https://pic4.zhimg.com/80/v2-aa8e4afbad76c864b8faf94d756a1043_1440w.png" alt="img"></p>
<h2 id="布尔代数三个基本操作"><a href="#布尔代数三个基本操作" class="headerlink" title="布尔代数三个基本操作"></a>布尔代数三个基本操作</h2><h3 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h3><blockquote>
<p>NOT 操作把布尔值反转</p>
</blockquote>
<p>NOT 操作<strong>真值表</strong>：</p>
<table>
<thead>
<tr>
<th><strong>INPUT</strong></th>
<th><strong>OUTPUT</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>TRUE</strong></td>
<td>FALSE</td>
</tr>
<tr>
<td>FALSE</td>
<td><strong>TRUE</strong></td>
</tr>
</tbody></table>
<p><strong>符号：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596101654320-98cb03e0-b3a9-4946-831a-bb7d835ccea9.png" alt="image.png"></p>
<p><strong>实现：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-98e01f6c43dba82989235c181dbadef6_1440w.jpg" alt="img"></p>
<p>上方电极接通电源，下方电极接地。当输入开启时，两个电极接通，所有电流都会流向接地，所以使得输出还是关闭状态；当输入关闭时，两个电极还是断开状态，所有电流就会流向输出，使得输出为开启状态。由此就通过晶体管实现了<strong>NOT GATE</strong>。</p>
<h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><blockquote>
<p>如果 2 个输入都是 true，输出才是 true</p>
</blockquote>
<p>AND 操作<strong>真值表</strong>：</p>
<table>
<thead>
<tr>
<th><strong>INPUT A</strong></th>
<th><strong>INPUT B</strong></th>
<th><strong>OUTPUT</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>TRUE</strong></td>
<td><strong>TRUE</strong></td>
<td><strong>TRUE</strong></td>
</tr>
<tr>
<td><strong>TRUE</strong></td>
<td>FALSE</td>
<td>FALSE</td>
</tr>
<tr>
<td>FALSE</td>
<td><strong>TRUE</strong></td>
<td>FALSE</td>
</tr>
<tr>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
</tr>
</tbody></table>
<p><strong>符号：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596101717846-654480f6-e0e6-4dc2-872d-e188187fbce0.png?x-oss-process=image/resize,w_248" alt="image.png"></p>
<p><strong>实现：</strong></p>
<p>这里需要使用两个晶体管来实现<strong>AND GATE</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-52ce8f7c558649dfb96615003acf7ca6_1440w.jpg" alt="img">AND GATE</p>
<p>下方两个电极分别为两个输入，左侧电极接通电源，右侧电极为输出。当两个输入都开启时，电源和输出就会接通，使得输出开启；当任意输入关闭时，电源就不会和输出接通，使得输出保持关闭。</p>
<h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><blockquote>
<p>只有 2 个输入都是 false，OR 的结果才是 false</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>INPUT A</strong></th>
<th><strong>INPUT B</strong></th>
<th><strong>OUTPUT</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>TRUE</strong></td>
<td><strong>TRUE</strong></td>
<td><strong>TRUE</strong></td>
</tr>
<tr>
<td><strong>TRUE</strong></td>
<td>FALSE</td>
<td><strong>TRUE</strong></td>
</tr>
<tr>
<td>FALSE</td>
<td><strong>TRUE</strong></td>
<td><strong>TRUE</strong></td>
</tr>
<tr>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
</tr>
</tbody></table>
<p><strong>符号：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596101754326-effed64c-3176-4e58-ba75-886dbe60dc72.png?x-oss-process=image/resize,w_258" alt="image.png"></p>
<p><strong>实现：</strong></p>
<p>同样使用两个晶体管实现<strong>OR GATE</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-fda2d5cd50eb2f760f0a2ac72eb5efe5_1440w.jpg" alt="img"></p>
<h2 id="XOR-异或"><a href="#XOR-异或" class="headerlink" title="XOR 异或"></a>XOR 异或</h2><blockquote>
<p>想要 XOR 输出 true ，一个输入必须是 true，另一个必须是 false</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>INPUT A</strong></th>
<th><strong>INPUT B</strong></th>
<th><strong>OUTPUT</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>TRUE</strong></td>
<td><strong>TRUE</strong></td>
<td>FALSE</td>
</tr>
<tr>
<td><strong>TRUE</strong></td>
<td>FALSE</td>
<td><strong>TRUE</strong></td>
</tr>
<tr>
<td>FALSE</td>
<td><strong>TRUE</strong></td>
<td><strong>TRUE</strong></td>
</tr>
<tr>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
</tr>
</tbody></table>
<p><strong>符号：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596101899904-a8a7496e-c86d-4855-b031-865172644ba2.png" alt="image.png"></p>
<p><strong>实现：</strong></p>
<p>XOR 可由 与或非门组合而成：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596101882037-c12f65f0-6f1a-4fba-8893-50401821162d.png" alt="image.png"></p>
<h1 id="算术逻辑单元-ALU"><a href="#算术逻辑单元-ALU" class="headerlink" title="算术逻辑单元 ALU"></a>算术逻辑单元 ALU</h1><p>我们知道了如何在计算机中用二进制来表示数字，<strong>表示</strong>和<strong>存储</strong>数字是计算机的重要功能，但真正的目标是<strong>计算</strong>、有意义地处理数字，这些操作由计算机的<strong>算术逻辑单元（Arithmetic and Logic Unit，ALU）</strong>处理。ALU是计算机的数学大脑，是计算机里负责所有运算的组件，所以基本其他所有部件都会用到它。</p>
<p><strong>典型的 ALU 设备：</strong> <strong>英特尔 74181</strong>，1970年发布时，它是<strong>第一个封装在单个芯片内的完整ALU</strong>，能够处理4位输入，使用了70个逻辑门，但不能执行乘除法。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><strong>ALU 有 2 个单元：1 个算术单元和 1 个逻辑单元</strong></p>
<h3 id="算术单元"><a href="#算术单元" class="headerlink" title="算术单元"></a>算术单元</h3><ul>
<li><p><strong>负责计算机里的所有数字操作</strong>（eg. 加减法、增量运算/+1）</p>
</li>
<li><p><strong>8个基础功能</strong>：加法 ADD、带进位的加法 ADD WITH CARRY 、减法 SUBTRACT、带借位的减法 SUBTRACT WITH BORROW、取反 NEGATE、增量（+1） INCREMENT、减量（-1） DECREMENT、数字无改变通过 PASS THROUGH</p>
</li>
<li><p>简单处理器通过多次ALU（加法）实现乘法</p>
</li>
<li><p>更好的处理器有专门做乘法的算术单元</p>
</li>
</ul>
<h4 id="半加器（处理1个bit的加法，2个输入）"><a href="#半加器（处理1个bit的加法，2个输入）" class="headerlink" title="半加器（处理1个bit的加法，2个输入）"></a>半加器（处理1个bit的加法，2个输入）</h4><blockquote>
<p>半加器用来处理两个输入的加法运算，输出<code>进位(CARRY)</code>与<code>和(SUM)</code></p>
</blockquote>
<p>最简单的加法电路，就是拿2个bit加在一起。这里有两个输入A和B，以及一个输出就是这两个数字的和。<strong>注意：</strong>A、B和输出都是单个bit的。将这个结果用真值表表示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596459312165-7c6fbde6-7ddf-4908-8da2-465f98a5be34.png" alt="image.png"></p>
<p>可以发现和XOR操作的真值表相同，所以可以把XOR门用作<strong>1位加法器（1-bit adder）。</strong></p>
<p>但其中一个特殊的结果是 <img src="https://www.zhihu.com/equation?tex=1+1=10" alt="[公式]"> ，其中存在进位，而使用XOR门的输出只能表示加法的结果，还需要另一个电路表示进位的结果，可以发现其真值表和ADN门真值表相同，所以可以使用AND门来表示进位，称为<strong>半加器（Half adder）</strong>。</p>
<p>用 AND，OR，NOT 和 XOR 逻辑门构建半加器电路：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596459338587-1d558cc2-2033-4f3a-aa5b-25d9525f9aaf.png" alt="image.png"></p>
<p>由于半加器是比较基础的部件，所以可以将其抽象成一个单独部件，其中有两个输入，并且输出相加后的总和和进位。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596459545541-62496618-6ea6-43a9-9e55-d2f761c5a27a.png" alt="image.png"></p>
<h4 id="全加器（处理1个bit的加法，3个输入）"><a href="#全加器（处理1个bit的加法，3个输入）" class="headerlink" title="全加器（处理1个bit的加法，3个输入）"></a>全加器（处理1个bit的加法，3个输入）</h4><blockquote>
<p>全加器用来处理3个输入的加法运算（两个加数 + 上一级传过来的进位）</p>
</blockquote>
<p>如果想要处理多位二进制数加法时，就需要<strong>全加器（Full Adder）</strong>，因为半加器计算完当前位的结果后，会输出进位，意味着计算下一位的结果时，要将两个输入以及前一位的进位相加。我们可以得到全加器的真值表</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596459784121-b5f7e598-882c-47ec-b2c6-18101d9fa98c.png?x-oss-process=image/resize,w_610" alt="image.png"></p>
<p>我们这里可以使用半加器来实现全加器。我们可以将一个半加器结果当做是INPUT A 和INPUT B相加后的结果，然后将SUM当做是新的INPUT A，而PRE CARRY当做是新的INPUT B输入到新的半加器中，可以发现其SUM结果和全加器SUM结果相同。而全加器的CARRY只要对这两个半加器的CARRY进行OR运算就可以了。（<strong>注意：</strong>这两个半加器不会同时出现进位）</p>
<p>用半加器和逻辑门构建全加器：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596459891787-24d6064c-0e50-42df-8beb-40a8a68cd679.png?x-oss-process=image/resize,w_778" alt="image.png"></p>
<p>同样我们也可以对全加器进行抽象，得到一个包含三个输入和两个输出的独立部件：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596460061870-a082aded-a73e-4eaf-a6b7-db3f19ab7e51.png" alt="image.png"></p>
<p>由此我们可以进行两个8位数字相加，表示为A和B</p>
<ol>
<li>对A和B的第一位进行相加时，由于不存在进位，所以值使用一个半加器就能实现，这个半加器的SUM就为该位的结果，CARRY就为进位。</li>
<li>后续的7位二进制相加，由于每一个都涉及了上一位的进位，所以后续需要7个全加器，并且每个全加器的CARRY要连接到下一个全加器的输入，而每个全加器的SUM就为该位的结果。</li>
<li>最后一个全加器有CARRY的输出，如果该CARRY为1，就表示相加结果太大了，超出了8位，所以出现了<strong>溢出（overflow）</strong>。</li>
</ol>
<blockquote>
<p><strong>溢出：</strong>一般来说 “溢出” 的意思是, 两个数字的和太大了，超过了用来表示的位数，这会导致错误和不可预期的结果。</p>
</blockquote>
<h4 id="由此，我们就构建出了一个8位加法器（8-bit-adder）（处理8bit加法，1个半加器-7个全加器）"><a href="#由此，我们就构建出了一个8位加法器（8-bit-adder）（处理8bit加法，1个半加器-7个全加器）" class="headerlink" title="由此，我们就构建出了一个8位加法器（8-bit adder）（处理8bit加法，1个半加器 + 7个全加器）"></a>由此，我们就构建出了一个<strong>8位加法器（8-bit adder）</strong>（处理8bit加法，1个半加器 + 7个全加器）</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596460359723-0a114112-c769-429d-b00b-6f3e6556566c.png?x-oss-process=image/resize,w_1492" alt="image.png"></p>
<p>通过连接1个半加器和n-1个全加器，就能构建n位加法器。通过叠加更多的加法器，能够避免溢出的出现，但是会出现更多的逻辑门，而且每次进位都要一些时间，而计算是串行的，所以消耗的时间也越长，到如今的每秒几十亿次运算时就会造成影响，所以现代计算机用的加法电路有所不同，称为<strong>超前进位加法器（Carry-Look-Ahead Adder）。</strong></p>
<p><strong>ALU通常支持以下操作：</strong>加法、带进位的加法、减法、带借位的减法、取反、增1、减1、数字无改变通过。这些操作也是由逻辑门构成的。<strong>注意：</strong>简单的ALU并不支持乘法，而是把乘法用多次加法来实现，而更好的处理器有专门做乘法的算数单元。</p>
<h3 id="逻辑单元"><a href="#逻辑单元" class="headerlink" title="逻辑单元"></a>逻辑单元</h3><ul>
<li>逻辑单元<strong>执行逻辑操作</strong>，eg. AND，OR 和 NOT 操作；做简单的数值测试，比如判断一个数字是不是负数</li>
<li>example：检测数字是否为0的电路：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596461230955-35c5bc84-07cb-44ab-bd8a-3f9d5828ffe0.png" alt="image.png"></p>
<h2 id="ALU-符号"><a href="#ALU-符号" class="headerlink" title="ALU 符号"></a>ALU 符号</h2><p>对整个8位ALU进行抽象，用一个特殊的V形符号进行表示。其中有两个<strong>8位输入</strong>，并且有一个4位<strong>操作码（Operation Code）</strong>来告诉ALU对输入执行什么操作，比如1000表示加法命令，1100表示减法命令，然后有一个<strong>8位输出</strong>。同时ALU会输出一系列1位<strong>标志（FLAG）</strong>，来表示特定状态，比如我们可以计算A-B，然后通过ZERO来判断结果是否为零来判断A与B是否相等，通过NEGATIVE来判断A是否小于B；然后OVERFLOW连接到加法器的进位，来判断是否出现溢出。</p>
<p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596461447760-4e30373e-c5b4-418d-a96a-fe34e47788b1.png?x-oss-process=image/resize,w_838" alt="image.png"></strong></p>
<p>利用ALU输出的flag，可以用来检测是否溢出、是否相等、是否小于等</p>
<h1 id="随机存储器（RAM，即内存）"><a href="#随机存储器（RAM，即内存）" class="headerlink" title="随机存储器（RAM，即内存）"></a>随机存储器（RAM，即内存）</h1><p><strong>存储（memory）</strong>分为<strong>随机存储器（RAM，即内存）</strong>和<strong>持久存储（persistent memory）</strong>，前者只能在有电的情况下存储东西，后者则在电源关闭时也不会丢失数据。</p>
<p>接下来我们将从实现 只能存储 1 位的电路开始，逐步扩大（抽象、套娃），最后制作出<strong>内存</strong>模块。</p>
<h2 id="锁存器-Gated-Latch-存-1-位"><a href="#锁存器-Gated-Latch-存-1-位" class="headerlink" title="锁存器 Gated Latch - 存 1 位"></a>锁存器 Gated Latch - 存 1 位</h2><h3 id="OR-门-记录‘1’的电路"><a href="#OR-门-记录‘1’的电路" class="headerlink" title="OR 门 - 记录‘1’的电路"></a>OR 门 - 记录‘1’的电路</h3><p>之前构建的都是单向电路，我们同样可以构建回向电路，把输出连回输入。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596542718222-7034a5e8-616b-41f9-90fe-daa249a2ad46.png?x-oss-process=image/resize,w_726" alt="image.png"></p>
<p>当将OR门构建成回向电路时，可以分析其电路特性</p>
<ol>
<li>A和B初始为0时，输出结果为0</li>
<li>将A修改为1时，输出结果为1，此时B的输入就变为了1。随后输出始终保持为1，不论A如何变化。</li>
</ol>
<p>所以这个电路能够<strong>永久记录1</strong>，并且无法将1变回0。</p>
<h3 id="AND-门-记录‘0’的电路"><a href="#AND-门-记录‘0’的电路" class="headerlink" title="AND 门 - 记录‘0’的电路"></a>AND 门 - 记录‘0’的电路</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596542813502-59371aab-a73a-4758-97d1-62902864cf1b.png" alt="image.png"></p>
<p>当将OR门构建成回向电路时，可以分析其电路特性</p>
<ol>
<li>A和B初始为0时，输出结果为0</li>
<li>将A修改为1时，输出结果为1，此时B的输入就变为了1。随后输出始终保持为1，不论A如何变化。</li>
</ol>
<p>所以这个电路能够永久记录1，并且无法将1变回0。</p>
<h3 id="AND-OR-锁存器"><a href="#AND-OR-锁存器" class="headerlink" title="AND-OR 锁存器"></a>AND-OR 锁存器</h3><p>所以我们就得到了能够存储1和0的电路，为了得到有用的Memory，需要将两个电路结合起来，可以得到<strong>AND-OR锁存器（AND-OR Latch）</strong>，上方的是SET输入，下方的是RESET输入，当SET=1、RESET=0，就能将输出设置为1，当RESET=1，就能将输出设置为0，当SET=0、RESET=0，则输出最后放入的内容。由此能够存储1位的信息（该信息存储在OR门上方的输入电极中）！</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596542983455-40ecffa7-5d01-46bb-ad1c-df01fb0c0de6.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th><strong>设置 SET</strong></th>
<th><strong>复位 RESET</strong></th>
<th><strong>输出 OUTPUT</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>输出最后放入的内容，即存储了 1 位内容</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>技巧：</strong>当OR门其中一个输入为0，或AND门其中一个输入为1，则相当于另一个输入直接穿过这个门。当OR门其中一个输入为1，则直接输出1；当AND门其中一个门为0，则直接输出0。</p>
</blockquote>
<p>这叫”锁存”, 因为它”锁定”了一个值，放入数据的动作叫 “写入” ，拿出数据的动作叫 “读取”。</p>
<h3 id="门锁-GATED-LATCH"><a href="#门锁-GATED-LATCH" class="headerlink" title="门锁 GATED LATCH"></a>门锁 GATED LATCH</h3><p>为了更易用，将 SET 和 RESET 两条输入线合为一条<strong>数据输入线</strong>（将锁存器设为0 或 1来存储值），另外增加一条<strong>允许写入线</strong>来启用内存，启用时允许写入，不启用则锁定。修改后电路图如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596543687157-aa4df334-5fc9-403b-a7ad-694c434e77e9.png" alt="image.png"></p>
<p>其中DATE INPUT表示数据输入，WRITE ENABLE表示允许写入线，用来控制是否保存当前输入的数据。对这个电路进行分析。</p>
<ol>
<li><p>当WRITE ENABLE=1时，电路可以化简为以下形式。当数据输入为0时，AND门可以忽略OR门的输出，直接输出0，并且OR门上方电极也将保存0。当数据输入为1时，相当于忽略了AND门，OR门的输出直接和OUTPUT相连，OR门输出1，并且OR门上方电极也将保存1。所以，<strong>当WRITE ENABLE=1时，数据输入会直接传到输出，而且数据输入会保存在OR门的上方电极，进行数据存储。</strong></p>
</li>
<li><p>当WRITE ENABLE=0时，电路可化简为以下形式。此时能够忽略AND门，直接将OR门的输出当做OUTPUT，而OR门的输出其实就是上方电极的数据，由于上方电极就是当前OUTPUT的数据，所以会保持OUTPUT不变。所以，<strong>当WRITE ENABLE=0时，会忽略数据输入，保持OUTPUT不变。</strong></p>
</li>
</ol>
<p>可以将门锁进行<strong>抽象</strong>，得到一个能够存储一个bit的部件。当允许写入线为0时，输出保持不变，当允许写入线为1时，输出就是数据输入，并且能够将数据输入进行存储。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596544119899-efb3ebb3-8f91-46b7-b596-47e6743a12df.png" alt="image.png"></p>
<h2 id="寄存器-Register-存-N-位"><a href="#寄存器-Register-存-N-位" class="headerlink" title="寄存器 Register - 存 N 位"></a>寄存器 Register - 存 N 位</h2><p><strong>定义</strong>：将 N 个锁存器组合，即可存储 N 位信息，这样一组锁存器称为<strong>寄存器</strong>。</p>
<p>寄存器能存一个数字，这个数字有多少位，叫 <strong>位宽</strong>。</p>
<p>早期电脑用 8 位寄存器，然后是 16 位，32 位，而现在许多计算机都有 64 位宽的寄存器。</p>
<h3 id="并排排放"><a href="#并排排放" class="headerlink" title="并排排放"></a>并排排放</h3><p>写入寄存器之前，要先启动里面所有的锁存器，可以将所有锁存器的允许写入线都连接在一起，把它设为1，然后用8条数据线发送数据，然后将允许写入线设回0，就能将8位数据存储在寄存器中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596544679422-5a19f2f6-0cd7-4538-9935-060ac677ee6b.png" alt="image.png"></p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>如果使用并排排放锁存器的方式，要存储 256 位，寄存器就需要连接 513 根线（256条输入，256条输出，1条启用写入线），过于庞大。解决办法就是使用<strong>矩阵</strong>。</p>
<p>在<strong>矩阵</strong>中，不再并列排放锁存器，而是以网格的形式排放。</p>
<p>如下图所示是一个 16 × 16 的矩阵，能存储256位，但一共只需要连接 35 条线（16条行线、16条列线用于选择相应的锁存器，还有 1 条数据线， 1 条公用的启用写入线，1 条允许读取线）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596545502440-4bcd5a96-49af-45ac-839c-5e44ac42789a.png" alt="image.png"></p>
<p>要启用某个锁存器十就打开相应的行线和列线</p>
<h4 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h4><p>使用矩阵，我们需要指定行和列。针对以上 16 ×16 的门锁矩阵，需要 4bits 表示行地址，4bits 表示列地址。</p>
<p>eg. 12 行 8 列表示为：1100 1000。</p>
<p>为了将地址转化为行和列，要用到 <strong>2 个多路复用器，一个用于处理行，一个用于处理列</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596546284888-df300797-d236-4200-8fe1-e6b57a21d831.png" alt="image.png"></p>
<p>将以上 256 位内存看作一个整体，提升一层<strong>抽象</strong>，如下图所示。输入一个 8 位地址：4 位代表列，4 位代表行。还有 1 条数据线， 1 条允许写入线，1 条允许读取线。（<strong>注意：每次只能选择一个锁存器，所以数据线只能读写1bit数据</strong>）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596546701434-f1ef5677-dc1f-4275-b168-fb7514b4ab77.png" alt="image.png"></p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>对其再进步一扩展，可以将8个256位内存拼在一起，这样就<strong>能一次读写8bit数据</strong>，也就是一个字节数据。由于每个256位内存都使用相同的8位数据线，因此8位数据会存在每个256位内存的相同地址中，并且第一个256位内存存放第一位，第二个256位内存存放第二位，以此类推。这个模块可以在256个地址中存储256个字节。<strong>（由于这种设计，所以计算机中以一个字节为寻址的最小单位）</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596546937449-4a59346f-d273-4a61-8ab4-33afeb8e1bd7.png" alt="image.png"></p>
<p>可以对其进行抽象，看成一个整体的<strong>可寻址内存</strong>，其中有256个地址，每个地址能读写一个字节的值。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596547304699-7f0bfcd4-321e-4372-998b-12a407488c0f.png" alt="image.png"></p>
<p><strong>内存的一个重要特性是：可以随时访问任何位置，因此叫 “随机存取存储器” ，简称 RAM。</strong></p>
<blockquote>
<p>RAM中存储的数据是保存在OR门其中一个电极上，所以断电后就无法保存。</p>
</blockquote>
<p>通过一层层的抽象（俄罗斯套娃），可以把内存打包到更大规模</p>
<p>我们用锁存器做了一块<strong>静态随机存取存储器（Static Random-Access Memory，SRAM）</strong>，还有很多其他类型的RAM，比如DRAM、闪存和NVRAM，它们的功能和SRAM相似，但是使用不同的电路存放单个位。但是根本上，这些技术都是矩阵层层嵌套来存储大量信息。</p>
<p>现代计算机可以在此基础上将内存扩展到MB和GB级别。我们这里使用8个16x16门锁矩阵可以得到256字节的内存，然后可以用4位表示行4位表示列来进行寻址，由此可以将门锁矩阵扩展到更大范围，但是需要更多位来表示地址。所以对于nxn门锁矩阵，存储空间为 <img src="https://www.zhihu.com/equation?tex=n%5E2" alt="[公式]"> 字节，需要的寻址空间为 <img src="https://www.zhihu.com/equation?tex=n%5E2" alt="[公式]">。比如要给千兆字节的内存寻址，就需要32位的地址。</p>
<h1 id="中央处理器-CPU-The-Central-Processing-Unit-CPU"><a href="#中央处理器-CPU-The-Central-Processing-Unit-CPU" class="headerlink" title="中央处理器(CPU) The Central Processing Unit(CPU)"></a>中央处理器(CPU) The Central Processing Unit(CPU)</h1><p>将我们之前实现好的ALU和RAM组合在一起，就能组建计算机的心脏——<strong>中央处理单元（Central Processing Unit，CPU）</strong></p>
<p>CPU负责执行程序，而程序由一个个操作组成，这些操作称为<strong>指令（Instruction）</strong>，用来指示计算机要做什么。如果是数学指令，比如加减，CPU就会让ALU进行数学运算；如果是内存指令，CPU就会和内存通信，然后读写值。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li><p><strong>程序</strong>：由一条条<strong>指令</strong>组成。程序存储在内存中。</p>
</li>
<li><p><strong>指令</strong>：指示计算机要做什么。</p>
</li>
<li><p>如下图所示是一张<strong>指令表</strong>，假设 8 位指令，前 4 位代表操作码，指向相应的指令；后 4 位代表数据来自哪里，可以是寄存器或内存地址。</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596615187481-8dc6d121-9a9a-44e7-a28b-ba458aee3621.png" alt="image.png"></p>
<ul>
<li><p><strong>CPU的功能</strong>：中央处理单元，与RAM配合，<strong>负责执行程序</strong>。</p>
</li>
<li><p><strong>数学指令</strong>（eg. 加/减）：CPU 让 ALU 进行数学运算</p>
</li>
<li><p><strong>内存指令</strong>：CPU 和内存进行通信，然后读/写值</p>
</li>
<li><p><strong>微体系架构</strong>：把重点放在功能，而不是一根根线具体怎么连，当我们用一条线连接两个组件时，这条线只是所有必须线路的一个抽象，这种高层次视角叫  “<strong>微体系架构</strong>“。</p>
</li>
</ul>
<h2 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h2><p><strong>寄存器</strong>：用来 <strong>临时存数据 和 操作数据</strong></p>
<ul>
<li><strong>通用寄存器</strong>：存储任意数据</li>
<li><strong>指令地址寄存器</strong>/<strong>指令计数器</strong>：存放当前指令的内存地址（追踪程序运行到哪里了）。能自动形成下一条指令的地址（+1）</li>
<li><strong>指令寄存器</strong>：存储指令</li>
</ul>
<p><strong>运算器 ALU</strong>：负责算数和逻辑运算</p>
<ul>
<li><p><strong>控制器/控制单元</strong>：控制整个 CPU 的工作，保证 程序的正确执行 以及 能够处理异常事件。</p>
</li>
<li><p>eg. 指令解码由控制单元的逻辑电路完成。</p>
</li>
<li><p><strong>包含 指令地址寄存器 和 指令寄存器 等</strong>。</p>
</li>
</ul>
<p><strong>时钟</strong>：负责管理CPU的节奏</p>
<ul>
<li><p>时钟以精确的间隔触发电信号，控制单元会用这个信号，推进 CPU 的内部操作，确保一切按步骤进行。</p>
</li>
<li><p>CPU “取指令→解码→执行” 中每一步的时间为一个周期，每一步的速度叫 “<strong>时钟速度</strong>“，单位是<strong>赫兹</strong>，代表 多少个周期每秒。</p>
</li>
<li><p>eg. 6 分钟 4 条指令，每条指令包含取指令、解码、执行这 3 个周期，则时钟速度为 4 × 3 / 360 = 0.033 赫兹</p>
</li>
<li><p><strong>超频</strong>：加快时钟速度，提升性能</p>
</li>
<li><p><strong>降频</strong>：减慢时钟速度，省电</p>
</li>
<li><p><strong>动态调整频率</strong>：很多现代处理器可以按需求  加快或减慢时钟速度</p>
</li>
</ul>
<p>将以上组件提升一层新的<strong>抽象</strong>，变成一个独立的 CPU 组件，如下图所示。</p>
<p>RAM 是在 CPU 外面的独立组件，CPU 和 RAM 之间用 “地址线”  “数据线” 和 “允许读/写线” 进行通信。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596620628301-45ea1c24-0d1a-43f7-b116-bbdc6a9560aa.png?x-oss-process=image/resize,w_1492" alt="image.png"></p>
<h1 id="CPU-执行指令的流程"><a href="#CPU-执行指令的流程" class="headerlink" title="CPU 执行指令的流程"></a>CPU 执行指令的流程</h1><blockquote>
<p>取指令  –&gt;  解码  –&gt;  执行</p>
</blockquote>
<h2 id="取指令阶段-FETCH-PHASE"><a href="#取指令阶段-FETCH-PHASE" class="headerlink" title="取指令阶段 FETCH PHASE"></a>取指令阶段 FETCH PHASE</h2><p>取指令阶段负责拿到指令。</p>
<ul>
<li><p>首先，指令地址寄存器连接到 RAM。</p>
<blockquote>
<p>由于当我们启动计算机时，所有寄存器从0开始，所以指令地址寄存器中的值为0，将指令地址寄存器与RAM的地址线相连，然后开启RAM的允许读取线，就能使得RAM返回地址0中保存的值，并且将RAM的数据线和指令寄存器相连，就能将存放到指令寄存器中。</p>
</blockquote>
</li>
<li><p>若当前指令地址寄存器中存储的指令地址为address，则RAM返回address对应的值（指令），并复制到指令寄存器</p>
</li>
</ul>
<p>如下图所示，初始时，各个寄存器初始值都为0，因此RAM返回地址0对应的值。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596616068373-9a0b17d2-23a4-4c56-bbfd-66022522978e.png?x-oss-process=image/resize,w_1492" alt="image.png"></p>
<h2 id="解码阶段-DECODE-PHASE"><a href="#解码阶段-DECODE-PHASE" class="headerlink" title="解码阶段 DECODE PHASE"></a>解码阶段 DECODE PHASE</h2><ul>
<li>将指令寄存器中的指令参照指令表</li>
</ul>
<p>这里的例子，指令前四位代表操作码，后四位代表数据来源（内存或寄存器地址）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596616976387-8b02601f-869e-4c1f-ba3e-9b4ca24bc954.png?x-oss-process=image/resize,w_1492" alt="image.png"></p>
<p><strong>指令解码由控制单元（Control Unit）进行</strong>。可通过简单的逻辑门电路对指令进行解码，如下图所示。不同的指令由不同的逻辑电路解码。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596617109711-1450db2c-566e-4da0-b153-42a3bb5d238b.png?x-oss-process=image/resize,w_732" alt="image.png"></p>
<h2 id="执行阶段-EXECUTE-PHASE"><a href="#执行阶段-EXECUTE-PHASE" class="headerlink" title="执行阶段 EXECUTE PHASE"></a>执行阶段 EXECUTE PHASE</h2><p>以指令 0010 1110 为例，该指令操作码是0010，解码为 LOAD_A 指令：</p>
<ul>
<li>用”检查是否 LOAD_A 指令的电路”，可以打开 RAM 的 “允许读取线”</li>
<li>把地址 14（1110） 传给 RAM</li>
<li>用 “检查是否 LOAD_A 指令的电路” 启用寄存器 A 的 “允许写入线”</li>
<li>把 RAM 地址 14 的值存储到寄存器A中</li>
<li>指令执行结束，<strong>指令地址寄存器中的地址 +1</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596617938534-6928702f-f485-4bb9-b34a-ee89e9f54aab.png?x-oss-process=image/resize,w_1492" alt="image.png"></p>
<p>以指令 1000 0100 为例，该指令操作码是1000，解码为 ADD 指令；第一个地址是 01, 代表寄存器B，第二个地址是 00, 代表寄存器A。该指令代表把寄存器 B 的值，加到寄存器 A 里：</p>
<ul>
<li>启用寄存器 B（寄存器地址01），作为 ALU 的第一个输入</li>
<li>启用寄存器 A（寄存器地址00），作为 ALU 的第二个输入</li>
<li>传递 ADD 操作码给 ALU，使 ALU 明确其要进行的是加法操作</li>
<li>控制单元用一个自己的寄存器暂时保存结果 0001 0001（3+4=17）</li>
<li>关闭 ALU，然后把值写入正确的寄存器 A 。（先保存到控制单元的临时寄存器，关闭ALU后再写入寄存器A，否则会不断和自己相加）</li>
<li><strong>指令地址 + 1</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596618833588-96289e30-a4bf-485e-8643-dc9cb55ec78a.png?x-oss-process=image/resize,w_1492" alt="image.png"></p>
<p>所以控制单元必须传递ADD操作码告诉它要做什么</p>
<p>以指令 0100 1101 为例，该指令操作码是0100，解码为 STORE_A 指令：</p>
<ul>
<li>打开 RAM 的允许写入线</li>
<li>把地址 13（1101） 传给 RAM</li>
<li>打开寄存器 A 的 “允许读取线”</li>
<li>把寄存器 A 里的值，传给 RAM，保存到 RAM 地址 13</li>
<li><strong>指令地址 + 1</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596619378433-732fea03-3c49-4fb2-a1da-450a6972958a.png?x-oss-process=image/resize,w_1492" alt="image.png"></p>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>逻辑门</tag>
        <tag>ALU</tag>
        <tag>RAM</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学技术之指令和程序</title>
    <url>/posts/5d7c338d/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>CPU之所以强大，是因为它是可编程的，如果写入不同指令，就会执行不同任务，所以CPU是一块可以被软件控制的硬件</p>
</blockquote>
<a id="more"></a>

<h1 id="CPU-指令集"><a href="#CPU-指令集" class="headerlink" title="CPU 指令集"></a>CPU 指令集</h1><blockquote>
<p><strong>指令集</strong>，就是CPU中用来计算和控制计算机系统的一套指令的集合。而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。</p>
</blockquote>
<p>这里假定一个简单的指令集，进行说明。这里假设的 CPU 很基础，所有指令都是 8 位，前四位代表操作码，后四位代表内存地址或寄存器编号。</p>
<table>
<thead>
<tr>
<th><strong>指令 INSTRUCTION</strong></th>
<th><strong>描述</strong></th>
<th><strong>内存地址或寄存器</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LOAD_A</td>
<td>从 RAM 中读取并加载到寄存器 A</td>
<td>4-bit RAM 地址</td>
</tr>
<tr>
<td>LOAD_B</td>
<td>从 RAM 中读取并加载到寄存器 B</td>
<td>4-bit RAM 地址</td>
</tr>
<tr>
<td>STORE_A</td>
<td>将寄存器 A 的内容保存到 RAM</td>
<td>4-bit RAM 地址</td>
</tr>
<tr>
<td>ADD</td>
<td>将两个寄存器的值相加，结果保存到第二个寄存器</td>
<td>2-bit 寄存器 ID，2-bit 寄存器 ID</td>
</tr>
<tr>
<td>SUB</td>
<td>将两个寄存器的值相减，结果保存到第二个寄存器</td>
<td>2-bit 寄存器 ID，2-bit 寄存器 ID</td>
</tr>
<tr>
<td>JUMP</td>
<td>更新指令地址寄存器中的指令地址，即跳转到新地址</td>
<td>4-bit memory 地址</td>
</tr>
<tr>
<td>JUMP_NEG</td>
<td>如果 ALU 的结果是负的，则更新指令地址寄存器中的指令地址（跳转到新地址）</td>
<td>4-bit memory 地址</td>
</tr>
<tr>
<td>HALT</td>
<td>程序运行结束，CPU<strong>停止</strong>运行。</td>
<td>NA</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注</strong>：指令和数据都是存在同一个内存里的，它们在根本层面上毫无区别（都是二进制数）。因此，HALT 指令很重要，能区分指令和数据，让 CPU 停止运行。</p>
</blockquote>
<p>举个例子，如下图所示的保存了一些指令和数据的RAM，其中将操作码根据指令集转换成了对应的指令。首先，指令地址寄存器初始化为0，所以控制单元会先从RAM中地址为0处获取指令并保存在指令寄存器中，LOAD_A 14是将RAM中14处的数据保存在寄存器A中，所以当前寄存器A中保存了数据1，然后指令地址寄存器+1，由此执行下一条指令；LOAD_B 15是将RAM中15处的1保存在寄存器B中；ADD B A是使用ALU将寄存器B中的数据加到寄存器A中，所以当前寄存器A中数据为2；STORE_A 13是将寄存器A中的数据保存在RAM 13处；JUMP 2表示将2覆盖指令地址寄存器，所以当前指令地址寄存器指向ADD B A，就是将寄存器B中的数据再加到寄存器A中，所以当前寄存器A中的数据为3，然后又执行STORE_A 13将寄存器A中的数据保存在RAM 13处。反复执行上述过程，就是对寄存器A中的数据不断+1，并且结果不断刷新在RAM 13处，从未停止，这个称为<strong>无限循环（Infinite Loop）</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1596700067072-7d78d66b-ca2f-44f2-b8f9-ba1533738891.png?x-oss-process=image/resize,w_1192" alt="image.png"></p>
<p>我们这里假设的CPU十分简单，一个指令长度只有8位，操作码4位说明最多只支持16中指令，而地址位只有4位，说明最多只能索引到RAM中的16位，这具有很大的局限性。</p>
<p>目前真正的现代CPU采用两种策略：</p>
<ol>
<li>最直接的方法就是用更多位来代表指令，比如32位或64位，这个称为<strong>指令长度（Instruction Length）</strong>，说明一个指令要跨越多个字节。</li>
<li>另一种策略可以使用<strong>可变长度指令（Variable Length Instruction）</strong>。比如某个CPU用8位操作码，因为内存中每个地址保存一个字节，而指令地址寄存器保存的是该指令最小地址，并且操作码刚好是一个字节，所以指令地址寄存器保存的是操作码的地址，所以CPU最先看到的信息就是操作码，所以CPU可以根据操作码的类型，来决定是否要读取后续字节来确定指令内容。比如CPU看到HALT指令，因为HALT指令不需要其他额外的数据，所以CPU就会马上执行HALT指令；如果看到了JUMP，因为该操作码需要知道需要跳转到的地址，而这个值就在JUMP后面，这个称为<strong>立即值（Immediate Value）</strong>，CPU就会读取这立即值来知道跳转的地址。通过这样设计，指令可以是任意长度的，但是会让读取阶段复杂一些</li>
</ol>
<blockquote>
<p>一般来说，指令=操作码+操作值地址，比如LOAD_A 10表示的是将RAM 10中保存的数据加载到寄存器A中。当指令=操作码+操作值时，该操作值就称为<strong>立即值</strong>，不需要在RAM中索引出对应的操作值，比如JUMP 2，这里直接跳转到RAM 2处，所以这个2称为立即值。总之，不需要从RAM中索引出操作值就能使用的称为立即值。</p>
</blockquote>
<p>在Intel 4004中，它支持46个指令，使用8位立即值来执行JUSMP，所以可以表示更多的内存地址。处理器从1971年至今，现代CPU比如Intel Core i7含有上千个指令和指令变体，长度从1到15字节。</p>
<p><img src="https://pic3.zhimg.com/v2-4b875c844248119e0daa74576011811e_r.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之高级CPU设计</title>
    <url>/posts/bd281c41/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>早期计算机的提速方式是减少晶体管的切换时间，因为晶体管是门、ALU和之前介绍的所有部件的基础，但是这种提速方法最终会遇到瓶颈。所以处理器厂商发明各种新技术来提升性能，不但让简单指令运行更快，也让它能进行更复杂的运算</p>
</blockquote>
<a id="more"></a>

<h1 id="早期计算机提速方式"><a href="#早期计算机提速方式" class="headerlink" title="早期计算机提速方式"></a>早期计算机提速方式</h1><p>早期，通过<strong>减少晶体管的切换时间</strong>，来提升 CPU 速度。</p>
<ul>
<li><strong>晶体管</strong>组成了逻辑门，ALU 以及其他组件</li>
<li>碰到了<strong>瓶颈</strong></li>
</ul>
<h1 id="提升-CPU-性能的新技术"><a href="#提升-CPU-性能的新技术" class="headerlink" title="提升 CPU 性能的新技术"></a>提升 CPU 性能的新技术</h1><p>提升 CPU 性能，不但让简单指令运行更快，也让它能进行更复杂的运算。</p>
<h2 id="专门电路处理复杂操作（复杂度-vs-速度的平衡）"><a href="#专门电路处理复杂操作（复杂度-vs-速度的平衡）" class="headerlink" title="专门电路处理复杂操作（复杂度 vs 速度的平衡）"></a>专门电路处理复杂操作（复杂度 vs 速度的平衡）</h2><p>现代 CPU 直接<strong>在硬件层面设计了除法</strong>，可以直接给 ALU 除法指令</p>
<ul>
<li><strong>缺点</strong>：让 <strong>ALU 更大也更复杂</strong>一些</li>
<li><strong>优点</strong>：但是<strong>运算速度更快</strong>（用一连串减法代替除法的操作要多个时钟周期，很低效）</li>
</ul>
<p>现代处理器有<strong>专门电路来处理图形操作</strong>, 游戏、解码压缩视频, 加密文档 等等</p>
<ul>
<li><strong>优点</strong>：<strong>速度快</strong>，而如果用标准操作来实现，要很多个时钟周期</li>
<li><strong>缺点</strong>：指令不断增加，人们一旦习惯了它的便利就很难删掉，所以为了兼容旧指令集，指令数量越来越多</li>
</ul>
<blockquote>
<p>基于标准操作用软件方式构建的方法，通常需要若干个时钟周期，而通过关键专门的电路可以进行提速。</p>
</blockquote>
<p>为了兼容旧指令集，指令数量变得越来越多。第一个集成CPU Intel 4004有46条指令，但现代处理器有上千条指令，有各种巧妙复杂的电路。</p>
<h2 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 Cache"></a>缓存 Cache</h2><blockquote>
<p>问题引入：超高的时钟速度带来另一个问题，<strong>如何快速传递数据给 CPU</strong>？</p>
<p>——<strong>给 CPU 加缓存</strong></p>
</blockquote>
<p>RAM是独立于CPU的一个组件，CPU和RAM之间通过<strong>总线（Bus）</strong>相连（包含地址总线、数据总线、允许写入线、允许读取线等等），虽然这个总线通常只有几厘米，并且电信号的传输速度接近光速，但是对于超高的时钟速度，很小的延迟也会造成问题。并且RAM还需要时间找地址、取数据、配置输出数据等等，所以一条“从内存读取数据”的指令可能需要很多个时钟周期（因为目前时钟速度相对于读取RAM速度快很快），此时CPU就会空等数据。</p>
<p>以上解决延迟的方法之一就是给CPU加一个小的RAM，称为<strong>缓存（Cache）</strong>。因为CPU中的space不大，所以缓存一般只有KB或者MB，而RAM一般都是GB起步的。使用缓存能够提高速度。当CPU从RAM加载数据时，RAM不用传单独一个数据，而是传一批数据，然后将这批数据保存在缓存中。这种读取方式很实用，因为数据通常都是一个个按顺序处理的，这样CPU就可以先访问缓存来加载下一数据，因为缓存离CPU比较近，所以一个时钟周期就能找到数据，这样CPU就不用空等，这比反复去RAM读取数据快很多。</p>
<blockquote>
<p><strong>局部性原理：</strong>是指CPU访问RAM时，无论是存取指令还是存取数据，所访问的位置都趋于聚集在一个较小的连续区域中。<br>         <strong>为什么速度会更快：</strong>因为像RAM这种GB级别的存储器，如果使用性能更好造价更贵的部件，成本太高，而使用像缓存这种只有KB或MB级别的存储器，完全可以使用性能更好的部件，所以从缓存中读取数据会更快。并且根据局部性原理，下一个数据有很大可能会在缓存中，所以保证了CPU通常会从缓存中读取数据。</p>
</blockquote>
<h3 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h3><ul>
<li>提高数据存取速度，更快喂给 CPU </li>
<li><strong>解决CPU运算速率与内存读写速率不匹配的矛盾</strong></li>
</ul>
<h3 id="缓存工作的原则"><a href="#缓存工作的原则" class="headerlink" title="缓存工作的原则"></a>缓存工作的原则</h3><p><strong>缓存工作的原则</strong>，就是“引用的<strong>局部性</strong>”，这可以分为<strong>时间局部性和空间局部性</strong>。</p>
<p>CPU 从 RAM 拿数据时， RAM 不只传一个，可以传一批，虽然花的时间久一点，但数据可以存在缓存加快之后的访问速度。以 计算餐馆销售额 为例：算餐厅的当日收入，先取 RAM 地址 100 的交易额。RAM 与其只给 1 个值，不如直接把地址 100 到 200 的一批值都复制到缓存,当处理器要下一个交易额时，交易额原本存储在 RAM 地址 100，但现在已经存储在缓存中，就不需要去 RAM 中取了.缓存离 CPU 近, 一个时钟周期就能给数据；而去 RAM 读取数据可能要多个时钟周期,因此，从缓存中读取数据，比反复去 RAM 拿数据快得多，让 CPU 不用空等</p>
<p>如果想要的数据已经在缓存中，叫<strong>缓存命中（Cache Hit）</strong>，如果想要的数据不在缓存中，叫<strong>缓存未命中（Cache Miss）</strong>。并且缓存也可以当<strong>临时空间</strong>，存一些中间值，适合长/复杂的运算，这样不但存起来更快，而且如果还要用这个中间值继续计算时，取值也会更快。</p>
<p><strong>问题：缓存和 RAM 不一致</strong></p>
<p>缓存中保存的RAM的副本和RAM中真实的数据不一致了。这些不一致必须记录下来，之后还要<strong>同步</strong>，因此缓存中每块空间都有一个特殊标记，称为<strong>脏位（Dirty Bit）</strong>。同步通常发生在缓存满了，而CPU又需要新的缓存时。在清理缓存腾出空间之前，会先检查脏位，如果是脏的，则在加载新内容之前，会将数据写回RAM。</p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>另一种提升性能的方法叫<strong>指令流水线（Instruction Pipelining）</strong>，可以通过<strong>并行处理（Paralleize）</strong>来进一步提高效率。</p>
<h3 id="并行处理-parallelize"><a href="#并行处理-parallelize" class="headerlink" title="并行处理 parallelize"></a>并行处理 parallelize</h3><p>假设指令执行分为 3 个阶段：取指 → 解码 → 执行。</p>
<ul>
<li>若按序处理：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1597481827805-0996b918-c1af-4fc4-9293-6daeed54148f.png" alt="image.png"></p>
<ul>
<li>并行处理：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1597481874070-bd453462-fc27-4405-8d82-cb2b2c0933da.png" alt="image.png"></p>
<p>可以看到，使用并行处理，每个阶段利用 CPU 的不同部分，不同任务重叠进行，同时用上 CPU 里不同部分。这样的流水线，使得指令吞吐量 x 3，但并行处理也带来了两个主要问题：</p>
<h3 id="问题一：指令之间的依赖关系——-gt-乱序执行"><a href="#问题一：指令之间的依赖关系——-gt-乱序执行" class="headerlink" title="问题一：指令之间的依赖关系——&gt;乱序执行"></a>问题一：指令之间的依赖关系——&gt;乱序执行</h3><p>但是并行处理也存在问题，第一个问题是<strong>指令之间的依赖关系</strong></p>
<p>eg. 第二条指令读某个数据，而并行正在执行的第一条指令会改这个数据，那并行执行第二条指令的话，这个数据还没被改，也就是说拿的是旧数据。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案：</strong></h4><p>弄清数据依赖性，必要时停止流水线，避免出问题。</p>
<h5 id="乱序执行-out-of-order-execution"><a href="#乱序执行-out-of-order-execution" class="headerlink" title="乱序执行 out-of-order execution"></a><strong>乱序执行 out-of-order execution</strong></h5><ul>
<li>定义：高端 CPU，比如笔记本和手机里那种，会更进一步，动态排序 有依赖关系的指令，最小化流水线的停工时间，即<strong>乱序执行</strong></li>
<li>缺点：这种电路非常复杂</li>
<li>优点：流水线非常高效，几乎所有现代处理器都实现了流水线</li>
</ul>
<h3 id="问题二：条件跳转——-gt-推测执行-amp-分支预测"><a href="#问题二：条件跳转——-gt-推测执行-amp-分支预测" class="headerlink" title="问题二：条件跳转——&gt;推测执行 &amp; 分支预测"></a>问题二：条件跳转——&gt;推测执行 &amp; 分支预测</h3><p>另一个问题是<strong>条件跳转（Conditional Jump Instructions）</strong>，这些指令会改变程序的执行流。</p>
<h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a><strong>解决方案</strong>：</h4><p>简单的流水线处理器，看到 JUMP 指令会停一会儿，等待条件值确定下来，再继续流水线。缺点：造成延迟</p>
<h5 id="推测执行-speculative-execution"><a href="#推测执行-speculative-execution" class="headerlink" title="推测执行 speculative execution"></a><strong>推测执行 speculative execution</strong></h5><p>可以把 JUMP 想成是 “岔路口”，高端 CPU 会猜哪条路的可能性大一些，然后提前把指令放进流水线，这叫 “推测执行”</p>
<h5 id="分支预测-branch-prediction"><a href="#分支预测-branch-prediction" class="headerlink" title="分支预测 branch prediction"></a><strong>分支预测 branch prediction</strong></h5><p>推测执行如果如果 CPU 猜错了，就要清空流水线。为了尽可能减少清空流水线的次数，CPU 厂商开发了复杂的方法，来猜测哪条分支更有可能，叫”分支预测”</p>
<h2 id="优化-1-个指令流的吞吐量"><a href="#优化-1-个指令流的吞吐量" class="headerlink" title="优化 1 个指令流的吞吐量"></a>优化 1 个指令流的吞吐量</h2><h3 id="超标量处理器"><a href="#超标量处理器" class="headerlink" title="超标量处理器"></a>超标量处理器</h3><p>如果只有一个单核 CPU ，且 CPU 中各个部件（例如 ALU、缓存等）只有一套，则使用流水线时，理想情况下，一个时钟周期完成 1 个指令。而<strong>超标量处理器</strong>，使得一个时钟周期完成多个指令。</p>
<p><strong>原理理解</strong>：即便有流水线设计，在指令执行阶段，处理器里有些区域还是可能会空闲。比如，执行一个 “从内存取值” 指令期间，ALU 会闲置。所以一次性处理多条指令（取指令+解码） 会更好，如果多条指令要 ALU 的不同部分，就多条同时执行。</p>
<h3 id="多个相同电路-部件（eg-ALU）"><a href="#多个相同电路-部件（eg-ALU）" class="headerlink" title="多个相同电路/部件（eg. ALU）"></a>多个相同电路/部件（eg. ALU）</h3><p> 超标量处理其更进一步，加多几个相同的电路执行出现频次很高的指令，eg. 很多 CPU 有四个, 八个甚至更多 完全相同的 ALU ，可以同时执行多个数学运算。</p>
<h2 id="同时运行多个指令流"><a href="#同时运行多个指令流" class="headerlink" title="同时运行多个指令流"></a>同时运行多个指令流</h2><h3 id="多核-CPU"><a href="#多核-CPU" class="headerlink" title="多核 CPU"></a>多核 CPU</h3><p>目前提升性能的方法都是只有一个指令流，另一个提升性能的方法是同时运行多个指令流，这需要使用<strong>多核处理器（Multi-core Processors）</strong>，四核处理器意味着一个CPU芯片内，有多个独立处理单元，并且它们之间可以共享一些资源，比如缓存，使得多核之间可以合作运算。</p>
<h3 id="多个独立-CPU"><a href="#多个独立-CPU" class="headerlink" title="多个独立 CPU"></a>多个独立 CPU</h3><p>如果多核不够，可以用多个CPU，2个或4个CPU是最常见的，但是现在的需求更大，所以出现了<strong>超级计算机（Supercomputer）</strong>，中国无锡的国家超算中心，神威·太湖之光有40960个CPU，每个CPU有256个核，每个核心的频率为1.45GHz，每秒可进行9.3亿亿次浮点数运算，也称为<strong>浮点运算次数（Floating Point Math Operations Per Second，FLOPS）</strong>。</p>
<h3 id="超级计算机"><a href="#超级计算机" class="headerlink" title="超级计算机"></a>超级计算机</h3><p>如果要做怪兽级运算，比如模拟宇宙形成，你需要强大的计算能力，给普通台式机加几个 CPU 没什么用。需要成千上万个 CPU ！</p>
<p>神威·太湖之光有 40960 个CPU，每个 CPU 有 256 个核心，总共超过1千万个核心，每个核心的频率是 1.45GHz，每秒可以进行 9.3 亿亿次浮点数运算，也叫 每秒浮点运算次数 (FLOPS)。</p>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之编程语言发展史</title>
    <url>/posts/fa7f2f9/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>本文将简要介绍程序如何进入计算机以及编程语言的发展历史</p>
</blockquote>
<a id="more"></a>

<h1 id="早期计算机的编程方式"><a href="#早期计算机的编程方式" class="headerlink" title="早期计算机的编程方式"></a>早期计算机的编程方式</h1><blockquote>
<p>打孔纸卡  –&gt;  插线板   –&gt;  面板拨开关</p>
</blockquote>
<h2 id="打孔纸卡-Punched-card"><a href="#打孔纸卡-Punched-card" class="headerlink" title="打孔纸卡 Punched card"></a>打孔纸卡 Punched card</h2><h3 id="打孔纸卡的来源"><a href="#打孔纸卡的来源" class="headerlink" title="打孔纸卡的来源"></a>打孔纸卡的来源</h3><h4 id="打孔纸卡在纺织业的应用"><a href="#打孔纸卡在纺织业的应用" class="headerlink" title="打孔纸卡在纺织业的应用"></a><strong>打孔纸卡在纺织业的应用</strong></h4><p>在计算机出现之前，纺织业就有了给机器（纺织机）编程的需求（用来绘制图案）,通过纸卡特定位置是否穿孔，决定线的高低,为了让每行图案不同，纸卡连成长条，就形成了连续指令。<strong>雅卡尔织布机</strong>是最早的编程</p>
<h4 id="打孔纸卡在人口普查中的应用"><a href="#打孔纸卡在人口普查中的应用" class="headerlink" title="打孔纸卡在人口普查中的应用"></a><strong>打孔纸卡在人口普查中的应用</strong></h4><p>打孔纸卡用于 1890 年美国人口普查,一张卡存一个人的信息，包含种族、婚姻状况、子女数量等，针对每个问题，在对应位置打孔,卡片插入汇总机，孔会让对应的总和值 +1</p>
<ul>
<li><strong>早期汇总机只用于汇总数据，操作时固定的，不能编程，因此不算计算机</strong>。</li>
<li><strong>当时的打孔纸卡只用于存储数据，而不是程序</strong></li>
</ul>
<h3 id="打孔纸卡的优点"><a href="#打孔纸卡的优点" class="headerlink" title="打孔纸卡的优点"></a>打孔纸卡的优点</h3><p>打孔纸卡便宜、可靠、也易懂</p>
<h2 id="插线板-Plug-board"><a href="#插线板-Plug-board" class="headerlink" title="插线板 Plug board"></a>插线板 Plug board</h2><h3 id="插线板的来源"><a href="#插线板的来源" class="headerlink" title="插线板的来源"></a>插线板的来源</h3><p><strong>起源</strong>：上面说到打孔纸卡在人口普查中的应用，但当时的汇总机只用于汇总数据，而不能编程；之后的 60 年，这些机器被加强，不仅可以做汇总（加法），还可以做减、乘、除甚至这些机器还可以做一些小决定，决定何时执行某指令，为了正确执行不同计算，程序员需要某种控制面板；控制面板上有很多小插孔，程序员可以插电线，让机器的不同部分互相传数据和信号，因此也叫 <strong>插线板</strong></p>
<p><strong>发展：</strong>上面提到程序员通过插电线，让机器的不同部分互相传数据和信号，这意味着运行不同程序要重新接线；<strong>为了让编程更方便</strong>，到 1920 年代，控制面板变成了<strong>可拔插</strong>，对插线板进行不同的插线，就相当于给计算机编入不同的程序（<strong>编程</strong>）</p>
<p><strong>缺点</strong>：插线板编程复杂，线一团乱</p>
<p>​       <img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1597652017074-4802211c-e6a6-485d-b124-8393229f2343.png" alt="image.png"></p>
<ul>
<li>1946 年，第一台通用电子计算机 ENIAC 诞生，用了一大堆插线板</li>
<li>由于插线板编程极为复杂，程序在纸上设计好之后，给 ENIAC 连线，最多可能花三个星期</li>
<li>早期计算机非常昂贵，停机几个星期只为换程序，完全无法接受</li>
</ul>
<h3 id="冯诺依曼结构-amp-内存"><a href="#冯诺依曼结构-amp-内存" class="headerlink" title="冯诺依曼结构 &amp; 内存"></a>冯诺依曼结构 &amp; 内存</h3><h4 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a><strong>冯诺依曼结构</strong></h4><p>上面提到，插线板编程的复杂性，急需更快、更灵活的新方式来编程，到 1940 年代晚期 1950 年代初，<strong>内存</strong>价格下降, 容量上升；<strong>与其把程序存在插线板，不如存储在内存中</strong>，<strong>程序易于修改、方便 CPU 快速读取</strong>；这类机器叫 “<strong>存储程序计算机</strong>“</p>
<ul>
<li><strong>定义</strong>：<strong>把</strong> <strong>程序</strong> <strong>和</strong> <strong>数据</strong> <strong>都存在一个地方（内存）</strong>，叫冯诺依曼结构</li>
<li><strong>标志</strong>：<strong>处理器（包含 ALU） + 数据寄存器 + 指令寄存器 + 指令地址寄存器 + 内存（存储数据和指令）</strong></li>
</ul>
<p>第一台冯诺依曼架构的”储存程序计算机”：宝宝，曼彻斯特大学，1948</p>
<h4 id="内存-打孔纸卡（类似于外存）"><a href="#内存-打孔纸卡（类似于外存）" class="headerlink" title="内存 + 打孔纸卡（类似于外存）"></a><strong>内存 + 打孔纸卡（类似于外存）</strong></h4><p>前面提到可以用<strong>内存代替插线板存储程序和数据。但是程序和数据依旧需要某种方式输入计算机，所以还是需要用到打孔纸卡。同时，程序运行结果也可以输出到打孔纸卡</strong>。到1980年代，几乎所有的计算机都有打孔纸卡读取器，可以吸入一张卡片，把卡片内容写进内存。如果放了一叠卡片，读取器会一个个写进内存。一旦程序和数据写入完毕，电脑会开始执行。</p>
<p>用纸卡的最大型程序，是美国空军的 SAGE 防空系统，于 1955 年完成，顶峰时期 雇佣了世上 20% 程序员，主控制程序用了 62500 张穿孔纸卡</p>
<ul>
<li><strong>缺点</strong>：即便简单程序也有几百条指令，要用一叠纸卡来存。如果不小心摔倒弄撒了，要花上几小时、几天、甚至几周来整理</li>
<li><strong>发展</strong>：打孔纸卡——&gt;纸袋——&gt;更先进的存储方式（硬盘, 只读光盘, DVD, U盘等）</li>
</ul>
<h2 id="面板编程-Panel-programming"><a href="#面板编程-Panel-programming" class="headerlink" title="面板编程 Panel programming"></a>面板编程 Panel programming</h2><h3 id="面板编程"><a href="#面板编程" class="headerlink" title="面板编程"></a>面板编程</h3><ul>
<li>用一大堆开关和按钮，代替插线板的一堆插线</li>
<li>面板上有指示灯，代表各种函数的状态和内存中的值</li>
</ul>
<h3 id="Altair-8800——第一款取得商业成功的家用计算机"><a href="#Altair-8800——第一款取得商业成功的家用计算机" class="headerlink" title="Altair 8800——第一款取得商业成功的家用计算机"></a>Altair 8800——第一款取得商业成功的家用计算机</h3><ul>
<li>大多数家庭用户负担不起昂贵的外围设备 ，比如穿孔纸卡读取器。因此，早期家用计算机，大量使用了开关</li>
<li>组件版 Altair 8800 售价极低，在 1975 年卖 400 美元左右，相当于 2017 年的 2000 美元</li>
<li>为了给 8800 编程，需要拨动面板上的开关，输入二进制操作码，然后按 “存储键” 把值存入内存；然后会到下一个内存位置，你可以再次拨开关，写下一个指令；重复这样做，把整个程序都写入内存之后，可以推动开关，回到内存地址0，然后按运行按钮，灯会闪烁</li>
</ul>
<h2 id="早期编程的缺点"><a href="#早期编程的缺点" class="headerlink" title="早期编程的缺点"></a>早期编程的缺点</h2><p>早期编程需要非常了解底层硬件，比如操作码, 寄存器等, 才能写程序，需要专家才能完成；因此编程很难、很烦，哪怕工程师和科学家都无法 完全发挥计算机的能力；因此，需要一种更简单的编程方式，告诉计算机要做什么——编程语言</p>
<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="二进制-机器码"><a href="#二进制-机器码" class="headerlink" title="二进制/机器码"></a>二进制/机器码</h2><p>计算机只能理解并处理二进制（即 0 和 1 ），二进制是计算机的母语（CPU 可以直接执行机器码）；因此，在计算机早期阶段，必须用二进制（<strong>机器语言（Machine Language）</strong>或<strong>机器码（Machine Code）</strong>）来编写程序，程序员<strong>先</strong>在纸上<strong>写伪代码</strong>，<strong>然后</strong>再按照“操作码表”手工<strong>将伪代码转换成二进制机器码</strong></p>
<ul>
<li>缺点：很麻烦</li>
</ul>
<h2 id="汇编语言-助记符"><a href="#汇编语言-助记符" class="headerlink" title="汇编语言/助记符"></a>汇编语言/助记符</h2><p>在1940-1950年，程序员开发出一种新语言，更可读、更高层次，每个操作码分配一个简单名字，称为<strong>助记符（Mnemonics）</strong>，助记符后跟数据，形成完整的指令。所以与其写0和1的机器码，程序员可以直接写“LOAD_A 14”，这个语言称为<strong>汇编语言（Assembly Language）</strong>。</p>
<ul>
<li><strong>优点</strong>：更高层次，更可读，更易理解</li>
<li><strong>缺点</strong>：汇编和底层硬件连接很紧密，一般来说一条汇编指令对应一条机器指令。也就是说汇编只是修饰了一下机器码，但仍然强迫程序员思考用什么寄存器和内存，因此编写和改动代码都很麻烦，也很冗长</li>
</ul>
<h3 id="汇编器-Assmebler"><a href="#汇编器-Assmebler" class="headerlink" title="汇编器 Assmebler"></a>汇编器 Assmebler</h3><ul>
<li><strong>功能</strong>：将<strong>汇编语言</strong>自动<strong>转</strong>换成计算机能理解的<strong>机器码</strong>（二进制指令）</li>
</ul>
<h2 id="A-0-——-一个高级编程语言"><a href="#A-0-——-一个高级编程语言" class="headerlink" title="A-0 —— 一个高级编程语言"></a>A-0 —— 一个高级编程语言</h2><p>汇编只是修饰了一下机器码，一般来说，一条汇编指令对应一条机器指令，所以汇编码和底层硬件连接很密切，程序员仍需要思考使用什么寄存器和内存地址。为了释放电脑的潜力，海军军官 Grace 设计了一个高级编程语言，叫做Arithmetic Language Version 0，简称A0。</p>
<h3 id="编译器-Compiler"><a href="#编译器-Compiler" class="headerlink" title="编译器 Compiler"></a>编译器 Compiler</h3><p>一行高级编程语言，可能转换成几十条二进制指令。为此做到这种复杂转换，霍普在1952年创造了第一个<strong>编译器（Compiler）</strong>，编译器专门把高级语言转换成低级语言（比如汇编或机器码）。由此，高级编程语言就不用管寄存器或内存位置，编译器会解决这些细节。</p>
<p><strong>功能</strong>：将<strong>高级语言转</strong>换成<strong>低级语言（汇编语言或者机器码）</strong>。一行高级编程语言  可能会转成几十条二进制指令</p>
<h2 id="FORTRAN"><a href="#FORTRAN" class="headerlink" title="FORTRAN"></a>FORTRAN</h2><ul>
<li><strong>全称</strong>：Formula Translation，即 公式翻译</li>
<li><strong>来源</strong>：IBM，1957.</li>
<li><strong>优点</strong>：高级编程语言，使得编程更容易。主宰了早期计算机编程。平均来说，FORTRAN 写的程序，比等同的手写汇编代码短 20 倍</li>
</ul>
<blockquote>
<p>FORTRAN 项目总监 John Backus 说过：“我做的大部分工作都是因为懒，我不喜欢写程序，所以我写这门语言，让编程更容易”</p>
</blockquote>
<ul>
<li><strong>缺点</strong>：最初 FORTRAN 代码只能跑在 IBM 计算机上，如果更换计算机，可能要重新所有代码</li>
</ul>
<h2 id="COBAL"><a href="#COBAL" class="headerlink" title="COBAL"></a>COBAL</h2><p>在1950年，大多数编程语言和编译器只能运行在一种计算机中，如果更换计算机，就要重写所有代码，因此1959年开发一种通用编程语言，可以在不同机器上通用，最后诞生了一门高级、易于使用的语言<strong>普通面向商业语言（Common Business-Oriented Language，COBOL）</strong>。为了兼容不同底层硬件，每个计算机架构需要一个COBOL编译器，由此无论运行的计算机是什么，这些编译器可以接收相同的COBOL代码。如今大多数编程语言都是如此，不必接触CPU特有的汇编码和机器码。</p>
<ul>
<li><strong>优点</strong>：通用编程语言，可以在不同机器上通用</li>
<li><strong>特点</strong>：为了兼容不同底层硬件，每个计算架构需要一个 COBOL 编译器，这些编译器都可以接收相同 COBOL 代码，转换成各个计算机能识别执行的机器码，即”<strong>一次编写，到处运行</strong>“</li>
</ul>
<h2 id="新编程语言的发展"><a href="#新编程语言的发展" class="headerlink" title="新编程语言的发展"></a>新编程语言的发展</h2><ul>
<li>1960年代：ALGOL, LISP 和 BASIC</li>
<li>1970年代：Pascal，C 和 Smalltalk</li>
<li>1980年代：C++，Objective-C 和 Perl</li>
<li>1990年代：Python，Ruby 和 Java</li>
<li>2000+：Swift, C#, Go</li>
</ul>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之集成电路和摩尔定律</title>
    <url>/posts/c26da57a/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p><strong>摩尔定律（Moore’s Law）</strong>：每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍量的晶体管</p>
</blockquote>
<a id="more"></a>

<p>过去计算机的飞速发展，强烈依赖于硬件的发展。</p>
<h1 id="分立元件——电子计算机的诞生年代"><a href="#分立元件——电子计算机的诞生年代" class="headerlink" title="分立元件——电子计算机的诞生年代"></a>分立元件——电子计算机的诞生年代</h1><p>大约1940年代-1960年代中期，计算机都由独立部件组成，称为<strong>分立元件（Discrete Components）</strong>，然后不同组件再用线连在一起。比如ENIAC有1万7千多个真空管，7万个电阻，1万个电容，7千个二极管，5百万个手工焊点。</p>
<p><strong>数字暴政：</strong>使用分立元件，如果想提升计算机性能，就要添加更多部件，这导致更多的线路，更加复杂，很难做，这个问题称作 <strong>数字暴政</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598445671613-7d566081-5079-45e5-a0f5-20f68f0a3005.png" alt="image.png"></p>
<h1 id="晶体管——计算-2-0-时代"><a href="#晶体管——计算-2-0-时代" class="headerlink" title="晶体管——计算 2.0 时代"></a>晶体管——计算 2.0 时代</h1><p><strong>晶体管</strong></p>
<ul>
<li><strong>时间</strong>：1950 年代中期，晶体管开始商业化（市场上买得到），开始用在计算机里</li>
<li><strong>优点</strong>：晶体管比电子管 <strong>更小更快更可靠</strong>。<strong>晶体管标志着”计算 2.0 时代”的到来</strong>。</li>
<li><strong>缺点</strong>：<ul>
<li>晶体管<strong>依然是分立元件</strong>，依旧**没有解决没有解决”数字暴政”**的问题。</li>
<li>有几十万个独立元件的计算机不但难设计，而且难生产。1960 年代，这个问题的严重性达到顶点，电脑内部常常一大堆电线缠绕在一起。</li>
</ul>
</li>
</ul>
<p><strong>实例</strong>：1959年，IBM 把 709 计算机从原本的电子管全部换成了晶体管，诞生的新机器 IBM 7090  速度快 6 倍，价格只有一半</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598446190326-41fb10ca-028b-4aee-a7a9-039628966085.png" alt="image.png"></p>
<h1 id="集成电路-IC——计算-3-0-时代"><a href="#集成电路-IC——计算-3-0-时代" class="headerlink" title="集成电路 IC——计算 3.0 时代"></a>集成电路 IC——计算 3.0 时代</h1><p>到1960年代，上述问题的严重性达到顶点，解决方法就是引入一层新抽象，封装复杂性。突破性进展在1958年，与其把多个独立部件用电线连起来，拼装出计算机，我们把多个组件包在一起，变成一个新的独立组件，这个称为<strong>集成电路（Integrated Circuits，IC）</strong>。</p>
<p><strong>起源与发展</strong>：</p>
<ul>
<li>1958年，在德州仪器工作的 Jack Killby 演示了一个电子部件，将电路的所有组件都集中在一起，集成电路取得突破性进展。不过，Kilby 当时用锗来做集成电路，而锗很稀少而且不稳定。</li>
<li>1959年，Robert Noyce领导的<strong>仙童半导体公司</strong>用硅做集成电路，让集成电路成为现实。硅的蕴藏量丰富，占地壳四分之一，也更稳定可靠。Noyce 被公认为<strong>现代集成电路之父</strong>，开创了<strong>电子时代</strong>，创造了<strong>硅谷</strong>。</li>
<li>起初，一个 IC 只有几个晶体管。不过，即使只有几个晶体管，也可以把简单电路（eg.第三集介绍的逻辑门）封装成单独组件</li>
</ul>
<p><strong>意义</strong>：集成电路的出现，广泛用于制作微处理器，开启了<strong>计算 3.0 时代</strong>。</p>
<h2 id="印刷电路板-PCB"><a href="#印刷电路板-PCB" class="headerlink" title="印刷电路板 PCB"></a>印刷电路板 PCB</h2><p>起初，一个IC只有几个晶体管，但是也足以将逻辑门封装成独立组件，可以组合出无数种设计，但是最终还是要连起来，创造出更大更复杂的电路，比如计算机。所以创造出了<strong>印刷电路板（Printed Circuit Boards，PCB）</strong>，可以大规模生产，无需焊接或用一堆线，它通过蚀刻金属线的方式将零件连接到一起。<strong>把PCB和IC结合使用，可以大幅减少独立组件和电线，但做到相同的功能，而且更小更便宜更可靠。</strong></p>
<p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598449474733-fc6c7566-b56d-42b5-8ec7-925f66f9b511.png" alt="PCB.png"></strong></p>
<h3 id="光刻"><a href="#光刻" class="headerlink" title="光刻"></a>光刻</h3><p><strong>实现：</strong></p>
<ol>
<li><p>我们从一片硅开始，称为<strong>晶圆（Wafer）</strong>，长得和薄饼干一样。并且硅是半导体，有时导电有时不导电，我们就可以控制导电时机，所以硅是做晶体管的绝佳材料。我们可以用晶圆做基础，把复杂金属电路放上去，来集成所有东西。</p>
</li>
<li><p>在硅片顶部加一层薄薄的<strong>氧化层（Oxide Layer）</strong>作为保护层，然后加一层特殊化学品称为<strong>光刻胶（Photoresist）</strong>，光刻胶被光照射后，就变得可溶，可以用一种特殊化学药剂洗掉。然后我们会在光刻胶上加一层<strong>光掩膜（Photomask）</strong>，当用强光照射时，挡住光的部分光刻胶就不会变化，而光照射到的地方，光刻胶就会发生化学变化，洗掉变化的光刻胶后，就会暴露出部分氧化层。然后通常用酸能洗掉氧化层暴露出的部分，就能蚀刻到硅层。然后再用另一种化学试剂清洗掉剩余的光刻胶，这样只剩下氧化层和晶圆了。我们想修改硅暴露出来的区域，让它们导电性更好，所以我们使用<strong>掺杂（Doping）</strong>，通过将磷渗透进暴露的硅，来改变电学性质。</p>
</li>
<li><p>我们还需要几轮光刻法来做晶体管。还是叠加上氧化层、光刻胶和新的光掩膜，这样就能在掺杂区域上方开缺口，然后进行清洗蚀刻，再用另一种元素进行掺杂，把硅转换成另一种形式。为了控制深度，时机很重要，不要超过之前掺杂的区域，这样所有需要的组件都有了。</p>
</li>
<li><p>最后，在氧化层上做通道，这样可以用细小金属导线连接不同晶体管。首先用光刻胶和光掩膜，在氧化层上蚀刻出小通道。然后用新的处理方法称为<strong>金属化（Metalization）</strong>，在氧化层上放一层薄薄的金属，比如铝或铜，再加上光刻胶和光掩膜，然后融掉暴露的光刻胶，暴露出金属。最终清洗，只保留晶圆、氧化层和金属化，这样就做出了一个晶体管。它有三根线分别连接着硅的三个不同区域，每个区域的掺杂方式不同，这个叫<strong>双极型晶体管（Bipolar Junction Transistor）</strong>。</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598449188753-d301d826-73c2-460c-856f-f6e83477e18f.png" alt="image.png"></p>
<p><strong>发展</strong>：</p>
<ul>
<li>1960 年代中期，市场上开始出现超过 100 个晶体管的 IC</li>
<li><strong>Intel 4004，第一个用 IC 做的处理器</strong>，也叫微型处理器，有2300个晶体管</li>
<li>1980年，出现包含 3 万晶体管的 IC</li>
<li>1990年，出现包含 100 万晶体管的 IC</li>
<li>2000年，出现包含 3000 万晶体管的 IC</li>
<li>2010年，出现包含 10 亿晶体管的 IC</li>
<li>为了达到这种密度，光刻的分辨率从大约 一万 纳米（大概是人类头发直径的 1/10），发展到如今的 14 纳米（比血红细胞小 400 倍）</li>
</ul>
<p><strong>应用</strong>：CPU，内存、显卡、固态硬盘、摄像头感光元件等大多数电子器件都呈指数式发展</p>
<p>相同方法，光刻可以在一片硅上制作其他电子元件，比如电阻电容，而且相互连接的电路也做好了。</p>
<p>并且通过调节光掩膜和光源之间的距离，光可以投射成任意角度，我们可以把光掩膜聚焦到极小的区域，制作出非常精细的细节，这样一片晶圆就能做出很多IC，整块都做完后，就可以切割然后包进微型芯片中，芯片的核心都是一小片IC。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598449245677-7b643475-d9af-4e89-a669-a72512d8c72a.png" alt="image.png"></p>
<h1 id="超大规模集成-VLSI-软件——计算-3-0-时代"><a href="#超大规模集成-VLSI-软件——计算-3-0-时代" class="headerlink" title="超大规模集成(VLSI)软件——计算 3.0 时代"></a>超大规模集成(VLSI)软件——计算 3.0 时代</h1><p>现代工程师设计电路时，不可能人力手工一个个设计晶体管。1970年代开始，超大规模集成(VLSI)软件用来自动生成芯片设计。用比如 “逻辑综合” 这种技术可以放一整个高级组件，比如内存缓存，软件会自动生成电路，做到尽可能高效</p>
<p><strong>意义</strong>：被许多人认为是<strong>计算 4.0 时代</strong>的开始</p>
<h1 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h1><p><strong>定义</strong>：得益于材料和制造技术的发展，每两年左右，同样大小的空间，能塞进两倍数量的晶体管。</p>
<blockquote>
<p><strong>注意</strong>：摩尔定律不是定律，只是一种趋势</p>
</blockquote>
<p><strong>问题</strong>：摩尔定律可能正在接近终结，因为进一步做小会面临两个问题</p>
<ul>
<li>光刻 用光掩膜把图案弄到晶圆上，而<strong>光的波长不足以制作更精细的设计</strong>，精度已达极限。所以科学家在研制波长更短的光源，投射更小的形状</li>
<li>当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，这叫：<strong>量子隧道贯穿效应</strong>。如果晶体管漏电，就不是好开关。实验室中已造出小至1纳米的晶体管，但能不能商业量产依然未知。</li>
</ul>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之图灵</title>
    <url>/posts/2b236b5f/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>简单了解一下图灵相关知识，扩展下知识面</p>
</blockquote>
<a id="more"></a>

<h1 id="图灵"><a href="#图灵" class="headerlink" title="图灵"></a>图灵</h1><ul>
<li>阿兰·<strong>图灵</strong>——计算机科学之父</li>
<li>1921 年出生在英国伦敦</li>
<li>1935 年，图灵开始解决德国数学家 大卫·希尔伯特 提出的 可判定性问题</li>
<li>二战期间，图灵和同事在布莱切利园努力破解德军英格玛加密机。解密得到的德国情报，为盟军赢得了很多优势</li>
<li>战后，图灵回到学术界，为许多早期计算机工作做出贡献，比如曼彻斯特 1 号，一个早期有影响力的存储程序计算机</li>
<li>1952 年，调查他家的入室盗窃案时，向当局暴露了他的性取向，被起诉 “行为严重不检点”，图灵被定罪，面临 2 个选择：1. 入狱  2. 接受激素来压制性欲。他选了后者，部分原因是为了继续学术工作。但药物改变了他的情绪和性格，图灵于1954年服毒自尽，年仅41岁。</li>
<li><strong>图灵奖——计算机领域的最高奖项</strong></li>
</ul>
<h1 id="可判定性问题-decision-problem"><a href="#可判定性问题-decision-problem" class="headerlink" title="可判定性问题 decision problem"></a>可判定性问题 decision problem</h1><p><strong>定义</strong>：是否存在一种算法，输入正式逻辑语句，输出准确的”是”或”否”答案？eg. 如果这样的算法存在，可以回答比诸如”是否有一个数大于所有数”这样的问题。</p>
<p><strong>答案</strong>：不存在这样的算法</p>
<p><strong>意义</strong>：<strong>计算机的能力有极限</strong>。无论有多少时间或内存，有些问题是计算机无法解决的。——丘奇-图灵论题</p>
<h2 id="证明-1：Lambda算子，阿隆佐·丘奇"><a href="#证明-1：Lambda算子，阿隆佐·丘奇" class="headerlink" title="证明 1：Lambda算子，阿隆佐·丘奇"></a>证明 1：Lambda算子，阿隆佐·丘奇</h2><ul>
<li>美国数学家 阿隆佐·丘奇 于 1935 年，开发了一个叫”Lambda 算子”的数学表达系统，证明了这样的算法不存在。</li>
<li>该证明方法使用的数学技巧难以理解和使用</li>
</ul>
<h2 id="证明-2：图灵机，图灵"><a href="#证明-2：图灵机，图灵" class="headerlink" title="证明 2：图灵机，图灵"></a>证明 2：图灵机，图灵</h2><ul>
<li>阿兰·图灵为解决可判定问题，提出了一种假象的计算机，现在称为<strong>图灵机</strong>。</li>
<li>图灵机提供了简单又强大的数学计算模型，虽然用的数学方法不同，但是图灵机的计算能力和 Lambda 算子一样</li>
<li>由于图灵机更简单，在新兴的计算机领域更受欢迎</li>
</ul>
<h3 id="图灵机的组成"><a href="#图灵机的组成" class="headerlink" title="图灵机的组成"></a>图灵机的组成</h3><ul>
<li>一条无限长的纸带：纸带被分为一个个格子，每个格子上包含一个来自有限字母表的字符</li>
<li>一个读写头：可以在纸带上左右移动，并能读写纸带上的符号</li>
<li>一组控制规则：根据图灵机当前的状态 + 当前读写头所指的符号，决定图灵机下一步的动作（可能是在纸带写入一个符号；或改变状态寄存器的值，令图灵机进入新状态；或把读写头移动一格；或是以上动作的组合）</li>
<li>一个状态寄存器：保存图灵机当前所处的状态。图灵机所有可能的状态数目是有限的，且有一个特殊的停机状态</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1597911643400-d7d5b28b-31f2-41b9-98cf-97fc7af64205.png" alt="image.png"></p>
<h3 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a>图灵完备</h3><ul>
<li>只要有足够的规则，状态和纸带，<strong>图灵机</strong>可以创造任何东西，<strong>可以实现任何计算</strong></li>
<li>图灵机是很强大的计算模型。就可计算和不可计算而言，没有计算机比图灵机更强大。</li>
<li>和图灵机一样强大的，叫 “<strong>图灵完备</strong>“</li>
</ul>
<h3 id="停机问题——用图灵机回答可判定性问题"><a href="#停机问题——用图灵机回答可判定性问题" class="headerlink" title="停机问题——用图灵机回答可判定性问题"></a>停机问题——用图灵机回答可判定性问题</h3><p><strong>定义</strong>：给定图灵机描述和输入纸带，是否有算法可以确定机器会永远算下去还是到某一点会停机？</p>
<p><strong>答案</strong>：停机问题是无法解决的</p>
<p><strong>证明</strong>：</p>
<ul>
<li>假设有一台假想图灵机 H，输入：问题的描述 + 纸带的数据；输出：Yes 代表会停机，No 代表不会停机</li>
<li>如果有一个程序，图灵机 H 无法判断是否会停机，则说明停机问题无法解决</li>
<li>为了找到这样的程序，新设定另一个图灵机 H’：如果图灵机 H 说程序会停机（即输出 Yes），新图灵机 H’ 就输出 Yes，但永远运行不停机；如果图灵机 H 输出 No，则让新图灵机输出 No，然后停机。新机器 H’ 实质上是一台和 H 输出相反的机器，如果程序不停机，就停机；如果程序停机，就永远运行下去。</li>
<li>在图灵机 H’ 前面加一个分离器，使机器只接收一个输入，这个输入既是程序，也是输入。把这台新机器叫作 异魔。</li>
<li>把 异魔 的描述，作为图灵机异魔本身的输入，这意味着在问图灵机 H，当异魔的输入是自己时，异魔会否停机？</li>
<li>但如果 H 说异魔会停机，那么异魔会进入无限循环，因此不会停机；如果 H 说异魔不会停机，那么异魔会输出 No 然后停机。</li>
<li>因此图灵机 H 不能正确判定 停机问题，因为没有答案，这是一个悖论</li>
</ul>
<p><strong>意义</strong>：由于图灵证明了图灵机可以实现任何计算（图灵完备），而图灵机无法回答停机问题，因此停机问题证明了<strong>不是所有问题都能用计算解决</strong>。</p>
<h1 id="图灵测试"><a href="#图灵测试" class="headerlink" title="图灵测试"></a>图灵测试</h1><p><strong>定义</strong>：1950 年，图灵设想了未来的计算机拥有和人类一样的智力，或至少难以区分。图灵提出如果计算机能欺骗人类相信它是人类，才算是智能。这成了智能测试的基础，如今叫”图灵测试”</p>
<p><strong>规则</strong>：如果有一个人和一个计算机，你和他们沟通，但是你分不出哪个是人类，哪个是计算机，那么计算机就通过了图灵测试。</p>
<p><strong>应用</strong>：<strong>验证码</strong>（全称”公开全自动图灵测试”），用于区分计算机和人类，防止机器人发垃圾信息等</p>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之操作系统</title>
    <url>/posts/864d57dc/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>40 50年代的电脑，每次只能运行一个程序，程序员在打孔纸上写程序，然后再放入计算机中进行计算，一开始计算机速度比较慢，通常一个程序需要运行几天时间，所以放程序的时间还能忍受。但是随着计算机运算速度的高速发展后，放程序的时间比程序运行时间还要长，我们就需要一种方式，让计算机自动运行，于是诞生了<strong>操作系统（Operation Systems，OS</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="操作系统-OS"><a href="#操作系统-OS" class="headerlink" title="操作系统 OS"></a>操作系统 OS</h1><p><strong>起源</strong>：40 50年代的电脑，每次只能运行一个程序，程序员在打孔纸上写程序，然后再放入计算机中进行计算，一开始计算机速度比较慢，通常一个程序需要运行几天时间，所以放程序的时间还能忍受。但是随着计算机运算速度的高速发展后，放程序的时间比程序运行时间还要长，我们就需要一种方式，让计算机自动运行，于是诞生了<strong>操作系统（Operation Systems，OS）</strong>。</p>
<p><strong>定义和作用</strong>：</p>
<ul>
<li><strong>操作系统也是程序</strong>，一般是开机第一个启动的程序，其他所有程序都由操作系统启动</li>
<li>操作系统有操作硬件的特殊权限，可以运行和管理其它程序</li>
</ul>
<h2 id="批处理-batch-processing"><a href="#批处理-batch-processing" class="headerlink" title="批处理 batch processing"></a>批处理 batch processing</h2><p><strong>定义</strong>：当计算机运行完一个程序，会自动加载运行下一个程序。</p>
<h2 id="设备驱动程序-device-drivers"><a href="#设备驱动程序-device-drivers" class="headerlink" title="设备驱动程序 device drivers"></a>设备驱动程序 device drivers</h2><p><strong>起源</strong>：计算机变得越来便宜，越来越普及，也出现了很多不同的计算机配置（CPU、<strong>外部设备（Peripherals）</strong> 等）早期的外部设备交互是非常底层的，程序员需要了解设备的硬件细节，但是程序员又很少能拿到所有型号的设备来测试代码。所以一般是阅读手册然后尽可能编写代码。为了让程序员写软件更容易，由操作系统负责提供 API 来<strong>抽象</strong>硬件，隐藏复杂度和实现细节。</p>
<p><strong>操作系统的功能</strong>：</p>
<ul>
<li>操作系统充当<strong>软件和硬件之间的媒介</strong></li>
<li>更具体地说，操作系统提供 API 来抽象硬件，叫”<strong>设备驱动程序</strong>“。程序员只需调用相应的标准化接口，就能和外部设备进行交互，而不用管实现的细节。</li>
</ul>
<h2 id="多任务处理-multitasking"><a href="#多任务处理-multitasking" class="headerlink" title="多任务处理 multitasking"></a>多任务处理 multitasking</h2><p><strong>起源</strong>：计算机处理器的运行速度越来越快，因此往往处理器空闲，等待速度慢的机械设备（比如打印机和读卡器等外部设备），使得程序阻塞在 I/O 上。需要一种方式来最大限度地利用计算机性能。</p>
<p><strong>实例</strong>：50年代后期，英国曼彻斯特大学开始研发世界上第一台超级计算机，Atlas。他们开发了一个叫 Atlas Supervisor 的程序（操作系统）来最大限度地利用这台超级计算机。这个操作系统<strong>不仅能</strong>像早期的 <strong>批处理</strong>操作系统 一样自动加载程序，<strong>而且能</strong>通过调度实现<strong>在单个 CPU 上同时运行多个程序</strong>，即<strong>多任务处理</strong>。</p>
<p>这个操作系统运行多个程序的例子：一个游戏程序正在运行，游戏结束要打印游戏最高分，打印会调用外部设备（打印机），外部设备运行速度比 CPU 慢很多，因此将该程序休眠（休眠时该程序进行 I/O 操作，即打印，但不分配 CPU，CPU运行另外的程序）；游戏程序打印完成，操作系统将该程序标记为可继续执行。之后的某个时刻，操作系统会再分配 CPU 给该游戏程序，继续运行打印之后的代码。</p>
<p>该超算配备了4台纸带读取器，4台纸带打孔机，8个磁带驱动器，因此可以使得多个程序可以同时运行，在单个 CPU 上共享时间</p>
<h2 id="虚拟内存-virtual-memory"><a href="#虚拟内存-virtual-memory" class="headerlink" title="虚拟内存 virtual memory"></a>虚拟内存 virtual memory</h2><p><strong>起源</strong>：操作系统同时运行多个程序（多任务处理）会导致一个问题：每个程序都会占一些内存，但是当切换到另一个程序时，我们不能丢失数据，解决办法是 给每个程序分配专属内存块。但是又有一个问题，。如果一个程序请求更多内存，操作系统就会决定是否同意，如果同意，就要决定分配哪些内存块，这就使得程序A可能会分配到非连续的内存块，使得程序员能难进行跟踪。为了隐藏这种复杂性，操作系统会把内存地址进行虚拟化，称为<strong>虚拟内存（Virtual Memory）</strong>。</p>
<p><strong>功能</strong>：操作系统将实际的内存地址虚拟化，<strong>程序可以假定内存总是从地址0开始，且地址连续</strong>。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>这种机制使程序的内存大小可以灵活增减，即<strong>动态内存分配（Dynamic Memory Allocation）</strong>，这种简化为操作系统同时运行多个程序提供了极大的灵活性</li>
<li>给程序分配专用的内存范围，程序与程序之间的内存相互隔离，如果一个程序出错（例如开始写乱七八糟的数据），只会捣乱自己的内存，而不影响其他程序，即“<strong>内存保护</strong>”。也可以防止病毒等恶意软件。</li>
</ul>
<h2 id="多用户分时操作系统"><a href="#多用户分时操作系统" class="headerlink" title="多用户分时操作系统"></a>多用户分时操作系统</h2><p><strong>定义</strong>：把计算机主机与许多终端用户连接起来，分时操作系统将系统资源（CPU 时间与内存空间等）按一定的时间间隔，轮流地切换给各终端用户的程序使用。<strong>由于切换时间间隔很短，每个用户的感觉就像他独占计算机一样</strong>。</p>
<p><strong>起源</strong>：到1970年代，大学会购买电脑给学生使用，此时计算机不仅能同时运行多个程序，还能让多个用户同时访问。多个用户使用<strong>终端（Terminal）</strong>来访问计算机，这里的终端只有键盘和屏幕，然后连接到计算机，终端本身并不具有处理能力。这样计算机不仅要能处理多个程序，还要处理多个用户，为了确保其中一人不会占满计算机资源，开发了<strong>分时操作系统（Time-Sharing）</strong></p>
<p><strong>功能</strong>：多用户分时操作系统不但要处理多个程序，还要处理多个用户，确保其中一个终端的程序不会占满计算机资源，每个用户只能用一小部分处理器、内存等计算机资源。</p>
<p><strong>实例</strong>：早期分时操作系统中，最有影响力的是1969年发布的Multics，它是第一个从设计时就考虑到安全性的操作系统。开发人员不希望恶意用户访问不该访问的数据，这使得操作系统的复杂度远超当时的平均水平，通常内存的一半都要用来运行操作系统，这种过度设计使得Multics未能获得商业成功。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598518771490-39a82951-329c-49de-85ca-aaced18c1949.png" alt="image.png"></p>
<h2 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h2><p><strong>设计理念</strong>：抛弃 Multics 的过度设计，将操作系统分成两部分：</p>
<ul>
<li><strong>内核</strong>：操作系统的核心功能，如内存管理，多任务和输入/输出处理等</li>
<li>其他工具：程序和运行库等，虽然是有用的工具，但不是内核的部分</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>紧凑的内核 意味着功能没有那么全面</li>
<li>如果有错误发生，就让**内核”恐慌”**（panic），机器崩溃，需重启电脑解决</li>
</ul>
<p><strong>发展：</strong>1970~80年代最流行的操作系统之一</p>
<h2 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h2><p>于1981年微软发布的磁盘操作系统MS-DOS只有160kb，虽然缺少多任务和保护内存这样的功能，意味着程序经常使系统崩溃，用户可以直接重启。即使在1985年发布的早期windos，也一样缺少内存保护功能，当程序错误时，就会出现蓝屏。</p>
<p><strong>起源</strong>：计算机价格下降，出现个人电脑或家庭电脑，这些电脑比大型主机简单得多，操作系统也得简单。</p>
<p><strong>缺点</strong>：缺少”多任务”和”保护内存”这样功能，程序经常使系统崩溃，要求用户重启</p>
<h2 id="后续操作系统"><a href="#后续操作系统" class="headerlink" title="后续操作系统"></a>后续操作系统</h2><p>早期 Windows：依旧缺乏 内存保护，当程序行为不当时，就会”<strong>蓝屏</strong>“</p>
<p>新版 Windows：有更好的保护，不会经常崩溃</p>
<p>现代操作系统：Mac OS X，Windows 10，Linux，iOS 和 Android</p>
<p>操作系统有 <strong>多任务，虚拟内存， 内存保护</strong> 等功能，可以同时运行多个程序。</p>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之压缩</title>
    <url>/posts/3a3f6fcf/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>之前介绍了文件格式，如何编码文字、声音和图片，但是它们的效率并不高，我们希望文件能小一点，这样就能保存大量文件，同时传输也会快一些，解决方法就是<strong>压缩（Compression）</strong>，把数据占用的空间压得更小，为此我们需要用更少的bit来表示数据。</p>
</blockquote>
<a id="more"></a>

<h1 id="压缩的作用："><a href="#压缩的作用：" class="headerlink" title="压缩的作用："></a>压缩的<strong>作用</strong>：</h1><ul>
<li>将文件占用的空间压得更小，用更少的位(bit)来表示数据，能存更多的文件</li>
<li>使得传输更快</li>
</ul>
<p>感知编码有损压缩用更紧凑的表示方法字典编码（哈夫曼树）消除冗余游程编码无损压缩压缩</p>
<p>下面用来举例说明的原始数据如下图所示，是一张4×4的图像，每个像素由RGB三个值（各8位）组成。总共4×4×3 = 48个字节</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598705416029-a012cb35-c833-4b29-abf9-211e9575c58f.png" alt="image.png"></p>
<h1 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h1><blockquote>
<p><strong>定义</strong>：不损失任何数据，可以轻易恢复到原来的数据。解压缩后，数据和压缩前完全一致。</p>
</blockquote>
<h2 id="游程编码——消除冗余"><a href="#游程编码——消除冗余" class="headerlink" title="游程编码——消除冗余"></a>游程编码——消除冗余</h2><p><strong>英文</strong>：<strong>Run-Length Encoding</strong></p>
<p><strong>机制</strong>：<strong>消除冗余</strong>，简单地减少重复信息。插入额外数据表示重复的长度</p>
<p><strong>优点</strong>：</p>
<ul>
<li>适合经常出现相同值的文件</li>
<li><strong>无损压缩</strong></li>
</ul>
<p><strong>实例</strong>：</p>
<p>可以看到例子中的图像由连续7个像素都是黄色，可以插入一个额外的字节表示连续黄色像素的长度。不过，要给所有不重复颜色的像素前面都加上长度，使得格式一致，才能让计算机分辨哪些字节表示长度，哪些字节表示颜色，因此，游程编码适合经常出现相同值的文件；否则，有时候可能数据反而会变多。</p>
<p>上面的例子字节数由48压缩到24</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598705993690-e32ba65c-6634-4618-a936-842772412920.png" alt="image.png"></p>
<h2 id="字典编码（霍夫曼树）——更紧凑的表示方法"><a href="#字典编码（霍夫曼树）——更紧凑的表示方法" class="headerlink" title="字典编码（霍夫曼树）——更紧凑的表示方法"></a>字典编码（霍夫曼树）——更紧凑的表示方法</h2><p><strong>英文</strong>：<strong>Huffman Tree</strong></p>
<p><strong>机制</strong>：<strong>使用更紧凑的编码方式来表示数据块</strong>。需要一个字典，存储 编码 和 数据 间的对应关系。</p>
<p><strong>实例</strong>：</p>
<p>简单起见，在这里我们把图像看成一块块，而不是一个个像素。将两个像素（6个字节当作一块），这里只有四对：白黄 黑黄 黄黄 白白，为这4对生成紧凑代码。</p>
<ul>
<li>霍夫曼树是一种高效的编码方式，各个数据块出现频率不同，编码的长度也不同。</li>
<li>首先，列出所有块和出现频率，每轮选两个最低的频率，组成一个树，这棵树合并两个子树的频率作为自身频率。不断重复，直到全部合并。</li>
<li>把每个分支的左子树标为0，右子树标为1，就可以生成字典，频率大的编码短，频率低的编码长。而且，这些编码绝对不会冲突，因为树的每条路径是唯一的，意味着代码是”无前缀”的，没有代码是以另一个代码开头的。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598710891097-9df63dfc-a187-42ee-889b-f199add62e2b.png" alt="image.png"></p>
<ul>
<li>生成哈夫曼树：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598711011114-222ce6bc-7e3d-4f06-a614-768ef2eff81f.png?x-oss-process=image/resize,w_1492" alt="image.png"></p>
<ul>
<li>生成字典：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598711052292-2ca7b58d-5e4c-4731-9acd-7c1b27a67cdf.png" alt="image.png"></p>
<ul>
<li>根据字典对数据进行压缩：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598711139139-cb6cf23a-d860-470f-89eb-4d4144a10741.png" alt="image.png"></p>
<ul>
<li>数据压缩成了14bits编码：10110000111100，不到2字节；还要在前面加上字典，28字节。最终压缩为30字节</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598711622633-3a765f28-290d-4ec3-8a49-100960cf95fd.png" alt="image.png"></p>
<h2 id="组合-消除冗余-更紧凑的表示方法"><a href="#组合-消除冗余-更紧凑的表示方法" class="headerlink" title="组合 消除冗余 + 更紧凑的表示方法"></a>组合 消除冗余 + 更紧凑的表示方法</h2><p>前面提到的两种无损压缩方式，游程编码是消除冗余，字典编码（霍夫曼树）是使用更紧凑的表示方法。</p>
<ul>
<li><strong>通常会组合使用 消除冗余 和 使用更紧凑的表示方法</strong></li>
<li>几乎所有无损压缩格式都用了这两个的组合，比如 GIF, PNG, PDF, ZIP</li>
</ul>
<h1 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h1><blockquote>
<p><strong>定义</strong>：一些文件，丢掉一些数据没什么关系，可以丢掉一些存在与否人体都感知不到区别的数据</p>
</blockquote>
<h2 id="感知编码"><a href="#感知编码" class="headerlink" title="感知编码"></a>感知编码</h2><p><strong>定义</strong>：对感知敏感程度不同的数据进行不同精度的编码（删掉人类无法感知的数据）。</p>
<p><strong>实例</strong>：</p>
<ul>
<li><p>声音压缩:你的听力不是完美的，一些频率我们根本听不见，比如超声波，因此可以丢掉音乐文件中的超声波数据；而我们对人声很敏感，因此应该尽可能保持原样；低音介于两者之间，人类听得到，但不怎么敏感，一般是感觉到震动。因此，可以用<strong>不同精度编码不同频段</strong>，我们也听不出什么区别，不会明显影响体验。</p>
</li>
<li><p>图像压缩</p>
</li>
<li><p>视频压缩：帧和帧之间很多像素一样，即存在 <strong>时间冗余</strong>。视频里不用每一帧都存画面里的所有像素，可以只存变了的部分，更高级的视频压缩格式会更进一步，找出帧和帧之间相似的补丁，然后用简单效果实现，比如移动和旋转</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之内存</title>
    <url>/posts/eb13a479/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>一般来说，电脑内存是<strong>非永久性的（Non-Permanent）</strong>，如果电脑关机，则内存中的所有数据都会丢弃，所以内存叫<strong>易失性存储器（Volatile Memory）</strong>，还存在另一种<strong>存储器（Storage）</strong>，存储器（storage）和内存（memory）存在一定的不同。任何写入storage的数据，就会一直保存，直到被覆盖或删除，断点也不会丢失，称为<strong>非易失性（Non-volatile）</strong>。过去是易失性的速度快，非易失性的速度慢，但随着技术发展，两者的差异越来越小。</p>
<p><strong>存储技术的发展</strong>：</p>
<p>打孔纸卡/纸带   –&gt;    延迟线存储器  –&gt;   磁芯存储器   –&gt;   磁带 –&gt;   磁鼓存储器  —&gt; 硬盘 &amp; 软盘  —&gt;   光盘  —&gt; 固态硬盘</p>
</blockquote>
<a id="more"></a>

<p><strong>内存 &amp; 储存介质</strong></p>
<ul>
<li><strong>内存 memory</strong>：”易失性”存储器，断电则数据丢失</li>
<li><strong>储存介质/存储器 storage</strong>：是”非易失性”的，任何写入”存储器”的数据，比如你的硬盘数据会一直存着，直到被覆盖或删除，断电也不会丢失</li>
</ul>
<h1 id="打孔纸卡-amp-打孔纸带"><a href="#打孔纸卡-amp-打孔纸带" class="headerlink" title="打孔纸卡 &amp; 打孔纸带"></a>打孔纸卡 &amp; 打孔纸带</h1><p>最早的存储介质是打孔纸卡以及打孔纸带，到1940年代，纸卡标准是80列x12行，能够存储960位数据。纸卡用了十几年，因为不用电而且便宜耐用，但是读取速度较慢，只能写入一次，对于存临时值，纸卡不好用，我们需要更大更灵活的存储方式。</p>
<p><strong>实例</strong>：美国军方 1958 年投入使用的防空系统，主程序存储在 62,500 个纸卡上，大小 5MB 左右, 相当如今手机一张照片的大小</p>
<p><strong>优点</strong>：不用电而且便宜耐用</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>读取<strong>慢</strong></li>
<li>容量<strong>小</strong></li>
<li><strong>只能写入一次</strong>（打的孔无法轻易补上），不灵活，不方便存储临时值</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598535660895-8d1c3d7d-cad6-4179-9589-922cca02f5db.png" alt="image.png"></p>
<h1 id="延迟线存储器-Delay-Line-Memory"><a href="#延迟线存储器-Delay-Line-Memory" class="headerlink" title="延迟线存储器 Delay Line Memory"></a>延迟线存储器 Delay Line Memory</h1><p>1944年时，出现了<strong>延迟线存储器（Delay Line Memory）</strong>。</p>
<p>拿一个管子装满液体，如水银，扬声器发出脉冲时会产生压力波，压力波需要时间传播到另一端的麦克风，麦克风将压力波转换回电信号。我们可以用压力波的传播延迟来存储数据。假设有压力波代表 1，没有代表 0，扬声器可以输出 1010 0111，压力波沿管子传播，过了一会儿，撞上麦克风，将信号转换回 1 和 0，如果加一个电路，连接麦克风和扬声器，再加一个放大器（Amplifier）来弥补信号衰弱，就能做一个存储数据的循环。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598536308327-ab657763-1fc0-4692-85b9-27e4ff419f15.png" alt="image.png"></p>
<p><strong>特点</strong>：</p>
<ul>
<li>信号沿电线传播几乎是瞬时的，所以任何时间点只显示  1 bit 数据</li>
<li>但管子中可以存储多个位(bit)</li>
</ul>
<p><strong>实例</strong>：在1949年的EDVAC计算机中使用了延迟线存储器，总共有128条延迟线，每条能存352位，一共能保存45000位。这使得EDVAC成为最早的存储程序计算机之一。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li> <strong>顺序存储器/循环存储器</strong>，访问速度慢：由于每一个时刻只能读一位 (bit) 数据，如果想访问一个特定的 bit，比如第 112 位(bit) ，你得等待它从循环中出现</li>
<li><strong>难以增加内存密度</strong>，即难以提升存储容量：把压力波变得更紧密就更容易混在一起。</li>
</ul>
<p><strong>改良：</strong> “磁致伸缩延迟存储器”，用金属线的振动来代表数据，通过把线卷成线圈，1英尺×1英尺的面积能存储大概 1000位(bit)</p>
<p><strong>时间</strong>：延迟线存储器在 1950 年代中期就基本过时了</p>
<h1 id="磁芯存储器-Magnetic-Core-Memory"><a href="#磁芯存储器-Magnetic-Core-Memory" class="headerlink" title="磁芯存储器 Magnetic Core Memory"></a>磁芯存储器 Magnetic Core Memory</h1><ul>
<li>使用一个像甜甜圈的小型磁圈，如果给磁芯绕上电线，并施加电流，可以将磁化在一个方向；如果关掉电流，磁芯保持磁化；如果沿相反方向施加电流，磁化的方向（极性）会翻转。这样就可以存一位 1 和 0。</li>
<li>把磁圈排列成网格来存储多位数据。有电线负责选行和列；也有电线贯穿每个磁芯, 用于读写一位(bit)。</li>
</ul>
<p><strong>实例</strong>：磁芯存储器的第一次大规模运用是 1953 年麻省理工学院的 Whirlwind 1 计算机，磁芯排列是 32×32，所以能存 1024 位(bit)  (32x32=1024)；用了 16 块板子，能存储大约 16000 位(bit)</p>
<p><strong>优点</strong>：磁芯存储器能是<strong>随机存取存储器</strong>，能随时访问任何一位(bit)</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>手工编织磁芯网格</li>
<li><strong>存储成本依然很高</strong>：刚开始时，存储成本大约 1 美元 1 位(bit)；到1970年代，下降到 <strong>1 美分左右</strong> **1 位(bit)**，这意味着存储现代手机的一张照片（5MB ≈ 4000 万 bit），需要花费 40 万美分</li>
</ul>
<p><strong>时间</strong>：”磁芯存储器” 从 1950 年代中期开始成为主流，流行了 20 多年</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598537639922-2ff7f2fc-9a06-4fd1-8776-78b019c5480a.png" alt="image.png"></p>
<h1 id="磁带-Magnetic-Tape"><a href="#磁带-Magnetic-Tape" class="headerlink" title="磁带 Magnetic Tape"></a>磁带 Magnetic Tape</h1><p>到1951年，UNIVAC电脑推出了一种新存储——<strong>磁带（Magnetic Tape）</strong>。</p>
<p>磁带是纤薄柔软的一长条卷在轴上的磁性带子，磁带可以在<strong>磁带驱动器</strong>内前后移动。</p>
<ul>
<li>写：磁带驱动器里面有一个”写头”绕了电线，电流通过产生磁场，导致磁带的一小部分被磁化，电流方向决定了极性，代表 1 和 0。</li>
<li>读：磁带驱动器里还有一个”读头”，可以非破坏性地检测极性。</li>
</ul>
<p><strong>实例</strong>：1951 年，最早进行商业销售的电脑之一 UNIVAC 用了半英寸宽、8条并行的磁带，磁带每英寸可存 128 位数据，每卷有 1200 英尺长，意味着一共可以存 1500 万位左右，接近2兆字节（2 MB）</p>
<p><strong>优点</strong>：虽然磁带驱动器很贵，但磁带<strong>又便宜又小</strong>，因此<strong>磁带至今仍用于存档</strong>。</p>
<p><strong>缺点</strong>：<strong>访问速度慢</strong>：因为磁带是连续的，必须倒带或快进到达特定位置才能访问相应的数据，可能要几百英尺才能得到某个字节(byte)，这很慢。</p>
<h1 id="磁鼓存储器-Magnetic-Drum-Memory"><a href="#磁鼓存储器-Magnetic-Drum-Memory" class="headerlink" title="磁鼓存储器 Magnetic Drum Memory"></a>磁鼓存储器 Magnetic Drum Memory</h1><p><strong>时间</strong>：1950, 60年代。到 1970 年代 “磁鼓存储器” 不再生产。</p>
<p>类似磁带。有金属圆筒，盖满了磁性材料以记录数据。滚筒会持续旋转，周围有数十个读写头，data,,等滚筒转到正确的位置，读写头会读或写 1 位(bit) 数据。为了尽可能缩短延迟, 鼓轮每分钟上千转。</p>
<p><strong>实例</strong>：到 1953 年，磁鼓技术飞速发展，可以买到存 80,000 位的”磁鼓存储器”，也就是 10 KB</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598538164741-e56b91e3-d559-4f86-ba57-534e917c1b51.png" alt="image.png"></p>
<h1 id="硬盘-Hard-Disk-Drives"><a href="#硬盘-Hard-Disk-Drives" class="headerlink" title="硬盘 Hard Disk Drives"></a>硬盘 Hard Disk Drives</h1><p>硬盘和磁鼓类似，<strong>磁鼓导致了硬盘的发展</strong>。不过硬盘用的是盘，不像磁鼓用圆柱体。</p>
<ul>
<li>磁盘表面有磁性，写入头和读取头  可以处理上面的 1 和 0。</li>
<li>要访问某个特定位，一个读写磁头会上下移动，找到正确的磁盘，然后磁头会滑进去，就和磁鼓存储器一样，磁盘也会高速旋转，所以读写头要等到正确的部分旋转过来，这个称为<strong>寻道时间（Seek Time）</strong></li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>容量大</strong>：硬盘薄，可以叠在一起，提供更多表面积来存数据</li>
<li><strong>价格便宜</strong></li>
</ul>
<p><strong>实例</strong>：1956年，IBM生产的世界上第一台磁盘计算机 RAMAC 305，有 50 张 24 英寸直径的磁盘，总共能存 5 MB 左右。RAMAC 305 访问任意数据，平均要六分之一秒左右（寻道时间）</p>
<p><strong>发展 &amp; 容量</strong>：如今的硬盘可以轻易容纳 1TB 甚至更多的数据，能存 20 万张 5MB 的照片，网上最低 40 美元就可以买到，每 bit 成本 0.0000000005 美分。另外，现代硬盘的平均寻道时间低于 1/100 秒。</p>
<h1 id="软盘-Floppy-Disk"><a href="#软盘-Floppy-Disk" class="headerlink" title="软盘 Floppy Disk"></a>软盘 Floppy Disk</h1><p><strong>时间</strong>：在 1970~1990 非常流行，现已淘汰。</p>
<p><strong>原理</strong>：除了磁盘是软的，软盘与硬盘基本一样。</p>
<p><strong>优点</strong>：便携</p>
<h1 id="光盘-CD-amp-DVD-Compact-Disk"><a href="#光盘-CD-amp-DVD-Compact-Disk" class="headerlink" title="光盘 CD &amp; DVD - Compact Disk"></a>光盘 CD &amp; DVD - Compact Disk</h1><p><strong>时间</strong>：光学存储器于 1972 年出现，12 英寸的”激光盘”；后来出现光盘，简称 CD；90年代流行 DVD</p>
<p><strong>原理</strong>：光盘表面有很多小坑，造成光的不同反射，光学传感器会捕获到，并解码为 1 和 0</p>
<h1 id="固态硬盘-SSD-Solid-State-Disk"><a href="#固态硬盘-SSD-Solid-State-Disk" class="headerlink" title="固态硬盘 SSD - Solid State Disk"></a>固态硬盘 SSD - Solid State Disk</h1><p>固态硬盘没有机械活动部件，里面是<strong>集成电路</strong>。</p>
<p><strong>优点</strong>：<strong>快</strong>：由于 SSD 没有移动部件，磁头不用等磁盘转，所以 SSD 访问时间低于 1/1000 秒。</p>
<p><strong>缺点</strong>：还是比 RAM 慢很多倍</p>
<h1 id="内存层次结构-Memory-Hierarchy"><a href="#内存层次结构-Memory-Hierarchy" class="headerlink" title="内存层次结构 Memory Hierarchy"></a>内存层次结构 Memory Hierarchy</h1><p>一小部分高速但昂贵的内存 + 一部分稍慢但相对便宜些的内存 + 更慢更便宜但容量更大的内存。</p>
<p>在成本和速度间取得平衡</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598538614362-8fd35636-34a9-4164-b695-0941114061f9.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之命令行到图形化界面</title>
    <url>/posts/87988e0b/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>人机交互的发展</p>
</blockquote>
<a id="more"></a>

<h1 id="人机交互"><a href="#人机交互" class="headerlink" title="人机交互"></a>人机交互</h1><p><strong>定义</strong>：通过 输入输出设备 提供的交互界面（interface），使人和计算机之间交换信息</p>
<h2 id="人机交互的发展"><a href="#人机交互的发展" class="headerlink" title="人机交互的发展"></a>人机交互的发展</h2><h3 id="早期"><a href="#早期" class="headerlink" title="早期"></a>早期</h3><p>机械输入，打印机输出</p>
<ul>
<li>早期机械计算设备用齿轮、旋钮和开关等机械结构来输入输出</li>
<li>早期电子计算机（eg. Colossus 和 ENIAC）用一大堆机械面板和线来进行操作（输入），运行完毕后，通过打印机将数据打印到纸上（输出）</li>
</ul>
<p><strong>特点</strong>：1950年代前，早期计算的<strong>输入概念很原始</strong>，开始前人类<strong>同时输入程序和数据</strong>，程序开始运行后就一直运行到结束，<strong>中间</strong>没有人类进行操作，计算机也<strong>不会交互</strong>式响应。因为当时的计算机太贵，不能等人类慢慢敲命令和数据，等到全部执行完毕，再将结果打印在纸上</p>
<h3 id="1950年代"><a href="#1950年代" class="headerlink" title="1950年代"></a>1950年代</h3><p>打孔纸带/磁带输入，打印机输出</p>
<ul>
<li>1950年代，机械输入完全消失，使用打孔纸带和磁带作为输入，但输出仍然是打印到纸上，还有大量指示灯在运行中提供实时反馈</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>那个时代的特点是，<strong>尽可能迁就机器</strong>，对人类是否有后是次要的。打孔纸带就是方便计算机读取，纸带是连续的，纸孔可以编码程序和数据；但是，人类不是以纸孔的方式思考的，因此程序员需要花费额外的时间和经理将算法转换成计算机能理解的方式（打孔纸带）。</li>
</ul>
<h3 id="1960-1970"><a href="#1960-1970" class="headerlink" title="1960-1970"></a>1960-1970</h3><p>电传打字机做输入输出：打字机/键盘输入，打印机输出到纸上</p>
<ul>
<li>1950年代晚期，小型计算机变得足够便宜，运行速度也变得更快，<strong>人</strong>类和<strong>计</strong>算机进行<strong>交互</strong>式操作<strong>变得可行</strong>。改造之前已有的打字机，变成<strong>电传打字机</strong>，用来让人类<strong>输入</strong>到计算机。</li>
<li><strong>电传交互界面</strong>在 1960~1970 很常见，输入一个命令，按回车，然后计算机会输回来，用户和计算机来回”对话”，这叫”<strong>命令行界面</strong>“。它是最主要的人机交互方式，一直到 1980 年代。</li>
</ul>
<p><strong>QWERTY键盘布局</strong>：1868年，克里斯托弗·莱瑟姆·肖尔斯发明的打字机用了QWERTY键盘布局，直到现在的键盘还在用这个布局。</p>
<p><strong>电传打字机</strong>：一种特殊打字机，专门用来发电报。电传打字机可以用电报线发送和接收文本，按一个字母，信号会通过电报线，发到另一端，另一端的电传打字机会打出来，使得两人可以长距离沟通。因为电传打字机有电子接口，稍作修改就能用于计算机。</p>
<p><strong>电传交互界面/命令行界面</strong>：用户可以是输入各种命令，计算机有对应的输出</p>
<ul>
<li>输入命令 ls，名字来自 list 的缩写，然后计算机会列出 当前目录里的所有文件</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598758272945-5205050f-6c11-48eb-91ca-e64768741067.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598758316805-a40bd1f9-31a4-4b6a-8ea7-adac18d1b02c.png" alt="image.png"></p>
<ul>
<li>用 cat 命令显示文件内容，cat 是连接(concatenate)的缩写，在cat后面指定文件名</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598758424376-4b62515d-7e94-42ca-81ed-2205804bc0f6.png" alt="image.png"></p>
<ul>
<li>如果同一个网络里有其他人，可以用 finger 命令找朋友</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598758468942-e7f0b23c-8f06-4242-b15b-34e726b15476.png" alt="image.png"></p>
<h3 id="1970年代"><a href="#1970年代" class="headerlink" title="1970年代"></a>1970年代</h3><p>终端（键盘+屏幕）代替电传打字机做交互：键盘输入，屏幕输出</p>
<ul>
<li><p>尽管屏幕最早出现在 1950 年代，但对日常使用太贵 而且分辨率低</p>
</li>
<li><p>1970年代，针对普通消费者的电视机开始量产，同时处理器与内存也在发展，屏幕代替电传打字机变得可行</p>
</li>
<li><p>工程师直接用现有的电传打字机协议，屏幕就像无限长度的纸，除了输入和输出字，没有其它东西</p>
</li>
<li><p>因此，<strong>键盘 + 屏幕</strong>的组合被称为<strong>终端</strong>，也叫”虚拟电传打字机”或”玻璃电传打字机”</p>
</li>
<li><p>到 1970 年代末  屏幕成了标配</p>
</li>
</ul>
<p><strong>特点</strong>：屏幕又好又快又灵活，如果删一个错别字，会立刻消失</p>
<p><strong>早期命令行文字游戏</strong>：Zork，1977</p>
<p><strong>现代计算机命令行界面</strong>：</p>
<ul>
<li>Windows：cmd</li>
<li>Mac：Terminal</li>
</ul>
<h1 id="显示技术的发展"><a href="#显示技术的发展" class="headerlink" title="显示技术的发展"></a>显示技术的发展</h1><h2 id="1960年-圆形屏幕：显示临时值"><a href="#1960年-圆形屏幕：显示临时值" class="headerlink" title="1960年 圆形屏幕：显示临时值"></a>1960年 圆形屏幕：显示临时值</h2><p>早期的文本任务通过打印机显示，因为屏幕分辨率较低，无法显示清晰的文字，而将计算结果的文字打印在纸上，有更高的对比度和分辨率，屏幕一般只用于跟踪程序的运行情况，比如寄存器的值，可以节约纸，并且屏幕更新很快，对临时值很匹配。</p>
<p><strong>特点：</strong></p>
<ul>
<li>键盘和显示器分开，因为当时的文本任务和图形任务是分开的。</li>
<li><strong>屏幕主要用于</strong>跟踪程序的运行情况，<strong>显示临时值</strong>。因为临时值（比如寄存器的值）如果用打印机一遍又一遍打印出来没有意义，不仅废纸而且速度很慢；而屏幕刷新很快，正适合显示临时值。</li>
<li>但是<strong>屏幕很少用于输出计算结果</strong>，结果一般都打印在纸上或其它更永久的东西上。因为早期的屏幕无法显示清晰的文字，而打印到纸上有更高的对比度和分辨率。</li>
</ul>
<p><strong>实例</strong>：早期的图形计算机——1960 年的 PDP-1</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598770381699-a673b4aa-1589-46d3-8396-509d340c8c38.png" alt="image.png"></p>
<h2 id="阴极射线管-CRT"><a href="#阴极射线管-CRT" class="headerlink" title="阴极射线管 CRT"></a>阴极射线管 CRT</h2><p><strong>意义</strong>：CRT 是最早最有影响力的显示技术</p>
<p><strong>原理</strong>：把电子发射到有磷光体涂层的屏幕上，当电子撞击涂层时会发光几分之一秒。由于电子是带电粒子，路径可以用磁场控制，屏幕内用板子或线圈  把电子引导到想要的位置，上下左右都行。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598771024353-4860e2e0-01f9-4e34-b233-9ba1e4049baa.png" alt="image.png"></p>
<p><strong>两种绘图方式</strong>：</p>
<ul>
<li><strong>矢量扫描</strong>：引导电子束描绘出形状。虽然发光只持续一小会儿，但如果重复得足够快 可以得到清晰的图像。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598771093778-e6aa7ce4-fb71-449b-bbbc-167e4822b18d.png" alt="image.png"></p>
<ul>
<li><strong>光栅扫描</strong>：按固定路径，一行行来，从上向下，从左到右，不断重复，只在特定的点打开电子束，以此绘制图形。用这种方法，可以用很多小线段绘制形状，甚至文字。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598771231055-b14c5a9d-edcc-44f7-ba0f-bccf10ff5484.png" alt="image.png"></p>
<h2 id="液晶显示器-LCD：显示像素"><a href="#液晶显示器-LCD：显示像素" class="headerlink" title="液晶显示器 LCD：显示像素"></a>液晶显示器 LCD：显示像素</h2><p><strong>原理</strong>：随着显示技术的发展，终于可以在屏幕上显示清晰的点，叫”像素”</p>
<ul>
<li><strong>液晶显示器（Liquid Crystal Display，LCD）</strong>也使用光栅扫描，每秒更新多次像素里红绿蓝的颜色。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598772420082-fe690f7a-89f4-4f96-b14a-55a9a02e1223.png" alt="image.png"></p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>像素太占内存，在当时不可行</strong>。200像素×200像素的图像，有 40,000 个像素，哪怕每个像素只用一个 bit 表示黑或白，连灰度都没有，也会占 40,000 bit 内存，比 PDP-1 全部内存的一半还多。</li>
</ul>
<p>因此，很多早期计算机不用像素，而使用一些其他技巧来渲染图形，直到发展到内存足够用。</p>
<h2 id="字符生成器——CRT光栅扫描"><a href="#字符生成器——CRT光栅扫描" class="headerlink" title="字符生成器——CRT光栅扫描"></a>字符生成器——CRT光栅扫描</h2><p> 早期计算机因为内存不够，不存像素值，而是存字符。其中80×25个字符最为典型（总共 2000 个字符），如果每个字符用 8 位表示，比如用 ASCII，总共才 16000 位，这种大小更合理。为此，计算机需要额外硬件来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上，这个硬件叫 “<strong>字符生成器</strong>“，基本算是第一代显卡。</p>
<p><strong>原理</strong>：</p>
<ul>
<li>字符生成器内部有一小块<strong>只读存储器（ROM）</strong>，存着每个字符的图形，叫<strong>点阵图案（Dot Matrix Patter）</strong>。如果图形卡看到一个 8 位二进制，发现是字母 K，那么会把字母 K 的点阵图案，通过<strong>CRT的 光栅扫描</strong>显示到屏幕的适当位置。</li>
<li>为了显示，”字符生成器” 会访问内存中一块特殊区域，这块区域专为图形保留，叫 <strong>屏幕缓冲区（Screen Buffer）</strong>，程序想显示文字时，修改这块区域里的值就行。</li>
</ul>
<p><strong>缺点</strong>：只能画字符到屏幕上，限制大，<strong>没法绘制任意形状</strong>。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>占用内存少得多</li>
<li>用字符也能模仿图形界面。不过由于字符集小，做不了复杂的绘图，可以对 ASCII 进行了各种扩展，加新字符。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598772490017-96dc79fa-5142-4ca8-a7bc-dab2048bce37.png" alt="image.png"></p>
<h2 id="屏幕矢量画图——CRT适量模式"><a href="#屏幕矢量画图——CRT适量模式" class="headerlink" title="屏幕矢量画图——CRT适量模式"></a>屏幕矢量画图——CRT适量模式</h2><p><strong>原理</strong>：所有东西都由线组成，只有线条，没有别的。要显示文字和其他图案，都是用线条画出来。</p>
<p><strong>实例</strong>：使用一个早期矢量显示系统Vectrex的适量命令来画三角形。</p>
<ol>
<li>首先使用RESET命令来清空屏幕， 同时将电子枪的绘图点移动到坐标(0,0)，也就是屏幕左上角，并将线的亮度设为0。 </li>
<li>调用MOVE_TO 50 50，就会将绘图点移动到坐标(50,50)。然后使用INTENSITY 100将强度设为100， 然后反复调用以上命令就会绘制出对应图形。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598772610968-90b7e359-c24b-406f-9f5b-4fab5e58fdd9.png" alt="image.png"></p>
<p>这些命令也就占160位，比直接保存一个像素矩阵好很多。</p>
<h2 id="Sketchpad-光笔"><a href="#Sketchpad-光笔" class="headerlink" title="Sketchpad + 光笔"></a>Sketchpad + 光笔</h2><p>1962年诞生的Sketchpad是一个巨大的里程碑，它是一个交互式图形界面，用于计算机辅助设计（CAD），它被认为是第一个完整的图形程序。</p>
<ul>
<li>为了与图形界面交互，Sketchpad 用了当时发明不久的输入设备 <strong>光笔</strong>：就是一个有线连着电脑的触控笔，笔尖用光线传感器，可以检测到显示器刷新，通过判断刷新时间，电脑可以知道笔的位置</li>
<li>有了光笔和各种按钮，用户可以画线和其他简单形状，甚至 Sketchpad 还可以让线条完美平行，长度相同，完美垂直90度，甚至动态缩放。用户还可以保存设计结果，方便以后再次使用，甚至和其他人分享。用户还可以有一整个库，里面有电子元件和家具之类的，可以直接拖进来用</li>
</ul>
<p><strong>意义</strong>：代表了人机交互方式的关键转折点</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598773059291-2db50db6-d0bb-4045-8a49-390b247c2041.png" alt="image.png"></p>
<h2 id="位图显示——使用像素"><a href="#位图显示——使用像素" class="headerlink" title="位图显示——使用像素"></a>位图显示——使用像素</h2><p><strong>时间</strong>：最早用真正<strong>像素</strong>的计算机和显示器出现于 1960 年代末</p>
<p><strong>定义</strong>：内存中的位(Bit) 对应屏幕上的像素，这叫 <strong>位图显示</strong>。</p>
<p><strong>优点</strong>：可以绘制任意图形了</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598773423202-6e88b437-0832-45d8-9c16-ac32c45efbd7.png" alt="image.png"></p>
<p>当然,程序员不会浪费时间从零写绘图函数</p>
<p>而是用预先写好的函数来做,画直线,曲线,图形文字等</p>
<h1 id="图形用户界面-Graphical-User-Interfaces"><a href="#图形用户界面-Graphical-User-Interfaces" class="headerlink" title="图形用户界面 Graphical User Interfaces"></a><strong>图形用户界面 Graphical User Interfaces</strong></h1><h2 id="现代图形界面先驱：道格拉斯·恩格尔巴特"><a href="#现代图形界面先驱：道格拉斯·恩格尔巴特" class="headerlink" title="现代图形界面先驱：道格拉斯·恩格尔巴特"></a><strong>现代图形界面先驱：道格拉斯·恩格尔巴特</strong></h2><ul>
<li>1962年发表一份名为”<strong>增强人类智力</strong>“的报告，认为，人类面临的问题比解决问题的能力增长得更快，因此，找到增强智力的方法似乎是必要且值得一做的目标。他构想计算机不仅做自动化工作，也可以成为未来知识型员工应对复杂问题的工具。</li>
<li>受 Sketchpad（几何画板） 启发，开始招募团队来做 oN-Line System，他意识到如果只有键盘，对他想搭建的程序来说是不够的，用户需要和屏幕上的信息互动，用某种设备在屏幕上移动[光标。1964年，<strong>鼠标诞生</strong>了。</li>
<li>1968年，他在”秋季计算机联合会议”展示了他的系统，包含了现代计算机的许多功能：位图图像、视频会议、文字处理、实时协作编辑文件等，还有现代图像界面的原型，比如鼠标和多窗口。这是跨时代的产品，在商业上失败了，但恩格尔巴特 因此获得1997年图灵奖。</li>
</ul>
<h2 id="施乐"><a href="#施乐" class="headerlink" title="施乐"></a><strong>施乐</strong></h2><ul>
<li>1970年，施乐公司成立”帕洛阿尔托研究中心”（<strong>Xerox PARC</strong>）。</li>
<li>1973年，开发了<strong>第一台带真正 GUI 的计算机——施乐奥托</strong>。</li>
<li>施乐奥托将2D屏幕当作”桌面”，用户可以打开多个程序，每个程序都在一个框里，叫”窗口”，就像桌上的文件一样。窗口可以重叠，挡住后面的东西。还有桌面配件，比如计算器和时钟，可以在屏幕上四处移动。</li>
<li>施乐奥托团队用窗口，图标，菜单和指针来设计界面，因此称为 WIMP 界面。</li>
<li>施乐奥托还提供了一套基本部件，比如按钮，打勾框，滑动条和标签页。<strong>GUI 程序</strong>就是这些小组件组成的。</li>
<li>1981年发布了 <strong>施乐之星系统</strong>。包含文件系统，文件看起来就像一张纸，还可以存在文件夹里。因为过于超前，在商业上失败了。</li>
<li>首先使用了 <strong>“剪切””复制””粘贴”</strong> 这样的术语。</li>
</ul>
<h2 id="苹果"><a href="#苹果" class="headerlink" title="苹果"></a><strong>苹果</strong></h2><ul>
<li>施乐公司找到苹果公司，寻求合作，最终施乐还买了苹果的一百万美元股份，但有一个额外条款：公布一切施乐研究中心正在进行的酷工作</li>
<li>史蒂夫·乔布斯去施乐参观后，回到苹果，开始开发新功能，比如菜单栏和垃圾桶，垃圾桶存删除文件，满了甚至会膨胀。</li>
<li>1983 年， <strong>Apple Lisa</strong> 发布，这是苹果第一款有图形界面和鼠标的产品。价格差不多是如今的 25000 美元，在市场上同样失败。</li>
<li> 1984 年，<strong>Macintosh</strong> 发布。价格大约是如今的6000美元，开售100天就卖了7万台。但在最初的狂潮后，销售额开始波动，Apple II 的销量高于 Mac，面临一个问题：没人给这台新机器做软件。</li>
</ul>
<h2 id="微软"><a href="#微软" class="headerlink" title="微软"></a><strong>微软</strong></h2><ul>
<li>1985年，<strong>Windows 1.0</strong> 发布。不如 Mac OS 漂亮，但搭载该系统的 PC 价格只有 Mac 的几分之一，得到了消费者的认可，也得到了软件开发者的认可。让微软在市场中站稳脚跟，奠定了统治地位，十年内，95％的个人计算机上都有微软的 Windows。</li>
<li>Windows 早期版本都是基于 DOS，而 DOS 设计时 没想过运行图形界面，一直到Windows 3.1。</li>
<li>1995年，<strong>Windows 95</strong> 发布，是面向消费者的 GUI 操作系统，不仅提供精美的界面，还有一些 Mac OS 没有的高级功能，比如”多任务”和”受保护内存”</li>
</ul>
]]></content>
      <categories>
        <category>计算机科学技术之</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之文件系统</title>
    <url>/posts/4d9a0402/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>存储器可以在断电状态下长时间存上万亿位，所以非常适合用来存一整块有关系的数据，或者称为<strong>文件（Files）</strong>，比如文本文件、音乐文件、照片和视频。这一节将讨论文件是什么以及计算机是怎么管理文件的。</p>
</blockquote>
<a id="more"></a>

<h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><p><strong>文件</strong>：一整块有关系的数据，<strong>文件的底层</strong>都<strong>是一长串二进制数</strong>。</p>
<p><strong>文件格式</strong>：虽然可以随意存储文件数据，但按格式存会更方便，也就是说文件格式定义了文件数据在存储器中的存储方式。</p>
<h2 id="文本文件：TXT格式"><a href="#文本文件：TXT格式" class="headerlink" title="文本文件：TXT格式"></a>文本文件：TXT格式</h2><p>就像其他文件一样，文本文件只是一长串二进制数，可以通过ASCII编码将其解码成对应文本。</p>
<p><strong>ASCII 编码</strong>：一种字符编码标准，将文件原本的 二进制数 解码为 英文、数字和其他字符</p>
<h2 id="音频文件：WAV格式"><a href="#音频文件：WAV格式" class="headerlink" title="音频文件：WAV格式"></a>音频文件：WAV格式</h2><p><strong>波形文件（Wave File，WAV）</strong>用于存音频数据。在正确读取数据之前，我们需要知道一些信息比如码率，以及是单声道还是立体声，这种关于数据的数据成为<strong>元数据（Meta Data）</strong>。元数据保存在文件开头，在实际数据之前，因此也叫<strong>文件头（Header）</strong>。以下是WAV文件的前44个字节，有些部分会根据数据进行变化。而音频数据就紧跟在元数据之后，也是一长串二进制数，这些数字代表每秒捕获多次的声音幅度。麦克风首先会对声音进行每秒上千次采样，每次采样可以用一个数字表示，声压越高数字越大，称为振幅（Amplitude），这就是WAV文件中存储的数据。播放声音时，扬声器就会产生相同的波形。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598618507222-eb357ddc-62ad-423a-b7a5-3a1b87eb71f0.png" alt="image.png"></p>
<h2 id="图片文件：BMP格式"><a href="#图片文件：BMP格式" class="headerlink" title="图片文件：BMP格式"></a>图片文件：BMP格式</h2><p><strong>位图</strong>：bitmap，文件后缀为 <code>.bmp</code>，用于存储图片文件</p>
<p><strong>实例</strong>：如下图所示，该图片 4像素宽 x 4像素高，颜色深度为 24 位，即 8 bit 表示红色， 8 bit 表示黄色， 8 bit 表示蓝色。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598618716105-902322b8-0326-455d-8dad-e32679d74388.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598618859723-46bb8bb2-112c-4bbd-9c41-d594568cad59.png" alt="image.png"></p>
<h1 id="文件系统：计算机如何存文件"><a href="#文件系统：计算机如何存文件" class="headerlink" title="文件系统：计算机如何存文件"></a>文件系统：计算机如何存文件</h1><p>早期计算机存储容量很小，<strong>整个存储器就像一个文件</strong>，数据从头存到尾，直到占满；随着计算能力和存储容量的提高 ，<strong>多文件</strong>变得非常必要。</p>
<p>目录文件以及对目录文件的管理，是最基本的<strong>文件系统（File System）</strong>的例子，文件系统专门负责管理文件。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>文件系统使我们不必关心文件在磁带或磁盘的具体位置，整理和访问文件更加方便</li>
<li>使得我们像普通用户一样直观操纵数据，比如打开和整理文件</li>
</ul>
<h2 id="目录文件-Directory-File"><a href="#目录文件-Directory-File" class="headerlink" title="目录文件 Directory File"></a>目录文件 Directory File</h2><p>最简单存储多个文件的方法是将文件<strong>连续存储</strong>，但是这样怎么知道文件开头和结尾在哪呢？存储器并没有文件的概念，它只是用来存储大量二进制数。所以我们需要特殊文件来记录其他文件的位置，这里称为<strong>目录文件（Directory File）</strong>，它通常保存在存储器最开头，方便寻找。</p>
<p><strong>作用</strong>：</p>
<ul>
<li>记录其他文件的文件名、扩展名、存储位置、元数据（eg.文件创建时间、最后修改时间、文件所有者、是否能读/写等）等信息。</li>
</ul>
<p><strong>位置</strong>：目录文件通常存在开头（位置0），以便于查找</p>
<p><strong>现代文件系统</strong>会做以下两件事：</p>
<ul>
<li><strong>把空间划分成一块块</strong>，使得有一些 “预留空间” 可以方便改动，也方便管理。目录文件记录文件存储在哪些块里。</li>
<li><strong>拆分文件，存储在多个块中</strong>。目录文件存储文件的位置时存储的是多个块，而不止是一块。因此，只要分配块，文件就可以轻松增大缩小。</li>
</ul>
<p><strong>举例</strong>，如下图所示：</p>
<ul>
<li>文件”todo.txt”存储在BLOCK1，扩增后超出BLOCK1的容量，则另外增加了BLOCK5</li>
<li>删除文件“carrie.bmp”，只是将目录里该文件的信息删除了，并没有擦除数据。因此在BLOCK2被新数据覆盖之前，原来的数据还在，所以可以恢复数据</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598619829504-c996c8a8-d2be-4212-9f68-d984bf7fbc9d.png" alt="image.png"></p>
<h2 id="碎片整理-defragmentation"><a href="#碎片整理-defragmentation" class="headerlink" title="碎片整理 defragmentation"></a>碎片整理 defragmentation</h2><p><strong>碎片</strong> <strong>fragmentation</strong>：文件的增删改，不可避免会导致<strong>碎片</strong>（文件散落在各个块中）。</p>
<p><strong>问题</strong>：对很多存储技术来说，碎片是坏事。eg. 如果上图的 todo.txt 存在磁带上，读取文件要先读块1, 然后快进到块5，然后往回转到块2，来回转个半天。现实世界中，大文件可能存在数百个块里，你可不想等五分钟才打开文件，因此碎片会造成问题。</p>
<p><strong>碎片整理</strong>：计算机会把数据来回移动，排列成正确的顺序</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1324638/1598620416585-1899f43c-cd30-4c4e-ad55-096fd31f3028.png" alt="image.png"></p>
<h2 id="平面文件系统-Flat-File-Systems"><a href="#平面文件系统-Flat-File-Systems" class="headerlink" title="平面文件系统 Flat File Systems"></a>平面文件系统 Flat File Systems</h2><p><strong>定义</strong>：文件都在同一个层次，都存储在同一个目录里。也就是没有子目录，没有目录嵌套。</p>
<p><strong>缺点</strong>：当我们想要对中间文件增加数据时，就会覆盖后续文件的数据。</p>
<h2 id="分层文件系统"><a href="#分层文件系统" class="headerlink" title="分层文件系统"></a>分层文件系统</h2><p><strong>起源</strong>：计算机容量爆炸式增长，文件数量也飞速增长，使得所有文件都存在同一层变得不切实际</p>
<p><strong>定义</strong>：文件夹套文件夹，目录文件不仅要指向文件，还要指向目录</p>
<p><strong>优点</strong>：</p>
<ul>
<li>能做无限深度的文件夹，便于文件分类整理</li>
<li>可以轻松移动文件：如果想把 theme.wav 从根目录移到音乐目录，不用移动任何数据块，只需在根目录删除该记录，在音乐目录增加该记录</li>
</ul>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之计算机安全</title>
    <url>/posts/d6843d0f/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的<strong>保密性、完整性和可用性</strong>。</p>
</blockquote>
<a id="more"></a>

<h1 id="计算机安全"><a href="#计算机安全" class="headerlink" title="计算机安全"></a>计算机安全</h1><p>计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的<strong>保密性、完整性和可用性</strong>。</p>
<p><strong>保密性（Secrecy）：</strong>只有有权限的人才能读取计算机系统和数据，比如黑客泄露别人的信用卡信息，就是攻击保密性。</p>
<p><strong>完整性（Integrity）：</strong>只有有权限的人才能使用和修改系统和数据，比如黑客假冒你发送邮件，就是攻击完整性。</p>
<p><strong>可用性（Availability）：</strong>有权限的人应该随时可以访问系统和数据，<strong>拒绝服务攻击（DDOS</strong>）就是黑客发送大量的假请求到服务器上，使得网站很慢或者直接挂掉，这就是攻击可用性。</p>
<p>为了实现这三个目标，安全专家会从抽象层面想想敌人可能是谁，这个称为<strong>威胁模型分析（Threat Model）</strong>。模型会对攻击者有个大致的描述：能力如何、目标是什么、可能使用什么手段。攻击手段又称为<strong>攻击矢量（Attack Vector）</strong>。威胁模型分析能够让你为特定情境做好准备，不被可能的攻击手段所淹没。换句话说，要怎么保护，具体看要对抗谁。</p>
<p>通常威胁模型分析中，会以能力水平进行区分。在给定的威胁模型下，安全架构师要提供解决方案，来保持系统安全。</p>
<p>有很多保护计算机系统、网络和数据的方法。很多安全问题可以总结成<strong>两个问题</strong>：</p>
<ol>
<li>你是谁？</li>
<li>你能访问什么？</li>
</ol>
<p>权限应该给适合的人而拒绝错误的人，所以为了区分谁是谁，我们使用<strong>身份认证（Authentication）</strong>来让计算机得知使用者是谁。通常身份认证有三种，各有利弊：</p>
<ol>
<li><strong>你知道什么：</strong>这个是基于某种只有用户和计算机知道的秘密，比如用户名和密码。这是如今使用最广最容易实现的方法。但是如果黑客知道了你的密码就惨了，或者可以通过暴力攻击试了密码的所有可能来获取你的密码，有些系统会在你尝试若干次错误后阻止你继续尝试。即使增长密码也很容易破解，所以现在很多网站都要求大小写字母加特殊字符，来增加可能的密码。</li>
<li><strong>你有什么：</strong>这是基于用户特定的物体，比如钥匙和锁。这种方法可以避免被人猜中密码的问题，而且通常需要人在现场，所以远程攻击就更加困难了。</li>
<li><strong>你是什么：</strong>这是基于你，通过你自己的特征展示给计算机来进行验证，比如指纹识别器和红膜扫描仪，这些方法特别的安全，但是最好的识别技术十分昂贵。“你知道什么”和“你有什么”是确定性的，但是来自传感器的数据每次都不相同，所以“你是什么”是概率性的，系统可能认不出你，或者将其他人认成了你。并且这种方法另一个问题就是无法重设，你无法修改自己的指纹或者虹膜。</li>
</ol>
<p>每种方法都有优缺点，一般建议使用两种或两种以上的认证方式。</p>
<p>当系统知道了你是谁，接下来就需要知道你能访问什么，这个称为<strong>访问控制（Access Control）</strong>，因此需要一个规范，来说明谁能访问什么、修改什么和使用什么。这个可以通过<strong>权限（Permission）</strong>或<strong>访问控制列表（Access Control List，ACL）</strong>来实现，其中描述了用户对每个文件、文件夹和程序的访问权限。</p>
<p>读权限：允许用户查看文件内容。</p>
<p>写权限：允许用户修改文件内容。</p>
<p>执行权限：运行用户运行文件。</p>
<p>有些阻止需要不同层次的权限，则ACL的正确配置就十分重要。假设我们有三个访问级别：<strong>公开、机密和顶级机密</strong>。有个经典模型称为<strong>Bell-LaPadula模型</strong>，其中包含两条规则：</p>
<ol>
<li>用户不能<strong>read up</strong>，即不能读等级更高的信息。</li>
<li>用户不能<strong>write down</strong>，即用户不能写更低权限的信息，这样能避免高级别的信息不会泄漏到低级别的文件中。</li>
</ol>
<p>通过身份认证和权限控制，可以让计算机知道你是谁和你能访问什么，但是必须先保证做这些事的软硬件必须是可信的。但是仍然无法保证程序或计算机系统的安全，因为安全软件在理论上可能是安全的，但是实现时可能会不小心留下漏洞。但是我们有办法减少漏洞出现的可能性，比如一发现漏洞就马上修补。</p>
<p>大部分漏洞都是具体实现时出错了，所以为了减少执行错误，就要减少执行。系统级安全的圣杯之一是安全内核或可信计算机基础：一组尽可能少的操作系统软件，这个安全性是接近可验证的。</p>
<p>构建安全内核的挑战在于，要决定内核应该有什么（代码越少越好）。当最小化代码数量后，要是能保证代码是安全的，那就很好了。现在最好的验证代码安全性的手段是<strong>独立安全监察和质量验证（Independent Verification and Validation）</strong>，让一群安全行业内的软件开发者来审计代码，这也是为什么安全型代码几乎都是开源的。</p>
<p>但是即使这样，还是有可能被黑客攻破，因此程序开发者需要控制损失的最大程度，这个称为<strong>隔离（Ioslation）</strong>。要实现隔离，可以<strong>“沙盒”（sandbox）</strong>程序，操作系统通过给每个程序独立的内存块，使得别的程序是无法触及的，这样就能把程序放到沙盒中，即使沙盒被破坏了，也不会影响别的程序执行。并且一台计算机可以运行多个<strong>虚拟机（Virtual Machine）</strong>，使得每个虚拟机都在自己的沙盒中。</p>
<h1 id="黑客与攻击"><a href="#黑客与攻击" class="headerlink" title="黑客与攻击"></a>黑客与攻击</h1><p>这里只介绍一些入侵原理，提供一个大概的概念。</p>
<p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p>
<p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p>
<p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，知道设备让你等待，这时只要把复制的内容覆盖掉内存，就无需等待，继续尝试密码。</p>
<p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p>
<p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p>
<p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SELECT password FROM users WHERE username=&#x27;___&#x27;;</span><br></pre></td></tr></table></figure>
<p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SELECT password FROM users WHERE username=&#x27;whatever&#x27;;DROP TABLE users;&#x27;;</span><br></pre></td></tr></table></figure>
<p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code>，这个是我们注入的命令，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p>
<p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p>
<p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p>
<p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p>
<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p>这节将介绍计算机安全中最常见的防御形式——密码学。</p>
<p>为了加密信息，要将<strong>加密算法（Cipher）</strong>将明文专为密文，除非知道如何解密，否则密文看起来就是一堆乱码，这种将明文专为密文的过程叫做<strong>加密（Encryption）</strong>，而相反过程称为<strong>解密（Decryption）</strong>。</p>
<p>加密算法早在计算机出现之前就存在了，凯撒使用我们如今称为<strong>凯撒加密（Caesar Cipher）</strong>的方法来加密私人信件，他会将信件中的字母向前移动3个位置，所以a变成d，brutus变成euxwxv。为了解密，接受者要知道使用了什么算法，以及偏移的字母位数作为钥匙。</p>
<p>有一大类算法称为<strong>替换加密（Substitution Cipher）</strong>，凯撒密码就是其中一种，算法把每个字母替换成其他字母。但是有一个巨大的缺点是，字母出现的频率是一样的，比如英语中字母E出现的频率最高，如果将E替换成了X，则密文中X的出现频率就会很高，通过统计字母频率，就有可能破译密码。</p>
<p>另一类加密算法叫<strong>移位加密（Permutation Cipher）</strong>，比如<strong>列移位加密（Columnar Transposition Cipher）</strong>，我们这里将明文填入网格，比如选择5x5大小的网格。为了加密信息，我们换一个顺序来读取，比如从左边开始，从下往上一次读一列，就会变成图2的形式，这样加密后的字母排列是不同的，，但是字母出现的频率没有变化。这里解密的关键是要知道读取方向和网格大小。</p>
<p><img src="https://pic4.zhimg.com/v2-ad22132f4bd318368243f25a680fba8f_r.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/v2-2f8bbc97560a1921161c1601c23b3442_r.jpg" alt="img"></p>
<p>到了1900年代，人们用密码学做了加密机器，比如德国的Enigma用来加密通讯信息。Enigma是一台类似打字机的机器，包含键盘和灯板，这两个都有完整的字母表，而且它还有一系列转子，这些是加密的关键。首先我们看一个转子，它一面有26个接触点，代表26个字母，然后线会连接到另一面来替换字母，其实这个就是替换加密。但是Enigma更加复杂，它有更多的转子，一个转子的输出作为下一个转子的输入，并且转子还有26个起始位置，还可以按不同顺序加入转子，来提供更多字母替换映射。转子之后是一个叫反射器的特殊电路，它每个引脚会连接另一个引脚，并把信号发回转子，最后机器前方有一个插板，可以把输入键盘的字母预先进行替换来增加一层复杂度。图中显示的是输入H后，经过加密会输出L，因为线路是双向的，所以输入L也会被加密成H，所以加密和解密步骤是一样的，直接将密文输入机器就能得到对应的明文。</p>
<p><img src="https://pic2.zhimg.com/v2-a93ea4bc100410987f352c87e3d25fc1_r.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/v2-7b79d79f273c903857207db7c25f8865_r.jpg" alt="img"></p>
<p>但是这个机器有个缺点，就是字母加密后，一定会变成另一个字母。</p>
<p>最后，为了让Enigma不只是简单的替换加密，每输入一个字母，转子就会转一格，这样比如你输入<code>AAA</code>，可能会输出<code>BDK</code>，映射会随着每次按键发生改变。</p>
<p>随着计算机出现，加密从硬件转向了软件。早期应用最广的加密算法是IBM和NSA于1977年开发的<strong>数据加密标准（Data Encryption Standard，DES）</strong>，DES最初用56位二进制密钥，但到了1999年，计算机能将DES所有可能密钥都试一遍，所以DES不再安全。所以在2001年出现了<strong>高级加密标准（Advanced Encryption Standard，AES）</strong>，AES使用128/192/256位密钥，使得暴力破解更加困难。</p>
<p>AES将数据切成一块一块，每块16个字节，然后用密钥进行一系列替换加密和移位加密，再加上一些其他操作，进一步加密信息，并且每块数据会重复这个过程10次以上。因为加密是需要时间的，如果使用过长的密钥或者加密次数过多，虽然更加安全，但是加密时间过长。目前AES被广泛应用，比如iPhone上加密文件，用WPA2协议在WiFi中访问HTTPS网站。</p>
<p>之前讨论的加密技术，都依赖于发送方和接收方都知道密钥，发送方用密钥进行加密，而接收方使用相同密钥来解密。现在我们需要某种方法，在公开的互联网上传递密钥给对方，但是这种方法不是很安全，密钥可能会被黑客拦截。解决方案就是<strong>密钥交换（Key Exchange）</strong>，这是一种不发送密钥，但依然让两台计算机在密钥上达到共识的算法。我们可以使用<strong>单向函数（One-way Function）</strong>来实现，这是一种数学操作，很容易计算出结果，但是想从结果逆向推算出输入非常困难。</p>
<p>以颜料为例，我们可以很容易地将多个颜料混合得到最终的颜色，但是想要从最终颜色推算出用了哪些颜料进行混合是非常困难的。在这个例子中，我们的密钥就是一种独特的颜色。首先有一个公开的颜色，所有人都可以看到，然后对方和我自己各自选择一个秘密颜色，为了交换密钥，我先将我的颜色和公开颜色进行混合，然后发送给对方，并且对方也将他的颜色和公开颜色混合后发送给我，当我收到对方发来的颜色后，也将自己的颜色混入，并且对方也这么操作，这样我们就都得到了由3中颜色混合的一样的最终颜色，我们就可以将这个最终颜色当做密钥。</p>
<p>计算机中，我们可以用<strong>Diffie-Hellman密钥交换</strong>，在Diffie-Hellman中，单向函数是<strong>模幂运算</strong>，首先将一个数作为基数（Base），再拿另一个数作为指数（Exponent），然后将其结果出于第三个数就得到我们想要的余数， <img src="https://www.zhihu.com/equation?tex=B%5Ex%5C%25M" alt="[公式]"> ，这样，如果只给B、M和余数很难知道x是多少，并且如果将数字变得很长，比如几百位，想要找到秘密指数几乎是不可能的。</p>
<p>在Diffie-Hellman中，我们有公开的数——基数B和模数M。为了安全地给对方发送信息，我们选择一个秘密指数X，然后将计算结果发送给对方，对方同样也选择一个秘密指数Y，然后也将计算结果发送给我，为了算出双方共用的密钥，我将对方的结果作为新的基数，再取X指数并求余，即 <img src="https://www.zhihu.com/equation?tex=(B%5EY+%5C%25M)%5EX%5C%25M=B%5E%7BXY%7D%5C%25M" alt="[公式]"> ，而对方也用相同方法进行计算，得到的也是相同结果。这样就可以将这个计算结果当做密钥，使用AES之类的加密技术进行加密通信。</p>
<p>Diffie-Hellman密钥交换时简历共享密钥的一种方法，双方使用一样的密钥加密和解密信息，称为<strong>对称加密（Symmetric Encryption）</strong>，因为加密和解密使用的密钥是一样的，前面的凯撒加密、Enigma和AES都是对称加密。同样还存在<strong>非对称加密（Asymmetric Encryption）</strong>，这里有两个不同的密钥，一个是公开的，一个是私有的，人们可以用公钥加密消息，而只有有私钥的人才能解密，所以知道公钥只能进行加密不能进行解密，而通过公钥加密后，也只能用私钥进行解密，所以它是不对称的。</p>
<p>比如有一个带锁的箱子，我们可以将锁和箱子给别人，他将信息放入箱子并上锁后还给我，我就可以通过自己的钥匙将其打开。</p>
<p>过程反过来也是可以的，可以用私钥加密再用公钥解密，这个通常用于签名。服务器可以用私钥进行加密，任何人都可以用服务器的公钥进行解密来获得信息，这使得私钥相当于一个签名，只有有私钥的人才能进行加密，只有当公钥能正确解密，才能证明数据来自正确的服务器或个人。</p>
<p>目前最流行的非对称加密技术是RSA。</p>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学技术之计算机网络</title>
    <url>/posts/4a543580/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>简要介绍计算机网络的历史及相关知识</p>
</blockquote>
<a id="more"></a>

<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>第一个计算机网络出现在1950-1960年代，通常在公司或研究室内部使用，方便信息交换，称为<strong>球鞋网络（Sneakernet）</strong>，第二个好处在于共享物理资源，比如多台计算机可以共享一台打印机，并且早期网络也会共享存储空间，因为为每台计算机都配存储器太过昂贵。</p>
<p>计算机近距离构成的小型网络称为<strong>局域网（Local Area Network，LAN）</strong>，局域网能小到是同一间房间内的两台计算机，或者大到校园内的上千台电脑。</p>
<p>其中最著名和成功的局域网技术是1970年代的<strong>以太网（Ethernet）</strong>，以太网最简单的形式是一条以太网电线连接数台计算机，当一台计算机要传数据给另一台计算机时，它以电信号形式，将数据传入电缆中，由于电缆是共享的，所以连接在同一个网络里的其他计算机都能看到数据，但是所有计算机都不知道这些数据是给自己的还是给别人的。为了解决这个问题，以太网需要每台计算机有唯一的<strong>媒体访问控制地址（Media Access Control Address，MAC Address）</strong>，然后将MAC地址作为数据的前缀发送到网络中，所以计算机只需要监听以太网电缆，只要看到自己的MAC地址，才去接收处理数据。现在制造的每台计算机都自带唯一的MAC地址，用于以太网和无线网络。</p>
<p><img src="https://pic4.zhimg.com/80/v2-bd0dfa011a483016ac431b355610fefb_1440w.jpg" alt="img"></p>
<p>这种多台电脑共享一个传输媒介（比如上面例子中共享的以太网电线）的方法称为<strong>载波侦听多路访问（Carrier Sense Multiple Access，CSMA）</strong>，这里的<strong>Carrier</strong>指的是传输数据用的任意共享传输媒介，比如以太网的载体就是铜线，WiFi的载体就是传播无线电波的空气。许多计算机可以同时侦听相同的载体，因此使用Sense和Multiple Access。而载体传输数据的速度称为<strong>带宽（Bandwidth）</strong>。</p>
<p>但是共享载体有个很大的<strong>弊端</strong>：当网络流量比较小时，计算机可以等待载体清空，然后再传输他们的数据。但随着网络流量上升，两台计算机想同时写入数据的概率也会上升，这称为<strong>冲突（Collision）</strong>，就会使得传输的数据混乱。幸好计算机能够监听电线里的信号来检测冲突，最简单的解决方案就是看到冲突就停止传输，等待网络空闲后再试一次，问题是其他计算机也是这样打算的，其他等待的计算机可能在任何停顿间隙就闯入开始传输数据，这就导致了越来越多的冲突。</p>
<p>以太网的<strong>解决方法</strong>是：当计算机检测到冲突后，就会在重传之前等待一小段时间，并且要保证所有计算机等待时间都不相同，所以就会让计算机等待1秒叫上一个随机时间，来相互避开。</p>
<p>当然这个并不能完全解决问题，还需要用到另一个技巧。如果一台计算机在传输数据期间检测到冲突，就等待1秒加上一个随机时间，但是如果再次发生冲突，就表明有网络拥塞，就让计算机等待2秒加上一个随机时间，以此类推，直到成功传输。因为计算机的退避，冲突次数会大幅减少，使得数据能够再次流动起来，网络就变得顺畅了。这种指数级增加等待时间的方法称为<strong>指数退避（Exponential Backoff）</strong>，很多以太网和WiFi都用到这个技术。</p>
<p>但是即使有了以上的技术，想用一根网线连接整个大学的计算机还是不可能的，为了减少冲突同时提高效率，我们需要减少同一载体中设备的数量，载体和其中的设备总称为<strong>冲突域（Collision Domain）</strong>。以之前以太网为例，一根电缆连接了6台计算机，这个称为一个冲突域。为了减少冲突，我们可以用<strong>交换机（Switch）</strong>将它拆成两个冲突域。交换机位于两个更小的网络之间，在必要时才在两个网络之间传输数据，并且交换机会记录一个<strong>列表</strong>，写着哪个MAC地址位于哪边网络，所以当MAC A想要传数据给MAC C，交换机就不会将数据传到另一边的网络，同理如果MAC E传输数据给MAC F，交换机也不会将数据传到上面的网络，这使得两边的传输能同时进行。但是如果MAC F想传数据给A，数据就会通过交换机，使得两个网络都会被短暂占用。</p>
<p><img src="https://pic4.zhimg.com/80/v2-059e0333f1ad801bb826f3f89afeb0a7_1440w.jpg" alt="img"></p>
<p>即使最大型的网络——<strong>互联网（Internet）</strong>也是这样构建起来的，本质还是多个连在一起的稍小一点的网络，使得不同网络间可以传递数据。而大型网络有一个特点，从一台主机到另一台主机通常有多条线路（<strong>解决的主要问题</strong>），这就引出了另一个话题——<strong>路由（Routing）（用来选择合适路线的方法）</strong>。</p>
<p><img src="https://pic3.zhimg.com/80/v2-618cd9d33b6ca884945143c2d8e3810e_1440w.jpg" alt="img"></p>
<p>连接两台相隔遥远的计算机或网络，最简单的方法是分配一条专门的通信线路，早期的电话系统就是这样运作的，这种方法称为<strong>电路交换（Circuit Switching）</strong>，因为是对整个电路进行修改，来连接到正确目的地，所以这种方法不灵活且价格昂贵，并且总有闲置的路线。但是好处是你可以最大限度随意使用，无需共享。因此军队、银行和其他一些机构依然会购买专门线路来连接数据中心。</p>
<p>传输数据的另一种方法是<strong>报文交换（Message Switching）</strong>，就像邮政系统一样。不像之前A和B之间有一条专有线路，这里消息会经过好几个站点，就类似于邮寄信封，信封会通过一个个中转站最终到达收件人手中，每个站点都知道下一站要发往哪里，因为站点都有自己一个<strong>表格</strong>，用来记录到达各个目的地，信件要如何传递。报文交换的<strong>好处是</strong>，你可以用不同的路由，使得通信更可靠。比如如果其中一个城市由于降雪无法接收邮件时，就能换到另一个城市继续传递数据。这里，城市就相当于网络中的路由器一样。</p>
<blockquote>
<p>交换机是连接若干个主机的机器，用来解决冲突域问题。路由器是连接主机、路由器或交换机的机器，用来构建数据传输的线路。</p>
</blockquote>
<p>信息沿着路由跳转的次数称为<strong>跳数（Hop Count）</strong>，通过记录跳数，可以分辨出路由问题。比如当路由A认为到达目的地最快的下一个路由是B，就将信息传递给路由B，而路由B则认为到达目的地最快的下一个路由是A，又将信息传递回给了路由A，这就使得信息在路由A和B之间踢皮球，但是这种错误可以通过在信息中实时记录的跳数来解决，如果某条信息的跳数很大，就说明路由有出问题，这个称为<strong>跳数限制（Hop Limit）</strong>。</p>
<p>而报文交换的<strong>缺点</strong>之一就是当报文较大时，会堵塞网络，因为这里要求将整个报文从一个路由传到下一个路由后，才能继续传递其他报文，当传输大报文时，其他报文要么等待它传递完，要么选择另一条效率较低的路线。解决方法就是将大报文分成很多小块，称为<strong>数据包（Packet）</strong>。和报文交换一样，每个数据包都有网络中的目的地址，因此路由器知道要发送到哪里，这个地址的具体格式由<strong>互联网协议（Internet Protocol，IP）</strong>定义。每个联网的计算机都需要一个<strong>IP地址（IP Address）</strong>，例如<code>172.217.7.238</code>。</p>
<blockquote>
<p>MAC地址用来标识每条计算机，而IP地址是对数据包而言的。</p>
</blockquote>
<p>路由器会平衡与其他路由器之间的负载，来确保传输可以快速可靠，称为<strong>拥塞控制 （Congestion Control）</strong>。有时候一个报文的多个数据包会经过不同线路，使得到达顺序也可能不相同，这对一些软件来说是存在问题的。幸运的是，在IP之上还有其他协议，比如TCP/IP可以解决乱序问题。</p>
<p>将数据拆分成多个小数据包，然后通过灵活的路由传递，非常高效且容错率高，这种方法称为<strong>分组交换（Packet Switching）</strong>。它的好处是可以去中心化，就没有单点失败问题。</p>
<p>如今全球的路由器协同工作，找出最高效的线路，用各种标准协议传输数据，比如<strong>因特网控制信息协议（Internet Control Message Protocol，ICMP）</strong>和<strong>边界网关协议（Border Gateway Protocol，BGP）</strong>。</p>
<h1 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h1><p>任意计算机都和一个巨大的分布式网络连接在一起，称为<strong>互联网（Internet）</strong>。</p>
<p>当你在家中通过计算机观看网上视频时，你的计算机首先需要连接到局域网LAN，这个局域网是由家里WiFi路由器连接的所有设备组成的。然后家里的局域网再通过路由器连接到<strong>广域网（Wide Area Network，WAN</strong>），广域网的路由器一般属于你的<strong>互联网服务提供商（Internet Service Provider，ISP）</strong>。在广域网里，首先会有一个区域性路由器，比如覆盖你所在街区的一个路由器，然后该路由器会连接到一个更大的广域网中，比如覆盖你所在的城市，可能再跳跃几次，最终会到达互联网主干，一般由一群超大型、带宽超高的路由器组成。</p>
<blockquote>
<p>即首先会连接到你家里的WiFi路由器构建的局域网，然后该路由器再连接到ISP提供的广域网中，该广域网是由很多层层递进的路由器构成的。</p>
</blockquote>
<p>比如要从YouTube中获得视频，数据包首先会到达互联网主干，沿着主干到达对应保存该视频文件的YouTube服务器，可能这里会跳4次到达互联网主干，然后跳两次穿过互联网主干，最终再跳4次到达YouTube服务器，所以总共会跳跃10次。</p>
<p>我们可以通过<code>traceroute</code>来看跳跃了几次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows上的Traceroute</span><br><span class="line">1.按开始按钮</span><br><span class="line">2.输入“ CMD”，然后按“ Enter”</span><br><span class="line">3.在命令提示符下，键入“ tracert dftba.com”</span><br><span class="line"></span><br><span class="line">在Mac上的Traceroute</span><br><span class="line">1.点击“转到”下拉菜单</span><br><span class="line">2.点击“实用程序”</span><br><span class="line">3.打开终端</span><br><span class="line">4.键入“ traceroute dftba.com”</span><br><span class="line"></span><br><span class="line">Linux上的Traceroute</span><br><span class="line">1.通过键入CTRL + Alt + T打开终端</span><br><span class="line">2.输入：“ traceroute dftba.com”</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/v2-ad036fdcd77f84f1660e8450f1e80d58_r.jpg" alt="img"></p>
<p>但是数据包到底是怎么传递过去的呢？如果传输时数据包丢失了，会发生什么？当我们在浏览器中输入网址时，浏览器怎么知道服务器的地址是什么呢？</p>
<p>就像上节介绍的，互联网是一个巨大分布式网络，如果要发送的数据较大，分组传输就会将数据拆成一个个较小的数据包进行传输。其中数据包要想在互联网上进行传输，就要符合<strong>互联网协议（Internet Protocol，IP）</strong>。类似于邮寄手写信一般，每封信都需要一个地址，并且地址必须是唯一的，并且信的大小和重量也是有限制的，否则信件就无法送达。IP数据包也是如此，因为IP是一个非常底层的协议，数据包的头部只包含目标地址（IP地址），意味着当数据包到达对方电脑时，计算机不知道要把数据包交给哪个程序（比如QQ或微信），因此需要在IP之上，开发更高级的协议。</p>
<p><img src="https://pic1.zhimg.com/80/v2-1dfe349330934319af7db52c2e6a1f20_1440w.jpg" alt="img"></p>
<p>最简单常见的协议称为用户数据报协议（User Datagram Protocol，UDP）。UDP也有头部，位于data payload里面，在data之前。UDP头部里面包含了很多有用的信息，其中之一就是<strong>端口号（Port Number）</strong>，每个想访问网络的程序都要向操作系统申请一个端口号。所以当数据包到达时，接收方的操作系统会读取UDP头部里的端口号，来确定该数据包是要交给哪个软件的。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ec8b9003913221d48a7cd5896c709232_1440w.png" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4b93626c61f38edb5e2508ff877bc512_1440w.jpg" alt="img"></p>
<blockquote>
<p>IP协议通过IP地址把数据包送到正确的计算机内；UDP通过数据包里的端口号送到正确的程序。</p>
</blockquote>
<p>同时UDP的头部中还有<strong>校验和（Checksum）</strong>，通过对数据求和来检查数据是否正确。假设UDP数据包里原始数据是<code>89 111 33 32 58 41</code>， 最简单的计算校验和的方式就是，在发送数据包之前，计算机会把所有数据加在一起，计算出校验和364。在UDP中，校验和是以16位形式存储的，如果计算出来的和超过16位能表示的最大值，则高位数会被丢弃，只保留低位。当接收方计算机接收到这个数据包时，也会重复以上过程，如果计算出来的校验和和UDP中保存的校验和相同，代表数据是正常的，否则数据是出错的。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9211cf69881af0f8ba2e4a8e8b5ce8ee_1440w.jpg" alt="img"></p>
<p>但是，UDP不提供数据修复或数据重发机制，当接收方知道数据损坏后，一般只是丢弃这个数据包。并且当发送方使用UDP协议发送数据包时，是无法得知数据包是否到达目的地的。</p>
<p>有些程序并不在意以上问题，因为UDP十分简单且快速。比如视频通常使用UDP协议，当数据包丢失时，也就造成视频卡顿。</p>
<p>但是有些数据不能接受数据包丢失的问题，比如发送电子邮件时，所有数据必须到达，所以就需要<strong>传输控制协议（Transmission Control Protocol，TCP）</strong>。和UDP一样，它的头部也保存在数据之前，人们通常将IP协议和TCP协议统称为<strong>TCP/IP协议</strong>。TCP的头部中也包含端口号和校验和，并且TCP协议还提供更高级的功能：</p>
<p><img src="https://pic1.zhimg.com/80/v2-969988861bec7064179dd4e99b60dbf8_1440w.png" alt="img"></p>
<ol>
<li>TCP的数据包是有序号的，使得接收方可以通过这个序号将数据包排成正确顺序，即使到达时间不同。</li>
<li>TCP要求接收方的电脑收到数据包并校验和检查无误后，需要给发送方发送一个<strong>确认码（Acknowledgement，ACK）</strong>，代表数据包已经正确接收。当发送方接收到确认码后，就知道上一个数据包成功抵达了，发送方就会发送下一个数据包，如果这次发送方过了一段时间没有接收到确认码，则会重新发送一次。即使这里只是由于确认码延迟了，使得接收方那里有重复的数据包，但是通过序列号，可以直接删除重复的数据包。</li>
</ol>
<p><img src="https://pic4.zhimg.com/v2-0caef9d75a93b514ed6f84d3c7f4ca63_r.jpg" alt="img"></p>
<p>并且数据包并不会一个个数据包进行传输，而是同时发送多个数据包，同时接收多个确认码，这将大大提高效率，不用浪费时间等待确认码。并且通过确认码的成功率和来回时间，我们可以推测网络的拥塞程度，TCP通过这个信息，来调整同时发包数量来解决拥塞问题。</p>
<p><img src="https://pic1.zhimg.com/v2-061760eadb27bb199a2a917547852efc_r.jpg" alt="img"></p>
<p>简而言之，TCP可以处理乱序和丢包问题，并且可以根据拥塞情况自动调整传输率。但是由于确认码数据包的存在，使得TCP需要传输的数据包数量翻了一倍，并且并没有传输更多信息，这对时间要求很高的程序代价太高，所以这类程序就会使用UDP协议。</p>
<p>当计算机访问一个网站时，需要两个东西：IP地址（目标网站的地址）和端口号（对应于你使用的计算机浏览器）。但是通过IP地址访问网站十分不方便，所以互联网提供一个特殊服务，来将<strong>域名（Domain Name）</strong>和IP地址一一对应，称为<strong>域名系统（Dimain Name System，DNS）</strong>，一般DNS服务器都是由ISP提供的。当你在浏览器中输入网站域名时，浏览器就会去访问DNS服务器，DNS就会去查表，如果域名存在，则会返回浏览器对应IP地址，然后浏览器就会给这个IP地址发送TCP请求。</p>
<p>因为当前域名特别多，所以DNS不会将其保存成列表形式，而是将其保存成树状结构。最顶层是<strong>顶级域名（Top Level Domain，TLD）</strong>，比如<code>.com</code>和<code>.gov</code>；下一层是<strong>二级域名（Second Level Domain）</strong>， 比如<code>google.com</code>和<code>dftba.com</code>；再下一层是<strong>子域名（Sub-domain）</strong>，比如<code>images.google.com</code>等等。由于这个树结构特别大，因此这些数据分布在很多DNS服务器上，不同服务器负责树的不同部分。</p>
<p><img src="https://pic1.zhimg.com/v2-d373ca2976fcc9af82483fd35094f7a4_r.jpg" alt="img">域结构</p>
<p>总结上两节的内容，其实计算机网络分成很多层次，接下来从最底层到最高层：</p>
<ol>
<li><strong>物理层（Physical Layer）</strong>，比如线路中的电信号，以及无线网络中的无线信号。</li>
<li><strong>数据链路层（Data Link Layer）</strong>负责操控物理层，其中包含MAC地址、冲突检测、指数回退以及其他一些底层协议。</li>
<li><strong>网络层（Network Layer）</strong>负责各种报文交换和路由技术。</li>
<li><strong>传输层（Transport Layer）</strong>负责在计算机之间进行点到点的传输，还会检测和修复错误，比如UDP和TCP协议。</li>
<li><strong>会话层（Session Layer）</strong>会使用TCP和UDP来创建连接，传递信息，然后关掉连接。</li>
</ol>
<p>以上是<strong>开放式系统互联通信参考模型（Open System Interconnection model，OSI）</strong>下的5层，这个框架将网络通信划分成了很多层，每一层处理各自的问题。这种抽象可以使得分工改进多个层，而无需考虑整体复杂性。并且OSI还有额外两层：<strong>表示层（Presentation Layer）</strong>和<strong>应用层（Application Layer）</strong>，在下一节中进行介绍。</p>
<h1 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h1><p>前两节介绍的东西共同组成了互联网，这一节将向上抽象一层，来讨论<strong>万维网（World Wide Web）</strong>。万维网和互联网的概念完全不同，万维网是运行于互联网之上的，还有其他比如Skype、Instagram等也是运行在互联网之上的。互联网是用来传输数据的管道，各种程序都会使用到，其中传输最多数据的程序就是万维网，我们可以使用特殊的程序——<strong>浏览器（Web Browser）</strong>来访问万维网。</p>
<p>万维网的最基本单位是单个页面，里面包含内容，也有访问其他页面的链接，这些链接称为<strong>超链接（Hyperlink）</strong>。这些超链接形成巨大的互联网络，这也是万维网名字的由来。</p>
<p>并且由于文字超链接的强大，它有一个特殊的名字——<strong>超文本（Hypertext）</strong>。如今超文本最常指向的是另一个页面，这些页面会被获取并由浏览器进行渲染。</p>
<p>为了使网页能够互相连接，每个网页需要一个唯一的地址，这个地址称为<strong>统一资源定位器（Uniform Resource Locator，URL）</strong>，比如<code>thecrashcourse.com/courses</code>就是一个页面URL。</p>
<p>当你访问<code>thecrashcourse.com</code>网址时，计算机首先会进行DNS查询，这里输入一个域名，然后DNS就会返回给浏览器对应的计算机IP地址。然后浏览器就会打开一个TCP连接到这个IP地址对应的计算机上，而这个计算机运行着一个特殊的软件——<strong>网络服务器（Web Server）</strong>，网络服务器的标准端口是80。此时，你的计算机就连接到了<code>thecrashcourse.com</code>对应的服务器了，下一步是向服务器请求<code>courses</code> 页面，这里就会用到<strong>超文本传输协议（Hypertext Transfer Protocol，HTTP）</strong>。</p>
<p>HTTP的第一个标准是1991年创建的HTTP 0.9，只有一个指令<code>GET</code> 。因为这里我们想要获取<code>courses</code>页面， 我们可以直接向服务器发送指令<code>GET/courses</code>， 该指令以ASCII编码发送到服务器，服务器会返回该网址对应的页面，然后浏览器就会将其渲染到屏幕上。如果用户点击了另一个链接，计算机就会重新发送一个GET请求。</p>
<p>在之后的版本中，HTTP添加了新的状态码，会将其放在请求页面的前面，比如状态码200表示网页被正确找到了，状态码400-499代表客户端出错。</p>
<p><img src="https://pic2.zhimg.com/v2-5c297a37758affab1974f221b51a678d_r.jpg" alt="img"></p>
<p>因为超文本的存储和发送都是以普通文本形式进行的，编码可能是ASCII或者UTF-8，这样就无法表明什么是链接，什么只是普通的文本了，所以必须开发一种标记方法，因此出现了<strong>超文本标记语言（Hypertext Markup Language，HTML）</strong>，第一代HTML创建于1990年的0.8版本，有18种指令。</p>
<p><img src="https://pic4.zhimg.com/v2-d1f17935f645f06fc006ff22a4d68d4b_r.jpg" alt="img"></p>
<p>综上，网络浏览器可以和网络服务器沟通，不仅获取网页和媒体，并且还负责显示。</p>
<p>随着后期万维网日益繁荣，人们越来越需要搜索。起初人们会维护一个目录，来链接到其他网站，但是随着网络越来越大，人工编辑目录变得很不方便，所以开发了搜索引擎。</p>
<p>最早的搜索引擎是JumpStation，它有3个部分：1. 通过爬虫来将新链接添加进自己的列表中。2. 不断扩张的索引，用来记录访问过的网页上出现了哪些词。3. 查询索引的搜索算法，比如输入了某个关键字，则包含这个关键字的网页就会显示出来。早期的搜索引擎的排名方式直接取决于搜索词在页面上的出现次数，但是有的网页会通过在页面中重复该关键字来提高排名。Google成名的很大原因就是提出了一种算法来解决这个问题，与其信任页面上的内容，搜索引擎会看其他网页有没有连接到这个网页。</p>
<p>最后提一个概念——<strong>网络中立性（Network Neutrality）</strong>，它指的是要对所有数据包都平等对待，速度和优先级都应该一样。</p>
]]></content>
      <categories>
        <category>计算机科学技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络之结构体系</title>
    <url>/posts/49f3519/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>计算机网络的分层模型概述以及相关概念的介绍</p>
</blockquote>
<a id="more"></a>

<h1 id="计算机网络体系概述"><a href="#计算机网络体系概述" class="headerlink" title="计算机网络体系概述"></a>计算机网络体系概述</h1><h2 id="计算机网络在信息时代的作用"><a href="#计算机网络在信息时代的作用" class="headerlink" title="计算机网络在信息时代的作用"></a>计算机网络在信息时代的作用</h2><ul>
<li>计算机网络已由一种<strong>通信基础设施</strong>发展成为一种重要的<strong>信息服务基础设施</strong></li>
<li>计算机网络已经像水，电，煤气这些基础设施一样，成为我们<strong>生活中不可或缺</strong>的一部分</li>
</ul>
<h2 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2><h3 id="网络、互联网和因特网"><a href="#网络、互联网和因特网" class="headerlink" title="网络、互联网和因特网"></a>网络、互联网和因特网</h3><p>网络：网络由<strong>若干节点和连接这些节点的链路</strong>组成。<br><img src="https://img-blog.csdnimg.cn/20210125175238302.png" alt="网络组成"></p>
<p>互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</p>
<p><img src="https://img-blog.csdnimg.cn/20210125175557264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="多个网络形成互联网"></p>
<p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p>
<blockquote>
<p><strong>internet与Internet的区别</strong></p>
<ul>
<li><p><strong>internet(互联网或互连网)**是一个通用名词，它泛指</strong>多个计算机网络互连而成的网络**。在这些网络之间的通信协议可以是任意的。</p>
</li>
<li><p><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。</p>
</li>
</ul>
<p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-cb6c0dd7a1f70e3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h3><p><img src="https://img-blog.csdnimg.cn/20210125180108669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="三个阶段"><br><strong>因特网服务提供者ISP(Internet Service Provider)</strong></p>
<p>提供给用户IP地址的角色，每个用户通过ISP提供的IP地址使用互联网，没有IP地址不可以使用互联网。</p>
<p>生活中电信等便是最经典的例子，其中在互联网中每个用户都可以是ISP。<br><img src="https://upload-images.jianshu.io/upload_images/24878825-332e68bc46bc59ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p>
</blockquote>
<p>基于ISP的三个结构互联网</p>
<p><img src="https://img-blog.csdnimg.cn/20210125180535421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="三层结构"></p>
<blockquote>
<p>一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p>
</blockquote>
<h3 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h3><p><img src="https://img-blog.csdnimg.cn/20210125180623902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p>边缘部分：由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p>
<p>核心部分：由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/230760/1560423887412-d4d4f5b7-65c7-4642-b8b5-3d41f8c386b8.png" alt="image"></p>
<blockquote>
<p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p>
<p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p>
<p><strong>端系统在功能上可能有很大的差别：</strong></p>
<ol>
<li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li>
<li>大的端系统则可以是一台非常昂贵的大型计算机。</li>
<li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。</li>
</ol>
</blockquote>
<h2 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h2><p>网络核心部分是互联网中最复杂的部分。</p>
<p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p>
<p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p>
<p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p>
<h3 id="电路交换（Circuit-Switching）"><a href="#电路交换（Circuit-Switching）" class="headerlink" title="电路交换（Circuit Switching）"></a>电路交换（Circuit Switching）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-cbb94cf7d6bc6f8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p>
<p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-7ad293b2ca19158b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp" alt="img"></p>
<ul>
<li><p>电话交换机接通电话线的方式称为电路交换；</p>
</li>
<li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p>
</li>
<li><p>电路交换的三个步骤：</p>
<p>  1、建立连接（分配通信资源）</p>
<p>  2、通话（一直占用通信资源）</p>
<p>  3、释放连接（归还通信资源）</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-acb87df045723236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p>
<p>这是因为计算机数据是突发式地出现在传输线路上的。</p>
<p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p>
</blockquote>
<h3 id="分组交换（Packet-Switching）"><a href="#分组交换（Packet-Switching）" class="headerlink" title="分组交换（Packet Switching）"></a>分组交换（Packet Switching）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c57bf61052cb33f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p>
<p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p>
<p>首部包含了<strong>分组的目的地址</strong></p>
<p>分组从源主机到目的主机，可走不同的路径。</p>
</blockquote>
<p>发送方</p>
<ul>
<li>构造分组</li>
<li>发送分组</li>
</ul>
<p>路由器</p>
<ul>
<li>缓存分组</li>
<li>转发分组</li>
<li>简称为“分组转发”</li>
</ul>
<blockquote>
<p>在路由器中的输入和输出端口之间没有直接连线。</p>
<p>路由器处理分组的过程是：</p>
<ol>
<li><p>把收到的分组先<strong>放入缓存（暂时存储）；</strong></p>
</li>
<li><p><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</p>
</li>
<li><p>把分组送到适当的端口<strong>转发</strong>出去。</p>
</li>
</ol>
</blockquote>
<p>接收方</p>
<ul>
<li>接收分组</li>
<li>还原报文</li>
</ul>
<h3 id="报文交换（Message-Switching）"><a href="#报文交换（Message-Switching）" class="headerlink" title="报文交换（Message Switching）"></a>报文交换（Message Switching）</h3><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p>
<h3 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h3><blockquote>
<p>假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e655a213714d1871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>分析：</p>
<p>电路交换：</p>
<ul>
<li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li>
<li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li>
</ul>
<p>报文交换：</p>
<ul>
<li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li>
<li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li>
</ul>
<p>分组交换：</p>
<ul>
<li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li>
<li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c56f91f290cbc92b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>计算机网络的精确定义并未统一</li>
<li>计算机网络的最简单的定义是：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong>。<ul>
<li>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</li>
<li>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li>
<li>集合：是指至少需要两台计算机；</li>
</ul>
</li>
<li>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件（一定包含有中央处理机CPU）互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。<ul>
<li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li>
<li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li>
</ul>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按交换技术分类：</strong></p>
<ul>
<li>电路交换网络</li>
<li>报文交换网络</li>
<li>分组交换网络</li>
</ul>
<p><strong>按使用者分类：</strong></p>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<p><strong>按传输介质分类：</strong></p>
<ul>
<li>有线网络</li>
<li>无线网络</li>
</ul>
<p><strong>按覆盖范围分类：</strong></p>
<ul>
<li><p>广域网WAN（Wide Area Network）:作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p>
</li>
<li><p>城域网MAN:作用范围一般是一个城市，可跨越几个街区甚至整个城市</p>
</li>
<li><p>局域网LAN:一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右）</p>
</li>
<li><p>个域网PAN:就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p>
</li>
</ul>
<p><strong>按拓扑结构分类：</strong></p>
<ul>
<li>总线型网络</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4ed63e74d9ced719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/384/format/webp" alt="img"></p>
<ul>
<li>星型网络</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f6a1849bcc443935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/260/format/webp" alt="img"></p>
<ul>
<li>环形网络</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ca133aaaf8fe8659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/308/format/webp" alt="img"></p>
<ul>
<li>网状型网络</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d0d30cddc7356396.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/557/format/webp" alt="img"></p>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><p>性能指标可以从不同的方面来度量计算机网络的性能。</p>
<p>常用的性能指标有8个 ⬇</p>
<h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>首先先了解比特：</p>
<p>比特：计算机中<strong>数据量的单位</strong>，也是信息论中信息量的单位。一个比特就是二进制数字中的一个1或0。</p>
<p>基本单位：bit(b) 比特<br>常用单位：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">8 bit = 1 Byte</span><br><span class="line"></span><br><span class="line">         KB = 2^10B</span><br><span class="line">           </span><br><span class="line">         MB = K KB = 2^20 B</span><br><span class="line">           </span><br><span class="line">         GB = K MB = 2^30 B</span><br><span class="line">           </span><br><span class="line">         TB = K GB = 2^40 B</span><br></pre></td></tr></table></figure>
<p>速率就是<strong>连接在计算机网络上的主机在数字信道上传送比特的速率</strong>，也称为<strong>比特率或数据率</strong>。</p>
<p>基本单位：bit/s(b/s，bps)</p>
<p>常用单位：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">kb/s = 10^3b/s</span><br><span class="line"></span><br><span class="line">         Mb/s = K Kb/s = 10^6 b/s</span><br><span class="line">         </span><br><span class="line">         Gb/s = k Mb/s = 10^9 b/s</span><br><span class="line">         </span><br><span class="line">         Tb/s = k Gb/s = 10^12 b/s</span><br></pre></td></tr></table></figure>
<p>注意！！</p>
<p><strong>数据单位bit中K = 2^10B</strong></p>
<p><strong>数据单位bit中K = 10^3B</strong></p>
<p>所以在计算过程中二者存在一定差距，不要弄错了。</p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>带宽在<strong>模拟信号系统</strong>中表示的是信号所包含的各种不同频率成分所占据的频率范围，也就是<strong>传输过程中最大频率与最小频率的范围</strong>。</p>
<p>带宽中计算机网络中的意义：</p>
<p>用来表示<strong>网络的通信线路所能传送数据的能力</strong>，因此网络带宽表示在<strong>单位时间内从网络中的某一点到另一个点所能通过的“最高数据率。</strong></p>
<p>单位：b/s(kb/s, Mb/s, Gb/s, Tb/s)，与速率相同。</p>
<p>在日常生活中的宽带带宽除以8，一般就是平时使用中的最高传输速率。（1B = 8bit）</p>
<p>是一个很重要的计算机网络性能指标。直接关系网络的应用体验。</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量表示<strong>在单位时间内通过某个网络（或信道、接口）的数据量。</strong></p>
<p>吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底<strong>有多少数据量能够通过网络</strong>。</p>
<p>吞吐量受网络的<strong>带宽或额定速率</strong>的限制。</p>
<blockquote>
<p>带宽1 Gb/s的以太网，代表其额定速率是1 Gb/s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽1 Gb/s的以太网，可能实际吞吐量只有 700 Mb/s，甚至更低。</p>
<p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p>
</blockquote>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p>
<p>网络时延由几部分组成：</p>
<ul>
<li><p>发送时延：主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p>
</li>
<li><p>传播时延：电磁波在信道中传播一定的距离需要花费的时间。</p>
</li>
<li><p>处理时延：主机或路由器在收到分组时要花费一定时间进行处理</p>
</li>
<li><p>排队时延：分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p>
</li>
</ul>
<blockquote>
<p>有时会把排队时延看成<strong>处理时延 一部分</strong></p>
<p>总时延 = 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5f9bf4982c20ad4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-dd48cf5be5b2a7f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p>
</blockquote>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积 = 传播时延 * 带宽</p>
<p>若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特。</p>
<p>实际上就是<strong>一个比特到达终点的单位时间内传输的比特个数</strong>。</p>
<p>链路的时延带宽积又称为以比特为单位的链路长度。</p>
<h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p>
<p>一个网络请求双向交互一次所需的时间。</p>
<p>往返时间RTT也是一个重要的性能指标</p>
<p>可以更好的了解到网络的情况</p>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p>
<p><strong>信道利用率</strong>：用来表示某信道有百分之几的时间是被利用的（有数据通过）。</p>
<p><strong>网络利用率</strong>是全网络的信道利用率的加权平均。</p>
<p>根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增大。如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2021012622503898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70" alt="时延与利用率关系"><br>当网络利用率达到50％时，时延就要加倍。</p>
<p>当网络利用率超过50％时，时延就急剧增大。</p>
<p>当网络利用率接近100％时，时延趋于无穷大。</p>
<p>因此要控制信道利用率不超过50％，否则就要准备扩容。</p>
<h4 id="丢包率："><a href="#丢包率：" class="headerlink" title="丢包率："></a>丢包率：</h4><p>丢包率即<strong>分组丢失率</strong>，是指在一定的时间范围内，传输过程中<strong>丢失的分组数量与总分组数量的比率。</strong></p>
<p>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。</p>
<p>分组在传输过程中出现<strong>误码</strong>，被结点丢弃。</p>
<p>分组<strong>到达一台队列已满的分组交换机时被丢弃</strong>，在通信量较大时就可能造成网络拥塞。</p>
<p>丢包率反映了网络的拥塞情况。</p>
<p>无拥塞时丢包率为0</p>
<p>轻度拥塞时丢包率为1％—4％</p>
<p>严重拥塞时丢包率为5％-15％</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/230760/1586578197640-28d8e905-7b3a-4d68-ac5b-66b3e789a9c0.png" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b5174af1551d6cee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>如今用的最多的是TCP/IP体系结构，现今规模最大的、覆盖全球的、基于TCP/IP的互联网并未使用OSI标准。</p>
<p>TCP/IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p>
<p>TCP/IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP/IP体系结构的网络层称为网际层</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f647ab572971d89a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1126/format/webp" alt="img"></p>
<blockquote>
<p>在用户主机的操作系统中，通常都带有符合TCP/IP体系结构标准的TCP/IP协议族。</p>
<p>而用于网络互连的路由器中，也带有符合TCP/IP体系结构标准的TCP/IP协议族。</p>
<p>只不过路由器一般只包含网络接口层和网际层。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6800e214b18c47c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/931/format/webp" alt="img"></p>
<blockquote>
<p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p>
<p>所以实际上TCP/IP协议只有三层：网际层、运输层、应用层。</p>
<p>其中：</p>
<p><strong>网际层核心协议是IP协议。</strong></p>
<p><strong>运输层的两个重要协议：TCP(可靠传输)、UDP(不可靠传输)。</strong></p>
<p><strong>应用层有大量的应用协议：HTTP、SMTP等等。</strong></p>
</blockquote>
<blockquote>
<p><strong>IP协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP协议和UDP协议（运输层）</strong>提供网络互连服务</p>
<p>而<strong>TCP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p>
<p><strong>UDP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p>
</blockquote>
<blockquote>
<p>TCP/IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-82255e6c6d5f29bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>教学时把TCP/IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p>
</blockquote>
<h1 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h1><p>1、计算机网络是个非常复杂的系统</p>
<p>2、“分层”可将庞大而复杂的问题，转化为若干较小的局部问题</p>
<p>基于以上原因选择对计算机网络进行分层。</p>
<p>其中各层的主要解决问题：</p>
<p>物理层：</p>
<ul>
<li>采用怎样的传输媒体（介质）？</li>
<li>采用怎样的物理接口？</li>
<li>使用怎样的信号表示比特0和1？</li>
</ul>
<p><strong>解决以上问题后就可以实现01信号在计算机之间的传输。</strong></p>
<p><strong>物理层问题</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0274083e0bf0da85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>这图说明</p>
<ul>
<li><p>第一，严格来说，传输媒体并不属于物理层</p>
</li>
<li><p>计算机传输的信号，并不是图示的方波信号</p>
</li>
</ul>
<p>这样举例只是让初学者容易理解</p>
</blockquote>
<p><strong>数据链路层问题</strong></p>
<ul>
<li>如何标识网络中的各主机（主机编址问题，例如MAC地址）？</li>
<li>如何从信号所表示的一连串比特流中区分出地址和数据？</li>
<li>如何协调各主机通信（例如，各主机争用总线，交换机的实现原理）？</li>
</ul>
<p><strong>解决此问题后可以实现分组在一个网络上传输。</strong></p>
<p><strong>网络层问题</strong></p>
<ul>
<li>如何标识各网络以及网络中的各主机（网络和主机共同编址的问题，例如IP地址）？</li>
<li>路由器如何转发分组，如何进行路由选择?</li>
</ul>
<p><strong>解决此问题后可以实现分组在网络间传输。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f55f86e0a78ffe23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>运输层问题</strong></p>
<ul>
<li>如何解决进程之间基于网络的通信？</li>
<li>出现传输错误时如何处理？</li>
</ul>
<p><strong>解决此问题后可以实现进程之间基于网络的通信。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-20174ff3821a739b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是QQ进程</p>
</blockquote>
<p><strong>应用层问题</strong></p>
<ul>
<li>通过应用进程间的交互来完成特定的网络应用。</li>
</ul>
<p><strong>解决此问题后可以实现计算机网络所解决的所有问题。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-edab6d1f00b0ab15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>应用层该用什么方法（应用层协议）去解析数据</p>
</blockquote>
<p><strong>总结</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-96bdae8525215011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d29fee34f68a16b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1cf0ec9780d80019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="3、计算机网络体系结构分层思想举例"><a href="#3、计算机网络体系结构分层思想举例" class="headerlink" title="3、计算机网络体系结构分层思想举例"></a>3、计算机网络体系结构分层思想举例</h2><p><strong>解析：</strong></p>
<p>主机和Web服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与Web服务器中的<strong>Web服务器应用进程</strong>之间基于<strong>网络的通信</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8c5d1b3fdc1b7111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p>
<p><strong>1、发送方发送</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ac36f7a9544dde9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>第一步：</p>
<ul>
<li><p><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></p>
</li>
<li><p>应用层将<strong>HTTP请求报文</strong>交付给<strong>运输层</strong>处理</p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-cc2b73b1736d5809.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>第二步：</p>
<ul>
<li><p><strong>运输层</strong>给<strong>HTTP请求报文</strong>添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></p>
</li>
<li><p><strong>TCP报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</p>
</li>
<li><p><strong>运输层</strong>将T<strong>CP报文段</strong>交付给<strong>网络层</strong>处理</p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-dc02183dcf759d9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>第三步：</p>
<ul>
<li><p><strong>网络层</strong>给<strong>TCP报文段</strong>添加一个<strong>IP首部</strong>，使之成为<strong>IP数据报</strong></p>
</li>
<li><p><strong>IP数据报的首部格式</strong>作用是使<strong>IP数据报</strong>可以在互联网传输，也就是被路由器转发</p>
</li>
<li><p><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong>处理</p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f8cf8ce4a6bfdb54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>第四步：</p>
<ul>
<li><p><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> （图示右边为首部，左边为尾部）</p>
</li>
<li><p>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</p>
</li>
<li><p>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</p>
</li>
<li><p><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e7285afa504bce0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>第五步：</p>
<ul>
<li><p><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络N1假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></p>
</li>
<li><p><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</p>
</li>
<li><p><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8ffee68ffe58b8a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>第六步：</p>
<ul>
<li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li>
</ul>
</blockquote>
<p><strong>2、路由器转发</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b9824f4625354b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/945/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-09a0b27933c9895e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/832/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6eace5a882cca26d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/697/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-92d182edd57d1054.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp" alt="img"></p>
<blockquote>
<p>在路由器中</p>
<ul>
<li><p><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></p>
</li>
<li><p><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></p>
</li>
<li><p><strong>网络层</strong>解析<strong>IP数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bc79de20a0c4b57c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/638/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-33d09406bfc433e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/674/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-28228b60dd019bb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/740/format/webp" alt="img"></p>
<blockquote>
<p>在路由器中</p>
<ul>
<li><p>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</p>
</li>
<li><p><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong></p>
</li>
<li><p><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></p>
</li>
<li><p><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></p>
</li>
<li><p><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></p>
</li>
<li><p>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></p>
</li>
</ul>
</blockquote>
<p><strong>3、接收方接收</strong></p>
<blockquote>
<p>和发送方（主机）发送过程的封装正好是反着来</p>
<p>在Web 服务器上</p>
<ul>
<li><p><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></p>
</li>
<li><p><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></p>
</li>
<li><p><strong>网络层</strong>将<strong>IP数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></p>
</li>
<li><p><strong>运输层</strong>将<strong>TCP报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></p>
</li>
<li><p><strong>应用层</strong>对<strong>HTTP请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></p>
</li>
</ul>
<p><strong>发回响应报文的步骤和之前过程类似</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d9f5b6ce408c252b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="计算机网络体系结构中的专用术语"><a href="#计算机网络体系结构中的专用术语" class="headerlink" title="计算机网络体系结构中的专用术语"></a>计算机网络体系结构中的专用术语</h2><p>以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP/IP的四层体系结构和五层协议体系结构</p>
<p><strong>实体：</strong></p>
<p>实体是指<strong>任何可发送或接收信息的硬件或软件进程。</strong></p>
<p>对等实体是指<strong>通信双方相同层次中的实体</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b4c748c8f731e416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>协议</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-01d621fd0afde0a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>协议：控制两个对等实体进行逻辑通信的规则的集合</p>
<p>协议三要素：</p>
<ul>
<li><p>语法：定义所交换信息的格式</p>
</li>
<li><p>语义：定义收发双方所要完成的操作</p>
</li>
<li><p>同步：定义收发双发的时序关系</p>
</li>
</ul>
</blockquote>
<p><strong>服务</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b3d7eb63257d9914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f24a75796ed2c7f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f9bd7898a7f2dadd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络之物理层</title>
    <url>/posts/18784b9d/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p>物理层是计算机网络的第一层，是整个计算机网络系统的基础，为数据传输提供可靠的环境。</p>
<p>物理层要解决的<strong>基本问题</strong>：<strong>如何在各种传输媒体上传输比特0和1</strong>的问题。进而给数据链路层提供透明传输比特流的服务。</p>
<p>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</p>
<h4 id="物理层协议的主要任务"><a href="#物理层协议的主要任务" class="headerlink" title="物理层协议的主要任务"></a>物理层协议的主要任务</h4><p>定义物理层的四个特性：</p>
<ul>
<li><strong>机器特性</strong>：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</li>
<li><strong>电器特性</strong>：指明在接口电缆的各条线上出现的电压的范围。</li>
<li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义。</li>
<li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
<p>由于传输媒体种类众多（双绞线、光纤等），物理连接方式也很多（点对点连接、广播连接等），因此物理协议有很多种，但是<strong>每一种都需要包括以上四个特性。</strong></p>
<hr>
<h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p>
<p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p>
<h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p>
<p><strong>同轴电缆</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-50d3acc8eff03935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>双绞线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-692dde0bbbc49a1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>光纤</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-fc85597b91c2cd7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-060d940d8451692e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>多模光纤</strong></p>
<ul>
<li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li>
</ul>
<p><strong>单模光纤</strong></p>
<ul>
<li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li>
</ul>
</blockquote>
<p><strong>电力线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2c23cb1d18aa345c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1175/format/webp" alt="img"></p>
<h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><p>非导引型传输媒体是指自由空间。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8432039f51003722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d2a8692970355b05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>无线电波</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-357bc29ed7591006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>微波</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f042b478ef808a1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>红外线</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-95eac658ca822ab2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>可见光</strong></p>
<p><a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">LIFI</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e1bc3e93ff50114b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-54b03a1b4fd3cdd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/787/format/webp" alt="img"></p>
<blockquote>
<p><strong>串行传输</strong>：</p>
<ul>
<li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li>
</ul>
<p><strong>并行传输</strong>：</p>
<ul>
<li><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p>
</li>
<li><p>并行传输的优点是比串行传输的速度n倍，但成本高</p>
</li>
</ul>
<p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p>
</blockquote>
<h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-15060e3d8de110ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>同步传输</strong>：</p>
<ul>
<li><p>数据块以稳定的比特流的形式传输。字节之间没有间隔</p>
</li>
<li><p>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</p>
</li>
<li><p>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</p>
</li>
</ul>
<p>所以要使收发双发时钟保持同步</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-19cfd094ecef0538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>异步传输</strong>：</p>
<ul>
<li><p>以字节为独立的传输单位，字节之间的时间间隔不是固定</p>
</li>
<li><p>接收端仅在每个字节的起始处对字节内的比特实现同步</p>
</li>
<li><p>通常在每个字节前后分别加上起始位和结束位</p>
</li>
</ul>
</blockquote>
<h2 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h2><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p>
<p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p>
<p><strong>单向通信</strong>：</p>
<p>又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5b07729ff4cd3411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>双向交替通信</strong>：</p>
<p>又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e0f90a502a95d1b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>双向同时通信</strong>：</p>
<p>又称为<strong>全双工通信</strong>，即通信的双发可以同时发送和接收信息。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-68977b7eeac3b7f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p>
<p><strong>双向同时通信</strong>的传输效率最高</p>
</blockquote>
<h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p><img src="https://upload-images.jianshu.io/upload_images/24878825-acc59055804f0890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>常用术语</strong></p>
<ul>
<li><p><strong>数据 (data)</strong> —— 运送消息的实体。</p>
</li>
<li><p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。</p>
</li>
<li><p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。</p>
</li>
<li><p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。</p>
</li>
<li><p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p>
</li>
<li><p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p>
</li>
<li><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong> (modulation)。</p>
</li>
</ul>
</blockquote>
<p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ded8a3e566f7687b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/715/format/webp" alt="img"></p>
<h2 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a><strong>传输媒体与信道的关系</strong></h2><blockquote>
<p><strong>信道的几个基本概念</strong></p>
<ul>
<li><p><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</p>
</li>
<li><p><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</p>
</li>
<li><p><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</p>
</li>
<li><p><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。</p>
</li>
</ul>
</blockquote>
<p>严格来说，传输媒体不能和信道划等号</p>
<p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-414f829a7df390e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/893/format/webp" alt="img"></p>
<p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d3b3583526407c45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/827/format/webp" alt="img"></p>
<blockquote>
<p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p>
</blockquote>
<h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><p><strong>不归零编码</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2f6b70fef84339ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<ul>
<li><p>正电平表示比特1/0</p>
</li>
<li><p>负电平表示比特0/1</p>
</li>
</ul>
<p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0732d0edc74846b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>这需要发送方的发送与接收方的接收做到严格的同步</p>
<ul>
<li><p>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</p>
</li>
<li><p><strong>但是</strong>对于计算机网络，<strong>宁愿利用这根传输线传输数据信号</strong>，而不是传输时钟信号</p>
</li>
</ul>
<p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p>
</blockquote>
<p><strong>归零编码</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8aa838a116fdafb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2fa351ff35477f1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/723/format/webp" alt="img"></p>
<blockquote>
<p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p>
</blockquote>
<p><strong>曼彻斯特编码</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a34a686a9d052e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>在每个码元时间的中间时刻，信号都会发生跳变</p>
<ul>
<li><p>负跳变表示比特1/0</p>
</li>
<li><p>正跳变表示比特0/1</p>
</li>
<li><p>码元中间时刻的跳变即表示时钟，又表示数据</p>
</li>
</ul>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
<p>传统以太网使用的就是曼切斯特编码</p>
</blockquote>
<p><strong>差分曼彻斯特编码</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9a758474e374329a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p>
<ul>
<li><p><strong>跳变仅表示时钟</strong></p>
</li>
<li><p><strong>码元开始处电平是否变换表示数据</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   变化表示比特1&#x2F;0</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">*   不变化表示比特0&#x2F;1</span><br></pre></td></tr></table></figure>

<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
<p>比曼彻斯特编码变化少，更适合较高的传输速率</p>
</blockquote>
<p><strong>总结</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-de92dd43d328b4f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK/直接序列扩频DSSS/正交频分复用OFDM等<strong>调制</strong>方式。</p>
<p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p>
<p><strong>基本调制方法</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-7ce461637de91b6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<ul>
<li><p><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</p>
</li>
<li><p><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</p>
</li>
<li><p><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</p>
</li>
</ul>
<p>但是使用基本调制方法，1个码元只能包含1个比特信息</p>
</blockquote>
<p><strong>混合调制</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8fec8ccb7ff3ea77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-30e70220d4127135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1cb6de826ba63b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-600f7802e1eaa18a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1e2617434d904ce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p>
<h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><ul>
<li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</li>
<li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a9bbf5bcd5e8226.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>失真的原因：</p>
<ul>
<li>码元传输的速率越高</li>
<li>信号传输的距离越远</li>
<li>噪声干扰越大</li>
<li>传输媒体质量越差</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b90918937a54faa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-57e105e5df793b93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>奈氏准则和香农公式对比：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5ce50e745950c8eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h1 id="补充：信道复用技术"><a href="#补充：信道复用技术" class="headerlink" title="补充：信道复用技术"></a>补充：信道复用技术</h1><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p>
<h2 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h2><p>复用 (multiplexing) 是通信技术中的基本概念。</p>
<p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8503f147c44d220f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p>
<ul>
<li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li>
<li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bcb9321a6a8a3d7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/425/format/webp" alt="img"></p>
<p><strong>时分复用TDM (Time Division Multiplexing)</strong></p>
<ul>
<li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li>
<li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li>
<li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-cb9a20b7ce00d497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<ul>
<li><strong>时分复用可能会造成线路资源的浪费</strong><ul>
<li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c1ef02caf1f2cfda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>统计时分复用 STDM (Statistic TDM)</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-7f0b54d1c14702ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h2><p>波分复用 WDM(Wavelength Division Multiplexing)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-039cdf67599ebe3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>码分复用 CDM (Code Division Multiplexing)</p>
<ul>
<li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li>
<li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li>
<li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络之应用层</title>
    <url>/posts/41158dda/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<h1 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h1><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023195112701.png" alt="image-20201023195112701"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023200511781.png" alt="image-20201023200511781"></p>
<p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023200819770.png" alt="image-20201023200819770"></p>
<p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP/IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023201028141.png" alt="image-20201023201028141"></p>
<p>常见的应用</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023201101024.png" alt="image-20201023201101024"></p>
<p>总结</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023201137047.png" alt="image-20201023201137047"></p>
<hr>
<h1 id="客户-服务器方式（C-S方式）和对等方式（P2P方式）"><a href="#客户-服务器方式（C-S方式）和对等方式（P2P方式）" class="headerlink" title="客户/服务器方式（C/S方式）和对等方式（P2P方式）"></a>客户/服务器方式（C/S方式）和对等方式（P2P方式）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023201308269.png" alt="image-20201023201308269"></p>
<h2 id="客户-服务器方式（C-S方式）"><a href="#客户-服务器方式（C-S方式）" class="headerlink" title="客户/服务器方式（C/S方式）"></a>客户/服务器方式（C/S方式）</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023201610088.png" alt="image-20201023201610088"></p>
<h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023202017683.png" alt="image-20201023202017683"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c1c3868fb5e127b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li>
<li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li>
</ul>
<h2 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h2><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023205719672.png" alt="image-20201023205719672"></p>
<blockquote>
<p>如果主机数很多，就工作量大，容易出错</p>
</blockquote>
<p>如果我们给网络中添加一台DHCP服务器</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023210345650.png" alt="image-20201023210345650"></p>
<h2 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h2><p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li>
<li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li>
<li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li>
</ul>
<p><strong>DHCP 工作方式</strong></p>
<ul>
<li>DHCP 使用客户-服务器方式，采用请求/应答方式工作。</li>
<li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li>
</ul>
<p><strong>DHCP交互过程</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023211525686.png" alt="image-20201023211525686"></p>
<blockquote>
<p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p>
<ul>
<li>事务ID</li>
<li>DHCP客户端的MAC地址</li>
</ul>
<p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p>
<p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p>
<p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023213058543.png" alt="image-20201023213058543"></p>
<blockquote>
<p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p>
<ul>
<li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li>
<li>配置信息：<ul>
<li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li>
<li>子网掩码</li>
<li>地址租期</li>
<li>默认网关</li>
<li>DNS服务器</li>
</ul>
</li>
</ul>
<p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p>
<p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p>
</blockquote>
<p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023214542329.png" alt="image-20201023214542329"></p>
<blockquote>
<p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p>
<ul>
<li>事务ID</li>
<li>DHCP客户端的MAC地址</li>
<li>接收的租约中的IP地址</li>
<li>提供此租约的DHCP服务器端的IP地址</li>
</ul>
<p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p>
<p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p>
</blockquote>
<p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023215341522.png" alt="image-20201023215341522"></p>
<blockquote>
<p>源地址：DHCP服务器1的IP地址</p>
<p>目的地址：广播地址</p>
<p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p>
<p><strong>在使用前还会进行ARP检测</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023215652859.png" alt="image-20201023215652859"></p>
</blockquote>
<p>剩下流程图示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a01eacfba40e9098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023221111923.png" alt="image-20201023221111923"></p>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023221251022.png" alt="image-20201023221251022"></p>
<hr>
<h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>域名相比IP地址更容易记忆</p>
<p>因特网是否可以只使用一台DNS服务器？</p>
<p>不行</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023235123151.png" alt="image-20201023235123151"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023235231869.png" alt="image-20201023235231869"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023235457857.png" alt="image-20201023235457857"></p>
<blockquote>
<p>名称相同的域名其等级未必相同</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201023235617575.png" alt="image-20201023235617575"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c2350ce866abf74e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024000255580.png" alt="image-20201024000255580"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024000335147.png" alt="image-20201024000335147"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024000408396.png" alt="image-20201024000408396"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024002135210.png" alt="image-20201024002135210"></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024002224354.png" alt="image-20201024002224354"></p>
<hr>
<h1 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024132745558.png" alt="image-20201024132745558"></p>
<h2 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h2><p>FTP采用C/S方式（客户/服务器方式）</p>
<p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024133155327.png" alt="image-20201024133155327"></p>
<p>FTP客户计算机也可以从FTP服务器计算机下载文件</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024133247537.png" alt="image-20201024133247537"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024133400777.png" alt="image-20201024133400777"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024133601943.png" alt="image-20201024133601943"></p>
<h2 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h2><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p>
<p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024134319922.png" alt="image-20201024134319922"></p>
<p>下图为建立数据通道的TCP连接</p>
<p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024134624114.png" alt="image-20201024134624114"></p>
<blockquote>
<p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p>
</blockquote>
<p>下图实例为被动模式</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024135018620.png" alt="image-20201024135018620"></p>
<p>两种模式对比</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024135050743.png" alt="image-20201024135050743"></p>
<blockquote>
<p>注意两种模式都是</p>
<p>控制连接在整个会话期间保持打开状态</p>
<p>数据连接传输完毕后就关闭</p>
</blockquote>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2b566956ff071b24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024151757221.png" alt="image-20201024151757221"></p>
<h2 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024152052056.png" alt="image-20201024152052056"></p>
<h2 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024152628966.png" alt="image-20201024152628966"></p>
<h2 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024153425016.png" alt="image-20201024153425016"></p>
<h2 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024153736033.png" alt="image-20201024153736033"></p>
<h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024154039565.png" alt="image-20201024154039565"></p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-b400e3f6c0a87238.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p><strong>概述</strong></p>
<ul>
<li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li>
<li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li>
<li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li>
<li>这种访问方式称为“<strong>链接</strong>”。</li>
</ul>
<p><strong>万维网的工作方式</strong></p>
<ul>
<li>万维网以<strong>客户 - 服务器</strong>方式工作。</li>
<li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li>
<li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li>
<li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024170819303.png" alt="image-20201024170819303"></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024171432743.png" alt="image-20201024171432743"></p>
<p><strong>万维网应用举例</strong></p>
<p>访问网页</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024170923530.png" alt="image-20201024170923530"></p>
<p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024171058583.png" alt="image-20201024171058583"></p>
<p><strong>万维网的文档</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024171724030.png" alt="image-20201024171724030"></p>
<h2 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h2><h3 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h3><ul>
<li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li>
<li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024222457800.png" alt="image-20201024222457800"></p>
<ul>
<li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li>
<li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li>
<li>最后，TCP 连接就被释放了。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024222825888.png" alt="image-20201024222825888"></p>
<h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p><strong>HTTP请求报文格式</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024224828528.png" alt="image-20201024224828528"></p>
<p><strong>HTTP响应报文格式</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024224920638.png" alt="image-20201024224920638"></p>
<h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024224945200.png" alt="image-20201024224945200"></p>
<h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024224632514.png" alt="image-20201024224632514"></p>
<p>如果该请求有缓存</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024224720124.png" alt="image-20201024224720124"></p>
<p>如果该请求没有缓存</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024225013288.png" alt="image-20201024225013288"></p>
<blockquote>
<p>若WEb缓存的命中率比较高</p>
<p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p>
</blockquote>
<p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p>
<p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p>
<p>若未过期</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024225504869.png" alt="image-20201024225504869"></p>
<p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024225846863.png" alt="image-20201024225846863"></p>
<p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p>
<p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89.assets/image-20201024230242550.png" alt="image-20201024230242550"></p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-dab94fae0e969502.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络之运输层</title>
    <url>/posts/51f8ba2a/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<h1 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>进程之间的通信</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-86df51cb4523e3bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/607/format/webp" alt="img"></p>
<ul>
<li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-09b69e8c98c856d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>进程之间通信流程</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d9a70806edc95dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p>
<blockquote>
<p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p>
<p>在运输层使用不同的端口，来对应不同的应用进程</p>
<p>然后通过网络层及其下层来传输应用层报文</p>
<p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p>
<p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a6a6ccc0bbd7f56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-49194e15f1010ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-04161b0a03409d04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/951/format/webp" alt="img"></p>
<hr>
<h1 id="运输层端口号、复用与分用的概念"><a href="#运输层端口号、复用与分用的概念" class="headerlink" title="运输层端口号、复用与分用的概念"></a>运输层端口号、复用与分用的概念</h1><h2 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-de597eda77aa6acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a4ec3f5d5c11433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p>
<p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做 <strong>分用</strong>。</p>
</blockquote>
<h2 id="TCP-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP/IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2117fa99a7f2a89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h2><p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1a74e63c3af96dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>在浏览器输入域名，回车浏览</p>
<p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p>
<p>DNS查询请求报文需要使用运输层的UDP协议</p>
<p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p>
<p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-30701c2470e290ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c4b699dfdd16826d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p>
<p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p>
<p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p>
<p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p>
<p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6912810cd1134dc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-eddf54c480b0a2b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>用户PC收到该数据报后，从中解封出UDP用户数据报</p>
<p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p>
<p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p>
</blockquote>
<p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e60fa3dedd69fae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1184eefc458e27b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5fd36c843b4e1bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-62b9ed69203838ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4e8b2e2943e1ec81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP/IP体系结构<strong>运输层</strong>中的两个重要协议</li>
<li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li>
<li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li>
</ul>
<p>可靠信道与不可靠信道</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-fceecce4ac04df77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/909/format/webp" alt="img"></p>
<ul>
<li>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</li>
<li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</li>
<li>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-58c94f043969af9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>UDP的通信是无连接的，不需要套接字（Socket）</p>
<p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p>
<h2 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h2><p>可以发送广播</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6b064807ce85da9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/937/format/webp" alt="img"></p>
<p>可以向某个多播组发送多播</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ad578349b071fd1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/983/format/webp" alt="img"></p>
<p>还可以发送单播</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4d5ff7d4922fd433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/914/format/webp" alt="img"></p>
<blockquote>
<p>UDP 支持单播、多播以及广播</p>
<p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p>
</blockquote>
<p>运输过程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-93e3dea8064d7a6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/949/format/webp" alt="img"></p>
<blockquote>
<p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p>
<p>换句话说，UDP是面向应用报文的</p>
</blockquote>
<p>UDP向上层提供无连接不可靠传输服务</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ce94f5cade6a0e97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/970/format/webp" alt="img"></p>
<p>UDP结构</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-624005a24bc5bfcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/871/format/webp" alt="img"></p>
<h2 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h2><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-fe9d1bdd35dbd5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/920/format/webp" alt="img"></p>
<p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e193eb63d50a9c79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/932/format/webp" alt="img"></p>
<blockquote>
<p>很显然，TCP仅支持单播，也就是一对一的通信</p>
</blockquote>
<p>运输过程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-cd38698ad784fcea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/951/format/webp" alt="img"></p>
<blockquote>
<p>发送方</p>
<ul>
<li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p>
</li>
<li><p>并将他们编号，并存储在自己发送缓存中</p>
</li>
<li><p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li><p>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</p>
</li>
<li><p>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</p>
</li>
<li><p>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</p>
</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p>
<p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p>
</blockquote>
<p>TCP向上层提供面向连接的可靠传输服务</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-915eafb17567c438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/932/format/webp" alt="img"></p>
<p>TCP结构</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-db48b70af7fb7884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/897/format/webp" alt="img"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-b0c1d4146735458a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2265c15b05b648dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b05bfb5781a99f95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-822d96dec58ce11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-43345f50233197a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f73e94f75e94ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5bd53b8a5a5ac400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ea9dc3589e6c6bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p>
<p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p>
</blockquote>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d8221e9dda7919f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-9d4b410b2a44c125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<p><strong>拥塞控制的一般原理</strong></p>
<ul>
<li>拥塞控制的前提：网络能够承受现有的网络负荷。</li>
<li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li>
<li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li>
<li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li>
</ul>
<p><strong>开环控制和闭环控制</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2740d71c5e1d6aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/884/format/webp" alt="img"></p>
<p><strong>监测网络的拥塞</strong></p>
<p>主要指标有：</p>
<ol>
<li>由于缺少缓存空间而被丢弃的分组的百分数；</li>
<li>平均队列长度；</li>
<li>超时重传的分组数；</li>
<li>平均分组时延；</li>
<li>分组时延的标准差，等等。</li>
</ol>
<p>上述这些指标的上升都标志着拥塞的增长。</p>
<h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-67852fc13fc0e263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c7682fe29ebcb6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<p>下图的实例横纵坐标的意思</p>
<p>传输轮次：</p>
<ul>
<li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li>
<li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li>
<li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li>
</ul>
<p>拥塞窗口：</p>
<ul>
<li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li>
</ul>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><h4 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h4><ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-47dba7f2068f35df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1bca665e8eaa965a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/713/format/webp" alt="img"></p>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h4 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h4><ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd = cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-28dacc122d9ef398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c35271774108d273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>这个时候又回到了慢开始</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-233c4e9e061dc1d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-98094e880a6fad4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-f5db7ea25d8aca73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fee86fb3707a175c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a57c7cc819aa4bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ab5a63efbd586eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h4><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8f61b8eddb5b2624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h1><p><img src="https://upload-images.jianshu.io/upload_images/24878825-855245410fc0ff17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-789e0116477a41df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-994128acb2576516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-20d1cf6bb211fe7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-39ab62874e65b623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d454ebe83c1133ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-dbc63525eab966e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-7d23bd8b0a165628.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>总结</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c94fa8a3ad6b277f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6d10ea76a1ea032b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-92d975bc880db892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-35bff0a8cc5b0d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-e7d2329746de8e6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><ul>
<li>TCP 建立连接的过程叫做<strong>握手</strong>。</li>
<li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li>
<li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<h3 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-84c2b6dbb20379bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h3><ul>
<li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li>
</ul>
<p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p>
<p>过程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9f509a892fb0f5c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>最初两端的TCP进程都处于关闭状态</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e69d0e450b080e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p>
<p>之后，就准备接受TCP客户端进程的连接请求</p>
<p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p>
</blockquote>
<p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9e597559ec8fcae8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>TCP客户进程也是首先创建传输控制块</p>
</blockquote>
<p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-46865d700124bfd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p>
<p>TCP连接请求报文段首部中</p>
<ul>
<li><p>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</p>
</li>
<li><p>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</p>
</li>
</ul>
<p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f8dec0443dc56584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p>
<p>TCP连接请求确认报文段首部中</p>
<ul>
<li><p>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</p>
</li>
<li><p>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</p>
</li>
<li><p>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</p>
</li>
</ul>
<p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c6b6b91049a352db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p>
<p>普通的TCP确认报文段首部中</p>
<ul>
<li><p>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</p>
</li>
<li><p>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</p>
</li>
<li><p>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</p>
</li>
</ul>
<p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-987d5c8512392422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p>
<p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p>
</blockquote>
<p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p>
<p>下图实例是“两报文握手”</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a5773a600817c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有&gt; 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个&gt; 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同&gt; 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因&gt; 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。<br> 所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-3205fd7d7d75b62e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><ul>
<li>TCP 连接释放过程比较复杂。</li>
<li>数据传输结束后，通信的双方都可释放连接。</li>
<li>TCP 连接释放过程是<strong>四报文握手</strong>。</li>
</ul>
<h3 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h3><ul>
<li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li>
<li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li>
</ul>
<p>过程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d56a05b1da63bf01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p>
<p>TCP客户进程的应用进程通知其主动关闭TCP连接</p>
<p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p>
<p>TCP连接释放报文段首部中</p>
<ul>
<li><p>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</p>
</li>
<li><p>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</p>
</li>
<li><p>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</p>
</li>
</ul>
<p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d8be7c2c584d245a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p>
<p>普通的TCP确认报文段首部中</p>
<ul>
<li><p>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</p>
</li>
<li><p>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</p>
</li>
<li><p>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-733705e761921b6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p>
<p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p>
<p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p>
<p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-583da1984154448c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p>
<p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p>
<p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-60b55978f2d24a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p>
<p>该报文段首部中</p>
<ul>
<li><p>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</p>
</li>
<li><p>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</p>
</li>
<li><p>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1c5e0c6357d039ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p>
<p>该报文段首部中</p>
<ul>
<li><p>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</p>
</li>
<li><p>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</p>
</li>
<li><p>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</p>
</li>
</ul>
<p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p>
</blockquote>
<p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ef85470fe120f146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p>
</blockquote>
<h3 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h3><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p>
<p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p>
<p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2dc97e06fe1d82ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><p><img src="https://upload-images.jianshu.io/upload_images/24878825-df9263a14e1da2c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><p>源端口和目的端口</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-27e4bd51d5db2f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>序号、确认号和确认标志位</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-fd0e64d8be3f598b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>数据偏移、保留、窗口和校验和</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d3d4c61af68fdb6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f09bdaba863c4ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>选项和填充</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d1a8d3ca5ac7f39d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1185/format/webp" alt="img"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络之数据链路层</title>
    <url>/posts/c9d999de/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<h1 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p>
<p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-72eec9c2f5da1885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4f088da1859e7e90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/785/format/webp" alt="img"></p>
<p><strong>从层次上来看数据的流动</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-11c77ea98c206763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>仅从数据链路层观察帧的流动</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6a1acd1ad2a6c1eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1dacf9fe20464222.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p>
<p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p>
</blockquote>
<p><strong>数据链路层使用的信道</strong></p>
<p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0f0962eb5fccf66f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/923/format/webp" alt="img"></p>
<blockquote>
<p><strong>局域网属于数据链路层</strong></p>
<p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p>
<p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p>
</blockquote>
<h2 id="三个重要问题"><a href="#三个重要问题" class="headerlink" title="三个重要问题"></a>三个重要问题</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong></p>
<p><strong>封装成帧</strong></p>
<ul>
<li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li>
<li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1ad51faea9b7b205.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>差错控制</strong></p>
<p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-82811736b014aa98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>可靠传输</strong></p>
<p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p>
<p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p>
<p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0d2fd9bb2602bf28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p>
</blockquote>
<p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p>
<p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-34c5f707bef17f14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>可以用编址（地址）的来解决</p>
<p>将帧的目的地址添加在帧中一起传输</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-abbf8309faf2ebf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>还有数据碰撞问题</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-92422213075fe0e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>随着技术的发展，交换技术的成熟，</p>
<p>在 有线（局域网）领域 使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<del>共享式局域网</del></p>
<p>在无线局域网中仍然使用的是共享信道技术</p>
</blockquote>
<hr>
<h1 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p>
<ul>
<li><strong>帧头和帧尾中包含有重要的控制信息</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bf6fe42eeea3f376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p>
<p>答：需要帧头和帧尾来做<strong>帧定界</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3a36c2a60343962c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f1441c531b4d740e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>前导码</p>
<ul>
<li><p>前同步码：作用是使接收方的时钟同步</p>
</li>
<li><p>帧开始定界符：表明其后面紧跟着的就是MAC帧</p>
</li>
</ul>
</blockquote>
<p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-eee524ce4e17f0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><blockquote>
<p><strong>透明</strong></p>
<p>指某一个实际存在的事物看起来却好像不存在一样。</p>
</blockquote>
<p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p>
<p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中， 恰好也包含这个特定数值，接收方就不能正确接收</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-12fe81306aedad15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p>
</blockquote>
<p><strong>解决透明传输问题</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-645dde5eed8eceb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<ul>
<li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li>
<li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li>
<li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li>
</ul>
<p><strong>帧的数据部分长度</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9d3f61fdd96b7dee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6d39c2f162ddcae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fa8e42040c9adf41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-8a049d137b19e372.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-190a469aba121c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e3a6540cad78b41e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>例题</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-52140f44375b471a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-01ea200a849a5e31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>总结</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5b743916f5355e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p>
</blockquote>
<hr>
<h1 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>下面是比特差错</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-570f7783660d9c10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>其他传输差错</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1a955429af0480a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<ul>
<li>分组丢失</li>
</ul>
<p>路由器输入队列快满了，主动丢弃收到的分组</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f805603357f3a3a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<ul>
<li>分组失序</li>
</ul>
<p>数据并未按照发送顺序依次到达接收端</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6fdae389d4679bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<ul>
<li>分组重复</li>
</ul>
<p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-88599fefa01ee548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h2><ul>
<li>停止-等待协议SW</li>
<li>回退N帧协议GBN</li>
<li>选择重传协议SR</li>
</ul>
<blockquote>
<p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p>
</blockquote>
<h2 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h2><h3 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h3><p><strong>确认与否认</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-68772b26b0ef0d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518/format/webp" alt="img"></p>
<p><strong>超时重传</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-af381efb26eee719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>确认丢失</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e30648ec8764ab02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/958/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-34bf2b8a370feab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/462/format/webp" alt="img"></p>
<blockquote>
<p>既然数据分组需要编号，确认分组是否需要编号？</p>
<p>要。如下图所示</p>
</blockquote>
<p><strong>确认迟到</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-da5036b780359576.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/486/format/webp" alt="img"></p>
<blockquote>
<p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p>
</blockquote>
<p><strong>注意事项</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8dbdfdbac8087fd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h3><p>假设收发双方之间是一条直通的信道</p>
<ul>
<li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li>
<li><strong>RTT</strong>：是收发双方之间的往返时间</li>
<li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li>
</ul>
<p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3b4b0d81e5dd78eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4015447553ed26b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/888/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-372ef347c338b585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p>
</blockquote>
<h2 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h2><h3 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h3><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-cc9d42f63bd259cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a7141766ab1aa80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h3><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-eee45713110af40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>image-20201012191936466</p>
<p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-13f6dabf165db4e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0dfe16aee5eb8d75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-1414be9bd8307609.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>累计确认</p>
<p>优点:</p>
<ul>
<li><p>即使确认分组丢失，发送方也可能不必重传</p>
</li>
<li><p>减小接收方的开销</p>
</li>
<li><p>减小对网络资源的占用</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li>
</ul>
</blockquote>
<h3 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a><strong>有差错情况</strong></h3><p>例如</p>
<p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-7a8c7e3ec6ebaca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-7621ee1bc4ab1619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>接收同样也不能接收它们，讲它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c3f86dad2611e347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-215e8704b22ef7f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1df324a9b09dffb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>若WT超过取值范围，例如WT=8，会出现什么情况？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d2789fe0732f13ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>总结</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0d5f64664d096287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<ul>
<li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li>
<li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li>
<li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li>
</ul>
<h2 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2ab9c838fac0cb24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>总结</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bcb835b2adac5b3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-dab51e8895eb9313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><ul>
<li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li>
<li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li>
<li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-fd145efb1acc73fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<ul>
<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bbc4187b9e27ef4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p>必须规定特殊的字符作为帧定界符</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b384615e861000f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h2><p>必须保证数据传输的透明性</p>
<p>实现透明传输的方法</p>
<ul>
<li>面向字节的异步链路：字节填充法（插入“转义字符”）</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d40da4575c590f5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<ul>
<li>面向比特的同步链路：比特填充法（插入“比特0”）</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6290c73d8957ee8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h2><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-501e6b9dd2afcee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h2><ul>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li>
<li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li>
<li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-96bbde153c114cf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p>
</blockquote>
<hr>
<h1 id="媒体接入控制（介质访问控制）——广播信道"><a href="#媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="媒体接入控制（介质访问控制）——广播信道"></a>媒体接入控制（介质访问控制）——广播信道</h1><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p>
<blockquote>
<p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p>
</blockquote>
<p><strong>局域网的数据链路层</strong></p>
<ul>
<li>局域网最主要的<strong>特点</strong>是：<ul>
<li>网络为一个单位所拥有；</li>
<li>地理范围和站点数目均有限。</li>
</ul>
</li>
<li>局域网具有如下<strong>主要优点</strong>：<ul>
<li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li>
<li>提高了系统的可靠性、可用性和残存性。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4acef21a5275fab6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/849/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6a109c1bb8576571.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/847/format/webp" alt="img"></p>
<p><strong>数据链路层的两个子层</strong></p>
<p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p>
<ol>
<li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li>
<li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li>
</ol>
<p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。  <strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-faea2c7d90c97f4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/831/format/webp" alt="img"></p>
<h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>为什么要媒体接入控制（介质访问控制）？</p>
<p><strong>共享信道带来的问题</strong></p>
<p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e8558245e4dd7086.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3d6792f6b442b459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p>
</blockquote>
<h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>信道复用</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f42ef63e4cf0d34b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p>
<ul>
<li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li>
<li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-7b3574f649543f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>时分复用TDM (Time Division Multiplexing)</strong></p>
<ul>
<li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li>
<li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li>
<li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-85128fb198aad76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9f1dfdd7ce2cb611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p>
<p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p>
</blockquote>
<p><strong>码分复用 CDM (Code Division Multiplexing)</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-753efa9c750d4ef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-91ed6f416ae8fad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8d81f17d93395b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><p>受控接入</p>
<p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p>
<p><strong>随机接入</strong></p>
<p><strong>重点</strong></p>
<h2 id="随机接入（CSMA-CD协议）"><a href="#随机接入（CSMA-CD协议）" class="headerlink" title="随机接入（CSMA/CD协议）"></a>随机接入（CSMA/CD协议）</h2><p><strong>总线局域网使用协议：CSMA/CD</strong></p>
<h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p>
<blockquote>
<p><strong>以太网（Ethernet）</strong>是一种计算机<strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了<strong>以太网（Ethernet）</strong>的技术标准</p>
<p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-daba961daee80d20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-00eb7fba113030d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h3><p>表示许多主机以多点接入的方式连接在一根总线上。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a26a912dcecd040a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h3><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9dc7a68973377382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p>
<h3 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h3><ul>
<li><strong>“碰撞检测”</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li>
<li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li>
<li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li>
<li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li>
<li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li>
<li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-574d77a51611a634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a03963c28232dfb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/940/format/webp" alt="img"></p>
<p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p>
</blockquote>
<h3 id="CSMA-CD-协议工作流程"><a href="#CSMA-CD-协议工作流程" class="headerlink" title="CSMA/CD 协议工作流程"></a>CSMA/CD 协议工作流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-5621a9827bd41bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/669/format/webp" alt="img"></p>
<h3 id="CSMA-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA/CD 协议工作——争用期（碰撞窗口）"></a>CSMA/CD 协议工作——争用期（碰撞窗口）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a77d88a950995527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="CSMA-CD-协议工作——最小帧长"><a href="#CSMA-CD-协议工作——最小帧长" class="headerlink" title="CSMA/CD 协议工作——最小帧长"></a>CSMA/CD 协议工作——最小帧长</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-423fe21ffdbacb81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="CSMA-CD-协议工作——最大帧长"><a href="#CSMA-CD-协议工作——最大帧长" class="headerlink" title="CSMA/CD 协议工作——最大帧长"></a>CSMA/CD 协议工作——最大帧长</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-fa63a8f164fb9191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="CSMA-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA/CD 协议工作——截断二进制指数退避算法"></a>CSMA/CD 协议工作——截断二进制指数退避算法</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-93f832e4b0a569ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="CSMA-CD-协议工作——信道利用率"><a href="#CSMA-CD-协议工作——信道利用率" class="headerlink" title="CSMA/CD 协议工作——信道利用率"></a>CSMA/CD 协议工作——信道利用率</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-dc35877bb4bead1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="CSMA-CD-协议工作——帧接收流程"><a href="#CSMA-CD-协议工作——帧接收流程" class="headerlink" title="CSMA/CD 协议工作——帧接收流程"></a>CSMA/CD 协议工作——帧接收流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-cf2d95546ecf2664.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="CSMA-CD-协议的重要特性"><a href="#CSMA-CD-协议的重要特性" class="headerlink" title="CSMA/CD 协议的重要特性"></a>CSMA/CD 协议的重要特性</h3><ul>
<li>使用 CSMA/CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li>
<li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li>
<li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li>
</ul>
<blockquote>
<p>CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p>
<p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CS协议</strong></p>
</blockquote>
<h2 id="随机接入（CSMA-CA协议）"><a href="#随机接入（CSMA-CA协议）" class="headerlink" title="随机接入（CSMA/CA协议）"></a>随机接入（CSMA/CA协议）</h2><p><strong>无线局域网使用的协议：CSMA/CA</strong></p>
<h3 id="为什么无线局域网要使用CSMA-CA协议"><a href="#为什么无线局域网要使用CSMA-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA/CA协议"></a>为什么无线局域网要使用CSMA/CA协议</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-dd01f296832d017a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-6c9fe4ae6927eb02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="CSMA-CA协议的工作原理"><a href="#CSMA-CA协议的工作原理" class="headerlink" title="CSMA/CA协议的工作原理"></a>CSMA/CA协议的工作原理</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-c0ce898b417b3228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p>
<ul>
<li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li>
</ul>
<p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p>
<ul>
<li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a756ebbd569e600a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p>
<p>防止多个站点同时发送数据而产生碰撞</p>
</blockquote>
<p><strong>使用退避算法的时机</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f0d70f0b26645fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="CSMA-CA协议的退避算法"><a href="#CSMA-CA协议的退避算法" class="headerlink" title="CSMA/CA协议的退避算法"></a>CSMA/CA协议的退避算法</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-1de197cb6f859f3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>退避算法的示例</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-12262e66fc986d52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="CSMA-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA/CA协议的信道预约和虚拟载波监听"></a>CSMA/CA协议的信道预约和虚拟载波监听</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-98353d62c0ef033f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ac35b15f5f22bf7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c8d7aca5f6faec4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="MAC地址、IP地址以及ARP协议"><a href="#MAC地址、IP地址以及ARP协议" class="headerlink" title="MAC地址、IP地址以及ARP协议"></a>MAC地址、IP地址以及ARP协议</h1><p><img src="https://upload-images.jianshu.io/upload_images/24878825-ede2c92a0c809e6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><blockquote>
<ul>
<li><p>使用点对点信道的数据链路层不需要使用地址</p>
</li>
<li><p>使用广播信道的数据链路层必须使用地址来区分各主机</p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b498a111836f82c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-eabec58905a9aad1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1199/format/webp" alt="img"></p>
<blockquote>
<p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p>
</blockquote>
<h3 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-5a66994327412b90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>组织唯一标识符OUI</strong></p>
<ul>
<li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li>
</ul>
<p><strong>网络接口标识符</strong></p>
<ul>
<li>由获得OUI的厂商自行随意分配</li>
</ul>
<p><strong>EUI-48</strong></p>
<ul>
<li>48是这个MAC地址的位数</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-70ee74506eca1df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p>
</blockquote>
<p><strong>关于无效的 MAC 帧</strong></p>
<ul>
<li>数据字段的长度与长度字段的值不一致；</li>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
</ul>
<blockquote>
<p><strong>对于检查出的无效</strong>  <strong>MAC</strong>  <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong></p>
</blockquote>
<h3 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d0cf5b54089e4b40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-db7d480bafececad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a69b9384665e17aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p>
<p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p>
<p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p>
<p>并将该帧交给其上层处理</p>
</blockquote>
<h3 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-7a825d6f30766d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-04fe098832094ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p>
</blockquote>
<h3 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-3f3a22fe2fbfa3ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p>
<p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p>
<p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f274d401c24ad4d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1d6c26260c21ba6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-70e6e705d20e5c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p>
<p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p>
<p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p>
</blockquote>
<blockquote>
<p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p>
</blockquote>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴</p>
<p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p>
<h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-597f8c69867e595b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-407cbc74e63b0e50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h3><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-77c204bc8181b3ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f12548de1d3cebe1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>如何从IP地址找出其对应的MAC地址？</p>
<p>ARP协议</p>
</blockquote>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>如何从IP地址找出其对应的MAC地址？</p>
<p>ARP（地址解析协议）</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-5e1fd5537944a420.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>ARP高速缓存表</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-13b5ca5d08126cde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9de96c1c37c62e26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>ARP请求报文有具体的格式，上图的只是简单描述</p>
<p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p>
<p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-97a253fd9b87b3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p>
<p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p>
<p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d852b42ef4dbea32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-87f01b333e4599d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a3f00154df65aac0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>动态与静态的区别</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a013636443263063.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d5847fbcc133c6b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>ARP协议的使用是逐段链路进行的</p>
</blockquote>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-11cd254f6251a6ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/624/format/webp" alt="img"></p>
<blockquote>
<p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p>
</blockquote>
<hr>
<h1 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h1><h2 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-dc092bbcb4344cf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<ul>
<li><p>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</p>
</li>
<li><p>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</p>
</li>
<li><p><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</p>
</li>
<li><p><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</p>
</li>
</ul>
</blockquote>
<h3 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h3><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0f8d87b7f79e94c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<ul>
<li><strong>优点</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">2.  扩大了以太网覆盖的地理范围。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>缺点</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  碰撞域增大了，但总的吞吐量并未提高。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">2.  如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</span><br></pre></td></tr></table></figure>
<p><strong>碰撞域</strong></p>
</blockquote>
<ul>
<li><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li>
<li>碰撞域越大，发生碰撞的概率越高。</li>
</ul>
<h2 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>扩展以太网更常用的方法是在数据链路层进行。</li>
<li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-001d34e299bee061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/876/format/webp" alt="img"></p>
<blockquote>
<p><strong>网桥</strong></p>
<ul>
<li><p>网桥工作在数据链路层。</p>
</li>
<li><p>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</p>
</li>
<li><p>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</p>
</li>
</ul>
<p><strong>交换机</strong></p>
<ul>
<li><p>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</p>
</li>
<li><p>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</p>
</li>
<li><p>以太网交换机实质上就是一个<strong>多接口的网桥</strong></p>
</li>
</ul>
</blockquote>
<h3 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a><strong>集线器HUB与交换机SWITCH区别</strong></h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a8f68b1ee60923c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p>
<p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bd7d832dc7f8ffbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>以太网交换机的交换方式</strong></p>
<ul>
<li>存储转发方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   把整个数据帧**先缓存**后再进行处理。</span><br></pre></td></tr></table></figure>

<ul>
<li>直通 (cut-through) 方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   接收数据帧的同时就**立即按数据帧的目的 MAC 地址决定该帧的转发接口**，因而提高了帧的转发速度。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">*   **缺点**是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</span><br></pre></td></tr></table></figure>

<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><strong>对比集线器和交换机</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-2e2faba35d2d7852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/741/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4638409baba882e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>多台主机同时给另一台主机发送单播帧</p>
<p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p>
<p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p>
<p><strong>单播</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-34c587f82d3a1286.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>广播</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-134f67554e64e22b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>多个单播</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d80949431bd76379.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d5c429a2f92149ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-25db1be3ca96bc2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-df6859d2396549cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/925/format/webp" alt="img"></p>
<blockquote>
<p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p>
</blockquote>
<hr>
<h1 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-5f9db8088bf224f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h2><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p>
<p><strong>A -&gt; B</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1ef3dc4a6841b1ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<ol>
<li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li>
<li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li>
<li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li>
<li>交换机向除接口 1 以外的所有的接口广播这个帧</li>
<li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li>
<li>交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中</li>
<li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li>
<li>主机B发现是给自己的帧，接受该帧</li>
</ol>
</blockquote>
<p><strong>B -&gt; A</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-dbe273924b7c8eea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<ol>
<li><p>B 向 A 发送一帧。该帧从接口 3 进入到交换机</p>
</li>
<li><p>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</p>
</li>
<li><p>主机 A 发现目的地址是它，就接受该帧</p>
</li>
<li><p>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</p>
</li>
</ol>
</blockquote>
<p><strong>E -&gt; A</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-cf46c0c890cfa2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<ol>
<li><p>E 向 A发送一帧</p>
</li>
<li><p>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</p>
</li>
<li><p>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</p>
</li>
<li><p>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</p>
</li>
<li><p>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</p>
</li>
<li><p>主机 A 发现目的地址是它，就接受该帧</p>
</li>
</ol>
</blockquote>
<p><strong>G -&gt; A</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4ee1af4bc8187125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p>
<ol>
<li>主机 G 发送给 主机 A 一个帧</li>
<li>主机 A 和 交换机接口 1都能接收到</li>
<li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li>
<li>交换机 1收到该帧后，首先进行登记工作</li>
<li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li>
<li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 讲帧转发出去，因为这是没有必要，于是丢弃该帧</li>
</ol>
</blockquote>
<p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-071ec78303db43c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p>
<p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p>
</blockquote>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>交换机自学习和转发帧的步骤归纳</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b39e4a9145068aca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/983/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3fc4ca18dcbaef03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h1><h2 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-04211a392a1b4b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/983/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5033bf0f4c26a32b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a65d811129786ec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-d43f5c0c9ddbaf93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1133/format/webp" alt="img"></p>
<blockquote>
<ul>
<li><p>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong> (Spanning Tree Protocol)。</p>
</li>
<li><p>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</p>
</li>
</ul>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-36746a91a09f583c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/895/format/webp" alt="img"></p>
<hr>
<h1 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h1><h2 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h2><p><strong>广播风暴</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a2a78b40ae5307db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>分割广播域的方法</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-89e9ef3fdfcc530c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p>
</blockquote>
<h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-3f98534c040b90f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<ul>
<li><p>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</p>
</li>
<li><p>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：  <strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</p>
</li>
<li><p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p>
</li>
<li><p><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></p>
</li>
<li><p>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</p>
</li>
</ul>
</blockquote>
<h2 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h2><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p>
<ul>
<li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li>
<li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5d3549cc02f9a3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6af352f81b800a98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>Access端口</strong></p>
<p>交换机与用户计算机之间的互连</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-44a2e259c33ecfd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/938/format/webp" alt="img"></p>
<blockquote>
<p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p>
</blockquote>
<p><strong>Truck端口</strong></p>
<p>交换机之间或交换机与路由器之间的互连</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a93996aae716c6aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1184/format/webp" alt="img"></p>
<p><strong>华为交换机私有的Hybrid端口类型</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-653b80a66c3cc5bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/908/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-239ec8f47d072a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1069/format/webp" alt="img"></p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-dd58aec183276962.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>虚拟局域网优点</strong></p>
<p>虚拟局域网（VLAN）技术具有以下主要优点：</p>
<ol>
<li><p>改善了性能</p>
</li>
<li><p>简化了管理</p>
</li>
<li><p>降低了成本</p>
</li>
<li><p>改善了安全性</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络之网络层</title>
    <url>/posts/bc654c1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-afcf88ff0d16dc80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1190/format/webp" alt="img"></p>
<blockquote>
<p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p>
<p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p>
<p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p>
</blockquote>
<ul>
<li><p>要实现网络层任务，需要解决一下主要问题：</p>
<ul>
<li><p>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</p>
<p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p>
</li>
<li><p>网络层寻址问题</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5993e7f74bf3a7ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
</li>
<li><p>路由选择问题</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8db9ef0ef83c53ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p>
<p><strong>依据数据包的目的地址和路由器中的路由表</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-14fffa90e5256d53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp" alt="img"></p>
<p>但在实际当中，路由器是怎样知道这些路由记录？</p>
<ul>
<li><p>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</p>
</li>
<li><p><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-87fc7ad0cc9ba272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>补充 <strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a692d0cb739f39ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h1><ul>
<li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li>
<li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</li>
</ul>
<h2 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h2><p><strong>一种观点：让网络负责可靠交付</strong></p>
<ul>
<li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li>
<li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。</li>
<li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3e9eab4cca1d0298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p>
<blockquote>
<ul>
<li><p>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</p>
</li>
<li><p>请注意，电路交换的电话通信是先建立了一条真正的连接。</p>
</li>
<li><p>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</p>
</li>
</ul>
</blockquote>
<h2 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h2><p><strong>另一种观点：网络提供数据报服务</strong></p>
<ul>
<li>互联网的先驱者提出了一种崭新的网络设计思路。</li>
<li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li>
<li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li>
<li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0a52c46cee7f1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p>
<blockquote>
<p><strong>尽最大努力交付</strong></p>
<ul>
<li><p>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</p>
</li>
<li><p><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</p>
</li>
<li><p>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</p>
</li>
</ul>
</blockquote>
<h2 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h2><table>
<thead>
<tr>
<th><strong>对比的方面</strong></th>
<th><strong>虚电路服务</strong></th>
<th><strong>数据报服务</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>思路</strong></td>
<td><strong>可靠通信应当由网络来保证</strong></td>
<td><strong>可靠通信应当由用户主机来保证</strong></td>
</tr>
<tr>
<td><strong>连接的建立</strong></td>
<td><strong>必须有</strong></td>
<td><strong>不需要</strong></td>
</tr>
<tr>
<td><strong>终点地址</strong></td>
<td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td>
<td><strong>每个分组都有终点的完整地址</strong></td>
</tr>
<tr>
<td><strong>分组的转发</strong></td>
<td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td>
<td><strong>每个分组独立选择路由进行转发</strong></td>
</tr>
<tr>
<td><strong>当结点出故障时</strong></td>
<td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td>
<td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td>
</tr>
<tr>
<td><strong>分组的顺序</strong></td>
<td><strong>总是按发送顺序到达终点</strong></td>
<td><strong>到达终点时不一定按发送顺序</strong></td>
</tr>
<tr>
<td><strong>端到端的差错处理和流量控制</strong></td>
<td><strong>可以由网络负责，也可以由用户主机负责</strong></td>
<td><strong>由用户主机负责</strong></td>
</tr>
</tbody></table>
<hr>
<h1 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-90e2d995adf53e57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1199/format/webp" alt="img"></p>
<h2 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-617a75508f564e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<ul>
<li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li>
<li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li>
<li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li>
</ul>
<p><strong>A类地址</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-eacc61b12148d0fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>B类地址</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3e51c8657163a587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>C类地址</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-82018abf428effc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>练习</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c1a55b79b312df0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>IP 地址的指派范围</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0fd510a88683ce19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/881/format/webp" alt="img"></p>
<p><strong>一般不使用的特殊的 IP 地址</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6ac646caef2b89d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/882/format/webp" alt="img"></p>
<p><strong>IP 地址的一些重要特点</strong></p>
<p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p>
<ul>
<li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li>
<li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li>
</ul>
<p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p>
<ul>
<li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li>
<li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li>
</ul>
<p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p>
<p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p>
<h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><h3 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h3><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p>
<ul>
<li>IP 地址空间的利用率有时很低。</li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li>
<li>两级的 IP 地址不够灵活。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-7e6aa3fe4c6184e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>如果想要将原来的网络划分成三个独立的网路</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9c21430ca1484519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>所以是否可以从主机号部分借用一部分作为子网号</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5925336afb4dfe54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p>
<p>所以就有了划分子网的工具：<strong>子网掩码</strong></p>
<ul>
<li><p>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</p>
</li>
<li><p>这种做法叫做<strong>划分子网</strong> (subnetting) 。</p>
</li>
<li><p>划分子网已成为互联网的正式标准协议。</p>
</li>
</ul>
</blockquote>
<h3 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h3><p>基本思路</p>
<ul>
<li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li>
<li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5006c8be601f1a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/545/format/webp" alt="img"></p>
<ul>
<li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li>
<li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li>
<li>最后就将 IP 数据报直接交付目的主机。</li>
</ul>
<p>划分为三个子网后对外仍是一个网络</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5eaab61ca2770932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/773/format/webp" alt="img"></p>
<blockquote>
<ul>
<li><strong>优点</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  减少了 IP 地址的浪费</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">2.  使网络的组织更加灵活</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">3.  更便于维护和管理</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li>
</ul>
</blockquote>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-0050159cd99737aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>(IP 地址) AND (子网掩码) = 网络地址</strong> 重要，下面很多相关知识都会用到</p>
</blockquote>
<p>举例</p>
<p>例子1</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-24fc0f5e02ad49ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/969/format/webp" alt="img"></p>
<p>例子2</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4e988e8ed1e154e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>默认子网掩码</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5e9d1b71bd598e62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-143b8b8433293353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<ul>
<li><p>子网掩码是一个网络或一个子网的重要属性。</p>
</li>
<li><p>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</p>
</li>
<li><p>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</p>
</li>
<li><p>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</p>
</li>
</ul>
</blockquote>
<h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><h3 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h3><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-dc335c4f88cede6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p><strong>CIDR 最主要的特点</strong></p>
<ul>
<li><p>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</p>
</li>
<li><p><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</p>
</li>
</ul>
</blockquote>
<h3 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-88843ec1d5739f3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bdff407b4d15ec43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a495310e8e5bc13a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-38c44dc0521cfc1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1181/format/webp" alt="img"></p>
<h2 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h2><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p>
<h3 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-097ed78c469f6c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/882/format/webp" alt="img"></p>
<p><strong>划分子网的IPv4就是定长的子网掩码</strong></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-814f06bb5874b724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a90a636c0ff5f71c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1156/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-da16abd19e811578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1146/format/webp" alt="img"></p>
<blockquote>
<p>通过上面步骤分析，就可以从子网1 ~ 8中任选5个分配给左图中的N1 ~ N5</p>
<p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p>
<p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p>
</blockquote>
<h3 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2c1bfb1250975630.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img"></p>
<p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e7a3b3efa0032ed5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b855ffbf02fe4306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h1><p><img src="https://upload-images.jianshu.io/upload_images/24878825-591d4b10e724a0c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-cb603ff4350d2927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6017dc6fd05d7dc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-1350e20953ab73c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p>
<ul>
<li><p>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong>  <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></p>
</li>
<li><p>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong>  <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</p>
</li>
</ul>
</blockquote>
<p>主机C如何知道路由器R的存在？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5f7abd26ae50d253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为<strong>默认网关</strong></p>
<p>例如。路由器的接口0的IP地址192.168.0.128做为左边网络的默认网关</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0351946f5505b37a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p>
</blockquote>
<p>路由器收到IP数据报后如何转发？</p>
<ul>
<li>检查IP数据报首部是否出错：<ul>
<li>若出错，则直接丢弃该IP数据报并通告源主机</li>
<li>若没有出错，则进行转发</li>
</ul>
</li>
<li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul>
<li>若找到匹配的条目，则转发给条目中指示的吓一跳</li>
<li>若找不到，则丢弃该数据报并通告源主机</li>
</ul>
</li>
</ul>
<p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-09e48a4a2debf9dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>接下来路由器对该IP数据报进行查表转发</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6ec850736125c7f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4ff7f2294cf39cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>路由器是隔离广播域的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f38fdc3eb91af37f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-cf80167248b787a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h2><p><strong>静态路由配置</strong></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-214e6a6830649edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>默认路由</strong></p>
<p>举例</p>
<p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8887ba23edaae006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>特定主机路由</strong></p>
<p>举例</p>
<p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p>
<p>一般用于网络管理人员对网络的管理和测试</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-434c1eec83abd86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>多条路由可选，匹配路由最具体的</p>
</blockquote>
<p><strong>静态路由配置错误导致路由环路</strong></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8b1a3cadc08a931f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>假设将R2的路由表中第三条目录配置错了下一跳</p>
<p>这导致R2和R3之间产生了路由环路</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d30fc31c76fe75b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>聚合了不存在的网络而导致路由环路</strong></p>
<p>举例</p>
<p>正常情况</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9e22a85322dfb654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-56bce2f676ef8d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>错误情况</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-030c93bce1443043.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>解决方法</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-caeddc52bde20f9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d91cb3837cfc2b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p>
</blockquote>
<p><strong>网络故障而导致路由环路</strong></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e3848e2bfcfc2c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-99cc1b342b3f645f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>解决方法</p>
<p>添加故障的网络为黑洞路由</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-0c30655d3122a50d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d8107f8fc71dd1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>假设。一段时间后故障网络恢复了</p>
<p>R1又自动地得出了其接口0的直连网络的路由条目</p>
<p>针对该网络的黑洞网络会自动失效</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3f60a84d11d15f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>如果又故障</p>
<p>则生效该网络的黑洞网络</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-dfe2cfdcdd6af09e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-3bc2906b99f6940d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a6ddde977e3398ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>因特网所采用的路由选择协议的主要特点</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b3382290a3965ffc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>因特网采用分层次的路由选择协议</strong></p>
<ul>
<li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-9e37d1229ec7836e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8729bdd2bd367edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p>
<p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p>
<p><strong>网关协议</strong>的名称可称为<strong>路由协议</strong></p>
</blockquote>
<p><strong>常见的路由选择协议</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6b1876963d6d9de0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>路由器的基本结构</strong></p>
<p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-e6b69c1f176e24c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>路由器结构可划分为两大部分：</p>
<p>1、<strong>分组转发部分</strong></p>
<p>由三部分构成</p>
<ul>
<li><p>交换结构</p>
</li>
<li><p>一组输入端口：</p>
<p>  信号从某个输入端口进入路由器</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-2bd1e24a95010cc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/742/format/webp" alt="img"></p>
<p>  物理层将信号转换成比特流，送交数据链路层处理</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-93fa25cf949ddf32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/627/format/webp" alt="img"></p>
<p>  数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-be61420be381fce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/632/format/webp" alt="img"></p>
<p>  如果送交网络层的分组是普通待转发的数据分组</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-13bf3933ea84f8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt="img"></p>
<p>  则根据分组首部中的目的地址进行查表转发</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-6e0cce7487b0555c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/452/format/webp" alt="img"></p>
<p>  若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p>
</li>
<li><p>一组输出端口</p>
<p>  网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-c20bbb057497a7dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/661/format/webp" alt="img"></p>
<p>  数据链路层将数据分组封装成帧，交给物理层处理</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-243c60046346ab42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/566/format/webp" alt="img"></p>
<p>  物理层将帧看成比特流将其变换成相应的电信号进行发送</p>
</li>
</ul>
<blockquote>
<p>路由器的各端口还会有输入缓冲区和输出缓冲区</p>
<ul>
<li><p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p>
</li>
<li><p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-af72fd2149d2c01e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p>
</blockquote>
<p>2、<strong>路由选择部分</strong></p>
<ul>
<li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p>
<p>  如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-109a369b44639a9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/419/format/webp" alt="img"></p>
<p>  路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-af4af7e182ea3f97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>  路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/24878825-9c1dca34462b76ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1106/format/webp" alt="img"></p>
</li>
</ul>
<h2 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-850c29aaf1e744d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-81a38e546cd55ec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/913/format/webp" alt="img"></p>
<p><strong>RIP的基本工作过程</strong></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6bf4e045a90846e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>RIP的路由条目的更新规则</strong></p>
<p>举例1</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-671231845f242b38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p>
<p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bacf546778de9f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-79852776853b7463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>举例2</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-7a0db5b1f8900318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>RIP存在“坏消息传播得慢”的问题</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-edc2c694de1a9ec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bedb4b539faf44dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4d1eda70d2f555bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>解决方法</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3a055002b79a9cda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p>
</blockquote>
<p><strong>总结</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6bcb92e542416b41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>RIP 协议的优缺点</p>
<p>优点：</p>
<ol>
<li>实现简单，开销较小。</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p>
</li>
<li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p>
</li>
<li><p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p>
</li>
</ol>
</blockquote>
<h2 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h2><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p>
<p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p>
<p><strong>概念</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f5dc77f36b5b1047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/940/format/webp" alt="img"></p>
<p><strong>问候（Hello）分组</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f9c642e76e871651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p>
</blockquote>
<p><strong>发送链路状态通告LSA</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bbed8a0d31bf19c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p>
</blockquote>
<p><strong>链路状态数据库同步</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6b8e10e2d82cfa6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-4239eee0b6040f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>OSPF五种分组类型</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a2a83ab2654e270f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>OSPF的基本工作过程</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-339786779f0e1a82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p>
<p>如果不采用其他机制，将会产生大量的多播分组</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6420e503df73b7ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>若DR出现问题，则由BDR顶替DR</p>
</blockquote>
<p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p>
<ul>
<li>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</li>
<li>每个区域都有一个32比特的区域标识符</li>
<li>主干区域的区域标识符必须为0，主干区域用于连通其他区域</li>
<li>其他区域的区域标识符不能为0且不相同</li>
<li>每个区域一般不应包含路由器超过200个</li>
<li>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-725b3aab5aa350b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>总结</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6382df507ddd76d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5aae9c53795e17a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/970/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-04fe6f98036db57c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-bc71c2ee5976ac53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b472dd1a51f30666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-67b837e6c27d5e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>总结</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ce7dcde013985e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-40cf22cbd65e9ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h1><h2 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><ul>
<li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li>
<li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li>
<li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-73800cce52c3a91e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f1cf7dd2ea4eb52e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1196/format/webp" alt="img"></p>
<blockquote>
<p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p>
<p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f7bb4a2e440abdc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a014cde6b0ff9691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>对IPv4数据报进行分片</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d7b3a6145ac1dde9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>现在假定分片2的IP数据报经过某个网络时还需要进行分片</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-5d538557f988dc41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-45ab400eac660e4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-94a3b7c0b1f01488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-b074f6fffe538c0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-07ac459878b48666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-95863501601f7757.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>架构IP网络时需要特别注意两点：</p>
<ul>
<li>确认网络是否正常工作</li>
<li>遇到异常时进行问题诊断</li>
</ul>
<p><strong>而ICMP就是实现这些问题的协议</strong></p>
<p>ICMP的主要功能包括：</p>
<ul>
<li>确认IP包是否成功送达目标地址</li>
<li>通知在发送过程当中IP包被废弃的具体原因</li>
<li>改善网络设置等</li>
</ul>
<p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-8739d970a0300acc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p>
<p>ICMP 报文的格式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6a02675fccdc2958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/813/format/webp" alt="img"></p>
<h2 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h2><h3 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-855edabd9c1e6298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-e7f27ef6c93c9621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-49d82185c88813fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1191/format/webp" alt="img"></p>
<h3 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-e2457fe1291c9bca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-0ef50227f921ca79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1186/format/webp" alt="img"></p>
<h3 id="不应发送ICMP差错报告报文情况"><a href="#不应发送ICMP差错报告报文情况" class="headerlink" title="不应发送ICMP差错报告报文情况"></a>不应发送ICMP差错报告报文情况</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-a0c3a21bb04ede42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h2><h3 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-75d7bc12ca942415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h3><p><img src="https://upload-images.jianshu.io/upload_images/24878825-185af899d5e5a922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/964/format/webp" alt="img"></p>
<p><strong>tracert命令的实现原理</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f59a9cacb015f074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1191/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-982e09181a0bc4ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1191/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-aeefc9f3ac87d9d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-571c2187a7833f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<h1 id="虚拟专用网VPN与网络地址转换NAT"><a href="#虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="虚拟专用网VPN与网络地址转换NAT"></a>虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h2><ul>
<li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li>
<li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li>
<li>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f295c690e2c90d69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-aee1ae10f8ccb65f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-f983b11370b6f354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p>
<p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-93cca695182bf40f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p>
<p>私有地址只能用作本地地址而不能用作全球地址</p>
<p>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</p>
<p><strong>本地地址与全球地址</strong></p>
<ul>
<li><p><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</p>
</li>
<li><p><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。</p>
</li>
<li><p><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</p>
</li>
</ul>
</blockquote>
<p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ab2d75fcfc34f709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>部门A向部门B发送数据流程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3a739ef0d60a031e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p>
<p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ad9e5dcca8c0a1c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>因此也被称为IP隧道技术</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-6731dbc8b1ee1abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-f9f42bd392a2375a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>举例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c489215f07bc88f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p>
<p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-41ae75149e86d0fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>专有NAT软件的路由器叫做NAT路由器</p>
<p>它至少有一个有效的外部全球IP地址</p>
<p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p>
</blockquote>
<p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-a74e4efad5297fc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>因特网上的这台主机给源主机发回数据报</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-c0463dd919523857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-3f71256d68f6a39a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>这种基本转换存在一个问题</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ff2eca30cc7a7b41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/953/format/webp" alt="img"></p>
<p>解决方法</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-05d3e1e3fd4b1998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<blockquote>
<p>我们现在用的很多家用路由器都是这种NART路由器</p>
</blockquote>
<p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p>
<p>否定</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-d2fd109d060e4853.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24878825-ff43ea52e61da271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/24878825-2a40d3a6e5d9e15a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统之基础概念</title>
    <url>/posts/cd4e3478/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<ul>
<li>硬件核心 =&gt; CPU</li>
<li>软件核心 =&gt; 操作系统 （系统软件）</li>
</ul>
<h1 id="主要目标："><a href="#主要目标：" class="headerlink" title="主要目标："></a>主要目标：</h1><ul>
<li><strong>方便性</strong>：在硬件（裸机）上跑程序很麻烦（得用机器语言）</li>
<li><strong>有效性：</strong><ul>
<li>提高系统资源利用率：没有 OS 的时候，诸如 I/O 等设备常处于空闲状态，没有得到有效的利用</li>
<li>提高系统吞吐量：合理组织工作流程，缩短程序的运行周期</li>
</ul>
</li>
<li>可扩充性：方便地增添新的功能和模块</li>
<li>开放性：遵循世界标准规范，达到彼此兼容</li>
</ul>
<h1 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h1><h2 id="无操作系统："><a href="#无操作系统：" class="headerlink" title="无操作系统："></a>无操作系统：</h2><p>阶段一 —— 人工操作：</p>
<ul>
<li>独占全机的问题：一个用户搞定之后，后面的用户才有机会使用</li>
<li>资源利用率低的问题：<ul>
<li><strong>纸带的输入输出的速度</strong>相对于<strong>CPU 的处理速度</strong>很慢，这导致 CPU 把大量空闲时间浪费在等待输入输出上</li>
<li><strong>人工将程序、数据存进纸带的速度</strong>相对于<strong>纸带的输入输出</strong>很慢（人机矛盾）</li>
</ul>
</li>
</ul>
<p>阶段二 —— 脱机输入/输出：</p>
<p>在纸带与 CPU 之间增加一个<strong>外围机</strong>，这个外围机协助将数据读入磁带，而磁带能够快速地将数据输入到内存中进行处理。</p>
<ul>
<li>外围机上有一个监督程序负责控制输入输出的流程，这个程序就是后来操作系统的雏形。</li>
</ul>
<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p>单道批处理系统通过<strong>连续处理</strong>尽可能地减少机器的空闲等待时间，但存在 CPU 和 IO 使用忙闲不均（总有一个人没做事）的情况，仍然没有做到充分利用资源。用一个例子来说明：</p>
<p>假如计算机现在需要处理 J1，J2，J3 三个作业，每个作业都需要经历输入（1秒）、计算（1秒）、输出（1秒）的过程。</p>
<p>如果计算机是单道批处理系统，那么处理过程大概是这样的：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1.png" alt="img"></a></p>
<p>（图源：《王道考研》视频）</p>
<p>可以看到，输入设备，CPU，输出设备这三者只能串行工作，不存在其中两者并行使用的情况。虽然系统尽可能地连续处理三个作业，但是可以看到，就同一时刻而言，输入设备，CPU，输出设备中总有至少一方<strong>无事可做</strong>，而这是对资源的浪费。</p>
<h2 id="多道程序批处理系统"><a href="#多道程序批处理系统" class="headerlink" title="多道程序批处理系统"></a>多道程序批处理系统</h2><p>作业存放在外存，形成“后备队列”，由作业调度程序选择若干个作业调入内存，使他们共享 CPU 和系统资源。由于有多道程序，可以及时<strong>补位</strong> CPU 的空闲。</p>
<ul>
<li>特点：无序性（先进入内存的作业不一定先完成）、多道性、调度性</li>
<li>优点：资源利用率高、系统吞吐量大</li>
<li>缺点：平均周转时间长、无法交互</li>
</ul>
<p>用一个例子来说明：</p>
<p>假如计算机现在需要处理 J1，J2，J3 三个作业，每个作业都需要经历输入（1秒）、计算（1秒）、输出（1秒）的过程。</p>
<p>如果计算机是多道批处理系统，那么处理过程大概是这样的：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-2.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-2.png" alt="img"></a></p>
<p>（图源：《王道考研》视频）</p>
<p>可以看到，输入设备，CPU，输出设备这三者是可以并行使用的。J1 输入完成后开始计算，此时输入设备空闲，可用于进行 J2 的输入工作，J1 计算完成后开始输出，此时 CPU 空闲，可用于 J2 的计算工作，J2 进行计算的时候，输入设备空闲，可用于 J3 的输入工作，以此类推……..可以看到，多道批处理系统尽可能在同一时刻让输入设备，CPU，输出设备这三者都<strong>有事可做</strong>，将资源充分调用起来。相比单道批处理系统耗时 9 秒，完成相同的工作，多道批处理系统只需要 5 秒即可。</p>
<h2 id="分时系统（Time-sharing-system）"><a href="#分时系统（Time-sharing-system）" class="headerlink" title="分时系统（Time sharing system）"></a>分时系统（Time sharing system）</h2><p>需求：人机交互（要能修改、能控制）、共享主机（有“独占”的感觉）</p>
<p>人机交互的关键：系统要及时接受并处理用户输入，所以作业不能再放在外存（磁盘），而要<strong>直接进入内存</strong>；另外，需要采用<strong>轮转运行</strong>方式。引入时间片的概念，时间片可以看作一个时间限制，每次每个作业（用户）只有一个时间片的运行时间，过了这个时间片，就必须让给其它作业（用户）运行。</p>
<p>特点：</p>
<ul>
<li>多路性：一主机，<strong>多终端</strong>，多个用户按照<strong>分时原则</strong>共享一台计算机</li>
<li>独立性：一用户一终端，互不打扰，有一种“独占”的感觉</li>
<li>及时性：及时响应用户请求</li>
<li>交互性：用户请求系统提供某些服务</li>
</ul>
<p>分时系统的缺点是，它对每个用户/作业都是<strong>公平</strong>的，循环地为它们执行一个时间片，不区分轻重缓急，因此不能优先处理紧急任务。</p>
<h2 id="实时系统-（Real-time-system）"><a href="#实时系统-（Real-time-system）" class="headerlink" title="实时系统 （Real time system）"></a>实时系统 （Real time system）</h2><p>实时即“及时”。这里要注意和分时系统的区别：实时系统能够及时响应外部事件的请求，指的是紧急任务可以不需要时间片的排队而<strong>优先得到处理</strong>。</p>
<p>实时任务：</p>
<ul>
<li>任务是否周期性？周期性实时任务：非周期性实时任务（开始截止时间、完成截止时间）</li>
<li>对截止时间的要求？硬实时任务（不能错过截止时间）：软实时任务（允许错过截止时间）</li>
</ul>
<p>特点：</p>
<ul>
<li>多路性：系统周期性地采集多路现场信息</li>
<li>独立性：对信息得采集、对对象得控制，互不干扰</li>
<li><strong>及时性</strong>：控制对象所要求的截止时间</li>
<li>交互性：仅限于某些系统特定的服务</li>
<li><strong>可靠性</strong>：多级容错措施</li>
</ul>
<h2 id="微机操作系统"><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h2><p>……</p>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><p>……</p>
<p>PS：同时具有<strong>批处理、分时、实时处理</strong>的功能，叫做通用操作系统</p>
<h1 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h1><h2 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h2><p>提高资源利用率、增加系统吞吐量，依靠的就是程序的并发执行。</p>
<p><strong>并行和并发的区别</strong></p>
<p><strong>并行(parallel)**：指在</strong>同一时刻，有多条指令在多个处理器上同时执行**。比如下图的 ABC 三个人同时吃面包，1分钟后都吃完了，无论是从微观角度（聚焦于一秒）还是从宏观角度（聚焦于几十秒），这三者都是同时执行的</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-3.webp"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-3.webp" alt="图片描述"></a><br><strong>并发(concurrency)**：指在</strong>同一时刻只能有一条指令执行<strong>，但多个进程指令被快速地</strong>轮换执行**，使得在宏观上具有多个进程同时执行的效果，但实际上在微观上并不是同时执行的。比如下图的 ABC 三个人吃面包，0-10 秒 A 吃面包，10-20 秒 B 吃面包，20-30 秒 C 吃面包，那么在微观角度上（聚焦于秒级别的比较），很显然不是同时执行的；但是在宏观角度上（聚焦于整体的1分钟），不考虑更加精细的时间，这三者是同时执行的。<a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-4.webp"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-4.webp" alt="图片描述"></a></p>
<ul>
<li>进程：在系统中能够独立运行并作为资源分配的基本单位，程序创建进程后才能并发执行</li>
</ul>
<h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>多个并发进程共同使用系统资源，资源在同一个时间段内交替地被多个进程使用</p>
<ul>
<li>互斥共享方式（例如打印机，仅当 A 进程访问完并释放系统资源后，才允许另一进程访问该资源）</li>
<li>同时访问方式（如磁盘设备，一段时间内是可以同时访问的。这里的同时是宏观层面上的）</li>
</ul>
<p>PS：并发和共享互为存在条件，是 OS 最基本的特征：进程并发是资源共享的前提，对共享资源的访问保证了进程并发的顺利执行</p>
<h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>通过虚拟技术把一个物理上地实体变为若干个逻辑上的对应物</p>
<ul>
<li>时分复用技术：把一个单一的大时间段分成多个时间片，交替执行各个进程。比如说虚拟处理器技术就是时分复用技术的一种 —— 单核计算机同时打开多个软件，在用户看来感觉像是多个 CPU 在跑这些软件。</li>
<li>空分复用技术：虚拟存储器技术就是空分复用技术的一种 —— 计算机只有 4G 内存，虽然各个运行的软件消耗的总的内存远不止 4G，但它们还是可以正常运行，在用户看来感觉像是物理内存超过了 4G。</li>
</ul>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，以不可预知的速度向前推进。</p>
<h1 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h1><p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-5.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-5.png" alt="img"></a></p>
<h2 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h2><ul>
<li><p>进程控制：为作业创建、撤销、种植进程，控制进程的状态转换</p>
</li>
<li><p>进程同步：为多个进程的运行进行协调</p>
<ul>
<li>进程互斥方式</li>
<li>进程同步方式</li>
</ul>
</li>
</ul>
<ul>
<li><p>进程通信：进程之间的信息交换</p>
</li>
<li><p>调度：作业调度、进程调度</p>
</li>
</ul>
<h2 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h2><ul>
<li>内存分配：静态内存分配（运行过程中不可申请新的内存空间）和动态内存分配（运行过程中允许申请新的内存空间）</li>
<li>内存保护：每个程序只在自己的内存区运行</li>
<li>地址映射：逻辑地址 =&gt; 物理地址</li>
<li>内存扩充：借助虚拟存储技术，从<strong>逻辑上</strong>进行内存扩充</li>
</ul>
<h2 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h2><ul>
<li>缓冲管理：在 I/O 和 CPU 之间引入缓冲，提高资源利用率和系统吞吐量。缓冲区机制包括：单缓冲机制、双缓冲机制、公用缓冲池机制</li>
<li>设备分配：根据用户请求的设备类型和采用的分配算法，对设备进行分配</li>
<li>设备处理：实现 CPU 与设备控制器之间的通信。</li>
</ul>
<h2 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h2><ul>
<li>文件存储空间的管理：为文件分配外存空间</li>
<li>目录管理：为文件建立一个目录项</li>
<li>文件读写管理和保护：对外存中的文件进行读写，提供防护</li>
</ul>
<h2 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h2><ul>
<li>命令接口（用户直接使用）：联机用户接口、脱机用户接口</li>
<li>程序接口（用户通过程序间接使用）：让用户程序在执行中访问系统资源，是用户程序取得 OS 服务的唯一途径，<strong>有时候也叫做系统调用</strong></li>
<li>图形用户接口</li>
</ul>
<h2 id="现代-OS-的新功能"><a href="#现代-OS-的新功能" class="headerlink" title="现代 OS 的新功能"></a>现代 OS 的新功能</h2><ul>
<li>系统安全：认证技术、密码技术、访问控制技术、反病毒技术</li>
<li>网络功能和服务：网络通信、资源管理、应用互操作</li>
<li>支持多媒体：接纳控制功能、实时调度、多媒体文件的存储</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统之体系结构和运行机制</title>
    <url>/posts/86e26df6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<h1 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h1><h2 id="传统的操作系统结构"><a href="#传统的操作系统结构" class="headerlink" title="传统的操作系统结构"></a>传统的操作系统结构</h2><p><strong>（1）无结构操作系统：</strong></p>
<p>早期的操作系统没有真正意义上的“结构”可言，只是大量的过程的集合，过程之间可以互相调用，导致操作系统内部复杂而混乱。</p>
<p><strong>（2）模块化结构操作系统：</strong></p>
<p>模块化结构的 OS 基于程序模块化开发的思想，按照功能划分了多个具有一定独立性和大小的模块，每个模块有自己的功能，同时互相之间能够通过接口实现交互。模块之下又有子模块，以此类推。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6-1.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6-1.png" alt="img"></a></p>
<ul>
<li>模块的大小：划分过小，就会引起模块之间联系过多；划分过大，就会引起内部联系增加，复杂度提高</li>
<li>模块的独立性：两个衡量标准，即低耦合、高内聚。耦合度指的是模块之间的互相联系和影响，内聚性指的是模块内部各部分之间的紧密程度</li>
</ul>
<blockquote>
<p>模块化开发的 OS 虽然提高了 OS 设计的正确性、可理解性、可维护性，加速了开发过程，但是也存在着一定的问题：接口难以满足实际需求；多个决定齐头并进，呈现出“无序性”。</p>
</blockquote>
<p><strong>（3）分层式结构操作系统</strong></p>
<p>为了将“无序性”转化成“有序性”，采用了<strong>自底向上</strong>方法，在目标系统和裸机（宿主）系统之间铺设多个中间层，使得目标系统最终得以在裸机系统上运行。</p>
<p>从层次来看，为了使<strong>每一步设计都建立在可靠的基础上</strong>（这正是模块化结构 OS 缺失的），规定每一层仅能使用其底层提供的功能和服务 —— 这就使得调试变得非常容易，比如调试 A2 层的时候，可以只考虑 A1 层，因为 A2 层依赖 A1 层的服务和功能。一层一层自底向上增添，每一层实现一些功能，最后构成一个完整的 OS。</p>
<p>聚焦于单个层次，每个层次都由若干个模块构成。</p>
<blockquote>
<p>分层式结构的 OS 虽然保证了系统的正确性、可扩充性和易维护性，但是由于是分层单向依赖，使得层次和层次之间的<strong>通信</strong>成为了一个问题。执行一个简单的功能，可能需要穿越多个层次完成通信。</p>
</blockquote>
<h2 id="微内核操作系统结构"><a href="#微内核操作系统结构" class="headerlink" title="微内核操作系统结构"></a>微内核操作系统结构</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>（1）足够小的内核：</strong></p>
<p>包含 —— 与硬件处理紧密相关的部分；基本的功能；客户与服务器之间的通信</p>
<p><strong>（2）基于客户/服务器模式 ：</strong></p>
<p>OS 最基本的部分放在内核中，其它绝大部分功能则在微内核外面的一组服务器（进程）中实现，比如 IO 设备管理服务器、进程服务器等。客户与服务器之间通过消息传递机制实现信息交互，如下图：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-2.webp"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-2.webp" alt="img"></a></p>
<p><strong>（3）应用“机制与策略分离”原理</strong>：</p>
<ul>
<li>机制：实现某个功能的具体执行机构</li>
<li>策略：在机制基础上借助某些算法实现功能</li>
</ul>
<p>在微内核 OS 中，通常将机制放在 OS 的微内核中。</p>
<p><strong>（4）采用面向对象技术：</strong></p>
<p>基于“抽象”“隐蔽”原则控制系统的复杂性，基于“对象”“封装”“继承”确保系统的正确性、可靠性、易修改性、易扩展性。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>进程（线程）管理：进程通信、切换、调度等</li>
<li>低级存储器管理</li>
<li>中断和陷入管理</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">提高了系统可扩展性</td>
<td align="center">采用了小的内核</td>
</tr>
<tr>
<td align="center">增强了系统的可靠性</td>
<td align="center">C/S模式和消息传递机制</td>
</tr>
<tr>
<td align="center">较好的可移植性</td>
<td align="center">运行效率有所降低</td>
</tr>
<tr>
<td align="center">提供了对分布式系统的支持</td>
<td align="center">传统 OS 只需进行两次变态，而微内核 OS 需进行多次变态（具体下文会提及）</td>
</tr>
<tr>
<td align="center">融入了面向对象技术</td>
<td align="center">/</td>
</tr>
</tbody></table>
<h1 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h1><h2 id="相关概念普及"><a href="#相关概念普及" class="headerlink" title="相关概念普及"></a>相关概念普及</h2><h3 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h3><p><strong>特权指令：</strong></p>
<p>指的是有特殊权限的指令，比如：<strong>清内存、置时钟、分配系统资源、修改虚存的段表和页表，修改用户的访问权限</strong>等。这类指令使用不慎将导致系统崩溃，因此不能直接向用户程序开放使用这些指令的权限。</p>
<p><strong>非特权指令：</strong></p>
<p>相对于特权指令来说的普通指令，任何程序都可以使用，比如运算指令等。</p>
<h3 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h3><p>CPU 的核心态或者用户态可以看作一种状态，一种模式或者一种级别。</p>
<p><strong>核心态（目态）：</strong>当处于核心态时，可以使用特权指令或者非特权指令（陷入指令是例外，它只能在用户态下执行）</p>
<p><strong>用户态（管态）：</strong>当处于用户态时，只能使用非特权指令</p>
<h3 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h3><p><strong>内核程序：</strong>运行在核心态下，可以执行特权指令</p>
<p><strong>应用程序：</strong>运行在用户态下，为了系统安全着想，它只能执行非特权指令</p>
<h2 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h2><p>先看计算机系统的结构层次：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-3.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-3.png" alt="img"></a></p>
<p>重点在 OS 的内核，它是 OS 最基本、最核心的部分。</p>
<p><strong>大内核：</strong></p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-3.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-3.png" alt="img"></a></p>
<p>如果内核不仅包括了时钟管理、中断处理以及原语（设备驱动、CPU 切换），还包含了进程管理、存储器管理以及设备管理等功能，那么就属于<strong>大内核</strong>。</p>
<p>大内核虽然使得内部代码非常庞大复杂，但是在用户态与核心态之间的切换，相对来说是很快的，这是因为大内核集成了进程管理、存储器管理等；</p>
<p><strong>微内核：</strong></p>
<p>如果内核仅由时钟管理、中断处理以及原语（设备驱动、CPU 切换）构成，那么这种内核属于<strong>微内核</strong>；</p>
<p>微内核的代码结构相对来说就很清晰、便于维护，但是由于微内核只集成了时钟管理、中断处理等这些最最基本的功能，所以在涉及到进程管理、存储器管理等时，就可能需要频繁变态（切换到用户态），而变态是需要消耗时间的，这无疑就会降低运行的性能。</p>
<h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><h3 id="为什么需要中断？"><a href="#为什么需要中断？" class="headerlink" title="为什么需要中断？"></a>为什么需要中断？</h3><p>在第一篇笔记中，我们说过，早期的操作系统只能串行跑程序，一个完成之后才能轮到下一个，这种情况下资源利用率显然是很低的；于是后来有了多道批处理系统，可以并发执行程序，为什么能够并发执行呢？这其实依赖于中断机制。</p>
<ul>
<li>CPU 从用户态切换到核心态，能且<strong>只能通过 中断 这一途径</strong></li>
<li>而从核心态切换到用户态，只需要执行一个特权指令</li>
</ul>
<h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><ul>
<li><p>内中断（异常、例外、陷入）：内中断的中断信号来自于 CPU 内部，和执行的指令有关</p>
<ul>
<li>自愿中断：比如 系统调用 这一指令中断</li>
<li>强迫中断：硬件故障、软件中断（比如不合法的运算）</li>
</ul>
</li>
</ul>
<ul>
<li><p>外中断（狭义的中断）：外中断的中断信号来自于 CPU 外部，和执行的指令无关</p>
<ul>
<li>外设请求：比如 I/O 操作完成后发出的中断信号</li>
<li>人工干预：比如用户强行终止进程</li>
</ul>
</li>
</ul>
<p>此外，还有另一种分类方式：</p>
<ul>
<li>硬中断：是由诸如磁盘，网卡，键盘，时钟等的外设发出中断信号的</li>
<li>软中断：是执行中断指令产生的，通常是一些对 I/O 的请求</li>
</ul>
<h3 id="中断的过程演示"><a href="#中断的过程演示" class="headerlink" title="中断的过程演示"></a>中断的过程演示</h3><p>我们用一个过程来演示中断的发生：</p>
<p><strong>（Session 1）时间片用完了：</strong></p>
<p>比方说，现在有个 A 进程正在用户态下运行。一段时间后，该进程消耗完了本次的时间片，那么操作系统内核中的计时部件知道时间到了，就会向 CPU 发射一个中断信号。CPU 接收到中断信号后，肯定要针对本次<strong>中断</strong>进行处理，但是它自己是无法处理的，需要<strong>借助操作系统</strong>内核的中断处理程序处理，而该程序又需要运行在核心态下，所以，此时 CPU 由一开始的用户态切换成了核心态。操作系统内核的中断处理程序针对中断信号进行处理，发现原来是 A 进程的时间片用完了，应该轮到 B 进程运行了，那么它就会把 CPU 使用权移交给 B 进程，让 B 进程开始运行，此时 CPU 也切换回用户态。</p>
<p><strong>（Session 2）要进行输出：</strong></p>
<p>B 进程正常运行，这时候执行到的某一行代码要求进行输出操作。前面我们说过，输入输出是特权指令，B 作为一个普通的用户程序来说，是不能直接执行特权指令的，因此，B 进程通过系统调用的方式向 CPU 发射一个中断信号，CPU 接收到中断信号后，肯定要针对本次<strong>中断</strong>进行处理，但是它自己是无法处理的，需要<strong>借助操作系统</strong>内核的中断处理程序处理，而该程序又需要运行在核心态下，所以，此时 CPU 由一开始的用户态切换成了核心态。操作系统内核的中断处理程序针对中断信号进行处理，发现原来是 B 进程要进行输出，那么它就会让打印机这一 I/O 设备开始工作。对于 B 进程，此时它要暂停运行，等待 I/O 完成。而这段空闲的时间不能浪费，所以操作系统就会把 CPU 使用权移交给 C 进程，让 C 进程开始运行，此时 CPU 也切换回用户态。</p>
<p><strong>（Session 3）输出完成了：</strong></p>
<p>现在，C 进程和 I/O 设备并发运行，在 I/O 设备搞定了自己的工作后，它会向 CPU 发射一个中断信号。一如既往地，CPU 再次变成核心态，操作系统介入，发现原来是输出工作完成了，应该让上次暂停的 B 进程继续运行了，那么它就会把 CPU 使用权再次移交给 B 进程，让 B 进程往后运行，此时 CPU 也切换回用户态。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="为什么需要系统调用"><a href="#为什么需要系统调用" class="headerlink" title="为什么需要系统调用"></a>为什么需要系统调用</h3><p>操作系统作为连接 用户/应用程序 和 计算机硬件 的中间层，需要向上提供一些接口以方便用户或者应用程序使用它的服务，这些接口包括命令接口和程序接口。</p>
<p>命令接口即联机命令接口和脱机命令接口，用户可以直接使用这些接口；而程序接口则是由一组系统调用组成的，用户需要通过程序间接使用：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-4.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-4.png" alt="img"></a></p>
<p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。系统中的各种共享资源归操作系统管理，因此在用户程序中，凡是和资源相关的操作，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成，从而保证系统的<strong>稳定性和安全性</strong>，防止用户进行非法操作。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>设备管理：完成设备的 请求/释放/启动 等</li>
<li>文件管理：完成文件的 读写增删 等</li>
<li>进程控制：完成进程的 创建/撤销/阻塞/唤醒 等</li>
<li>进程通信：完成进程之间的 消息传递/信号传递 等</li>
<li>内存管理：完成内存的 分配/回收 等</li>
</ul>
<p>这些功能都涉及到了特权指令，因此系统调用虽然是在用户态发出的，但是他的处理是需要在核心态下完成的。</p>
<p>PS：部分的库函数是对系统调用的封装</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>传递系统调用的参数 ==&gt; 在<strong>用户态</strong>下执行陷入指令，发生内中断，进入核心态 ==&gt; 在核心态下执行系统调用相应服务程序 ==&gt; 返回用户程序</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统之线程</title>
    <url>/posts/d2da0ebf/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程<strong>既是一个携带资源的独立单位，也是独立调度的基本单位</strong>，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销（没办法“轻装上阵”）。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。</p>
</blockquote>
<a id="more"></a>

<h3 id="引入线程"><a href="#引入线程" class="headerlink" title="引入线程"></a>引入线程</h3><p>首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程<strong>既是一个携带资源的独立单位，也是独立调度的基本单位</strong>，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销（没办法“轻装上阵”）。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。</p>
<p>如何解决这个问题呢？可以把进程看作是管理初创公司的老板，一开始人手不足，老板既要管理公司，也要四处奔跑沟通业务；但是一旦人手充足，那么老板仍然可以管理公司，只是沟通业务的工作就可以交给手下人去执行了。同理，我们可以考虑依然让进程作为拥有资源的独立单位，但是独立调度的基本单位则不再是进程，而是新引入的<strong>线程</strong>了。</p>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p><strong>调度的基本单位</strong></p>
<p>引入线程后，调度的基本单位不再是进程，而是线程。线程能够独立运行，且切换的时候，代价远远小于进程切换的代价。同一进程不同线程的切换，不会引起进程的切换。</p>
<p><strong>执行的基本单位</strong></p>
<p>通常认为进程不再作为可执行的实体。也即，可以说进程处于“执行”状态，但其实指的是该进程的某个线程正在执行；可以说进程处于“挂起”状态，但其实指的是该进程的所有线程都被挂起。其他同理。</p>
<p><strong>并发性</strong></p>
<p>进程间仍然能够并发，不仅如此，一个进程中的多个线程间也能并发，不同进程中的线程也能够并发，大大提高了 OS 的并发性。</p>
<p><strong>资源</strong></p>
<p>资源依然掌握在进程手中。为了性能考虑，线程仅占有一点必不可少的资源（比如 TCB，程序计数器等）。那么如何访问其它资源呢？事实上，同一进程的线程共享该进程所拥有的资源。另外，这些线程还共享同一片内存地址空间，所以也可以方便地进行通信。</p>
<p><strong>独立性</strong></p>
<p>同一进程中的线程间独立性要比不同进程间独立性低很多。前者独立性高，因为要防止进程之间彼此干扰和破坏；后者独立性低，因为同一进程的多个线程通常需要协作完成任务，互相之间可访问程度相对来说会比较高。</p>
<p><strong>系统开销</strong></p>
<p>在创建和撤销进程时，系统需要分配或者回收 PCB，分配或者回收资源，所以需要付出一定的时空开销；但是线程的创建和撤销的时空开销则明显小很多，尤其是在同一进程内的线程创建和撤销，这种开销会更加地小。</p>
<p><strong>支持多处理机系统</strong></p>
<p>传统的单线程进程，即使处理机再多，一个进程也只能运行在一个处理机上；但是引入了线程后，一个进程的多个线程可以分配到多个处理机上、并行执行。</p>
<h3 id="线程的状态和线程控制块"><a href="#线程的状态和线程控制块" class="headerlink" title="线程的状态和线程控制块"></a>线程的状态和线程控制块</h3><p>线程的状态类似于进程的状态，同样有：执行态、就绪态、阻塞态。</p>
<p>进程有进程控制块 PCB，线程也有线程控制块 TCB（Thread control block）。TCB 记录了所有用于控制和管理线程的信息。具体来说包括：</p>
<p>① 线程标识符：为每个线程赋予一个唯一的线程标识符</p>
<p>② 组寄存器：包括程序计数器PC、状态寄存器和通用寄存器的内容</p>
<p>③ 线程运行状态：用于描述线程正处于何种运行状态<br>④ 优先级：描述线程执行的优先程度</p>
<p>⑤ 线程专有存储区：用于线程切换时存放现场保护信息，和与该线程相关的统计信息等</p>
<p>⑥ 信号屏蔽：即对某些信号加以屏蔽</p>
<p>⑦ 堆栈指针：在线程运行时，经常会进行过程调用，而过程的调用通常会出现多重嵌套的情况，这样，就必须将每次过程调用中所使用的局部变量以及返回地址保存起来。为此，应为每<br>个线程设置一个堆栈，用它来保存局部变量和返回地址。相应地，在 TCB 中，也须设置两<br>个指向堆栈的指针:指向用户自己堆栈的指针和指向核心栈的指针。前者是指当线程运行<br>在用户态时，使用用户自己的用户栈来保存局部变量和返回地址，后者是指当线程运行在<br>核心态时使用系统的核心栈。</p>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>不同的系统对于线程的实现方式是不同的。</p>
<h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>用户级线程是由应用程序通过线程库实现的，所有的线程管理工作（包括对线程的创建、撤销等）都<strong>由应用程序来完成</strong>，无需操作系统内核的干预，操作系统内核也意识不到用户级线程的存在。</p>
<p>它的优点在于：</p>
<ul>
<li>正如前面所说的，应用程序一个人包办了线程的管理工作，所以进程无需切换到内核态来对线程进行管理。</li>
<li>不同的进程可以根据自己的需要选择不同的调度算法，对自己的线程进行管理和调度</li>
</ul>
<p>缺点在于：</p>
<ul>
<li>当线程执行一个系统调用而使自己陷入阻塞时，其它与自己同处于一个进程的线程也都会被阻塞</li>
</ul>
<h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>与用户级线程中应用程序全权进行线程管理不同，在内核级线程中，线程的管理是<strong>由操作系统内核来完成的</strong>。尤其是线程的切换，因为它是由内核完成的，所以需要在核心态下进行操作。</p>
<p>它的优点在于：</p>
<ul>
<li>当线程执行一个系统调用而使自己陷入阻塞时，其它与自己同处于一个进程的线程不会被阻塞，依然可以被调用。而且还可以选择调用其它进程中的线程。</li>
</ul>
<p>缺点在于：</p>
<ul>
<li>用户的线程切换需要一定的开销。虽然用户进程的线程在用户态下运行，但是是内核进行的线程管理，所以要切换线程，首先必须先从用户态转到核心态。</li>
</ul>
<h4 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h4><p>有的系统同时结合了用户级线程和内核级线程，将多个用户级线程映射到多个内核级线程上。根据映射方式的不同，分为三种模型：</p>
<p><strong>（1）多对一模型</strong></p>
<p>将同一个进程的多个用户级线程映射到一个内核级线程。优点在于线程的切换直接由应用程序完成，无需切换到核心态；缺点在于一个线程的阻塞将会导致整个进程阻塞。</p>
<p><strong>（2）一对一模型</strong></p>
<p>将同一个进程的每一个用户级线程映射到对应的每一个内核级线程。优点在于一个线程阻塞时，可以调用另一个线程。缺点在于需要为每个用户级线程分配一个对应的内核级线程，相当于一个进程就需要分配多个内核级线程，并且线程切换也需要在核心态下进行，这些都带来了比较大的开销。</p>
<p><strong>（3）多对多模型</strong></p>
<p>多个用户级线程对应多个内核级线程（用户级线程数目大于等于内核级线程数目）。优点在于，一个线程的阻塞不会再像多对一模型那样导致整个进程的阻塞，而且一个用户进程也不会再像一对一模型那样占用过多的内核级线程。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统之进程和进程控制</title>
    <url>/posts/36a35c47/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B-0.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B-0.png" alt="img"></a></p>
<p>在 基础概念中，我们介绍了与操作系统相关的一些概念，在 体系结构设计和运行机制]中，我们又介绍了操作系统的结构设计和运行机制，从这篇笔记开始，我们会逐一讲解操作系统的各个基本功能。</p>
<p>一切围绕这张图来进行：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-5.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-5.png" alt="img"></a></p>
<h1 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h1><h2 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h2><p>为了方便操作系统管理，对并发执行的各个程序加以控制和描述，引入了进程的概念。</p>
<h2 id="PCB："><a href="#PCB：" class="headerlink" title="PCB："></a>PCB：</h2><p><strong>定义：</strong></p>
<p>之前的单道批处理系统，程序是串行执行的，内存中可能只需要记录单一程序的程度段和数据段即可；但是现在使用的是多道批处理系统，多个程序并发执行，内存中就可能存在多个程序自己的程序段和数据段，那么这时候就需要一个管理单元对这些东西加以区分、描述和管理，所以就额外多了一个<strong>进程控制块</strong>，也就是 PCB（process control block）。</p>
<p>系统会为每一个运行的程序分配 PCB 这么一个数据结构，用以描述进程的各种信息。PCB 是进程存在的唯一标志，进程与 PCB 是一一对应的的。</p>
<p>PCB 记录了关于进程的信息，这些信息包括：</p>
<ul>
<li>进程标识符：外部内部各一个</li>
<li>处理机状态：通用寄存器、指令计数器、程序状态字 PSW，用户栈指针</li>
<li>进程调度信息：进程状态、进程优先级、其它的进程调度信息</li>
<li>进程控制信息：程序和数据的地址、进程同步和通信机制、资源清单、链接指针</li>
</ul>
<h2 id="进程实体："><a href="#进程实体：" class="headerlink" title="进程实体："></a>进程实体：</h2><p><strong>程序段</strong>（程序代码）、<strong>数据段</strong>（变量、常量等），<strong>PCB</strong>（相关的管理信息） 共同构成了进程实体（进程映像）。一般认为 进程实体 === 进程 === PCB</p>
<p>PS：下文提到的多个进程的组织方式，也可以说就是多个 PCB 的组织方式</p>
<h2 id="进程与程序的对比："><a href="#进程与程序的对比：" class="headerlink" title="进程与程序的对比："></a>进程与程序的对比：</h2><ul>
<li>进程是<strong>动态的</strong>（程序的执行），程序是静态的（有序代码的集合）</li>
<li>进程是暂时的，程序是永久的</li>
<li>进程和程序的组成不同</li>
<li>通过多次执行，一个程序可以对应多个进程；通过调用关系，一个进程可以包括多个程序</li>
</ul>
<h1 id="进程的组成和组织"><a href="#进程的组成和组织" class="headerlink" title="进程的组成和组织"></a>进程的组成和组织</h1><h2 id="单个进程的组成"><a href="#单个进程的组成" class="headerlink" title="单个进程的组成"></a>单个进程的组成</h2><ul>
<li>进程描述信息：进程标识符PID（区分不同进程）用户标识符 UID（区分不同用户）</li>
<li>进程控制和管理信息：进程当前状态、进程优先级</li>
<li>资源分配清单：程序段指针、数据段指针、键鼠</li>
<li>处理机相关信息：各种寄存器的值</li>
</ul>
<h2 id="多个进程的组织方式"><a href="#多个进程的组织方式" class="headerlink" title="多个进程的组织方式"></a>多个进程的组织方式</h2><p><strong>链接方式：</strong></p>
<p>按照进程状态将 PCB 分为多个队列，OS 持有指向各个队列的指针（执行指针、就绪队列指针、阻塞队列指针）</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-4.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-4.png" alt="img"></a></p>
<p><strong>索引（线性）方式：</strong></p>
<p>按照进程状态建立几张索引表，OS 持有指向各个索引表的指针（执行指针、就绪表指针、阻塞表指针）</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-5.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-5.png" alt="img"></a></p>
<h1 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h1><ul>
<li><strong>动态性</strong>：进程是程序的一次执行过程，是<strong>动态地</strong>产生、变化和消亡的</li>
<li>并发性：内存中有多个进程实体，各个进程可以并发执行</li>
<li>独立性：进程是系统进行资源分配和调度的一个<strong>独立单位</strong></li>
<li>异步性：各个进程以独立的、不可预知的速度推进</li>
<li>结构性：每个进程都有一个自己的 PCB，进程由程度段、数据段、PCB 构成</li>
</ul>
<h1 id="进程的状态-生命周期"><a href="#进程的状态-生命周期" class="headerlink" title="进程的状态/生命周期"></a>进程的状态/生命周期</h1><h2 id="五种基本状态："><a href="#五种基本状态：" class="headerlink" title="五种基本状态："></a>五种基本状态：</h2><p><strong>① 创建态：</strong>初始化 PCB，为进程分配系统资源</p>
<p><strong>② 就绪态：</strong>PCB 修改相应内容并被送到就绪队列。万事俱备（运行需要的条件都有了），只欠东风（只等 CPU 调度自己）</p>
<p><strong>③ 运行态：</strong> PCB 修改相应内容，出队（可能还会恢复进程运行环境）。该进程此时占有 CPU 使用权，在 CPU 上运行（对于单核处理器，一个时刻只会有一个进程）</p>
<p><strong>④ 阻塞态（等待态）：</strong>进程进行系统调用，或者等待事件发生时，进入阻塞态，PCB 修改相应内容并被送到相应事件的阻塞队列</p>
<p><strong>⑤ 终止态（结束态）：</strong>回收为进程分配的资源，撤销 PCB</p>
<p>PS：由于事件有多个，所以阻塞队列一般也是有多个的，一个事件对应一个阻塞队列。而就绪队列就只有一个了。</p>
<h2 id="进程状态的转换："><a href="#进程状态的转换：" class="headerlink" title="进程状态的转换："></a>进程状态的转换：</h2><p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B-1.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B-1.png" alt="img"></a></p>
<h2 id="引入挂起操作后"><a href="#引入挂起操作后" class="headerlink" title="引入挂起操作后"></a>引入挂起操作后</h2><p><strong>（1）挂起：</strong></p>
<p>前面所说的状态转换，是建立在内存资源够用的情况下 —— 当系统资源尤其是内存资源不够时，就需要将一些进程<strong>挂起</strong>（suspend），对换到外存中。</p>
<p><strong>（2）原因：</strong></p>
<p>引起进程挂起的原因是多样的，主要有：</p>
<ul>
<li>系统中的进程均处于阻塞态，处理器空闲，此时需要把一些阻塞进程对换出去，以<strong>腾出足够的内存</strong>装入就绪进程运行。</li>
</ul>
<ul>
<li>进程竞争资源，导致系统<strong>资源不足</strong>，负荷过重，此时需要挂起部分进程以调整系统负荷，保证系统的实时性或让系统正常运行。</li>
</ul>
<ul>
<li>把一些定期执行的进程（如审计程序、监控程序、记账程序）对换出去，以<strong>减轻系统负荷</strong>。</li>
</ul>
<ul>
<li><strong>用户要求</strong>挂起自己的进程，以便根据中间执行情况和中间结果进行某些调试、检查和改正。</li>
</ul>
<ul>
<li><strong>父进程</strong>要求挂起自己的后代进程，以进行某些检查和改正。</li>
</ul>
<ul>
<li><strong>操作系统</strong>需要挂起某些进程，检查运行中资源使用情况，以改善系统性能；或当系统出现故障或某些功能受到破坏时，需要挂起某些进程以排除故障。</li>
</ul>
<p><strong>（3）状态转换</strong></p>
<p>引入挂起操作后，在原来五种状态的基础上多了两个状态：就绪态变成了活动就绪态，且多了一个“静止就绪态/挂起就绪态“；原来的阻塞态变成了活动阻塞态，且多了一个“静止阻塞态/挂起阻塞态“。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B-2.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B-2.png" alt="img"></a></p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">活动就绪态 → 静止就绪态</td>
<td align="center">操作系统根据当前资源状况和性能要求，可能会把活动就绪态对换出去，成为静止就绪态。<strong>处于静止就绪态的进程不再被调度执行</strong>；</td>
</tr>
<tr>
<td align="center">静止就绪态 → 活动就绪态</td>
<td align="center">内存中没有进程处于活动就绪态，或者处于静止就绪态的进程具有更高的优先级，那么静止就绪态就会被对换回来，此时才可能被调度执行</td>
</tr>
<tr>
<td align="center">活动阻塞态→ 静止阻塞态</td>
<td align="center">操作系统根据当前资源状况和性能要求，可能会把活动阻塞态对换出去，成为静止阻塞态。</td>
</tr>
<tr>
<td align="center">静止阻塞态→ 静止就绪态</td>
<td align="center">常见的情况是，引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态</td>
</tr>
<tr>
<td align="center">静止阻塞态→ 活动阻塞态</td>
<td align="center">但有时候，如果<strong>静止阻塞态进程</strong>的优先级高于<strong>静止就绪队列中的任何进程</strong>、并且系统有把握它等待的事件即将完成，那么就会激活为活动阻塞态</td>
</tr>
<tr>
<td align="center">运行态→ 静止就绪态</td>
<td align="center">优先级较高的静止阻塞态在等待的事件完成后，可能会抢占 CPU，若此时资源不够，则可能导致正在运行的进程挂起为静止就绪态</td>
</tr>
<tr>
<td align="center">创建态→ 静止就绪态</td>
<td align="center">操作系统根据当前资源状况和性能要求，可能会在进程创建完就把它对换到外存</td>
</tr>
</tbody></table>
<p><strong>PS：</strong>进程一旦被挂起，就意味着它被对换到了外存中，此时该进程无法再被 CPU 直接调度，除非它被对换回内存中，回到活动就绪态。比如静止就绪态、静止阻塞态，最后要得到 CPU 的调度，都必须经历<strong>回归到活动就绪态</strong>的过程。</p>
<blockquote>
<p>那么一个状态具体是如何切换到另一个状态的呢？</p>
</blockquote>
<h1 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h1><p>在前面我们已经说过，进程的生命周期有多个状态，而状态的切换实质上是通过修改 PCB 的信息、让 PCB 出队或者入队来实现的，但是是谁来控制这个过程呢？—— 答案就是进程控制，进程控制指的是对系统中所有进程，从创建到终止的全过程实行的管理和控制。而进程控制是通过操作系统内核的 <strong>原语操作</strong> 来实现的。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-3.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-3.png" alt="img"></a></p>
<p>操作系统内核一览，其中一个核心就是原语操作</p>
<p>原语（Primitive）其实就是程序 —— 由若干条机器指令构成，用以完成特定功能的一段程序。原语操作属于<strong>原子操作</strong>（Atomic operation），具有不可中断性，一旦执行就不允许被打断。这种原子操作是依靠关中断指令实现的，在关中断指令下，即使有中断信号发射过来，也不会调用中断处理程序去处理中断，这就保证了原语操作不会被打断。而在开中断指令下，才会去处理中断。</p>
<p>原语的基本操作无非三个：</p>
<ul>
<li>更新 PCB 中的信息（修改进程状态标志、保存当前运行环境到 PCB、从 PCB 中恢复运行环境）</li>
<li>将 PCB 插入到合适的队列</li>
<li>分配/回收资源</li>
</ul>
<p>创建原语和撤销原语配对，阻塞原语和唤醒原语配对，所以这里我们放在一起讲。</p>
<h4 id="（1）创建原语"><a href="#（1）创建原语" class="headerlink" title="（1）创建原语"></a>（1）创建原语</h4><p>创建原语负责创建进程，具体包括：申请空白的 PCB，为新进程分配所需资源、初始化 PCB、将 PCB 插入到就绪队列。</p>
<p>引起进程创建的事件一般有四种：</p>
<ul>
<li>用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程</li>
<li>作业调度：多道批处理系统中，从作业队列取出作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务：用户向操作系统请求服务时，会创建一个进程来处理请求</li>
<li>应用请求：应用/用户进程主动请求创建一个子进程</li>
</ul>
<h4 id="（2）撤销原语"><a href="#（2）撤销原语" class="headerlink" title="（2）撤销原语"></a>（2）撤销原语</h4><p>撤销进程负责终止进程，具体包括：从 PCB 集合中找到终止进程的 PCB，如果进程正在运行，则立即将它的 CPU 使用权移交给其它进程。接着终止它的所有子进程，将该进程的资源还给父进程或者操作系统，最后再删除 PCB。</p>
<p>引起进程终止的事件一般有三类：</p>
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
<h4 id="（3）阻塞原语"><a href="#（3）阻塞原语" class="headerlink" title="（3）阻塞原语"></a>（3）阻塞原语</h4><p>阻塞原语负责让进程从运行态转换到阻塞态，具体包括：找到要阻塞的进程的 PCB，保存当前运行环境到 PCB（方便后续恢复），修改 PCB 状态信息。接着暂停进程的运行，将 PCB 插入相应事件的等待队列</p>
<p>引起进程阻塞的事件一般是：</p>
<ul>
<li>等待系统分配资源</li>
<li>请求系统某些服务（比如打印服务）</li>
<li>启动某种操作（比如 I/O 操作）</li>
<li>新数据尚未到达</li>
<li>无新工作可做</li>
</ul>
<blockquote>
<p>注意：前面我们说过，进程从运行态切换到阻塞态，是一个主动的过程，这个主动体现在是进程<strong>自己调用了</strong>阻塞原语</p>
</blockquote>
<h4 id="（4）唤醒原语"><a href="#（4）唤醒原语" class="headerlink" title="（4）唤醒原语"></a>（4）唤醒原语</h4><p>唤醒原语负责让阻塞的进程重新回到就绪态，具体包括：在事件等待队列中找到 PCB，让他出队，修改 PCB 的状态信息，再将 PCB 插入到就绪队列，等待 CPU 对他进行调度</p>
<p>一般在等待的事件发生时，进程就会被唤醒。</p>
<blockquote>
<p>注意：前面我们说过，进程从阻塞态切换到运行态，是一个被动的过程，这个被动体现在并不是进程<strong>自己调用了</strong>唤醒原语，而是“合作”进程进行了调用（比如说 I/O 进程）</p>
</blockquote>
<h4 id="（5）切换原语"><a href="#（5）切换原语" class="headerlink" title="（5）切换原语"></a>（5）切换原语</h4><p>前面的原语主要都是操作一个进程，而切换原语同时操作到了两个进程。</p>
<p>切换原语负责让当前运行的进程从 A 切换为 B，具体包括：</p>
<ul>
<li>一方面，将 A 的运行环境保存到 PCB 中，再将其 PCB 移入到相应的队列（如果当前进程是从运行态到阻塞态，那么就进入等待队列；如果是从运行态到就绪态，那么就进入就绪队列）</li>
</ul>
<ul>
<li>另一方面，选择 B 进程运行，更新其 PCB，同时可能会恢复其运行环境（考虑到 B 进程此前可能曾处于阻塞态）</li>
</ul>
<p>引起进程切换的事件一般有四种：</p>
<ul>
<li>当前进程的时间片被消耗完</li>
<li>有更高优先级的进程到达，抢占了当前进程正在使用的 CPU</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
<h4 id="（6）挂起原语和激活原语"><a href="#（6）挂起原语和激活原语" class="headerlink" title="（6）挂起原语和激活原语"></a>（6）挂起原语和激活原语</h4><p><strong>挂起原语：</strong></p>
<p>将进程从内存对换到外存，具体包括：找到需要挂起的进程的 PCB，检查它的状态并做相应操作（运行态、活动就绪态 ——&gt; 静止就绪态，活动阻塞态 ——&gt; 静止阻塞态），之后将该 PCB 复制到指定的内存区域。</p>
<p>引起进程挂起的事件，比如，用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起</p>
<p><strong>激活原语：</strong></p>
<p>将进程从外存对换回内存，检查该进程的现行状态并进行相应操作（静止就绪态——&gt;活动就绪态，静止阻塞 ——&gt; 活动阻塞态）。引起进程激活的事件，比如，父进程或用户进程请求激活指定进程，或者是某个进程驻留在外存而内存中已有足够的空间</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统之进程通信</title>
    <url>/posts/59c83435/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
<p>进程通信指的是进程之间的信息的传播和交换。</p>
</blockquote>
<a id="more"></a>

<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>进程 A 无法直接访问进程 B 的地址空间，反之亦然，所以提供一块可以供 AB 访问的共享空间。这块共享空间属于互斥的临界资源。</p>
<h4 id="基于数据结构"><a href="#基于数据结构" class="headerlink" title="基于数据结构"></a>基于数据结构</h4><p>各个进程共用某些数据结构，借以实现进程间的信息交换。比如共用一个长度为 10 的数组。这种共享速度慢、限制多，属于低级通信方式。</p>
<h4 id="基于存储区"><a href="#基于存储区" class="headerlink" title="基于存储区"></a>基于存储区</h4><p>在内存中划出一块共享存储区，各个进程通过对这个共享区的读写交换信息、实现通信。数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，属于高级通信方式。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>进程通过操作系统提供的“发送消息/接受消息”两个原语进行数据交换，而数据交换的基本单位是一个格式化的消息，该消息包括消息头和消息体。消息头包括：发送进程 ID，接受进程 ID，消息类型，消息长度等格式化的信息。</p>
<h4 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h4><p>发送进程发送消息之前，首先申请一个缓冲区，之后把消息复制到缓冲区，再通过发送原语把缓冲区发送给接受进程，缓冲区首先到达接受进程的消息缓冲队列队尾。接受进程通过接受原语读取队列消息，并复制到本地变量。</p>
<h4 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h4><p>也叫做信箱通信。发送进程发送的消息首先到达一个消息容器，接受进程再从消息容器中接受消息。</p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道又名 pipe 文件，其实就是在内存中开辟一个大小固定的缓冲区。它采用的是半双工通信，一个时间段内只能实现单向的传输。另外，管道也是互斥的临界资源。管道写满的时候，写进程会被阻塞，直到读进程把数据读走；而管道空的时候，读进程会被阻塞，直到写进程把数据读入。这里要注意，管道与我们之前说过的生产者、消费者使用的缓冲区不同。<strong>写会一次性写完，读会一次性读完，不存在写一下、读一下的情况</strong>。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统之调度</title>
    <url>/posts/ed6e1b1a/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="①-定义"><a href="#①-定义" class="headerlink" title="① 定义"></a>① 定义</h3><p>调度研究的问题是：面对有限的资源，如何处理任务执行的先后顺序。对于处理机调度来说，这个资源就是有限的处理机，而任务就是多个进程。故处理机调度研究的问题是：面对有限的处理机，如何从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，从而实现进程的并发执行。处理机调度共有三个层次，这三个层次也是一个作业<strong>从提交开始到完成</strong>所经历的三个阶段。</p>
<h3 id="②-三个层次"><a href="#②-三个层次" class="headerlink" title="② 三个层次"></a>② 三个层次</h3><p><strong>作业调度：</strong></p>
<p>作业调度也即高级调度，这个阶段可以看作是准备阶段。主要任务是按照一定的规则从外存上处于后备队列的作业中挑选一个或多个作业，为其分配内存，建立 PCB（进程） 等，使它们具备竞争处理机的能力。</p>
<p>这个阶段进程的状态变化是：无 –&gt; 创建态 –&gt; 就绪态</p>
<p><strong>内存调度：</strong></p>
<p>内存调度也即中级调度，这个阶段可以看作是优化阶段。主要任务是将暂时不能运行的进程对换到外存中，使它们挂起；而当挂起的进程具备运行条件时，它们会被重新对换回内存，得到激活。这个阶段的主要目的是提高内存利用率和系统吞吐量。</p>
<p>这个阶段进程的状态变化是： 静止就绪态 –&gt; 活动就绪态，静止阻塞态 –&gt; 活动阻塞态</p>
<p><strong>进程调度：</strong></p>
<p>进程调度即低级调度，这个阶段让进程真正运行起来。主要任务是按照某种算法，从就绪队列中选取一个进程，分配处理机给它。进程调度是最基本、次数最频繁的阶段。</p>
<p>这个阶段进程的状态变化是： 就绪态 –&gt; 活动态</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>我们把重点放在处理机调度中的进程调度阶段。</p>
<h3 id="①-时机"><a href="#①-时机" class="headerlink" title="① 时机"></a>① 时机</h3><p>进程调度的时机是什么呢？也就是说，什么时候会从就绪队列中选取一个进程，分配处理机给它呢？分为两种情况：<strong>当前进程主动放弃处理机</strong> 以及 <strong>当前进程被动放弃处理机</strong>。</p>
<ul>
<li>当前进程主动放弃处理机：比如进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞（如等待 I/O）</li>
</ul>
<ul>
<li>当前进程被动放弃处理机：比如进程的时间片用完、有更紧急的事需要处理（如 I/O 中断）、有更高优先级的进程进入就绪队列</li>
</ul>
<h3 id="②-方式"><a href="#②-方式" class="headerlink" title="② 方式"></a>② 方式</h3><p>根据进程运行的过程中，处理机能否被其它进程抢占，将调度分为两种方式：</p>
<p><strong>非抢占式：</strong>“非抢占”即“不能抢占”。一旦把处理机分配给某个进程后，除非该进程终止或者主动要求进入阻塞态，否则会一直运行下去，不允许其它进程抢占自己占有的处理机。</p>
<p><strong>抢占式：</strong>把处理机分配给某个进程 A 后，如果有一个更重要、更紧急的进程 B 需要用到处理机，那么进程 A 会立即暂停，把处理机交给进程 B。</p>
<h3 id="③-补充"><a href="#③-补充" class="headerlink" title="③ 补充"></a>③ 补充</h3><p>以下情况不会发生进程调度：</p>
<ul>
<li>处理中断的时候：由于中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在<strong>操作系统内核程序临界区</strong>的时候：注意是内核程序的临界区。普通临界区依然是有可能发生进程调度的。</li>
<li>进行原子操作的时候</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><ul>
<li><strong>CPU 利用率：</strong><code>忙碌的时间 / 总时间</code></li>
</ul>
<ul>
<li><strong>系统吞吐量：</strong><code>完成作业量 / 总时间</code></li>
</ul>
<ul>
<li><strong>周转时间：</strong><code>作业完成时间 - 作业提交时间 = 作业实际运行的时间 + 等待时间</code></li>
</ul>
<ul>
<li><strong>平均周转时间：</strong> <code>各作业周转时间之和 / 作业数</code></li>
</ul>
<ul>
<li><strong>带权周转时间：</strong><code>周转时间 / 作业实际运行的时间</code></li>
</ul>
<ul>
<li><strong>平均带权周转时间：</strong><code>各作业带权周转时间之和 / 作业数</code></li>
</ul>
<ul>
<li><p><strong>等待时间：</strong>进程或者作业处于等待处理机状态的时间之和，即 <code>周转时间 - 作业实际运行的时间</code></p>
<ul>
<li>对于进程来说，等待时间指的是进程建立后等待被服务的时间之和（由于等待 I/O 完成的期间也属于被服务时间，所以这个时间不计入等待时间）</li>
<li>对于作业来说，除了进程建立后的等待时间，还包括作业在外存后备队列中等待的时间</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>平均等待时间：</strong>各作业等待时间之和 / 作业数</p>
</li>
<li><p><strong>响应时间：</strong>从用户提交请求到首次产生响应所用的时间</p>
</li>
</ul>
<h3 id="早期批处理系统的调度算法"><a href="#早期批处理系统的调度算法" class="headerlink" title="早期批处理系统的调度算法"></a>早期批处理系统的调度算法</h3><h4 id="①-FCFS-算法"><a href="#①-FCFS-算法" class="headerlink" title="① FCFS 算法"></a>① FCFS 算法</h4><p>FCFS 算法即“先来先服务”算法，类似于我们生活中的排队，谁先来，谁就先享受服务。对于作业调度，它指的是谁先到达后备队列，谁就先出队，进而先被执行；对于进程调度，它指的是谁先到达就绪队列，谁就先出队，进而先被执行。</p>
<p>看下面的例子：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-1.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-1.png" alt="img"></a></p>
<p>这个就是很自然的谁先到达，谁就先享受服务，所以顺序上就是从 P1 到 P4。注意这里的到达时间，就是前面说过的提交时间。这里不考虑等待 I/O 的情况，否则计算等待时间的时候还需要减去等待 I/O 的时间。</p>
<ul>
<li>FCFS 算法是非抢占式的算法，不存在某个进程在执行的时候被其它进程抢占处理机的情况。</li>
<li>它的优点是公平、算法实现简单，并且不会导致饥饿（不管等多久，所有进程最后都会运行，不存在某个进程永远得不到处理机的情况）</li>
<li>缺点是对长作业有利、对短作业不利 —— 对于长作业，如果它先到，那么它自然无需做过多的等待，而即使是后到，它等待短作业的时间也是不足挂齿的，所以长作业怎么都不亏；对于短作业，如果它先到，自然也无需做过多等待，但是如果它后到，那么它不得不花很长的时间去等待长作业完成，然而它自己运行所需的时间却是很短的，所以说这个算法对短作业不利。在这种情况下，短作业的带权周转时间会很大，也即周转时间远远大于实际运行时间，表示有大量时间用于等待。</li>
<li>有时候也说 FCFS 算法对 CPU 繁忙型作业有利，对 I/O 繁忙型作业不利。这是因为 CPU 繁忙型作业的特点是需要大量的 CPU 时间进行计算，而很少请求 I/O 操作，通常视作长作业。</li>
</ul>
<h4 id="②-SJF-算法"><a href="#②-SJF-算法" class="headerlink" title="② SJF 算法"></a>② SJF 算法</h4><p>SJF 算法即“短作业优先”算法，前面的算法问题在于对短作业不利，所以 SJF 算法优先顾及短作业，让<strong>当前已到达并且运行时间最短</strong>的进程先执行。SJF 算法有非抢占式（默认）版本和抢占式版本，抢占式版本也叫做 SRTN 算法，即最短剩余时间优先算法。</p>
<p>先看非抢占式版本的例子：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-2.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-2.png" alt="img"></a></p>
<p>运行顺序的说明：</p>
<p>注意这里虽然 P1 不是运行时间最短的，但是它是 <strong>当前最先到达且运行时间最短</strong> 的进程，所以它首先运行，并且在运行过程中，P2，P3，P4 陆续到达就绪队列。在 P1 运行完之后就需要调度了，这时候，就绪队列中满足“当前已到达且运行时间最短”的进程是 P3，所以 P3 运行；P3 运行完之后继续调度其它进程，P2 和 P4 运行时间都一样，不过 P2 首先到达，所以 P2 运行，最后再轮到 P4 运行。</p>
<p>另外，由于这是非抢占式版本，所以除非进程终止或者其它原因，否则其它进程是无法与当前进程竞争处理机的。</p>
<p>接着看抢占式版本的例子：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-3.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-3.png" alt="img"></a></p>
<p>多了一个调度条件：</p>
<p>由于这是抢占式版本，所以存在着进程之间对于处理机的竞争。也就是说，除了进程正常终止会发生调度之外，每次有新进程进入就绪队列的时候，也可能发生调度。而具体谁会被调度并夺得处理机，则是比较<strong>新到达进程的剩余时间</strong>与<strong>正在运行进程的剩余时间</strong>，前者如果更短，那么它将夺得处理机。</p>
<p>下面是抢占式版本的相关指标计算：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-4.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-4.png" alt="img"></a></p>
<p><strong>注意：</strong></p>
<p>一般可以认为，SJF 算法的平均等待时间、平均周转时间都是最少的（相比于其它算法），但是更准确地说，其实它的抢占式版本，也即 SRTN 算法，各项指标要比 SJF 算法更低。</p>
<ul>
<li>SJF 算法的优点在于，它拥有“最短的”平均等待时间和平均周转时间</li>
<li>缺点在于，虽然这次顾及了短作业，但是没有顾及长作业，对长作业是不利的。因为一旦短作业源源不断进入，那么它们就会不断跑在长作业前面，导致长作业永远无法运行，产生“饥饿”甚至“饿死”现象。</li>
<li>另外一个缺点是，在实际实现中，要做到真正意义上的短作业优先，具有一定难度</li>
</ul>
<h4 id="③-HRRN-算法"><a href="#③-HRRN-算法" class="headerlink" title="③ HRRN 算法"></a>③ HRRN 算法</h4><p>HRRN 算法即高响应比优先算法，它优先调度响应比高的进程。</p>
<blockquote>
<p>响应比 = （ 等待时间+实际运行时间 ）/ 实际运行时间 = 等待时间 / 实际运行时间 + 1</p>
</blockquote>
<p>可以说它同时综合了 FCFS 算法和 SJF 算法的优点。为什么优先调度响应比高的进程？因为当两个进程的等待时间一样时，响应比越高的进程，它的实际运行时间越短，这一点类似于 SJF 算法，优先顾及运行时间短的进程；而当两个进程的实际运行时间一样时，响应比越高的进程，它的等待时间越长，等待时间越长说明该进程越先到达，这一点类似于 FCFS 算法，优先顾及先到达的进程。</p>
<p>HRRN 是非抢占式的算法，因此只有当前运行进程正常放弃处理机的时候，才会计算哪个进程的响应比高，然后进行调度。</p>
<p>看下面的例子：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-5.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-5.png" alt="img"></a></p>
<p>注意这里“要求服务的时间”就是实际需要运行的时间，等待时间则是从进程到达就绪队列的那一刻起，到发生进程调度这一段所花费的时间。</p>
<p>HRRN 算法的优点是综合考虑了等待时间和实际运行时间，而且也不会导致长作业饥饿的问题（因为长作业等待时间变长之后，它的响应比也会变高，增加了可以被调度的机会）。</p>
<h4 id="④-总结"><a href="#④-总结" class="headerlink" title="④ 总结"></a>④ 总结</h4><p>上面这几种算法主要关注对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但<br>是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此它们<strong>一般适合用于早期的批处理系统</strong>。下面介绍的算法则适合用于交互式系统。</p>
<h3 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h3><h4 id="①-RR算法"><a href="#①-RR算法" class="headerlink" title="① RR算法"></a>① <strong>RR</strong>算法</h4><p>RR 算法即时间片轮转算法。像前面的算法的话，通常都是非抢占式的，也就是说，一个进程正常运行完，另一个进程才有机会被调度，整体呈现出“顺序”的特点；而 RR 算法的特点则在于“公平分配”，按照进程到达就绪队列的顺序，轮流让每个进程执行一个相等长度的时间片，若在自己的时间片内没有执行完，则进程自动进入就绪队列队尾，并调度队头进程运行。整体呈现出“交替”的特点。因为进程即使没运行完也会发生调度，所以这是一个抢占式的算法。</p>
<p>看下面的例子：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-6.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-6.png" alt="img"></a></p>
<p>先来看时间片为2的情况：</p>
<p><strong>0 时刻：</strong>此时就绪队列为 <code>P1(5)</code>，P1 上处理机运行</p>
<p><strong>2 时刻：</strong>P2 到达就绪队列队头，同时 P1 时间片用完，到达就绪队列队尾。此时就绪队列为 <code>P2(4) —— P1(3)</code>，P2 被调度，上处理机运行。</p>
<p><strong>4 时刻：</strong>P3 到达就绪队列队尾，同时 P2 时间片用完，进入就绪队列，紧挨在 P3 后面。此时就绪队列为 <code>P1(3) —— P3(1) ——P2(2)</code>，P1 被调度，上处理机运行。</p>
<p><strong>5 时刻：</strong>P4 到达就绪队列队尾，P1 时间片还没用完，仍然在运行。此时就绪队列为 <code>P3(1) —— P2(2)——P4(6)</code></p>
<p><strong>6 时刻：</strong>P1 时间片用完，进入就绪队列队尾，此时就绪队列为 <code>P3(1) —— P2(2) —— P4(6) —— P1(1)</code>。P3 被调度，上处理机运行。</p>
<p><strong>7 时刻：</strong>虽然 P3 有 2 个单位的时间片可用，但是它实际上只需要用到一个单位，所以 7 时刻的时候它正常运行完，轮到 P2 被调度。此时就绪队列为 <code>P4(6) —— P1(1)</code>。</p>
<p><strong>9 时刻：</strong>P2 时间片用完，同时也正常运行结束。P4 被调度，上处理机运行。此时就绪队列为 <code>P1(1)</code>。</p>
<p><strong>11 时刻：</strong>P4 时间片用完，到达就绪队列队尾。此时就绪队列为 <code>P1(1) —— P4(4)</code>。P1 被调度，上处理机运行。</p>
<p><strong>12 时刻：</strong>在 12 时刻的时候，P1 就已经运行结束。此时再次调度 P4 上处理机运行</p>
<p><strong>14 时刻：</strong>P4 时间片用完，由于就绪队列中没有其它进程可供调度，所以让 P4 接着运行一个时间片</p>
<p><strong>16 时刻：</strong>P4 正常运行结束。</p>
<p>整个过程如下图所示：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-7.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-7.png" alt="img"></a></p>
<p>再来看时间片为 5 的情况：</p>
<p><strong>0 时刻：</strong>此时就绪队列为 <code>P1(5)</code>，P1 上处理机运行</p>
<p><strong>2 时刻：</strong>P2 到达就绪队列队头，P1 仍在运行</p>
<p><strong>4 时刻：</strong>P3 到达就绪队列队尾，P1 仍在运行</p>
<p><strong>5 时刻：</strong>P4 到达就绪队列队尾。P1 正常运行结束，时间片刚好用完。此时就绪队列是 <code>P2(4)——P3(1)——P4(6)</code>，所以 P2 被调度上处理机</p>
<p><strong>9 时刻：</strong>尽管时间片没有用完，但是 P2 正常运行结束，所以 P3 会被调度上处理机</p>
<p><strong>10 时刻：</strong>P3 正常运行结束，同样调度 P4</p>
<p><strong>15 时刻：</strong>P4 时间片用完，但是就绪队列没有可供调度的进程，所以 P4 还得继续运行</p>
<p><strong>16 时刻：</strong>P4 正常运行结束</p>
<p>整个过程如下图所示：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-8.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-8.png" alt="img"></a></p>
<p>这里会发现，效果和使用 FCFS 算法是差不多的。实际上，如果时间片太大，那么 RR 算法会退化成 FCFS 算法，而且会增加进程响应时间，所以时间片应该设置得小一点；另一方面，时间片也不能设置得太小，否则进程切换会过于频繁，导致更多的时间用于切换而不是有效执行进程。</p>
<p>总的来说，RR 算法的优点是公平、响应快，适用于分时操作系统；缺点则是进程切换频率相比其他算法会高一点，因此有一定的开销。另外它不区分任务的紧急程度，再紧急的任务，如果某个运行进程的时间片还没用完，这个任务也不会被调度。</p>
<p>RR 算法不会导致饥饿，因为时间片一到自然就会切换到其它进程，不存在某个进程永远无法被调度的情况。</p>
<h4 id="②-优先级算法"><a href="#②-优先级算法" class="headerlink" title="② 优先级算法"></a>② 优先级算法</h4><p>优先级算法在某种程度上和 HRRN 算法很像，两者可以联系起来进行理解。<strong>前面我们所讲的算法都无法区分进程紧急程度，而优先级算法弥补了这个问题</strong>。它会给每个进程一个优先级，调度时会选择当前已到达并且优先级最高的进程。和 HRRN 算法一样，它也有非抢占式和抢占式两个版本。</p>
<p><strong>先看非抢占式版本：</strong></p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-9.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-9.png" alt="img"></a></p>
<p>这里和 HRRN 算法是很像的，进程会正常运行，直到结束之后才发生调度，在调度的时候会选择队列中优先级最高的进程。</p>
<p><strong>再看抢占式版本：</strong></p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-9.1.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-9.1.png" alt="img"></a></p>
<p>这里同样和 HRRN 算法很像。除了正常运行结束会发生调度之外，每次就绪队列有新的进程到达时还会做一次检查，如果新到达进程优先级高于正在运行进程的优先级，那么新到达进程会抢占处理机。</p>
<p>PS：在优先级算法中，就绪队列可能不止有一个，可以按照不同优先级分成很多种队列。另外还要注意，有的地方规定优先数越小，优先级越高，具体看题目要求。</p>
<p><strong>静态优先级和动态优先级：</strong></p>
<p>优先级还包括静态优先级和动态优先级。上面所讲的属于静态优先级，指的是进程的优先级在它创建的时候就确定了，此后一直不会改变；动态优先级则相对灵活很多，它会根据具体情况动态调整进程的优先级。</p>
<ul>
<li>对于静态优先级，一般认为系统进程优先级要高于用户进程优先级；前台进程优先级高于后台进程优先级；I/O 型进程优先级会比较高。</li>
<li>对于动态优先级，会尽量遵循公平的原则。也就是说，如果某个进程实在等得太久，那么不妨提高它的优先级，让他有机会被调度；反之，如果某个进程占用处理机时间过长，那么就要考虑降低它的优先级，不要让他一直“霸占”处理机了。另外，之前说过 I/O 型进程的优先级会很高，所以如果某个进程频繁进行 I/O 操作，也可以考虑提高它的优先级。</li>
</ul>
<p>总的来说，优先级算法的优点在于区分了各个进程的紧急程度，比较紧急重要的进程会优先得到处理，因此它适用于实时操作系统。另外，由于动态优先级的存在，使得它对进程的调度相对灵活很多。缺点则是，如果源源不断进来了一些高优先级的进程，那么优先级相对较低的进程可能一直无法执行，进而导致饥饿现象的发生。这点和 HRRN 算法也是很像的。（其实也可以把 HRRN 算法看作优先级算法的一种特殊情况，将响应比作为优先级评判的标准）</p>
<h4 id="③-多级反馈队列算法"><a href="#③-多级反馈队列算法" class="headerlink" title="③ 多级反馈队列算法"></a>③ 多级反馈队列算法</h4><p>多级反馈队列算法是对其他调度算法的折中权衡，它的分析过程会复杂很多。下面我们先给定多级反馈队列算法的几个规则，再结合图片文字理一理具体的过程。</p>
<ul>
<li>有多个级别的就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>每次有新进程到达，都会首先进入第一级队列，并按 FCFS 算法被分配时间片。如果时间片用完了而进程还没执行完，那么该进程将被送到下一级队列队尾。如果当前已经是最后一级，则重新放回当前队列队尾</li>
<li>当且仅当上层级别的队列为空时，下一级队列的进程才有机会被调度</li>
<li>关于抢占：如果某个进程运行的时候，比它所在队列级别更高的队列中有新进程到达，则那个新进程会抢占处理机，而当前正在运行的进程会被送到当前队列队尾</li>
</ul>
<p>下面我们结合图片来进行理解。</p>
<p>在 0 时刻，P1 首先到达第一级就绪队列</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-11.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-11.png" alt="img"></a></p>
<p>然后，它被调度，来到了处理机这里</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-12.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-12.png" alt="img"></a></p>
<p>在 1 时刻，P1 时间片已经用完，但是进程还没执行完，所以这时候 P1 “降级”进入第二级就绪队列。同时，P2 作为新进程进入第一级就绪队列</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-13.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-13.png" alt="img"></a></p>
<p>P2 被调度进入处理机</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-14.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-14.png" alt="img"></a></p>
<p>在 2 时刻，P2 时间片已经用完，但是进程还没执行完，所以这时候 P2 也“降级”进入第二级就绪队列</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-15.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-15.png" alt="img"></a></p>
<p>像前面所说的，“当且仅当上层级别的队列为空时，下一级队列的进程才有机会被调度”，此时第一级队列为空，所以开始调度第二级队列的进程。队头进程 P1 进入处理机</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-16.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-16.png" alt="img"></a></p>
<p>在 3 时刻，P1 时间片没用完，所以继续执行；在 4 时刻，P1 时间片用完，进程却还没执行完，所以再次“降级”来到第三级就绪队列。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-17.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-17.png" alt="img"></a></p>
<p>此时，由于 P2 位于优先级更高的队列，所以 P2 被调度，来到处理机</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-18.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-18.png" alt="img"></a></p>
<p>在 5 时刻，P2 时间片还没用完，所以还在正常执行。<strong>但是</strong>，P3 作为新进程到达了第一级就绪队列</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-19.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-19.png" alt="img"></a></p>
<p>根据前面说的，“如果某个进程运行的时候，比它所在队列级别更高的队列中有新进程到达，则那个新进程会抢占处理机，而当前正在运行的进程会被送到当前队列队尾”，所以这时候 P3 抢占了处理机</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-20.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-20.png" alt="img"></a></p>
<p>在 6 时刻，P3 时间片用完，且刚好进程也执行完了，所以这时候没有 P3 什么事了。由于 P2 所在队列优先级更高，所以此时 P2 被调度，来到处理机</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-21.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-21.png" alt="img"></a></p>
<p>在 7 时刻，P2 时间片没用完，所以继续执行；在 8 时刻，P2 时间片用完了，且刚好进程也执行完了，所以这时候没有 P2 什么事了。此时还没完事的就剩下 P1 了，所以 P1 被调度</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-22.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-22.png" alt="img"></a></p>
<p>从 7 时刻被调度，一直到 10 时刻，P1 时间片用完了，但是进程还没执行完（剩下两个单位的时间），根据前面说的，“如果当前已经是最后一级，则重新放回当前队列队尾”，所以 P1 重新被送到第三级队列。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-23.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-23.png" alt="img"></a></p>
<p>P1 作为唯一的进程再次被调度，来到处理机</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-24.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-24.png" alt="img"></a></p>
<p>从 10 时刻被调度到 12 时刻，P1 终于执行完毕</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-25.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-25.png" alt="img"></a></p>
<p><strong>最后再做一下总结：</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>对各类型进程相对公平（FCFS 的优点）：谁先进来，谁就会处于高级队列，优先得到服务</li>
</ul>
</li>
</ul>
<pre><code>- 每个新到达的进程都可以很快就得到响应（RR 的优点）：新到达的进程首先在高级队列，可以很快得到响应



- 短进程只用较少的时间就可完成（SPF 的优点）：不需要经历过多的队列



- 可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（拓展：可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程就可以保持较高优先级）



- 对各类型用户友好。

    对于**终端型用户**来说，他们提交的大多属于较小的交互型作业，系统只要能使这些作业在第一队列所规定的时间片内完成，便可使终端型作业用户都感到满意；对**短批处理作业用户**来说，只需在第一队列中执行一个时间片，或至多在第二和第三队列中各执行一个时间片即可完成；对**长批处理作业用户**来说，只要让作业依次在第 1, 2，…. n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</code></pre>
<ul>
<li>缺点：可能会导致饥饿。若有源源不断的短进程到达第一队列，那么这些进程会持续被调度，使得下面一级的那些进程一直得不到调度，导致饥饿现象的发生。</li>
</ul>
<h4 id="④-总结-1"><a href="#④-总结-1" class="headerlink" title="④ 总结"></a>④ 总结</h4><p>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括<br>分时操作系统、实时操作系统等）更注重<strong>系统的响应时间、公平性、平衡性</strong>等指标。而以上这三种算法恰好也<br>能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。( 比如 UNIX 使用的就是多级反馈<br>队列调度算法）</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>已知有一个两道批处理系统，作业调度采用短作业优先算法，进程调度采用优先级算法（抢占式版本）。如下表所示，有 ABCD 四个作业，作业优先数即为对应进程的优先数，且优先数越小优先级越高。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-000.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6-000.png" alt="img"></a></p>
<p>求：</p>
<p>（1）ABCD 四个作业进入内存的时间和运行结束的时间</p>
<p>（2）平均周转时间</p>
<p>我们前面讨论的都是单道批处理系统，并且实际上没有讨论作业，而是讨论进程。但是本例题是两道作业的批处理系统，既要讨论作业，也要讨论进程。需要注意：</p>
<ul>
<li>只有作业首先被调度到内存中，它对应的进程才可能被处理机调度。进程的调度，考虑优先级。</li>
<li>两道作业批处理系统，一次只能调度两个作业进入内存。作业的调度，考虑运行时长</li>
</ul>
<p><strong>10:00 时刻：</strong>A 作业到达，被调度进入内存，A 进程再被处理机调度运行</p>
<p><strong>10:20 时刻：</strong>B 作业到达，被调度进入内存。因为 B 进程优先级高于 A 进程，所以抢占处理机，B 进程运行</p>
<p><strong>10:30 时刻：</strong>C 作业到达，系统中已有两道作业，C 作业暂时只能在外面等待。B 进程继续执行</p>
<p><strong>10:50 时刻：</strong>B 进程运行结束，系统中少了一道作业。D 作业到达，由于 D 作业运行时长比 C 作业短，所以 D 作业被调度进入内存。由于 D 进程优先级不如 A 进程，A 进程继续运行</p>
<p><strong>11:10 时刻：</strong>A 进程运行结束，系统中少了一道作业。C 作业被调度进入内存，由于 C 进程优先级高于 D 进程，所以 C 进程运行</p>
<p><strong>12:00 时刻：</strong>C 进程运行结束。最后剩下的 D 进程运行。</p>
<p><strong>12:20 时刻：</strong>D 进程运行结束。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统之进程同步和进程互斥</title>
    <url>/posts/cc497cb4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<p>首先还是看这张图，对我们当前正在学习的地方做一个定位：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-5.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-5.png" alt="img"></a></p>
<p>上一篇笔记我们已经讲了进程的相关概念和进程控制的知识，这篇笔记则涉及到了进程同步与进程互斥。</p>
<h1 id="进程同步与进程互斥"><a href="#进程同步与进程互斥" class="headerlink" title="进程同步与进程互斥"></a>进程同步与进程互斥</h1><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p><strong>问题：</strong></p>
<p>在多道批处理系统中，多个进程是并发执行的，而并发执行的进程具有异步性，也就是说，各个进程以各自独立的、不可预知的速度向前推进。这样会带来什么问题呢？如果有 AB 两个进程分别进行读写数据的操作，那么写数据应该发生在读数据之前，而实际上，由于异步性的存在，可能会发生先读后写的情况，而此时由于缓冲区为空，该读数据进程就会被阻塞。</p>
<p><strong>解决方案：</strong></p>
<p>所以，我们要通过<strong>进程同步</strong>来解决此类问题。</p>
<p>与进程同步相关的也就是<strong>直接制约关系</strong>，指的是多个进程一起完成某个任务，这些进程因为合作、因为需要在某些位置上协调他们的工作次序而产生了某些制约关系。</p>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p><strong>问题：</strong></p>
<p>在多道批处理系统中，多个进程是并发执行的，而并发执行的进程不可避免地需要共享一些系统资源（比如内存、打印机、摄像头等）。这样会带来什么问题呢？实际上，有些资源在一个时间段内只允许一个进程使用，诸如各种物理设备、变量、数据、内存缓冲区等，这些称之为<strong>临界资源</strong> —— 也就是说，一方面，并发执行的进程需要共享资源；另一方面，临界资源的访问又必须是互斥地进行（不能同时共享），很显然，这会导致资源访问上的矛盾。</p>
<p><strong>解决方案：</strong></p>
<p>所以，我们要通过<strong>进程互斥</strong>来解决此类问题。</p>
<p>与进程互斥相关的也就是间接制约关系，指的是当 A 进程在访问某个临界资源时，另一个也想要访问该资源的 B 进程就必须等着，直到 A 进程访问结束并释放资源后，B 进程才能去访问。</p>
<p><strong>基本实现逻辑：</strong></p>
<p>为了实现临界资源的互斥访问，可以在逻辑上将一个进程对临界资源的访问过程分为四个部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    extry section;       <span class="comment">// 进入区</span></span><br><span class="line">    critical section;    <span class="comment">// 临界区</span></span><br><span class="line">    exit section;        <span class="comment">// 退出区</span></span><br><span class="line">    remainder section;   <span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>进入区：A 进程想要访问临界资源，首先会在进入区检查是否可以进入，由于此时没有其它进程占用临界资源，所以检查通过，同时它设置了一个 Flag 标志当前自己正在访问临界资源；</li>
<li>临界区：实际访问临界资源的那段代码</li>
<li>退出区：负责解除之前的 Flag</li>
<li>剩余区：其它处理</li>
</ul>
<p>对于 B 进程，如果此时它也想要访问这个资源，同样就会在进入区做一个检查，它知道了 A 进程正在访问，所以自己就不能访问了。这样就实现了资源访问的互斥。</p>
<p><strong>四个原则：</strong></p>
<p>更加具体的细节，我们需要用四个原则来约束这个互斥的过程：</p>
<ul>
<li>空闲让进：临界区空闲时，说明没有进程使用临界资源，此时应该让想要进入临界区的进程立刻进来</li>
<li>忙则等待：如果已经有进程进入临界区，则其它同样想要进入的进程只能等着</li>
<li>有限等待：不能让进程一直干等着，要保证他在有限的时间内可以进入临界区</li>
<li>让权等待：当 A 进程进入临界区而导致 B 进程不能进入自己的临界区时，应该立刻释放处理机，防止进程陷入“忙等”状态。</li>
</ul>
<h1 id="如何实现进程互斥"><a href="#如何实现进程互斥" class="headerlink" title="如何实现进程互斥"></a>如何实现进程互斥</h1><h2 id="软件层面如何实现进程互斥"><a href="#软件层面如何实现进程互斥" class="headerlink" title="软件层面如何实现进程互斥"></a>软件层面如何实现进程互斥</h2><h3 id="①-单标志法："><a href="#①-单标志法：" class="headerlink" title="① 单标志法："></a>① 单标志法：</h3><p>单标志法的核心是用一个 Flag 来标志哪个进程可以进入临界区，在初始给定 Flag 的情况下，一定可以确保是 Flag 对应的进程可以进入临界区。而在该进程顺利进入并完成自己的任务后，它会将 Flag 改指向另一个进程。我们通过一个例子来说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P0 进程：                        P1 进程：</span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);              <span class="keyword">while</span> (turn != <span class="number">1</span>);</span><br><span class="line">critical section;               critical section;</span><br><span class="line">turn = <span class="number">1</span>;                       turn = <span class="number">0</span>;</span><br><span class="line">remainder section;              remainder section;</span><br></pre></td></tr></table></figure>
<p>在一开始我们置 Flag 指向 0 号进程。设想有两种可能：一种是 P0 进程先上处理机，那么此时不满足 while 条件，则顺利进入自己的临界区；另一种是 P1 进程先上处理机，尽管如此，由于满足 while 条件，所以陷入了死循环，一直无法进入临界区，直到消耗完了自己的时间片，轮到了 P0 运行。P0 由于不满足循环条件，所以顺利进入临界区。值得注意的是，在这个过程中，即使由于 P0 消耗完了时间片而导致处理机使用权转让给了 P1，P1 也不会实际进入临界区，而是不断循环 —— 这就确保了整个过程中，即使进程不断来回切换，始终都只有 P0 在使用临界资源，也就是<strong>做到了我们所要的“互斥访问资源”</strong>。</p>
<p>但问题在于，观察整个过程会发现，P0 完成任务后将“使用权限“（Flag）转交给 P1，而 P1 完成后也转交给 P0，所以整个过程一直都是 P0 ——&gt; P1 ——&gt; P0 ——&gt; P1……….. 这样交替进行，也就是说，即使 P0 运行完之后想要再次运行，它也<strong>不得不先等待 P1 的完成</strong>。</p>
<p>另一个问题是，P0 如果一直不访问临界区，那么就算此时临界区空闲、且 P1 有意愿想要访问临界资源，P1 也无法访问，也就是<strong>”空闲不让进“</strong>。这很明显违背了上面所说的”空闲让进“原则。</p>
<h3 id="②-双标志先检查法："><a href="#②-双标志先检查法：" class="headerlink" title="② 双标志先检查法："></a>② 双标志先检查法：</h3><p>双标志法不是用一个 Flag 来指示哪个进程可以进入临界区，而是为每个进程都设置一个可以起到开关作用的 Flag。它的核心是，初始所有的进程 Flag 都为 false，表示暂时都不想进入临界区。某一时刻有个进程想要进入了，他首先会检查当前是否有其他进程正在占用，有的话就作罢，自己慢慢等，没有的话就自己进入，一进入就马上打开 Flag 开关为 true，相当于”上了一把锁“，这期间只有自己拥有占有权，其他进程都是进不来的。在自己完成任务后，再置 Flag 为 false，相当于释放了占有权（把锁打开）。我们通过一个例子来说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool flag[<span class="number">2</span>];</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">P0 进程：                        P1 进程：</span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);                <span class="keyword">while</span> (flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;                 flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;               critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;                flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;              remainder section;</span><br></pre></td></tr></table></figure>
<p>这里的过程还是和之前一样的，即使其它进程被调度，也会陷入死循环而消耗完自己的时间片，所以看起来是可以实现互斥的了。</p>
<p>而且，注意这里单个进程释放”权限“的不同。单标志法的释放”权限”，是把“权限”交给一个指定的进程，这说明了另一个进程想要得到“权限”，必须经过这个进程的同意（所以才有了交替运行的问题）；但是由于双标志法设置的是可以起到开关作用的 Flag，所以所谓释放“权限”不过是放开了自己的权限，其它进程想要进入临界区只管进入就可以，不用非要这个进程进行指定，所以，这个方法不会有交替运行的问题，他在一定程度上做到了解耦。</p>
<p>问题在于，<strong>检查</strong> 与 <strong>上锁</strong> 并不是一个原子操作，它是可以被打断的 —— 这意味着，在检查之后、没来得及上锁之前，如果进程突然切换到 B 进程，那么 B 进程就会在 A 进程“上锁”之前抢先跳过本该陷入的死循环。之后，不管进程有没有再次切换回去，对于 A、B 进程来说，它们都跳过了循环，这意味着它们都可以顺利进入临界区，进而同时使用临界资源。换句话说，双标志先检查法并不能保证互斥访问资源，它违背了“忙则等待”的原则。</p>
<h3 id="③-双标志后检查法"><a href="#③-双标志后检查法" class="headerlink" title="③ 双标志后检查法"></a><strong>③ 双标志后检查法</strong></h3><p>双标志后检查法与先检查法的区别在于，它是先“上锁”后“检查”。也就是说，先检查法的问题在于“上锁”上得太慢，给其他进程可乘之机，所以后检查法决定不管怎么样，先上了锁再说。看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool flag[<span class="number">2</span>];</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">P0 进程：                        P1 进程：</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;                 flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);                <span class="keyword">while</span> (flag[<span class="number">0</span>]);</span><br><span class="line">critical section;               critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;                flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;              remainder section;</span><br></pre></td></tr></table></figure>
<p>后检查法解决了“忙则等待”的问题，但又违背了“空闲让进”和“有限等待”的原则 —— 由于非原子操作而引起的根本问题并未得到解决，因此极有可能导致两个进程都无法进入临界区。</p>
<p>比方说，P0 想要进入临界区，那么他就会抢先“上锁”，而由于“上锁”和“检查”之间有空隙，如果进程 P0 在这段空隙切换到了 P1，那么 P1 也会进行“上锁”。此后，无论进程是否有切换回去，双方都会陷入死循环无法自拔（因为此时双方都拿到了“上锁”的机会，锁死别人，也锁死了自己），进而导致谁都无法进入临界区，产生“饥饿”现象。</p>
<h3 id="④-Peterson-算法"><a href="#④-Peterson-算法" class="headerlink" title="④ Peterson 算法"></a><strong>④ Peterson 算法</strong></h3><p>Peterson 算法实际上同时结合了单标志法和双标志后检查法，它的核心就是：在一开始还是和后检查法一样，抢先进行“上锁”，但是上锁之后又将 turn 置为对方线程，表示自己虽然想要进入临界区，但是不介意“将这个机会让给对方”。尽管如此，由于 while 的限制条件增加了，而 turn 又是公用的，所以保证了最后只会有一方的 while 满足条件。既做到了互斥访问资源，也避免了双方都访问不到资源。</p>
<p>还是来看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool flag[<span class="number">2</span>];  flag[<span class="number">0</span>] = <span class="literal">false</span>;  flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">int turn = <span class="number">0</span>;     </span><br><span class="line"></span><br><span class="line">P0 进程：                        P1 进程：</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;                 flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">1</span>;                       turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);   <span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">critical section;               critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;                flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;              remainder section;</span><br></pre></td></tr></table></figure>
<p>首先进入后检查法的情况，即：P0 首先表示想要进入临界区，因此它的 Flag 为 true，之后进程切换来到了 P1，P1 也表示自己想要进入临界区，因此它的 Flag 也是 true。</p>
<p>在后检查法中，这种情况注定了双方都陷入死循环，谁也无法进入。但是 Peterson 算法却不一样。</p>
<p>在这个算法中，<strong>对方进程想进入、且最后一个做出“谦让”的进程最终将无法进入临界区。</strong>继续上面的例子，此时可能：</p>
<ul>
<li><p>继续执行 <code>turn = 0，while (flag[0] &amp;&amp; turn == 0)</code>，由此进入了死循环，于是时间片用完后来到了 P0，P0 执行 <code>turn = 1，while (flag[1] &amp;&amp; turn == 1)</code>，同样进入了死循环，于是时间片用完后来到了 P1，<strong>注意</strong>，此时对于 P1 来说，它的 while 条件不满足，所以顺利进入了临界区，直到运行完释放“权限”，P0 的才有机会跳出自己的死循环。</p>
<p>  这种情况，由于 P0 是最后一个“谦让”的，所以是对方 P1 进入临界区</p>
</li>
</ul>
<ul>
<li><p>或者，切换到 P0 执行 <code>turn = 1，while (flag[1] &amp;&amp; turn == 1)</code>， 由此进入了死循环，于是时间片用完后来到了 P1，执行 <code>turn = 0，while (flag[0] &amp;&amp; turn == 0)</code>，同样进入了死循环，于是时间片用完后来到了 P0，此时对于 P0 来说，while 条件已经不满足，所以 P0 得以顺利进入临界区。</p>
<p>  这种情况，由于 P1 是最后一个“谦让”的，所以是对方 P0 进入临界区</p>
</li>
</ul>
<ul>
<li>And others ……</li>
</ul>
<p>考虑到进程并发的异步性，其实有很多种排列组合的情况，但是不管哪种情况，可以肯定的是：即使双方都想进入临界区，由于 turn 只有一个，也肯定有一方可以顺利跳出死循环，进入临界区。这就避免了“饥饿”现象的产生；同时，只要自己进程临界区没执行完，就永远不会释放”权限“，意味着对方进程不会乘机抢着进入临界区，这就保证了”互斥“。</p>
<p>用一个生活案例来解释，可能更好理解：</p>
<blockquote>
<p>甲乙两个人同时去图书馆借一本书，甲说：”我很想看这本书，但是你想看的话，我不介意让你先看“，而乙也说：”我也很想看这本书，但是你这么谦让我都不好意思了，还是你先看吧“，双方就这样互相你来我往。到最后甲也累了，于是在听到乙再次说了”让你先看“之后，甲拍了拍乙的肩膀，同时把书拿了过来，说：”好吧，那我先看吧，我看完，你再看。“</p>
</blockquote>
<p>Peterson 算法解决了空闲让进、忙则等待、有限等待的问题，但还是没有解决让权等待的问题。也就是说，P1 进程尽管无法进入临界区，但是在时间片轮到自己的时候还是会做无意义的死循环，白白占用了处理机，而这些资源本该是给 P0 使用的。</p>
<h2 id="硬件层面如何实现进程互斥"><a href="#硬件层面如何实现进程互斥" class="headerlink" title="硬件层面如何实现进程互斥"></a>硬件层面如何实现进程互斥</h2><h3 id="①-中断屏蔽方法"><a href="#①-中断屏蔽方法" class="headerlink" title="① 中断屏蔽方法"></a>① 中断屏蔽方法</h3><p>在双标志方法中，有可能出现两个进程同时进入临界区的情况，而中断屏蔽方法可以很好地避免这种情况。</p>
<p>它和原语的原理很像，一样是通过”开/关中断指令“，来实现原子操作。具体地说，就是让进程在进入临界区之前先<strong>执行关中断指令</strong>”上锁“，保证了此后整个执行过程不会被中断，自然也不会发生进程切换、两个进程同时访问临界资源的情况，在访问完临界区之后，再通过<strong>开中断指令</strong>”解锁“，这样其它进程才有机会访问临界区。</p>
<p>中断屏蔽方法的优点是简单高效，但是它不适用于多处理机，并且由于涉及到了开/关中断这两个特权指令的使用，所以其实这种方法只适用于内核进程，不能用于用户进程。</p>
<h3 id="②-TestandSetLock-指令"><a href="#②-TestandSetLock-指令" class="headerlink" title="② TestandSetLock 指令"></a>② TestandSetLock 指令</h3><p>TestAndSetLock /TestAndSet 指令也叫 TSL/TS 指令。双标志方法的根本问题出在”上锁“和”检查“是非原子操作，导致某个进程可以利用这两个操作的空隙，而 TSL 指令将两个操作变成了原子操作（一气呵成，不留空隙），同时它也做到了像中断屏蔽指令那样，一旦进入临界区，执行过程就无法被中断。</p>
<p>虽然这是硬件操作，不过我们暂且用伪代码来进行理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool TestAndSet (bool *lock)&#123;</span><br><span class="line">    bool old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line">P0:                                        P1:</span><br><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;lock));                 <span class="keyword">while</span> (TestAndSet(&amp;lock));</span><br><span class="line">critical section;                          critical section;</span><br><span class="line">lock = <span class="literal">false</span>;                              lock = <span class="literal">false</span>;</span><br><span class="line">remainder section;                         remainder section;</span><br></pre></td></tr></table></figure>
<p>其中，lock 是全局变量，记录当前临界区是否”上锁“。</p>
<p>首先，进程 P0 想要访问临界区，那么就会来到 while 循环，在这个循环里，它一气呵成完成了”上锁“和”检查“的工作 —— 循环里执行了 TSL 函数，一方面将全局 lock 改为 true，一方面返回旧的值为 false 的 lock 给自己。所以，对自己来说，由于返回的是 false，它得以跳过循环进入临界区；而对 P1 进程来说，每次切换到它这里，它在 while 里企图”上锁“和”检查“的时候，都会由于之前全局 lock 已经被置 true 而陷入死循环。</p>
<p>因此，整个过程就保证了 P0 的”上锁“和”检查“是一气呵成的原子操作，同时也让 P0 执行时绝对不会被切换。在 P0 执行完之后，全局 lock 再次置 false，以此类推。</p>
<p>TSL 指令的方法实现简单，无需严格检查逻辑，也适用于多处理机环境，但是它仍然不满足”让权等待“的原则 —— 从伪代码可以看出，P1 在无法如愿进入临界区后仍然可能白白地占用处理机，导致”忙等“。</p>
<h3 id="③-Wrap-指令"><a href="#③-Wrap-指令" class="headerlink" title="③ Wrap 指令"></a>③ Wrap 指令</h3><p>Swap 指令或称 Exchange / XCHG 指令，它的逻辑其实和 TSL 指令差不多：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">P0:                             P1:</span><br><span class="line">bool old = <span class="literal">true</span>;                bool old = <span class="literal">true</span>;  </span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)             <span class="keyword">while</span> (old == <span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock,&amp;old)  ;                Swap(&amp;lock,&amp;old)  ;  </span><br><span class="line">critical section;               critical section;</span><br><span class="line">lock = <span class="literal">false</span>;                   lock = <span class="literal">false</span>;</span><br><span class="line">remainder section;              remainder section;</span><br></pre></td></tr></table></figure>
<p>一开始全局 lock 还是 false，P0 想要进入临界区，首先置 old 为 true，后面用 Swap 完成交换，所以得以跳出循环进入临界区；而对于 P1 进程，由于它共享全局 lock，全局 lock = 自身 old = true，所以陷入了死循环，无法进入临界区。</p>
<p>和 TSL 指令一样，Swap 指令也无法解决“让权等待”的问题。</p>
<blockquote>
<p>那么，是否有更加完善的方法来解决这个问题呢？</p>
</blockquote>
<p>在上文中，我们介绍到了进程同步和进程互斥，以及用软件层面上的四种方法、硬件层面上的三种方法，分别实现进程互斥。但是这些方法大部分都存在着一些问题：</p>
<ul>
<li>“上锁”与“检查”是非原子操作</li>
<li>都无法做到“让权等待”</li>
</ul>
<p>接下来，我们介绍一种全新的<strong>信号量机制</strong>。</p>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>信号量机制可以让用户通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而方便地实现进程互斥和进程同步。信号量（Semaphore）其实就是一个变量，它可以记录系统中某个资源的数量，而原语指的是 <code>wait(S)</code> 原语和 <code>signal(S)</code> 原语（或者说是 P 操作和 V 操作），可以看作是两个函数。</p>
<h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>信号量如果单纯是一个整数型的变量，那么就称为整型信号量，它的值记录了系统中某种资源的数量。在使用整型信号量的情况下，P 、V 操作是类似这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int S = <span class="number">1</span>;</span><br><span class="line">wait(int S)               </span><br><span class="line">&#123;                       </span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>)            </span><br><span class="line">    S = S-<span class="number">1</span>              </span><br><span class="line">&#125;</span><br><span class="line">signal(int S)</span><br><span class="line">&#123;</span><br><span class="line">    S = S+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样以进程 P0，P1 为例进行说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">P0：                    P1:</span><br><span class="line">wait(S)                wait(S)            <span class="comment">// 进入区</span></span><br><span class="line">critical section       critical section   <span class="comment">// 临界区</span></span><br><span class="line">signal(S)              signal(S)          <span class="comment">// 退出区 </span></span><br></pre></td></tr></table></figure>
<p>假定 P0 想要进入临界区，那么它就会在进入区申请资源：执行 P 操作，进行“检查”和“上锁”，由于 S 一开始是1（表示目前有一个资源可以使用），所以 P0 可以跳过循环，成功申请到资源。此后，S 减一变为 0，代表已经没有可用资源了 —— 这一步也相当于上锁；对于 P1，当他想要申请资源的时候，同样先来到进入区执行 P 操作，由于 S = 0，所以此时 P1 陷入了死循环；再回到 P0 ，他完成任务后会在退出区释放资源，S加一变为 1，这时候 P1 才有机会退出循环，进而申请资源。</p>
<p>整个过程其实和之前介绍的方法是很类似的，但是由于这次，“检查”和“上锁”两个操作被封装在一个原语里，所以这两个操作必定是一气呵成、无法被打断的，这就避免了某个进程钻空子的现象。但是同时我们也发现，在 P0 时间片用完后，P1 仍然会占用处理机进行没有意义的死循环，也就是<strong>仍然违背了“让权等待”的原则</strong>。</p>
<p>于是在此基础上，又出现了记录型信号量</p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>与整型信号量仅用一个单一变量记录可用资源数不同，记录型信号量的数据结构类似于一个结构体，它不仅记录了可用资源数 <code>value</code>，而且还提供了一个等待队列 <code>L</code>。</p>
<p>记录型信号量的思想其实是，如果由于 P0 在使用临界资源而导致 P1 暂时无法使用，那么干脆就不给 P1 陷入循环的机会，<strong>直接让它自己去阻塞队列</strong>，这样 P1 在被唤醒之前，永远无法占用处理机，也自然就不可能出现白白占用处理机的情况。而在 P0 释放资源后，我们才来考虑唤醒 P1。</p>
<p>记录型信号量的结构如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int value</span><br><span class="line">    sturct process *L</span><br><span class="line">&#125; semaphore</span><br></pre></td></tr></table></figure>
<p>同时，记录型信号量的 P、V 操作也有所不同，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wait (semaphore S)&#123;</span><br><span class="line">    S.value--</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        block(S.L)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">signal</span>(<span class="params">semaphore S</span>)</span>&#123;</span><br><span class="line">    S.value++</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        wakeup(S.L)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里要注意的第一个地方是，<code>value</code> 是可用的资源数，当它大于 0 的时候自然是存在可用资源（供大于求），当它小于 0 的时候，则说明不仅无可用资源而且有其他进程等着用（供不应求）。</li>
<li>第二个地方是，在进入区 value 一定会减一，表示申请到了资源，或者表示存在着某个进程有想要申请资源的意愿</li>
</ul>
<p>下面我们用例子来说明记录型信号量工作的过程，为了加深记忆，这里用四个进程来说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PO:            P1              P2           P3</span><br><span class="line">wait(S)        wait(S)         wait(S)      wait(S)</span><br><span class="line">临界区          临界区          临界区        临界区</span><br><span class="line">signal(S)      signal(S)       signal(S)    signal(S)</span><br></pre></td></tr></table></figure>
<p>假设计算机中有两台可用的打印机 A 和 B（也就是说，value = 2），有四个进程需要用到打印机资源。</p>
<p>一开始假定是 P0 先占有处理机，那么 P0 就会在进入区申请资源 。由于 value 一开始是 2，所以 P0 成功申请到资源 A，之后 value 数量减一变为 1，同时来到临界区开始“干活”；在 P0 的时间片完了之后，P1 占有处理机，此时同样申请到资源 B，value 由 1 变为 0，之后来到临界区“干活”。自此，两个打印机都被占用了。</p>
<p>在 P1 的时间片完了之后，P2 占有处理机，value 由 0 变为 -1 &lt; 0，前面我们说过，value &lt; 0 说明无可用资源，所以此时 P2 将自己<strong>主动</strong>送到了阻塞队列。接着来到了 P3，value 由 -1 变为 -2，P3 同样进入阻塞队列。P2，P3 都从运行态转为阻塞态。</p>
<p>处理机又来到 P0，P0 很快执行完了，于是在退出区执行 P 操作释放资源，将 value 加一变为 -1，之后由于通过 if 检测到阻塞队列中有进程等着用资源，所以马上唤醒了队头的 P2 ，P2 从阻塞态回到就绪态，并直接进入临界区开始自己的工作，在完成后同样来到退出区释放资源，value 由 -1 变为 0，但是在 if 中还是检测到了队列中仍然有进程等着用资源，于是马上把队头的 P3 唤醒，P3 回到就绪态，并直接进入临界区开始工作，此后，value 由 0 变为 1，此时 if 不通过，说明队列中再也没有其它进程等着了，该拿到资源的进程都拿到了。自此，P0，P2，P3 都拿到了 A 资源，而 P1 也在不久后完成工作，在退出区释放资源 B，此时 value 从 1 变回最初的 2 ，代表占用的资源已经全数归还。</p>
<p>PS：当然，实际情况还可能是，P2 拿到了 A 资源，P3 拿到了 B 资源，但分析过程也是大同小异的。</p>
<p>显然，记录型信号量与前面介绍的所有方法最大的区别就在于，不会再有进程白白占用处理机进行没有意义的循环 —— 相反地，这些进程非常“老实”地把自己送到了阻塞队列，选择在那里慢慢地等待，等待其它进程完成后将自己唤醒，这种做法“既方便了别人，也方便了自己”。这就正好与我们多次强调的”让权等待“非常契合了。</p>
<blockquote>
<p>记录型信号量明显优于整型信号量，所以在提到 PV 操作的时候，一般默认指的都是记录型信号量。</p>
</blockquote>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>我们通过几道题加深一下印象：</p>
<ul>
<li>n 个并发进程，信号量初始值为 1，当 n 个进程都执行 P 操作后，信号量的值为多少？</li>
<li>信号量初值为 4，多次 PV 操作后变为 -2，那么获得资源的进程数目是多少？</li>
<li>5 个并发进程，信号量初始值为 3，那么信号量取值范围是多少？</li>
</ul>
<p>（1）每执行一次 P 操作，信号量就会减一，所以对于 n 个并发进程，共需要执行 n 次 P 操作，所以此后信号量的值是 1-n</p>
<p>（2）信号量值为 -2，说明有两个进程位于阻塞队列，说明暂无空闲资源可用，换句话说，四个资源都被占用了，所以共有四个进程获得资源</p>
<p>（3）信号量初始值为3，所以最大值为3，如果 5 个进程都执行 P 操作，那么信号量会变成 3-5 = -2，即最小值为 -2，所以取值范围 -2 ~ 3。</p>
<h3 id="信号量机制的应用"><a href="#信号量机制的应用" class="headerlink" title="信号量机制的应用"></a>信号量机制的应用</h3><h4 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h4><p>其实上面讲的例子就已经很好地实现了进程互斥，但是实际上我们可以简化一下写法，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="title">P0</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    P(mutex)</span><br><span class="line">    critical section</span><br><span class="line">    V(mutex)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">P1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    P(mutex)</span><br><span class="line">    critical section</span><br><span class="line">       V(mutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们默认已经定义了 semaphore 的结构体，并用 mutex 变量记录可用资源的个数。要实现互斥，关键就是要<strong>在临界区之前使用 P 操作进行上锁，在临界区之后使用 V 操作进行解锁</strong>。</p>
<h4 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h4><p>在前面，我们一直用大量的篇幅解释进程互斥的实现，那么如何实现进程同步呢？也就是说，多个进程一起完成某项任务的时候，如何确保它们按照一定的先后顺序有秩序地执行呢？</p>
<p>实际上，信号量机制也可以很好地实现进程同步。它的核心是三个关键步骤：</p>
<ul>
<li>设置信号量初始值为 0</li>
<li>在”前操作“之后执行 V(S)</li>
<li>在”后操作“之前执行 P(S)</li>
</ul>
<p>先来解释一下原理，即：为什么这样就可以保证两个操作的前后顺序呢？首先我们先记住一点，<strong>0 是一个非常关键的”分水岭“</strong>，大于 0 的时候不会发生阻塞，小于 0 则会发生阻塞。</p>
<p>我们要确保”前操作“在前面，”后操作“在后面，实际上只要做到三件事：V 在”前操作“后面、P 在”后操作“前面、V 在 P 前面。第一个和第二个条件都是可以通过实际书写代码来做到的，而<strong>要达到第三个条件 —— V 在 P 前面，就有必要让信号量初始值为 0</strong>，因为一旦初始值为 0，则每当 P 想要”违规“抢先于 V 执行的时候，都会由于首先执行信号量自减的操作而导致当前所在进程进入阻塞队列 ，也就是说：</p>
<blockquote>
<p>P 先于 V 执行 ===&gt; P 所在进程会被阻塞 ===&gt; ”后操作“始终无法执行</p>
</blockquote>
<p>所以，在这种情况下，就只能转而执行 V 所在的进程了。在这个进程里，由于 V 在”前操作“后面，所以一定是”前操作“执行完了再去执行 V。而执行 V 就会自增信号量，同时唤醒对方进程，对方进程再去顺序执行 P 操作 —— <strong>虽然此时信号量又自减，但是是在加一的基础上自减，所以并不会导致再次阻塞</strong>，所以 P 执行完后就顺序执行”后操作“。由此，我们确保了两个操作一定是严格按照先后顺序执行的。</p>
<p>来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序应该是：code1,code2,code4</span></span><br><span class="line"></span><br><span class="line">P0：                 P1:</span><br><span class="line">code <span class="number">1</span>               P(S)</span><br><span class="line">code <span class="number">2</span>               code <span class="number">4</span></span><br><span class="line">V(S)                 code <span class="number">5</span></span><br><span class="line">code <span class="number">3</span>               code <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>我们设想比较差的情况 —— P1 拼命想要抢先执行 code 4，看看会发生什么。假设是 P1 首先占用处理机，那么就会执行 P 操作，这个操作使得信号量由 0 变成 -1，进而进入 if 代码块，使得 P1 进程阻塞；这之后，处理机来到 P0，执行 code1，code2，V 操作，使得信号量由 -1 变成 1，同时唤醒 P1 进程；P1 进程使得信号量由 1 变成 0，但是不满足 if 条件，所以不会阻塞自己，而是正常往下执行，来到 code4。以上，整个过程确保了按照 code1，code2，code4 的顺序执行。</p>
<h4 id="信号量实现进程前驱关系"><a href="#信号量实现进程前驱关系" class="headerlink" title="信号量实现进程前驱关系"></a>信号量实现进程前驱关系</h4><p>前面描述的都是两个进程的同步问题，但有时候也可能出现像下图这样多个进程互相依赖、有序运行的情况。其中，code * 语句仍然是前操作或者后操作，P1 进程有 code1 语句，P2 进程有 code2 语句…… 以此类推，这里要求六个进程必须按照箭头所指方向有序运行。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-4.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-4.png" alt="img"></a></p>
<p>其实这种情况就是把多个同步问题结合起来，对于每一对前驱关系来说，都有属于本关系的信号量，所以我们仍然是可以用信号量机制来实现的。代码大概如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">P1:          P2:          P3:          P4:        </span><br><span class="line">code1        P(signal1)   P(signal2)   P(signal3)</span><br><span class="line">V(signal1)   code2        code3        code4 </span><br><span class="line">V(signal2)   V(signal3)   V(signal7)   V(signal5)</span><br><span class="line">             V(signal4)</span><br><span class="line">P5:          P6:         </span><br><span class="line">P(signal4)   P(signal5)   </span><br><span class="line">code5        P(signal6) </span><br><span class="line">V(signal6)   P(signal7)</span><br><span class="line">             code6</span><br></pre></td></tr></table></figure>
<p>可以观察到，除了 P1 进程之外，其它进程首先执行的都是 P 操作，所以一旦这些进程之一首先拿到处理机使用权，都无一例外地会进入阻塞队列。由于情况很多，这里我们试着只分析某一种情况 ——</p>
<p>假设一开始是 P2 占有处理机，那么由于 signal1 初始为 0，导致了 P2 进队列，此后处理机来到 P3，P3 同样进队列……. 以此类推，阻塞队列就会变成：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-5.5.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-5.5.png" alt="img"></a></p>
<p>随后总算来到 P1 进程了，P1 进程作为一切的开始，特殊之处就在于它不是以 P 操作开始的，P1 会首先执行 V(signal1)，这一步把 signal1 加一，同时唤醒 P2 进程，P2 进程进入就绪队列：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-6.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-6.png" alt="img"></a></p>
<p>再之后，P1 执行 V(signal2)，这一步把 signal2 加一，同时唤醒 P3 进程，P3 进程也进入就绪队列。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-7.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-7.png" alt="img"></a></p>
<p>P1 执行完之后，就绪队列队头的 P2 进入运行态，执行到 V(signal3) 的时候，signal3 加一，同时唤醒 P4 进程，P4 进程进入就绪队列，</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-8.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-8.png" alt="img"></a></p>
<p>再之后，P2 执行 V(signal4)，这一步把 signal4 加一，同时唤醒 P5 进程，P5 进程也进入就绪队列。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-9.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-9.png" alt="img"></a></p>
<p>P2 执行完之后，处理机调度就绪队列队头的 P3 开始执行，P3 执行到 V(signal7) 的时候，signal7 加一，<strong>注意这一步没有唤醒任何进程</strong></p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-10.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-10.png" alt="img"></a></p>
<p>P3 执行完之后，处理机调度就绪队列队头的 P4 开始执行，P4 执行到 V(signal5) 的时候，signal5 加一，同时唤醒 P6 进程，P6 进程进入就绪队列</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-11.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-11.png" alt="img"></a></p>
<p>P4 执行完之后，处理机调度就绪队列队头的 P5 开始执行，P5 执行到 V(signal6) 的时候，signal6 加一，<strong>注意这一步没有唤醒任何进程（阻塞队列已经没有进程了）</strong></p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-12.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-12.png" alt="img"></a></p>
<p>P5 执行完之后，处理机调度就绪队列队头的 P6 开始执行，P6 的 signal6 、signal7 在前面已经得到加一操作，所以此时绝对不会在这里卡住，可以顺利执行，直到结束。</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-13.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-13.png" alt="img"></a></p>
<p>这样基本就把整个流程过了一遍，当然，经过排列组合之后，是有很多情况的，但是分析过程都是大同小异的。</p>
<h3 id="信号量集机制"><a href="#信号量集机制" class="headerlink" title="信号量集机制"></a>信号量集机制</h3><p>前面所说的信号量机制都属于多个进程申请同一个资源的情况，如果是多个进程申请多个资源，那么就需要用到<strong>信号量集机制</strong>了。信号量集机制包括 AND 信号量集机制和一般信号量集机制，它的核心是为每一个资源分配一个信号量，在某个进程申请多个资源的时候，<strong>要么全部资源同时都分配给它，要么全部资源一个也不分配给它</strong>。与信号量机制使用的 <code>wait</code> 和 <code>signal</code> 不同，信号量集机制使用的是 <code>Swait</code> 和 <code>Ssignal</code> （S 表示 Simultaneous，同时的），并且在具体实现上的思路也有所不同。</p>
<h4 id="AND-信号量集机制"><a href="#AND-信号量集机制" class="headerlink" title="AND 信号量集机制"></a>AND 信号量集机制</h4><p>AND 信号量集机制的 PV 操作如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Swait(S1,S2,...,Sn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S1&gt;=<span class="number">1</span> &amp;&amp; S2&gt;=<span class="number">1</span> &amp;&amp;...&amp;&amp; Sn&gt;=<span class="number">1</span>)    <span class="comment">// 注意这里是先检查后分配</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) Si--</span><br><span class="line">    <span class="keyword">else</span> block(Si.L)</span><br><span class="line">&#125;</span><br><span class="line">Ssignal(S1,S2,...,Sn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Si++</span><br><span class="line">        wakeup(Si.L)</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有 P0，P1 两个进程，它们都需要在临界区同时用到两个资源 AB，这两个资源 AB 的信号量分别用 S1 = 1，S2 =2 表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PO:               P1:                     </span><br><span class="line">Swait(S1,S2)      Swait(S1,S2)       </span><br><span class="line">临界区             临界区             </span><br><span class="line">Ssignal(S1,S2)    Ssignal(S1,S2)   </span><br></pre></td></tr></table></figure>
<p>一开始处理机来到 P0，if 判断的条件很苛刻，要求必须所有资源都够用才能给 P0 分配所需资源，因为初始信号量分别为 1 和 2 ，所以 P0 同时申请到了资源，来到临界区执行任务；而对于 P1，尽管 B 资源满足 S2 = 1 &gt;= 1，但是 A 资源是不满足条件的，<strong>但凡有一个条件不满足，P1 进程都无法得到任何资源</strong>，所以此时 P1 进程被送到 A 资源对应的阻塞队列。</p>
<p>之后，P0 完成任务后来到退出区，二话不说先把自己占有的资源都释放了，释放 A 资源的时候顺便查看对应的阻塞队列是否有进程在等待，刚好 P1 在阻塞队列，所以这时候把 P1 唤醒，送它到就绪队列；释放 B 资源的时候也查看对应的阻塞队列是否有进程在等待，这时候是没有的。</p>
<p>P0 执行完之后，P1 再从就绪态进入运行态，完成自己的工作。</p>
<h4 id="一般信号量集机制"><a href="#一般信号量集机制" class="headerlink" title="一般信号量集机制"></a>一般信号量集机制</h4><p>一般信号量集机制的 PV 操作如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Swait(S1,t1,d1, S2,t2,d2 ,..., Sn,tn,dn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S1&gt;=t1 &amp;&amp; S2&gt;=t2 &amp;&amp;...&amp;&amp; Sn&gt;=tn)   </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) Si = Si-di</span><br><span class="line">    <span class="keyword">else</span> block(Si.L)</span><br><span class="line">&#125;</span><br><span class="line">Ssignal(S1,d1, S2,d2,..., Sn,dn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Si = Si+di</span><br><span class="line">        wakeup(Si.L)</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不难发现，一般信号量集机制是相对于 AND 信号量集机制来说，更加普遍和一般的机制 ——</p>
<p>从 P0 进程的角度来说，执行 P 操作的时候，不仅要传多个信号量进去，而且每一个信号量还有配套的 t 和 d，分别表示“最小必须满足值”和“分配数目”，也就是说，每一个资源 Si 的数目都必须大于等于对应的 ti，才能将其中的 di 个分配给某个进程；同理，执行 V 操作的时候，也是要传多对 Si，di 进去，让每一种资源都得到一定的释放，同时唤醒对应阻塞队列中的进程。</p>
<p>从 P1 进程的角度来说，可能由于某个资源被分配给 P0 而导致自己对应的 ti 不符合要求，<strong>但凡有一个条件不满足，P1 进程都无法得到任何资源</strong>，所以 P1 进入这个对应资源的阻塞队列，直到后面 P0 释放对应资源并尝试唤醒队列中的进程的时候，P1 才会从阻塞态回到就绪态，进入就绪队列。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在之前，我们已经谈到了很多实现进程互斥的方法，但是这些方法几乎都违背了”让权等待“的原则，于是人们想到通过信号量机制来解决这个问题 —— 其中，真正发挥作用的就是记录型信号量。除了实现进程互斥，信号量机制还能很好地实现进程同步、进程前驱关系，从而近乎完美地解决了异步所带来的问题。之后又补充了信号量集机制，主要用于多个进程请求多个资源的情况，核心是：（为了防止“死锁”）对若干个临界资源的分配采取原子操作方式，要么全部分配到进程，要么一个也不分配。</p>
<h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><p>我们之前已经介绍了通过<strong>信号量机制</strong>解决进程同步和进程互斥问题的原理，不过，在遇到实际问题的时候，信号量机制到底是如何发挥作用的呢？这篇笔记将会从几个经典的问题出发，在解决问题的过程中，我们会体会到信号量机制的运用。</p>
<h2 id="生产者-—-消费者问题"><a href="#生产者-—-消费者问题" class="headerlink" title="生产者 — 消费者问题"></a>生产者 — 消费者问题</h2><p>生产者 — 消费者问题描述的是一个对产品生产和消费的过程：首先，对于生产者，如果缓冲区没满，它就会生产产品并将其放入缓冲区，如果缓冲区已满，它就会进行等待；对于消费者，如果缓冲区不空，它就会取走产品并释放缓冲区，如果缓冲区已空，它就会进行等待。</p>
<p>对于这个问题，不难看出有<strong>两个进程</strong>，一个是生产者进程，一个是消费者进程；同时有<strong>一个互斥关系</strong>，在同一时间内，只能有一个进程访问同一个缓冲区，要么放入产品，要么取走产品；同时有<strong>两个同步关系</strong>，一个指的是：必定是先生产产品，后取走产品，另一个指的是：必定是先释放缓冲区，后使用缓冲区。</p>
<p>因此，我们在这里需要准备两个进程，一个是表示生产者进程的 <code>producer</code>，一个是表示消费者进程的 <code>consumer</code>；同时，我们需要准备三个信号量。第一个信号量是互斥信号量，实现对缓冲区这个资源的互斥访问，用 <code>mutex = 1</code> 表示；第二个信号量是同步信号量，表示空闲缓冲区的数量，用 <code>empty = n</code> 表示；第三个信号量也是同步信号量，表示非空闲缓冲区的数量，也即产品数量，用 <code>full = 0</code> 表示。</p>
<p>先考虑对互斥关系的实现。这里所谓的临界资源其实就是某一个缓冲区，生产者进程把产品放进去，消费者进程从里面取走产品，这两者不能同时进行，所以这里是互斥的关系。我们可以想象到，对每一个进程而言，他都有属于自己的一对 PV 操作，用以实现对缓冲区资源的访问。另外，生产者在进行 PV 操作之前，必定要先生产产品；而消费者在进行 PV 操作之后，必定要使用产品。这时候，初步的伪代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span>(<span class="params"></span>)</span>&#123;                         <span class="function"><span class="title">consumer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                              P(mutex)</span><br><span class="line">        P(mutex)                             从缓冲区中取走产品 </span><br><span class="line">        把产品放入缓冲区                       V(mutex)</span><br><span class="line">        V(mutex)                             使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>
<p>接着考虑第一个同步关系。关注缓冲区，可以知道一定是先释放缓冲区，后使用缓冲区，所以这里“前操作”是释放缓冲区，“后操作”是使用缓冲区，根据上篇笔记所讲的 “前VP后”，我们需要在“前操作”之后针对 empty 这个信号量进行一次 V 操作，需要在“后操作”之前针对 empty 进行一次 P 操作。所以，这时候代码变成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span>(<span class="params"></span>)</span>&#123;                         <span class="function"><span class="title">consumer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                             P(mutex)</span><br><span class="line">        P(empty)                            从缓冲区中取走产品 </span><br><span class="line">        P(mutex)                            V(mutex)</span><br><span class="line">        把产品放入缓冲区                      V(empty)  </span><br><span class="line">        V(mutex)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>
<p>再考虑第二个同步关系。关注产品本身，可以知道一定是先生产产品，后使用产品，更进一步地说，一定是先生产产品并将其放入缓冲区，后从缓冲区取出产品并使用。这里划分出前后两个操作，所以再次安排一对 PV 操作。这时候，代码变成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span>(<span class="params"></span>)</span>&#123;                         <span class="function"><span class="title">consumer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                            P(full)</span><br><span class="line">        P(empty)                           P(mutex)</span><br><span class="line">        P(mutex)                           从缓冲区中取走产品 </span><br><span class="line">        把产品放入缓冲区                     V(mutex) </span><br><span class="line">        V(mutex)                           V(empty)  </span><br><span class="line">        V(full)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>
<p>这个实际上就是最后的代码了。现在我们试着跑一下流程：初始的时候 empty = n，表示所有缓冲区都是空闲的，同时 full = 0，表示一个产品都没生产出来。假如处理机首先来到 consumer 进程，那么就会通过 <code>P(full)</code> 检查是否有产品，这里当然是没有，所以它只能进行等待；处理机来到 producer，首先通过 <code>P(empty)</code> 检查是否有空闲缓冲区，这里当然有，于是它开始把生产的产品放入缓冲区，随后记录产品的数量，这个过程可以反复进行，直到所有缓冲区都被占用了，此时 producer 就会进入等待状态，等待 consumer 进程取出产品、释放缓冲区；当然还有可能的情况是，producer 尚未占用完所有缓冲区，进程就切换到 consumer 了，那么这时候 consumer 因为检查到有产品，所以也会取出产品、释放缓冲区。</p>
<p><strong>这里要注意可能会引起“死锁”现象的一种写法。如下所示：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">producer</span>(<span class="params"></span>)</span>&#123;                         <span class="function"><span class="title">consumer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                           <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产产品                            P(mutex)</span><br><span class="line">        P(mutex)                           P(full)</span><br><span class="line">        P(empty)                           从缓冲区中取走产品 </span><br><span class="line">        把产品放入缓冲区                     V(mutex) </span><br><span class="line">        V(mutex)                           V(empty)  </span><br><span class="line">        V(full)                            使用产品 </span><br><span class="line">    &#125;                                   &#125;     </span><br><span class="line">&#125;                                   &#125;</span><br></pre></td></tr></table></figure>
<p>这个写法的问题在于，还没有先检查缓冲区是否没满或者是否非空，就强行进行互斥的“上锁”。假如还是按照前面的流程，一开始处理机在 consumer 这里，那么 consumer 实际上在没有检查缓冲区是否非空的情况下就直接“上锁”了，这导致它在 <code>P(full)</code> 这一步的时候被卡住，只能等待，而在之后切换到 producer 的时候，正常情况下他应该生产可供对方消费的产品，但是由于对方已经上了锁，所以 producer 在 <code>P(mutex)</code> 这一步也被卡住了，只能进行等待。这也就是说，producer 等待 consumer 释放临界区，而 consumer 等待 producer 使用缓冲区，双方陷入循环等待，造成了“死锁”。</p>
<p>另一种情况，我们也可以设想一开始处理机是在 producer 这里，那么是不是不会导致“死锁”呢？并不是。事实上，按照这种情况正常用完全部缓冲区之后，如果处理机还是在 producer 这里，那么 producer 在检查缓冲区是否已满之前也会将自己提前上锁，在 <code>P(empty)</code> 这一步陷入等待，之后即使进程切换到 consumer 这里，它也会因为对方提前上锁，而导致自己在 <code>P(mutex)</code> 这一步陷入等待。也就是说，这不过是前面那种”死锁“现象的翻版。</p>
<p><strong>总之，关键就在于不管是消费者进程，还是生产者进程，都不能先上锁再检查，否则就有可能发生死锁。</strong></p>
<h2 id="橘子-—-苹果问题"><a href="#橘子-—-苹果问题" class="headerlink" title="橘子 — 苹果问题"></a>橘子 — 苹果问题</h2><p>橘子 — 苹果问题其实是生产者 — 消费者问题的一种变形，它有多种类型的生产者、多种类型的消费者，所以也叫多生产者 — 多消费者问题。它描述的是：有一个只能放一种水果的空盘子，父亲可以放苹果在上面，母亲可以放橘子在上面，女儿只吃父亲的苹果，而儿子只吃母亲的橘子。只有盘子空的时候父母亲才放水果上去，只有盘子中的水果符合自己的喜好时，女儿或者儿子才会去拿。</p>
<p>从上面这个过程，我们可以分析一下有哪些变量。首先可以肯定的是，有<strong>四个进程</strong>，父母亲扮演着生产者，女儿儿子扮演着消费者；同时有<strong>一个互斥关系</strong>，在同一个时间，只能有一个人去“访问”盘子这个资源，所谓“访问”，无非是四种情况：放苹果、放橘子、拿苹果、拿橘子；同时，有<strong>三个同步关系</strong>，第一个指的是，必定是先有父亲放苹果，后有女儿拿苹果。第二个指的是，必定是先有母亲放橘子，后有儿子拿橘子。第三个指的是，必定是先有女儿或者儿子拿走水果，后有父亲或者母亲放上水果。</p>
<p>因此，这里我们准备四个进程：<code>Dad</code>，<code>Mom</code>，<code>Son</code>，<code>Daughter</code>；同时，我们需要准备四个信号量。第一个信号量是互斥信号量，实现对盘子这个资源的互斥访问，用 <code>mutex = 1</code> 表示；第二个信号量是同步信号量，表示盘子中苹果的数量，用 <code>apple = 0</code> 表示；第三个信号量也是同步信号量，表示盘子中橘子的数量，用 <code>orange = 0</code> 表示；第四个同样是同步信号量，表示盘子中还可以放多少水果，用 <code>plate=1</code> 表示。</p>
<p>接下来，我们仿照生产者—消费者问题，对伪代码进行推导。由于四个进程都有对互斥资源的访问，也即都有一个 PV 操作，然后，对父亲而言，在 PV 操作之前自己要先拿出苹果，母亲则是拿出橘子；对女儿而言，在 PV 操作之后要吃掉苹果，儿子则是吃掉橘子。这时候，初步的伪代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Dad</span>(<span class="params"></span>)</span>&#123;                        <span class="function"><span class="title">Mom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        拿出苹果                       拿出橘子</span><br><span class="line">        P(mutex)                      P(mutex) </span><br><span class="line">        把苹果放入盘子                  把橘子放入盘子</span><br><span class="line">        V(mutex)                      V(mutex)</span><br><span class="line">    &#125;                             &#125;     </span><br><span class="line">&#125;                             &#125;</span><br><span class="line"><span class="function"><span class="title">Daughter</span>(<span class="params"></span>)</span>&#123;                   <span class="function"><span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex)                      P(mutex)</span><br><span class="line">        从盘中取出苹果                 从盘中取出橘子 </span><br><span class="line">        V(mutex)                      V(mutex)</span><br><span class="line">        吃掉苹果                      吃掉橘子</span><br><span class="line">    &#125;                             &#125;     </span><br><span class="line">&#125;                             &#125;</span><br></pre></td></tr></table></figure>
<p>再来考虑第一类同步关系，关注盘子，可以看到必定是<strong>先让盘子空出来，后让人使用盘子</strong>，所以这里前后操作就分清楚了，接下来再根据“前VP后”插入代码，此时的伪代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Dad</span>(<span class="params"></span>)</span>&#123;                        <span class="function"><span class="title">Mom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        拿出苹果                       拿出橘子</span><br><span class="line">        P(plate)                      P(plate)  </span><br><span class="line">        P(mutex)                      P(mutex) </span><br><span class="line">        把苹果放入盘子                  把橘子放入盘子</span><br><span class="line">        V(mutex)                      V(mutex)</span><br><span class="line">    &#125;                             &#125;     </span><br><span class="line">&#125;                             &#125;</span><br><span class="line"><span class="function"><span class="title">Daughter</span>(<span class="params"></span>)</span>&#123;                   <span class="function"><span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex)                     P(mutex)</span><br><span class="line">        从盘中取出苹果                 从盘中取出橘子 </span><br><span class="line">        V(mutex)                     V(mutex)</span><br><span class="line">        V(plate)                     V(plate) </span><br><span class="line">        吃掉苹果                      吃掉橘子</span><br><span class="line">    &#125;                             &#125;     </span><br><span class="line">&#125;                             &#125;</span><br></pre></td></tr></table></figure>
<p>最后考虑第二类同步关系，这次关注水果，可以看到必定是<strong>先拿出水果放到盘子上，后取出盘子上的水果吃掉</strong>，根据“前VP后”，最后的伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Dad</span>(<span class="params"></span>)</span>&#123;                        <span class="function"><span class="title">Mom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        拿出苹果                       拿出橘子</span><br><span class="line">        P(plate)                      P(plate)  </span><br><span class="line">        P(mutex)                      P(mutex) </span><br><span class="line">        把苹果放入盘子                  把橘子放入盘子</span><br><span class="line">        V(mutex)                      V(mutex)</span><br><span class="line">        V(apple)                      V(orange)</span><br><span class="line">    &#125;                             &#125;     </span><br><span class="line">&#125;                             &#125;</span><br><span class="line"><span class="function"><span class="title">Daughter</span>(<span class="params"></span>)</span>&#123;                   <span class="function"><span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(apple)                     P(orange)</span><br><span class="line">        P(mutex)                     P(mutex)</span><br><span class="line">        从盘中取出苹果                 从盘中取出橘子 </span><br><span class="line">        V(mutex)                     V(mutex)</span><br><span class="line">        V(plate)                     V(plate) </span><br><span class="line">        吃掉苹果                      吃掉橘子</span><br><span class="line">    &#125;                             &#125;     </span><br><span class="line">&#125;                             &#125;</span><br></pre></td></tr></table></figure>
<p>更进一步地，其实我们这里并不需要互斥变量 <code>mutex</code>，试着把它去掉并跑一下流程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Dad</span>(<span class="params"></span>)</span>&#123;                        <span class="function"><span class="title">Mom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        拿出苹果                       拿出橘子</span><br><span class="line">        P(plate)                      P(plate)  </span><br><span class="line">        把苹果放入盘子                  把橘子放入盘子</span><br><span class="line">        V(apple)                      V(orange)</span><br><span class="line">    &#125;                             &#125;     </span><br><span class="line">&#125;                             &#125;</span><br><span class="line"><span class="function"><span class="title">Daughter</span>(<span class="params"></span>)</span>&#123;                   <span class="function"><span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(apple)                     P(orange)</span><br><span class="line">        从盘中取出苹果                 从盘中取出橘子 </span><br><span class="line">        V(plate)                     V(plate) </span><br><span class="line">        吃掉苹果                      吃掉橘子</span><br><span class="line">    &#125;                             &#125;     </span><br><span class="line">&#125;                             &#125;</span><br></pre></td></tr></table></figure>
<p>在一开始，任何进程都可能先来到处理机，如果是儿子或者女儿，则会因为盘子中暂时没有水果而被堵塞，如果是父母亲，则会按照正常流程放水果上去，我们假设是第一种情况。由于儿子和女儿进程相继被阻塞，所以进程来到父亲这，拿出苹果并放在盘子上。假设这中途因为时间片的缘故被切换到母亲进程，母亲进程由于盘子已经被使用，所以也进入阻塞队列。之后又来到父亲进程，由于它唤醒了女儿进程，女儿进程直接来到就绪队列，并在父亲进程执行完毕之后执行，吃掉苹果。一吃掉苹果，盘子就空了，唤醒了母亲进程，母亲进程放上橘子（这期间即使其它进程进来，也会被阻塞），唤醒了儿子进程，儿子进程就可以吃掉橘子了。</p>
<p>整个过程可能存在各种进程切换的情况，但是无论哪种情况，都可以保证做到进程同步和进程互斥，并且这是在不借助互斥信号量的前提下做到的。基于这个原因，我们在这里可以不使用互斥信号量。</p>
<h2 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h2><p>吸烟者问题其实是生产者 — 消费者问题的另一种变形，它有可以生产多种类型产品的一个生产者，以及多种类型的消费者，所以也叫单生产者 — 多消费者问题。它描述的是：有一个供应者和三个抽烟者，供应者拥有无限的烟草、纸、胶水三种材料，抽烟者1号只有烟草，抽烟者2号只有纸，抽烟者3号只有胶水。每次供应者提供其中两种材料，其中一个抽烟者拿着这两种材料与自己的材料结合进行抽烟，抽完再发送信号给供应者，供应者重新供应材料。整个过程按照三个抽烟者轮流抽烟的顺序循环往复。</p>
<p>从上面这个过程，我们可以分析一下有哪些变量。首先可以肯定的是，有<strong>四个进程</strong>，也就是一个供应者和三个抽烟者；同时有<strong>一个互斥关系</strong>，在同一个时间，只能有一个人去“访问”桌子这个资源（假定材料放在桌子上），所谓访问，无非就是放东西和拿东西两个动作；同时，有<strong>四个同步关系</strong>，第一个指的是，必定是先放材料组合一，后有抽烟者1号拿材料。第二个指的是，必定是先放材料组合二，后有抽烟者2号拿材料。第三个指的是，必定是先放材料组合三，后有抽烟者3号拿材料；第四个指的是，必定是某一个抽烟者先发出信号，后有供应者重新供应材料。</p>
<p>因此，这里我们准备四个进程：<code>Provider</code>，<code>Smoker1</code>，<code>Smoker2</code>，<code>Smoker3</code>；同时，我们准备三个同类信号量，即 <code>offer1</code> 到 <code>offer3</code>，分别表示桌子上某个组合的数量。注意我们这里不准备互斥信号量，因为正如之前的问题提到的，这里即使不引入互斥信号量，也不会影响到我们对于进程互斥和同步的实现。另外，我们再准备一个信号量 <code>finish = 0</code> 表示抽烟是否完成。除了这些，由于题目要求三个抽烟者是轮流抽烟的，所以对于供应者来说，它不能只提供单一材料组合，而要根据索取者的身份选择给定的材料，这里我们还需要再用一个变量 <code>i</code> 记录具体是哪个抽烟者。从 0 到 2，分别表示三个抽烟者。而且在每一次给完材料之后，我们还要改变这个变量的值，好让它指向下一个抽烟者，从而达到“轮流抽烟”的目的。</p>
<p>接下来，我们对伪代码进行推导。由于四个进程都有对互斥资源的访问，也即都有一个 PV 操作，所以初步的伪代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Provider</span>(<span class="params"></span>)</span>&#123;           <span class="function"><span class="title">Smoker1</span>(<span class="params"></span>)</span>&#123;          <span class="function"><span class="title">Smoker2</span>(<span class="params"></span>)</span>&#123;        <span class="function"><span class="title">Smoker3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;           <span class="keyword">while</span>(<span class="number">1</span>)&#123;           <span class="keyword">while</span>(<span class="number">1</span>)&#123;         <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">     P(mutex)            P(mutex)            P(mutex)          P(mutex)</span><br><span class="line">     放组合一             拿走组合一           拿走组合二         拿走组合三</span><br><span class="line">     放组合二             抽烟，发信号         抽烟，发信号        抽烟，发信号  </span><br><span class="line">     放组合三             V(mutex)            V(mutex)          V(mutex)</span><br><span class="line">   &#125;                    &#125;                    &#125;                 &#125;</span><br><span class="line">&#125;                      &#125;                   &#125;                 &#125;</span><br></pre></td></tr></table></figure>
<p>不过，我们前面说了这里不需要互斥信号量，所以把它去掉。并且这里 Provider 的三个操作肯定是要根据抽烟者身份来决定的，所以我们加个 if 判断，以及对于 <code>i</code> 值的修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Provider</span>(<span class="params"></span>)</span>&#123;                     <span class="function"><span class="title">Smoker1</span>(<span class="params"></span>)</span>&#123;          </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;                      <span class="keyword">while</span>(<span class="number">1</span>)&#123;                     </span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;                      拿走组合一           </span><br><span class="line">          放组合一                      抽烟，发信号           </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;             &#125;                   </span><br><span class="line">        放组合二                 &#125;                 </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">        放组合三</span><br><span class="line">      &#125;</span><br><span class="line">      i = (i+<span class="number">1</span>)%<span class="number">3</span>       </span><br><span class="line">  &#125;                  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">Smoker2</span>(<span class="params"></span>)</span>&#123;        <span class="function"><span class="title">Smoker3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;         <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">     拿走组合二         拿走组合三</span><br><span class="line">     抽烟，发信号       抽烟，发信号</span><br><span class="line">   &#125;                 &#125; </span><br><span class="line">&#125;                 &#125;    </span><br></pre></td></tr></table></figure>
<p>按照“前VP后”的原则，必定是先把某个组合放在桌子上，后有某个抽烟者把组合拿走，所以我们考虑在放置组合的语句后面加上 <code>V(offer)</code>，在拿组合的语句前面加上 <code>P(offer)</code>；同理，必定是抽烟者先抽完烟发出信号，后有供应者重新放上材料组合，所以我们考虑在抽完烟的语句后面加上 <code>V(finish)</code>，在放置组合的语句前面加上 <code>P(finish)</code>，所以此时伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Provider</span>(<span class="params"></span>)</span>&#123;                    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;   </span><br><span class="line">      P(finish)  </span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;                     </span><br><span class="line">          放组合一 </span><br><span class="line">        V(offer1)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;             </span><br><span class="line">        放组合二 </span><br><span class="line">        V(offer2)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">        放组合三</span><br><span class="line">        V(offer3)</span><br><span class="line">      &#125;</span><br><span class="line">      i = (i+<span class="number">1</span>)%<span class="number">3</span>       </span><br><span class="line">  &#125;                  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">Smoker1</span>(<span class="params"></span>)</span>&#123;          <span class="function"><span class="title">Smoker2</span>(<span class="params"></span>)</span>&#123;        <span class="function"><span class="title">Smoker3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;           <span class="keyword">while</span>(<span class="number">1</span>)&#123;         <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    P(offer1)           P(offer2)         P(offer3)</span><br><span class="line">    拿走组合一           拿走组合二         拿走组合三</span><br><span class="line">    抽烟，发信号         抽烟，发信号       抽烟，发信号    </span><br><span class="line">    V(finish)           V(finish)         V(finish)</span><br><span class="line">  &#125;                    &#125;                 &#125;</span><br><span class="line">&#125;                   &#125;                 &#125;</span><br></pre></td></tr></table></figure>
<p>不过这样我们会发现，Provider 一上处理机就会被阻塞了，因为马上就遇到了 <code>P(finish)</code>，而此时根本还没有人拿到烟，更不可能抽完烟。事实上，我们想要的效果只是“抽烟者先抽完烟发出信号，供应者后重新供应”，也就是说，在抽烟者发出信号之前，我们要阻止 Provider 到达“重新放置组合”这一步，我们下意识考虑到的是直接在放置组合语句前加上限制条件，但这样会造成阻塞，所以放弃这个方案。那么何不把限制条件放在放置组合语句后面呢？<code>while</code> 本来就是个首尾连接的循环，放置组合语句的尾部其实就是语句的首部，如果我们在尾部给予了限制，而限制条件满足了，那么照样可以实现“阻止进程 Provider 到达放置组合语句”这个效果。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Provider</span>(<span class="params"></span>)</span>&#123;                    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;   </span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;                     </span><br><span class="line">          放组合一 </span><br><span class="line">        V(offer1)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;             </span><br><span class="line">        放组合二 </span><br><span class="line">        V(offer2)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">        放组合三</span><br><span class="line">        V(offer3)</span><br><span class="line">      &#125;</span><br><span class="line">      i = (i+<span class="number">1</span>)%<span class="number">3</span>       </span><br><span class="line">      P(finish)    </span><br><span class="line">  &#125;                  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">Smoker1</span>(<span class="params"></span>)</span>&#123;          <span class="function"><span class="title">Smoker2</span>(<span class="params"></span>)</span>&#123;        <span class="function"><span class="title">Smoker3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;           <span class="keyword">while</span>(<span class="number">1</span>)&#123;         <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    P(offer1)           P(offer2)         P(offer3)</span><br><span class="line">    拿走组合一           拿走组合二         拿走组合三</span><br><span class="line">    抽烟，发信号         抽烟，发信号       抽烟，发信号    </span><br><span class="line">    V(finish)           V(finish)         V(finish)</span><br><span class="line">  &#125;                    &#125;                 &#125;</span><br><span class="line">&#125;                   &#125;                 &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里一定会是抽烟者抽完烟发出信号之后，Provider 才有办法重新放置组合。因为但凡 Provider 想要抢先一步重新放置组合，它都要经过底部 <code>P(finish)</code> 的检查，而这个检查在 Smoker 发出信号之前，不可能轻易通过，因此 Provider 如果想要“强闯”，只会导致自己进入阻塞队列，之后进程切换到 Smoker，Smoker 发出信号，<code>V(finish)</code> 将 Provider 唤醒，Provider 才能重新放置组合，由此就实现了“先发出信号，后重新放置组合”的效果。</p>
<h2 id="读者-—-写者问题"><a href="#读者-—-写者问题" class="headerlink" title="读者 — 写者问题"></a>读者 — 写者问题</h2><p>读者 — 写者问题与我们之前遇到的问题类型不同，它描述的是：有读者和写者两组进程，它们共同访问同一个文件。对于读者，它可以与多个读者共同读取文件（因为不会修改到文件）；对于写者，它不能与其他任何进程共同访问文件（如果另一进程是写，则可能覆盖同一内容；如果是读，则可能修改到要读的内容）。也就是说，这里的互斥问题是读写互斥的问题，但与之前不同的是，除了<strong>实现读写的互斥，我们还要实现读读的“不互斥”。</strong></p>
<p>首先准备一个信号量 <code>rw = 1</code> 表示当前是否有进程在访问文件（注意一开始是没有这样的进程的，1 表示的不是进程数目，仅仅是使用互斥信号量时习惯上给定的初始值，这个看 <code>wait</code> 的代码就能理解了）。</p>
<p>在不考虑“读读不互斥”的情况下，我们的伪代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Writer</span>(<span class="params"></span>)</span>&#123;               <span class="function"><span class="title">Reader</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;             <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw)                P(rw)</span><br><span class="line">        写文件               读文件  </span><br><span class="line">        V(rw)                V(rw)</span><br><span class="line">    &#125;                     &#125;</span><br><span class="line">&#125;                      &#125;</span><br></pre></td></tr></table></figure>
<p>这个代码可以实现读写互斥，但显然无法实现“读读不互斥”，因为每个读进程之间也会受到 <code>rw</code> 的影响，使得最后只能有一个读进程访问文件。于是我们考虑从读进程入手，做一些改进。这里读和读不能同时进行的本质原因在于，所有的读进程都会经历“检查并上锁”这个步骤，而一个读进程进入后就会马上检查并上锁，导致另一个也想要进入的读进程被阻塞，所以我们考虑：能不能不要让所有的读进程都经历“检查并上锁”这一步骤？也就是说，某些进程可以跳过 P 操作，直接进入临界区，这样一来，这些进程就不存在在 P 操作这里被阻塞的可能性。</p>
<p>什么样的进程可以跳过 P 操作呢？就是中间的那些读进程。因为一开始肯定要有读进程上锁、最后肯定要有读进程解锁，所以上锁和解锁的任务交付给第一个和最后一个进程，而中间的那些进程来去自如，只需要负责读文件，不需要参与上锁和解锁。为了区分读进程的次序，我们准备一个 <code>count = 0</code> 的变量，它表示的是当前有多少个读进程正在访问文件。然后在读文件的前后，我们分别对 <code>count</code> 进行加一和减一的操作，每次读文件开始之前 <code>count</code> 会加一，所以<strong>在此之前如果变量为 0 ，说明当前读进程是第一个读进程；同理，每次读文件之后 <code>count</code> 会减一，所以在此之后如果变量为 0 ，说明当前读进程是最后一个读进程；</strong></p>
<p>此时伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Reader</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            P(rw)</span><br><span class="line">        count++</span><br><span class="line">        读文件</span><br><span class="line">        count--</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            V(rw)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样会产生一些问题。比方 1 号读进程首先进入并上锁，然后在 P 操作之后、<code>count</code> 加一变成 1 之前，进程切换到 2 号读进程，那么 2 号读进程就会卡在 P 操作这个地方，陷入阻塞，显然这时候无法实现我们想要的“读读不互斥”；又比方说，1 号读进程在 <code>count</code> 减一变成 0 之后、释放 rw 之前，进程切换到了 2 号读进程，那么 2 号同样又会被卡在 P 操作这里。所以我们还要进行改进。</p>
<p>问题其实就出在，对 <code>count</code> 的检查和赋值不是一个原子操作，这导致的结果是，如果在检查和赋值之间的空隙，进程发生切换，则必然会使得另一进程陷入阻塞。那么能不能让这两个操作一气呵成呢？事实上，可以把 <code>count</code> 当作是一个互斥访问的资源，对 <code>count</code> 的访问是互斥的，也就说明一个时间段内只能有一个读进程去访问它，即使这个过程中切换到了其它进程，那个进程也会被阻塞，从而保证只有一个进程可以访问 <code>count</code>，而这个访问就是检查和赋值，这种情况下，检查和赋值一定是不会被中断的。</p>
<p>准备一个互斥信号量 <code>mutex = 1</code> 表示对 <code>count</code> 的互斥访问，将<strong>检查和赋值封装在一个 PV 操作里</strong>。伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Reader</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex)</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            P(rw)</span><br><span class="line">        count++</span><br><span class="line">        V(mutex)</span><br><span class="line">        读文件</span><br><span class="line"></span><br><span class="line">        P(mutex)</span><br><span class="line">        count--</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            V(rw)</span><br><span class="line">        V(mutex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们再来跑一下过程。假设还是 1 号读进程运行到 P 操作的时候，进程切换到了 2 号读进程，那么由于互斥信号量 <code>mutex</code> 的存在，导致 2 号进程进入了 <code>mutex</code> 对应的阻塞队列 —— 是的，这时候看起来 2 号进程还是被阻塞了，不过我们要关注到的是，**阻塞它的信号量是 <code>mutex</code>，不是 <code>rw</code>**。这意味着，在进程重新切换回 1 号进程的时候，1 号进程一旦执行了 <code>V(mutex)</code>，就可以将 2 号进程唤醒并送到就绪队列了。也就是说，尽管 2 号进程还是经历了“阻塞”这个过程，但是这个过程只是为了确保 1 号进程检查和上锁两个操作的原子性，一旦操作完成，2 号进程马上就被唤醒了。而之前那种情况不同，之前的情况是，导致 2 号进程被阻塞的是信号量 <code>rw</code>，除非 1 号进程读完后释放，否则 2 号进程会一直处于阻塞状态。这就是说，2 号进程永远不可能与 1 号进程同时读文件，但是改进后是可以的。</p>
<p>但随之而来的又是另一个问题， <strong>“读写不公平”</strong>。也就是说，这样的代码本质上是对读进程更有利的。</p>
<p>因为对读进程来说，一旦第一个读进程进来了，中间即使穿插再多的读进程，也都是允许的，他们根本不受到 <code>rw</code> 这个“锁”的限制；而对于写进程，它的运气就没这么好了，写进程只要想进来，就必须通过 <code>rw</code> 这个“锁”，而这个“锁” 实际上又掌握在最后一个读进程手里 —— 这就是说，万一读进程源源不断进来，始终轮不到最后一个读进程解锁，那么写进程就只能陷入无尽的等待了。</p>
<p>既然 <code>rw</code> 这把锁无法做到公正对待每一个进程，那我们就考虑在外层加一把“更大、更公正的锁”。也就是说，所有的进程，无论读还是写，无一例外必须通过这把“锁”的检查。为此，我们准备一个新的互斥信号量 <code>w = 1</code>，并将 Writer 和 Reader 的一些关键操作封装在 <code>w</code> 的一对 PV 操作里。此时，伪代码如下：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-2.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-2.png" alt="img"></a></p>
<p>我们来跑一下流程。假设首先来到 1 号读进程，那么它就会执行 P 操作上锁，这个过程中即使有写进程想进来，也会被送到 <code>w</code> 对应的阻塞队列。在 1 号读进程执行到 V 操作之后，写进程才会被唤醒并送到就绪队列，之后就轮到写进程执行了，而写进程虽然通过第一个 P 操作，但是被卡在了第二个 P 操作（读进程尚未释放 <code>rw</code>），所以他来到了 <code>rw</code> 对应的阻塞队列。</p>
<p>注意！重点来了，如果这时候 2 号读进程也想要访问文件，那么在以前，它是不需要通过任何检查就可以直接来读文件的，并且直到 2 号读进程释放 <code>rw</code> 之后，写进程才能真正来执行写文件的操作。但是现在由于我们加了一把“更大的锁”，导致 2 号进程也必须先通过 <code>w</code> 的检查，而由于写进程抢先在他之前上了锁，所以 2 号读进程被送到了 <code>w</code> 对应的阻塞队列。也就是说，现在的情况是：写进程等着 1 号读进程释放 <code>rw</code>，而 2 号读进程等着写进程释放 <code>w</code>，1 号读进程是让一切正常进行下去的关键。在处理机又来到 1 号读进程并执行 <code>V(rw)</code> 之后，写进程从 <code>rw</code> 的阻塞队列被唤醒，继续往下执行写文件的操作。而在写进程真正执行完之后，<code>w</code> 才能得到释放，由此又唤醒了 <code>w</code> 阻塞队列中的 2 号读进程，2 号读进程来到处理机运行。</p>
<p>如果换一种情况，是按照 写者 — 读者 — 写者的顺序，那么由于读者在第二个写者之前，所以是读者作为阻塞队列队头，第二个写者则次之，在后续执行过程中，根据队列“先进先出”的原则，也会是读者先于第二个写者访问文件。</p>
<p>也就是说，实际上谁先到、谁就在后续过程中先被执行（而不是像之前那种情况，无论写进程先还是后，读进程都可以“无视规则”抢先一步执行）。由此，我们就实现了“读写公平”。</p>
<h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>最后我们再来看哲学家就餐问题。这个问题描述的是：一张圆桌，五个哲学家，五支筷子（每两个哲学家中间会有一支筷子），哲学家要么思考，要么吃饭，吃饭前会拿起左右两边的筷子，吃饭后会放下筷子。如果筷子被其它哲学家拿走，则自己需要等待。我们的目的很简单：<strong>保证所有哲学家都有机会吃上饭，不能让一个或者多个哲学家始终无法吃饭</strong>。</p>
<p>首先，五个哲学家对应了五个进程，然后在同一个时间段内，对于同一支筷子，只能有一个哲学家去使用它，所以筷子是一种临界资源，我们用互斥信号量 <code>chopstick = 1</code> 表示。鉴于这里有五支筷子，所以我们准备一个互斥信号量数组 <code>chopstick[5] = &#123;1,1,1,1,1&#125;</code>。另外，由于任何一个哲学家都只可能拿离自己最近的左右筷子，所以为了加以区分，我们需要给哲学家和筷子进行编号。对于哲学家，从 0 到 4 进行编号，由于哲学家按照圆桌首尾连接，所以某个哲学家左右两边的筷子编号与自己本身的编号相关。以哲学家 <code>i</code> 为例，它左边的筷子编号是 <code>i</code>。右边则是 <code>(i+1)%5</code>，如下图所示：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-4.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-4.png" alt="img"></a></p>
<p>对每一个哲学家进程来说，它都只能拿起左右两边的筷子，并且一定是吃饭前拿筷子，吃饭后放下筷子，所以初步的伪代码是这样的（这里忽略思考的过程）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Pi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(chopstick[i])</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        eat()</span><br><span class="line">        V(chopstick[i])</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果哲学家 0 号拿起左右筷子后，进程切换到哲学家 1 号，那么哲学家 1 号是会被阻塞的，所以这样写可以保证相邻的哲学家中有一个可以吃饭。但是，如果是拿起左筷子，之后进程切换到 1 号，那么 1 号也会拿起自己的左筷子，以此类推，直到 4 号也拿起自己的左筷子。接着，进程来到 0 号，这时候，0 号会发现自己已经没有右筷子可以拿了（作为 1 号的左筷子），于是 0 号被阻塞；同理，1 号也没有右筷子，所以他也被阻塞……以此类推，由于所有的哲学家都只有左筷子，他们的右筷子都在其他人手里，这导致了所有的哲学家都被阻塞，等待着另一个哲学家释放筷子。但实际上，没有任何哲学家能够吃饭，因此没有人可以释放筷子，这使得这些哲学家都陷入无限的等待中，造成“死锁”的发生。</p>
<p>解决这个问题有三个方法。</p>
<p><strong>（1）实现原子操作</strong></p>
<p>很容易想到的是，这里的一个问题在于，拿起左筷子和拿起右筷子并不是一个原子操作，如果在这之间发生了进程切换，那么就可能会像上面那样导致“死锁”的发生。所以我们设想能否将这两个操作一气呵成完成。按照前面问题的思路，第一种做法就是准备一个互斥信号量 <code>mutex = 1</code> ，并把拿筷子的操作封装在一个 PV 操作里。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Pi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex)</span><br><span class="line">        P(chopstick[i])</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        V(mutex)</span><br><span class="line">        eat()</span><br><span class="line">        V(chopstick[i])</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，在 0 号哲学家拿起左筷子之后，即使发生进程切换，来到 1 号进程，1 号进程也会被卡在 <code>mutex</code> 的 P 操作这里。被送往阻塞队列，其它进程也同理。所以最后又来到了 0 号进程，0 号进程顺利拿起了右筷子，之后释放阻塞队列队头的 1 号进程，自己开始吃饭。这种做法保证了有一个哲学家是可以吃饭的，不存在“所有哲学家都无法吃饭”的情况。</p>
<p>另外，这里涉及到了<strong>一个进程需要一次性两个资源才能完成任务</strong>的问题，这时候也可以考虑使用我们之前提到的 AND 信号量集机制。我们回顾一下，AND 信号量集机制的 P 操作是一个相对苛刻的操作，要求一个进程要么拿到全部资源，要么一个资源也拿不到，所以这里可以做到的是：对于初始的那个 0 号进程，他在拿筷子的时候要么左右筷子都拿到，要么一支筷子都拿不到。由于一开始筷子数量足够，所以它在一开始就可以一次性拿到左右筷子。同理，在释放筷子的时候，也是一次性释放两支筷子。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Pi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Swait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">        eat()</span><br><span class="line">        Ssignal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>],chopstick[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们同样可以保证有一个哲学家是可以吃饭的，不存在“所有哲学家都无法吃饭”的情况。</p>
<p><strong>（2）只有四个人可以参与这个过程</strong></p>
<p>我们也可以从另一个角度考虑，之前的情况是五个哲学家，五支筷子，所以很容易出现谁也无法吃饭的情况，但是如果我们规定整个过程最多只有四个哲学家参与，那么即使这四个哲学家每个人都拿走了一支筷子，也还剩下一支筷子可以分配给某个哲学家。换句话说，这样做，我们同样可以让至少一个哲学家吃到饭。</p>
<p>问题在于如何限定“只有最多四个人可以参与这个过程”呢？我们可以准备一个互斥信号量 <code>count</code>，但是这个信号量初值不再是 1 ，而是 4，表示最多允许四个哲学家参与过程。当 <code>count</code> 减少到 -1 的时候，就不能再让哲学家进来了，因此可以保证最多只有四个哲学家。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Pi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(count)</span><br><span class="line">        P(chopstick[i])</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        eat()</span><br><span class="line">        V(chopstick[i])</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])</span><br><span class="line">        V(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来演示前面发生“死锁”的过程。假如一开始还是从 0 号进程开始，在他拿到左筷子之后，进程切换到 1 号进程，由于 <code>count</code> 数量充足，所以它不会阻塞，而是同样拿到了左筷子……以此类推，到了 4 号哲学家的时候，由于 <code>count = -1&lt;0</code>，所以它此时是无法进来的。所以有一支筷子在一开始谁也没拿到，就是 4 号哲学家左边的筷子。而在稍后进程轮到 3 号哲学家的时候，它是可以拿到这支筷子然后去吃饭的。</p>
<p>这只是其中一种情况，但即便是其它情况，也能保证剩下一支暂时没被用到的筷子，而这支筷子也一定会在最后被某个进程拿走。因此得以保证总会存在至少一个进程可以吃到饭。</p>
<p><strong>（3）奇数拿左边，偶数拿右边</strong></p>
<p>还可以考虑对拿筷子的优先顺序进行调整。规定对于奇数哲学家，总是先拿左筷子再拿右筷子；对于偶数哲学家，总是先拿右筷子再拿左筷子。那么 0 号哲学家和 1 号哲学家就会争夺 1 号筷子，而 2 号哲学家和 3 号哲学家就会争夺 3 号筷子。如图所示：</p>
<p><a href="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-3.png"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-3.png" alt="img"></a></p>
<p>伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Pi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 偶数哲学家，先右后左。</span></span><br><span class="line">        &#123;</span><br><span class="line">            P(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">            P(chopstick[i]) ;</span><br><span class="line">            eat();</span><br><span class="line">            V(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">            V(chopstick[i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">//奇数哲学家，先左后右。</span></span><br><span class="line">        &#123;</span><br><span class="line">            P(chopstick[i]) ;</span><br><span class="line">            P(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">            eat();</span><br><span class="line">            V(chopstick[i]) ;</span><br><span class="line">            V(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如一开始还是从 0 号进程开始，很显然 0 号先拿到 1 号筷子，所以在之后切换进程的时候，1 号进程就会直接被阻塞。接着来到 2 号进程，显然他先拿到 3 号筷子，所以之后轮到 3 号进程的时候，3 号进程直接被阻塞。现在考虑轮到 4 号进程，它优先拿到右边的 0 号筷子，之后进程又切换到其它地方。但是，由于先前 3 号进程已经被阻塞，所以在再次轮到 4 号进程的时候，并没有人和他一起争夺 4 号筷子，换言之，4 号进程可以拿到 4 号筷子，再加上之前优先拿到的 0 号筷子，4 号进程现在就可以吃饭了。</p>
<p>值得提醒的是，这仍然只是其中一种情况，类似的排列组合有很多，但是无论是哪一种，在一对进程的争抢中必然有一个进程首先被送到阻塞队列，“被淘汰出局”，因此这个“被淘汰的”进程很难再去影响其它进程，相当于间接提高了其它进程拿到筷子的可能性。就像我们上面的例子一样，一下子“淘汰了” 1 号和 3 号两个进程，并且这两个进程当时并没有带着筷子进入阻塞队列，所以对于其它进程 2 号、4 号、 0 号来说，再次拿到一支筷子的可能性就大大提高了。所以，我们还是能够达到最初的目的，也就是至少让一个哲学家吃上饭。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL基础知识</title>
    <url>/posts/9d61f8d3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<blockquote>
</blockquote>
<a id="more"></a>

<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="一-数据库相关概念"><a href="#一-数据库相关概念" class="headerlink" title="一. 数据库相关概念"></a>一. 数据库相关概念</h2><p>一、数据库的好处</p>
<ol>
<li>可以持久化数据到本地</li>
<li>结构化查询</li>
</ol>
<p>二、数据库的常见概念</p>
<ol>
<li>DB：数据库，存储数据的容器</li>
<li>DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB</li>
<li>SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有主流的数据库软件通用的语言</li>
</ol>
<p>三、数据库存储数据的特点</p>
<ol>
<li>数据存放到表中，表再放到库中</li>
<li>一个库可以由多张表，每张表具有唯一的表名用来标识自己</li>
<li>表中有一个或多个列，列又称为“字段”，相当于java中“属性”</li>
<li>表中每一行数据，相当于java中“对象”</li>
</ol>
<p>四、常见的数据库管理系统<br>            mysql，oracle，db2，sqlserver</p>
<h2 id="二-MySQL"><a href="#二-MySQL" class="headerlink" title="二. MySQL"></a>二. MySQL</h2><p><strong>背景</strong>：前身属于瑞典的一家公司，MySQL AB，08年被sun公司收购，09年被oracle收购</p>
<p><strong>优点</strong>：</p>
<ul>
<li>开源，免费，成本低</li>
<li>性能高，移植性好</li>
<li>体积小，便于安装</li>
</ul>
<p> <strong>安装</strong>：属于c/s架构的软件，一般来讲安装服务端</p>
<p><strong>启动和停止</strong></p>
<ul>
<li>方法一：通过命令行<br>  net start 服务名<br>  net stop 服务名</li>
<li>方法二：计算机管理—-服务</li>
</ul>
<p><strong>登录和退出</strong></p>
<p>登录：mysql -h主机名 -P端口号 -u用户名 -p密码（默认端口3306，用户root）</p>
<p>退出：exit或ctrl+c</p>
<h2 id="三-常见命令和语法规范"><a href="#三-常见命令和语法规范" class="headerlink" title="三. 常见命令和语法规范"></a>三. 常见命令和语法规范</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> database();<span class="operator">/</span><span class="operator">/</span>查看当前所有的数据库</span><br><span class="line">use<span class="operator">+</span>库名;<span class="operator">/</span><span class="operator">/</span>打开指定的库</span><br><span class="line">（只要用了use你就在那个库中了）</span><br><span class="line"><span class="keyword">show</span> tables;<span class="operator">/</span><span class="operator">/</span>查看当前库所有的表</span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">from</span> 库名;<span class="operator">/</span><span class="operator">/</span>查看其他库所有的表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">       列名<span class="number">1</span> 数据类型 约束,</span><br><span class="line">       列名<span class="number">2</span> 数据类型 约束,</span><br><span class="line">       列名<span class="number">3</span> 数据类型 约束</span><br><span class="line">      );<span class="operator">/</span><span class="operator">/</span>创建表</span><br><span class="line"><span class="keyword">desc</span> 表名;<span class="operator">/</span><span class="operator">/</span>查看表的结构</span><br><span class="line">查看服务器的版本：</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql <span class="comment">--version或mysql --</span></span><br></pre></td></tr></table></figure>
<p><strong>mysql的语法规范</strong></p>
<ol>
<li>不区分大小写，但建议关键字大写，表名、列名小写。</li>
<li>每条命令最好用分号结尾。</li>
<li>每条命令根据需要，可以进行缩进，或者换行（建议关键字放一行，要要查询的放一行）。</li>
<li>注释<br> 单行注释：#注释文字<br> 单行注释：– 注释文字（注意空格）<br> 多行注释：/* 注释文字 */</li>
</ol>
<h1 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h1><h3 id="1-进阶一"><a href="#1-进阶一" class="headerlink" title="1.进阶一"></a>1.进阶一</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表 <span class="keyword">from</span> 表名</span><br><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line">#<span class="number">1.</span>查询表中的单个字段</span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>查询表中的多个字段</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,email <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>查询表中所有字段（双击左侧）</span><br><span class="line">#方式一</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  `department_id`,</span><br><span class="line">  `department_name`,</span><br><span class="line">  `manager_id`,</span><br><span class="line">  `location_id` </span><br><span class="line"> <span class="keyword">FROM</span> </span><br><span class="line">  employees;</span><br><span class="line">#方式二</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees ;</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>查询常量值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;john&#x27;</span>;</span><br><span class="line">#（不区分字符和字符串）</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span>查询表达式</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">%</span><span class="number">98</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">6.</span>查询函数</span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"></span><br><span class="line">#<span class="number">7.</span>起别名</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①便于理解</span></span><br><span class="line"><span class="comment">②如果要查询的字段有重名的情况，使用别名可以区分开来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#方式一:用<span class="keyword">as</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">%</span><span class="number">98</span> <span class="keyword">AS</span> 结果;</span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> 姓,first_name <span class="keyword">AS</span> 名 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#方式二:空格</span><br><span class="line"><span class="keyword">SELECT</span> last_name 姓，first_name 名 <span class="keyword">FROM</span> employees;</span><br><span class="line">#案例：查询salary，显示结果为output</span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">AS</span> &quot;out put&quot; <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">8.</span>去重</span><br><span class="line"></span><br><span class="line">#案例：查询员工表涉及到的所有部门编号</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">9.</span> <span class="operator">+</span>号的作用</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java中的+号：</span></span><br><span class="line"><span class="comment">①运算符：两个操作数都为数值型</span></span><br><span class="line"><span class="comment">②连接符：只要有一个操作数为字符串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">mysql中的+号：</span></span><br><span class="line"><span class="comment">仅仅只有一个功能：运算符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">select 100+90；</span></span><br><span class="line"><span class="comment">select &#x27;123&#x27;+90; 其中一方为字符型，会试图将字符型数值转换成数值型</span></span><br><span class="line"><span class="comment">		 如果转换成功则继续加法运算</span></span><br><span class="line"><span class="comment">select &#x27;john&#x27;+90; 如果转换失败，则字符型数组值转换成0；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">select null+10;只要其中一方为null，则结果为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#案例：查询员工名和姓连接成一个字段，并显示为 姓名</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(last_name,first_name) <span class="keyword">AS</span> 姓名 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">10.</span>判断是否为空</span><br><span class="line">#commission_pct是否为空？为空返回<span class="number">0</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	IFNULL(commission_pct,<span class="number">0</span>) <span class="keyword">AS</span> 奖金率,</span><br><span class="line">	commission_pct </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure>
<h3 id="2-进阶二：-条件查询"><a href="#2-进阶二：-条件查询" class="headerlink" title="2. 进阶二： 条件查询"></a>2. 进阶二： 条件查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	<span class="keyword">select</span></span><br><span class="line">		查询列表</span><br><span class="line">	<span class="keyword">from</span></span><br><span class="line">		表名</span><br><span class="line">	<span class="keyword">where</span></span><br><span class="line">		筛选条件;</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">	<span class="number">1.</span>按条件表达式筛选</span><br><span class="line">	</span><br><span class="line">	条件运算符: <span class="operator">&gt;</span> <span class="operator">&lt;</span> <span class="operator">=</span> <span class="operator">!=</span> <span class="operator">&lt;&gt;</span>(不等于) <span class="operator">&gt;=</span> <span class="operator">&lt;=</span></span><br><span class="line">	</span><br><span class="line">	<span class="number">2.</span>按逻辑表达式筛选</span><br><span class="line">	</span><br><span class="line">	逻辑运算符：<span class="operator">&amp;&amp;</span> <span class="operator">||</span> <span class="operator">!</span></span><br><span class="line">		    <span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span></span><br><span class="line">	作用：连接条件表达式</span><br><span class="line">	<span class="number">3.</span>模糊查询</span><br><span class="line">	<span class="keyword">like</span><span class="operator">/</span>regexp</span><br><span class="line">	<span class="keyword">between</span> <span class="keyword">and</span></span><br><span class="line">	<span class="keyword">in</span> </span><br><span class="line">	<span class="keyword">is</span> <span class="keyword">null</span>			   </span><br></pre></td></tr></table></figure>
<h4 id="（1）按条件表达式筛选"><a href="#（1）按条件表达式筛选" class="headerlink" title="（1）按条件表达式筛选"></a>（1）按条件表达式筛选</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">*</span><span class="operator">/</span></span><br><span class="line">#<span class="number">1.</span> 按条件表达式筛选</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：查询工资<span class="operator">&gt;</span><span class="number">12000</span>的员工信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	salary<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line">	</span><br><span class="line">#案例<span class="number">2</span>：查询部门编号不等于<span class="number">90</span>号的员工名和部门编号</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	department_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	department_id<span class="operator">!=</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure>
<h4 id="（2）按逻辑表达式筛选"><a href="#（2）按逻辑表达式筛选" class="headerlink" title="（2）按逻辑表达式筛选"></a>（2）按逻辑表达式筛选</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">2.</span>按逻辑表达式筛选</span><br><span class="line">#案例<span class="number">1</span>：查询工资在<span class="number">10000</span>到<span class="number">20000</span>之间的员工名，工资和奖金</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	salary<span class="operator">&gt;=</span><span class="number">10000</span> <span class="keyword">AND</span> salary<span class="operator">&lt;=</span><span class="number">20000</span>;</span><br><span class="line">	</span><br><span class="line">#案例<span class="number">2</span>：查询部门编号不在<span class="number">90</span><span class="number">-110</span>之间，或者工资高于<span class="number">15000</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	department_id<span class="operator">&lt;</span><span class="number">90</span> <span class="keyword">OR</span> department_id<span class="operator">&gt;</span><span class="number">110</span> <span class="keyword">OR</span> salary<span class="operator">&gt;</span><span class="number">15000</span>;</span><br></pre></td></tr></table></figure>
<h4 id="（3）模糊查询"><a href="#（3）模糊查询" class="headerlink" title="（3）模糊查询"></a>（3）模糊查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">like:</span></span><br><span class="line"><span class="comment">①一般和通配符搭配使用</span></span><br><span class="line"><span class="comment">	通配符：</span></span><br><span class="line"><span class="comment">	% 任意多个字符，包含0个</span></span><br><span class="line"><span class="comment">	_ 任意单个字符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例<span class="number">1</span>：查询员工名中包含字符a的员工信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;	</span><br><span class="line">#<span class="operator">%</span>代表通配符，代表任意个字符</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询员工名中第<span class="number">3</span>个字符为n，第五个字符为l的员工名和工资</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	last_name <span class="keyword">LIKE</span> <span class="string">&#x27;__n_l%&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">#案例<span class="number">3</span>：查询员工名中第二个字符为_的员工名（转义字符）	</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> 	 </span><br><span class="line">	last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_\_%&#x27;</span>;		</span><br><span class="line"></span><br><span class="line"># <span class="keyword">between</span> <span class="keyword">and</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①使用between and可以提高语句的简洁度</span></span><br><span class="line"><span class="comment">②包含临界值</span></span><br><span class="line"><span class="comment">③两个临界值顺序不能调换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#<span class="number">2.</span><span class="keyword">between</span> <span class="keyword">and</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：查询员工编号在<span class="number">100</span>到<span class="number">120</span>之间的员工信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	employee_id <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">120</span>;	</span><br><span class="line">#<span class="number">3.</span><span class="keyword">in</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">含义：用于判断某字段的值是否属于in列表中的某一项</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">	①使用in提高语句简洁度</span></span><br><span class="line"><span class="comment">	②in列表的值类型必须统一或者兼容</span></span><br><span class="line"><span class="comment">	③不支持通配符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例：查询员工的工种编号是 IT_PROT, AD_VP, AD_PRES中的一个的员工名和工种编号</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	job_id<span class="operator">=</span><span class="string">&#x27;IT_PROT&#x27;</span> <span class="keyword">OR</span> job_id<span class="operator">=</span><span class="string">&#x27;AD_VP&#x27;</span> <span class="keyword">OR</span> job_id<span class="operator">=</span><span class="string">&#x27;AD_VP&#x27;</span>;</span><br><span class="line">#<span class="comment">-------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	job_id <span class="keyword">IN</span> (<span class="string">&#x27;IT_PROT&#x27;</span> ,<span class="string">&#x27;AD_VP&#x27;</span> , <span class="string">&#x27;AD_VP&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span> <span class="keyword">is</span> <span class="keyword">null</span>(<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">=或者&lt;&gt;不能用于判断null值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例<span class="number">1</span>：查询没有奖金的员工名和奖金率</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#安全等于  <span class="operator">&lt;=&gt;</span>  <span class="keyword">is</span> <span class="keyword">null</span>可以换成<span class="operator">&lt;=&gt;</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：查询没有奖金的员工名和奖金率</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>;</span><br><span class="line">	</span><br><span class="line">#案例<span class="number">12</span>：查询工资为<span class="number">12000</span>的员工信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	salary <span class="operator">&lt;=&gt;</span> <span class="number">12000</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-进阶三：排序查询"><a href="#3-进阶三：排序查询" class="headerlink" title="3. 进阶三：排序查询"></a>3. 进阶三：排序查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">引入：</span></span><br><span class="line"><span class="comment">	select * from employees;</span></span><br><span class="line"><span class="comment">语法：</span></span><br><span class="line"><span class="comment">	SELECT 查询列表</span></span><br><span class="line"><span class="comment">	from 表</span></span><br><span class="line"><span class="comment">	[where 筛选条件]</span></span><br><span class="line"><span class="comment">	order by 排序列表 [asc|desc]</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">	1、asc代表升序，desc代表降序，默认不写是升序</span></span><br><span class="line"><span class="comment">	2、order by子句中可以支持单个字段、多个字段、表达式、函数、别名</span></span><br><span class="line"><span class="comment">	3、order by子句一般是放在查询语句的最后面，limit子句除外	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：查询员工信息，要求工资从高到低排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询部门编号<span class="operator">&gt;=</span><span class="number">90</span>的员工信息，按入职时间的先后进行排序</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id<span class="operator">&gt;=</span><span class="number">90</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hiredate <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">3</span>：按年薪高低显示员工的信息和年薪[按表达式排序]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">AS</span> 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">4</span>：按年薪高低显示员工的信息和年薪[按别名排序]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">AS</span> 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">5</span>：按姓名的长度显示员工的姓名和工资 [按函数排序]</span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(last_name) <span class="keyword">AS</span> 字节长度, last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> LENGTH(last_name) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">6</span>：查询员工信息，要求先按工资升序，再按员工编号降序 [按多个字段排序]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>,employee_id <span class="keyword">DESC</span>;</span><br><span class="line">#整体按工资排序，工资相同时，按员工编号降序</span><br></pre></td></tr></table></figure>
<h3 id="4-进阶四：常见函数"><a href="#4-进阶四：常见函数" class="headerlink" title="4. 进阶四：常见函数"></a>4. 进阶四：常见函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">概念：类似java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</span></span><br><span class="line"><span class="comment">好处：1、隐藏了实现细节 2、提高代码的重用性</span></span><br><span class="line"><span class="comment">调用：select 函数名(实参列表) [from 表(根据需要)];</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">	①叫什么（函数名）</span></span><br><span class="line"><span class="comment">	②干什么（功能）</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">	1、单行函数（字符函数，数学函数，日期函数，其他函数，流程控制函数）</span></span><br><span class="line"><span class="comment">	如concat、length、ifnull等</span></span><br><span class="line"><span class="comment">	2、分组函数</span></span><br><span class="line"><span class="comment">	功能：做统计使用，又称为统计函数、聚合函数、组函数</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">常见函数：</span></span><br><span class="line"><span class="comment">	字符函数:length  concat substr</span></span><br><span class="line"><span class="comment">	instr trim upper lower</span></span><br><span class="line"><span class="comment">	lpad rpad replace</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	数学函数： round ceil floor truncate mod</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	日期函数：now curdate curtime year month monthname </span></span><br><span class="line"><span class="comment">	day hour minute second str_to_date  date_format</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	其他函数：version database user</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	控制函数: if case</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a>一、字符函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> length 获取参数值的字节个数</span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;john&#x27;</span>);#<span class="number">4</span></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;张三丰hahaha&#x27;</span>);#<span class="number">15</span>，utf8一个汉字占<span class="number">3</span>个字节</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span> concat 拼接字符串（用下划线拼接）</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(last_name,<span class="string">&#x27;_&#x27;</span>,first_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span> upper,lower</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(<span class="string">&#x27;john&#x27;</span>);#变大写</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>(<span class="string">&#x27;JOHN&#x27;</span>);#变小写</span><br><span class="line">#示例：将姓变大写，名变小写，拼接 </span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">UPPER</span>(last_name),<span class="built_in">LOWER</span>(first_name)) <span class="keyword">AS</span> 姓名 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span> substr，substring</span><br><span class="line">#注意索引从<span class="number">1</span>开始，下语句输出:和李四</span><br><span class="line">#截取从指定索引处后面所有字符</span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;张三和李四&#x27;</span>,<span class="number">3</span>) out_put;</span><br><span class="line"></span><br><span class="line">#截取从指定索引处指定字符长度的字符</span><br><span class="line">#下面语句输出：张三</span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;张三和李四&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>) out_put;</span><br><span class="line"></span><br><span class="line">#案例：姓名中首字符大写，其他字符小写，用_拼接，显示出来</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">UPPER</span>(SUBSTR(last_name,<span class="number">1</span>,<span class="number">1</span>)),<span class="string">&#x27;_&#x27;</span>,<span class="built_in">LOWER</span>(SUBSTR(last_name,<span class="number">2</span>))) output</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span> instr</span><br><span class="line">#返回子串的起始索引，找不到返回<span class="number">0</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;杨不悔爱上了殷六侠&#x27;</span>,<span class="string">&#x27;殷六侠&#x27;</span>) <span class="keyword">AS</span> out_put</span><br><span class="line"></span><br><span class="line">#<span class="number">6</span>、trim 去掉首尾的</span><br><span class="line">#输出张翠山</span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="built_in">TRIM</span>(<span class="string">&#x27;    张翠山      &#x27;</span>)) <span class="keyword">AS</span> out_put;</span><br><span class="line">#输出张aaaa翠山</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">FROM</span> <span class="string">&#x27;aaaa张aaaa翠山aaaaaaaa&#x27;</span>) <span class="keyword">AS</span> out_put;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">7</span>、 lpad  用指定的字符实现左填充指定长度</span><br><span class="line">#输出<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>殷素素</span><br><span class="line"><span class="keyword">SELECT</span> LPAD(<span class="string">&#x27;殷素素&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;*&#x27;</span>) <span class="keyword">AS</span> out_put;</span><br><span class="line">#输出：殷素</span><br><span class="line"><span class="keyword">SELECT</span> LPAD(<span class="string">&#x27;殷素素&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;*&#x27;</span>) <span class="keyword">AS</span> out_put;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">8</span>、 rpad  用指定的字符实现右填充指定长度</span><br><span class="line">#输出：殷素素ababababa</span><br><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">&#x27;殷素素&#x27;</span>,<span class="number">12</span>,<span class="string">&#x27;ab&#x27;</span>) <span class="keyword">AS</span> out_put;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">9</span>、replace 替换</span><br><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">&#x27;张无忌爱上了周芷若&#x27;</span>,<span class="string">&#x27;周芷若&#x27;</span>,<span class="string">&#x27;赵敏&#x27;</span>) <span class="keyword">AS</span> out_put;</span><br></pre></td></tr></table></figure>
<h4 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a>二、数学函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#round四舍五入</span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.65</span>);#<span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">-1.45</span>);#<span class="number">-1</span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.567</span>,<span class="number">2</span>);#<span class="number">1.57</span>,小数点后保留<span class="number">2</span>位</span><br><span class="line"></span><br><span class="line">#ceil向上取整(返回<span class="operator">&gt;=</span>该参数的最小整数)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">-1.02</span>);#<span class="number">-1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">1.00</span>);#<span class="number">1</span></span><br><span class="line"></span><br><span class="line">#floor 向下取整，返回<span class="operator">&lt;=</span>该参数的最大整数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">-9.99</span>);#<span class="number">-10</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">truncate</span> 截断</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.65</span>,<span class="number">1</span>);#<span class="number">1.6</span>;</span><br><span class="line"></span><br><span class="line">#mod 取余</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mod(a,b) : a-a/b*b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">mod(-10,-3) : -10-(-10)/(-3)*(-3)=-1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>,<span class="number">-3</span>);#<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a>三、日期函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#now:返回当前系统日期加时间</span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"></span><br><span class="line">#curdate 返回当前系统日期，不包含时间</span><br><span class="line"><span class="keyword">SELECT</span> CURDATE();</span><br><span class="line"></span><br><span class="line">#curtime() 返回当前时间，不包含日期</span><br><span class="line"><span class="keyword">SELECT</span> CURTIME();</span><br><span class="line"></span><br><span class="line">#可以获取指定的部分，年，月，日，小时，分，秒</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW()) <span class="keyword">AS</span> 年;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="string">&#x27;1998-1-1&#x27;</span>) 年;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(hiredate) 年 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW()) 月;</span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(NOW()) 月;#显示英文月份</span><br><span class="line"></span><br><span class="line">#str_to_date 将日期格式的字符转换成指定格式的日期</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">%Y 四位的年份</span></span><br><span class="line"><span class="comment">%y 2位的年份</span></span><br><span class="line"><span class="comment">%m 月份 （01,02，...12）</span></span><br><span class="line"><span class="comment">%c 月份（1,2，..., 12）</span></span><br><span class="line"><span class="comment">%d 日</span></span><br><span class="line"><span class="comment">%H小时（24）%h（12）</span></span><br><span class="line"><span class="comment">%i 分钟  %s秒</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE(<span class="string">&#x27;9-13-1999&#x27;</span>,<span class="string">&#x27;%m-%d-%Y&#x27;</span>) 日期;#<span class="number">1999</span><span class="number">-09</span><span class="number">-13</span></span><br><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE (<span class="string">&#x27;2020-4-17&#x27;</span>,<span class="string">&#x27;%Y-%c-%d&#x27;</span>) <span class="keyword">AS</span> output;#<span class="number">2020</span><span class="number">-4</span><span class="number">-17</span></span><br><span class="line"></span><br><span class="line">#查询入职日期为<span class="number">1992</span><span class="number">-4</span><span class="number">-3</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> hiredate<span class="operator">=</span><span class="string">&#x27;1992-4-3&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> hiredate<span class="operator">=</span>STR_TO_DATE(<span class="string">&#x27;4-3 1992&#x27;</span>,<span class="string">&#x27;%c-%d %Y&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#date_format 将日期转换成字符</span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(NOW(),<span class="string">&#x27;%y年%m月%d日&#x27;</span>) <span class="keyword">AS</span> output;#<span class="number">20</span>年<span class="number">4</span>月<span class="number">17</span>日</span><br><span class="line"></span><br><span class="line">#查询有奖金的员工名和入职日期(xx月<span class="operator">/</span>xx日 xx年)</span><br><span class="line"><span class="keyword">SELECT</span> last_name,DATE_FORMAT(hiredate,<span class="string">&#x27;%m月/%d日 %Y年&#x27;</span>) 入职日期</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> </span><br></pre></td></tr></table></figure>
<h4 id="四、其他函数"><a href="#四、其他函数" class="headerlink" title="四、其他函数"></a>四、其他函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#四、其他函数</span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();#查看当前库</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();<span class="number">123</span></span><br></pre></td></tr></table></figure>
<h4 id="五、流程控制函数"><a href="#五、流程控制函数" class="headerlink" title="五、流程控制函数"></a>五、流程控制函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> if函数：if <span class="keyword">else</span> 的效果</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">10</span><span class="operator">&gt;</span><span class="number">5</span>,<span class="string">&#x27;大&#x27;</span>,<span class="string">&#x27;小&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,commission_pct,IF(commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>,<span class="string">&#x27;没奖金&#x27;</span>,<span class="string">&#x27;有奖金&#x27;</span>) 备注</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span><span class="keyword">case</span>函数的使用一: switch <span class="keyword">case</span>的效果</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case 要判断的字段或表达式</span></span><br><span class="line"><span class="comment">when 常量1 then要显示的值1或语句1;</span></span><br><span class="line"><span class="comment">when 常量2 then要显示的值2或语句2;</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">else 要显示的值n或语句n</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">（搭配select当表达式,then加一个值，或者不搭配select当语句）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*案例：查询员工的工资：要求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">部门号=30，显示的工资为1.1倍</span></span><br><span class="line"><span class="comment">部门号=40，显示的工资为1.2倍</span></span><br><span class="line"><span class="comment">部门号=50，显示的工资为1.3倍</span></span><br><span class="line"><span class="comment">其他部门显示原工资</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> salary,department_id,</span><br><span class="line"><span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">30</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">40</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">50</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.3</span></span><br><span class="line"><span class="keyword">ELSE</span> salary</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 新工资</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span><span class="keyword">case</span>函数的使用二: 类似于多重if</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case  </span></span><br><span class="line"><span class="comment">when 条件1 then 要显示的值1或语句1</span></span><br><span class="line"><span class="comment">when 条件2 then 要显示的值2或语句2</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">else 要显示的值n或语句n</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*与上一种情况的不同就是case后不加表达式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#案例：查询员工的工资情况</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果工资&gt;20000,显示A级别</span></span><br><span class="line"><span class="comment">如果工资&gt;15000,显示B级别</span></span><br><span class="line"><span class="comment">如果工资&gt;10000,显示C级别</span></span><br><span class="line"><span class="comment">否则显示D级别</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> salary,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">20000</span> <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 工资级别</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<h4 id="六、分组函数"><a href="#六、分组函数" class="headerlink" title="六、分组函数"></a>六、分组函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：用作统计使用，又称为聚合函数或统计函数或组函数</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">sum 求和、avg平均值、max、min、count计算个数</span></span><br><span class="line"><span class="comment">特点</span></span><br><span class="line"><span class="comment">1、sum，avg用于处理数值型</span></span><br><span class="line"><span class="comment">max，min，count可以处于任何类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、以上分组函数都忽略null值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、可以和distinct搭配实现去重</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、count函数的单独介绍</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、和分组函数一同查询的字段要求是group by后的字段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="number">1.</span>简单的使用</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) 和,ROUND(<span class="built_in">AVG</span>(salary),<span class="number">2</span>) 平均 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) 最高,<span class="built_in">MIN</span>(salary) 最低 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>参数支持哪些类型</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(last_name),<span class="built_in">AVG</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(hiredate),<span class="built_in">AVG</span>(hiredate) <span class="keyword">FROM</span> employees;</span><br><span class="line"> #无意义，不这样用</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(last_name),<span class="built_in">MIN</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(hiredate),<span class="built_in">MIN</span>(hiredate) <span class="keyword">FROM</span> employees;</span><br><span class="line"> #支持</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(last_name) <span class="keyword">FROM</span> employees;#计算非空的值 <span class="number">107</span></span><br><span class="line"> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(commission_pct) <span class="keyword">FROM</span> employees;#<span class="number">35</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #<span class="number">3</span>、是否忽略<span class="keyword">null</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(commission_pct),<span class="built_in">AVG</span>(commission_pct) <span class="keyword">FROM</span> employees;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #<span class="number">4</span>、和<span class="keyword">distinct</span>搭配</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(<span class="keyword">DISTINCT</span> salary), <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> salary), <span class="built_in">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line">  </span><br><span class="line">  #<span class="number">5</span>、count函数的详细介绍</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;#统计每一列的数目，即所有行数</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees;#和上一语句效果一样</span><br><span class="line">  </span><br><span class="line">  #<span class="number">6</span>、和分组函数一同查询的字段有限制</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),employee_id <span class="keyword">FROM</span> employees;#这个员工id查出来没有意义 </span><br></pre></td></tr></table></figure>
<h3 id="5-进阶五：分组查询"><a href="#5-进阶五：分组查询" class="headerlink" title="5. 进阶五：分组查询"></a>5. 进阶五：分组查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法：</span></span><br><span class="line"><span class="comment">	select 分组函数（max，min这些），列（要求出现在group by后面）</span></span><br><span class="line"><span class="comment">	from 表</span></span><br><span class="line"><span class="comment">	【where 筛选条件】</span></span><br><span class="line"><span class="comment">	group by 分组的列表</span></span><br><span class="line"><span class="comment">	【order by】子句</span></span><br><span class="line"><span class="comment">注意：	查询列表必须特殊，要求是分组函数和group by后出现的字段</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">	1、分组查询中的筛选条件分为两类（筛选的数据源不同</span></span><br><span class="line"><span class="comment">                        数据源           位置		    关键字</span></span><br><span class="line"><span class="comment">	分组前筛选：    原始表	   group by子句前面	    where</span></span><br><span class="line"><span class="comment">	分组后筛选：分组后的结果集   group by子句后面	    having</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	①分组函数做条件，肯定是放在having子句中</span></span><br><span class="line"><span class="comment">	②能用分组前筛选的，优先考虑用分组前筛选</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	2、group by子句支持单个字段分组，多个字段分组，</span></span><br><span class="line"><span class="comment">	（多个字段之间用逗号隔开无顺序要求），表达式或函数（用的较少）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	3、可添加排序（放在group by后）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#简单的分组查询</span><br><span class="line">#案例<span class="number">1</span>：查询每个工种的最高工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary),job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询每个位置上的部门个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),location_id</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> location_id;</span><br><span class="line"></span><br><span class="line">#添加分组前筛选条件</span><br><span class="line">#案例<span class="number">1</span>：查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询有奖金的每个领导手下员工的最高工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary),manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br><span class="line"></span><br><span class="line">#添加分组后的筛选条件</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：查询哪个部门的员工个数大于<span class="number">2</span></span><br><span class="line"></span><br><span class="line">#①查询每个部门的员工个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line">#②根据<span class="number">1</span>的结果进行筛选</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询每个工种有奖金的员工的最高工资<span class="operator">&gt;</span><span class="number">12000</span>的 工种编号和其最高工资</span><br><span class="line"></span><br><span class="line">#①查询每个工种有奖金的员工的最高工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary),job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id;</span><br><span class="line">#②根据<span class="number">1</span>的结果继续筛选，最高工资<span class="operator">&gt;</span><span class="number">12000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary),job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例<span class="number">3</span>：查询领导编号<span class="operator">&gt;</span><span class="number">102</span>的每个领导手下的最低工资<span class="operator">&gt;</span><span class="number">5000</span>的领导编号</span><br><span class="line">#①查询领导编号<span class="operator">&gt;</span><span class="number">102</span>的每个领导手下的最低工资</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary),manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id<span class="operator">&gt;</span><span class="number">102</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br><span class="line"></span><br><span class="line">#②在<span class="number">1</span>的基础上，最低工资<span class="operator">&gt;</span><span class="number">5000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary),manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id<span class="operator">&gt;</span><span class="number">102</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary)<span class="operator">&gt;</span><span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#按表达式或函数分组</span><br><span class="line">#案例：按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数<span class="operator">&gt;</span><span class="number">5</span>的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),LENGTH(last_name) len_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> len_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">#按多个字段分组</span><br><span class="line">#案例：查询每个部门每个工种的员工的平均工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),department_id,job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id,job_id;</span><br><span class="line"></span><br><span class="line">#添加排序</span><br><span class="line">##案例：查询每个部门每个工种的员工的平均工资,并将<span class="operator">&gt;</span><span class="number">10000</span>的按高低排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) a,department_id,job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id,job_id</span><br><span class="line"><span class="keyword">HAVING</span> a<span class="operator">&gt;</span><span class="number">10000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(salary) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-进阶六：连接查询"><a href="#6-进阶六：连接查询" class="headerlink" title="6. 进阶六：连接查询"></a>6. 进阶六：连接查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">含义：又称多表查询，当查询的字段来自多个表，就会用到连接查询</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">笛卡尔乘积现象：表1有m行，表2有n行，结果=m*n行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">发生原因：没有有效的连接条件</span></span><br><span class="line"><span class="comment">如何避免：添加有效的连接条件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">	按年代分类：</span></span><br><span class="line"><span class="comment">	sql92标准：仅仅支持内连接</span></span><br><span class="line"><span class="comment">	sql99标准【推荐】：支持内连接+外连接（左外，右外）+交叉连接</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	按功能分类：</span></span><br><span class="line"><span class="comment">	内连接：等值连接，非等值连接，自连接</span></span><br><span class="line"><span class="comment">	外连接：左外连接，右外连接，全外连接</span></span><br><span class="line"><span class="comment">	交叉连接</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> beauty;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> boys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NAME,boyName <span class="keyword">FROM</span> boys,beauty</span><br><span class="line"><span class="keyword">WHERE</span> beauty.boyfriend_id<span class="operator">=</span>boys.id;</span><br></pre></td></tr></table></figure>
<h4 id="（1-sql92标准"><a href="#（1-sql92标准" class="headerlink" title="（1) sql92标准"></a>（1) sql92标准</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、等值连接</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①多表等值连接的结果为多表的交集部分</span></span><br><span class="line"><span class="comment">②n表连接，至少需要n-1个连接条件</span></span><br><span class="line"><span class="comment">③多表的顺序无要求</span></span><br><span class="line"><span class="comment">④一般需要为表起别名</span></span><br><span class="line"><span class="comment">⑤可以搭配前面介绍的所有查询子句使用，比如排序，分组，筛选</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例<span class="number">1</span>：查询女神名和对应的男神名</span><br><span class="line"><span class="keyword">SELECT</span> NAME,boyName</span><br><span class="line"><span class="keyword">FROM</span> boys,beauty</span><br><span class="line"><span class="keyword">WHERE</span> beauty.boyfriend_id<span class="operator">=</span>boys.id;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询员工名和对应的部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id<span class="operator">=</span>departments.department_id;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、为表起别名</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①提高语句简洁度</span></span><br><span class="line"><span class="comment">②区分多个重名的字段</span></span><br><span class="line"><span class="comment">③如果为表起了别名，则查询的字段就不能用原来的表名去限定，只能用别名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#查询员工名、工种号、工种名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,e.job_id,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e,jobs <span class="keyword">AS</span> j #执行顺序是这句先</span><br><span class="line"><span class="keyword">WHERE</span> e.job_id<span class="operator">=</span>j.`job_id`;</span><br><span class="line"></span><br><span class="line">#两个表的顺序可以调换</span><br><span class="line"><span class="keyword">SELECT</span> last_name,e.job_id,j.job_title</span><br><span class="line"><span class="keyword">FROM</span> jobs <span class="keyword">AS</span> j,employees <span class="keyword">AS</span> e </span><br><span class="line"><span class="keyword">WHERE</span> e.job_id<span class="operator">=</span>j.`job_id`;</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、可以加筛选</span><br><span class="line">#案例：查询有奖金的员工名、部门名</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,commission_pct</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`commission_pct` <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询出城市名中第二个字符为o的部门名和城市名</span><br><span class="line"><span class="keyword">SELECT</span> department_name,city</span><br><span class="line"><span class="keyword">FROM</span> departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> d.`location_id`<span class="operator">=</span>l.`location_id`</span><br><span class="line"><span class="keyword">AND</span> city <span class="keyword">LIKE</span> <span class="string">&#x27;_o%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">5</span>、加分组</span><br><span class="line">#案例<span class="number">1</span>：查询每个城市的部门个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) 个数,city</span><br><span class="line"><span class="keyword">FROM</span> departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> d.`location_id`<span class="operator">=</span>l.`location_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> city;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询有奖金的每个部门的部门名和部门的领导编号，和该部门的最低工资</span><br><span class="line"><span class="keyword">SELECT</span> department_name,d.manager_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> departments d,employees e</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id`<span class="operator">=</span>e.`department_id`</span><br><span class="line"><span class="keyword">AND</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name;</span><br><span class="line"></span><br><span class="line">#<span class="number">6</span>、加排序</span><br><span class="line">#案例：查询每个工种的工种名和员工个数，按员工个数降序</span><br><span class="line"><span class="keyword">SELECT</span> job_title,<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees e,jobs j</span><br><span class="line"><span class="keyword">WHERE</span> e.`job_id`<span class="operator">=</span>j.`job_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_title</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">7</span>、实现三表连接</span><br><span class="line">#案例：查询员工名、部门名和所在的城市</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,city</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> d.`location_id`<span class="operator">=</span>l.`location_id`;</span><br><span class="line"></span><br><span class="line">###########################################################</span><br><span class="line">#<span class="number">2</span>、非等值连接</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：查询员工的工资和工资级别</span><br><span class="line">#创建工资级别</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> job_grades</span><br><span class="line">(grade_level <span class="type">VARCHAR</span>(<span class="number">3</span>),</span><br><span class="line">lowest_sal <span class="type">INT</span>,</span><br><span class="line">highest_sal <span class="type">INT</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> job_grades</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>,<span class="number">1000</span>,<span class="number">2999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> job_grades</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;B&#x27;</span>,<span class="number">3000</span>,<span class="number">5999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> job_grades</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;C&#x27;</span>,<span class="number">6000</span>,<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> job_grades</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;D&#x27;</span>,<span class="number">10000</span>,<span class="number">14999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> job_grades</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;E&#x27;</span>,<span class="number">15000</span>,<span class="number">24999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> job_grades</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;F&#x27;</span>,<span class="number">25000</span>,<span class="number">40000</span>);</span><br><span class="line">#############</span><br><span class="line">#查询员工的工资和工资级别</span><br><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades g</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> g.`lowest_sal` <span class="keyword">AND</span> g.`highest_sal`;</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、自连接</span><br><span class="line"></span><br><span class="line">#案例：查询员工名和上级的名称</span><br><span class="line"><span class="keyword">SELECT</span> e.employee_id,e.last_name,m.employee_id,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,employees m</span><br><span class="line"><span class="keyword">WHERE</span> e.`manager_id`<span class="operator">=</span>m.`employee_id`;</span><br></pre></td></tr></table></figure>
<h4 id="（2-sql99标准"><a href="#（2-sql99标准" class="headerlink" title="（2) sql99标准"></a>（2) sql99标准</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#二、sql99标准</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">	<span class="keyword">select</span> 查询列表</span><br><span class="line">	<span class="keyword">from</span> 表<span class="number">1</span> 别名 【连接类型】</span><br><span class="line">	<span class="keyword">join</span> 表<span class="number">2</span> 别名 <span class="keyword">on</span> 【连接条件】</span><br><span class="line">	<span class="keyword">on</span> 连接条件</span><br><span class="line">	【<span class="keyword">where</span> 筛选条件】</span><br><span class="line">	【<span class="keyword">group</span> <span class="keyword">by</span> 分组】</span><br><span class="line">	【<span class="keyword">having</span> 筛选条件】</span><br><span class="line">	【<span class="keyword">order</span> <span class="keyword">by</span> 排序列表】</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">内连接：<span class="keyword">inner</span></span><br><span class="line">外连接：左外 <span class="keyword">left</span> 【<span class="keyword">outer</span>】</span><br><span class="line">	右外 <span class="keyword">right</span> 【<span class="keyword">outer</span>】</span><br><span class="line">	全外 <span class="keyword">full</span> 【<span class="keyword">outer</span>】</span><br><span class="line">交叉连接：<span class="keyword">cross</span></span><br><span class="line">#一）内连接</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法：</span></span><br><span class="line"><span class="comment">select 查询列表</span></span><br><span class="line"><span class="comment">from 表1 别名</span></span><br><span class="line"><span class="comment">inner join 表2 别名</span></span><br><span class="line"><span class="comment">on 连接条件；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">等值</span></span><br><span class="line"><span class="comment">非等值</span></span><br><span class="line"><span class="comment">自连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">①添加排序、分组、筛选</span></span><br><span class="line"><span class="comment">②inner可以省略</span></span><br><span class="line"><span class="comment">③筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读</span></span><br><span class="line"><span class="comment">④inner join连接和sql92语法中的等值连接效果一样，都是查询多表的交集</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>、等值连接</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span> 查询员工名，部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.department_id<span class="operator">=</span>d.`department_id`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询名字中包含e的员工名和工种名（添加筛选）</span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs j</span><br><span class="line"><span class="keyword">ON</span> e.`job_id`<span class="operator">=</span>j.`job_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`last_name` <span class="keyword">LIKE</span> <span class="string">&#x27;%e%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">3</span>：查询部门个数<span class="operator">&gt;</span><span class="number">3</span>的城市名和部门个数（添加分组<span class="operator">+</span>筛选）</span><br><span class="line"><span class="keyword">SELECT</span> city,<span class="built_in">COUNT</span>(<span class="operator">*</span>) 部门个数</span><br><span class="line"><span class="keyword">FROM</span> locations l</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> d.`location_id`<span class="operator">=</span>l.`location_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> city</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">4</span>：查询哪个部门的部门员工个数<span class="operator">&gt;</span><span class="number">3</span>的部门名，和员工个数，并按个数进行降序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">5</span>：查询员工名、部门名、工种名，并按部门名降序（三表连接）</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs j</span><br><span class="line"><span class="keyword">ON</span> e.`job_id`<span class="operator">=</span>j.`job_id`</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_name <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、非等值连接</span><br><span class="line">#查询员工的工资级别</span><br><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> e.`salary` <span class="keyword">BETWEEN</span> g.`lowest_sal` <span class="keyword">AND</span> g.`highest_sal`;</span><br><span class="line"></span><br><span class="line">#查询工资的个数<span class="operator">&gt;</span><span class="number">20</span>的级别个数，并且按工资级别降序</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> e.`salary` <span class="keyword">BETWEEN</span> g.`lowest_sal` <span class="keyword">AND</span> g.`highest_sal`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade_level</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">20</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> grade_level <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、自连接</span><br><span class="line">#查询员工的名字，上级的名字</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m</span><br><span class="line"><span class="keyword">ON</span> e.`manager_id`<span class="operator">=</span>m.`employee_id`;</span><br><span class="line"></span><br><span class="line">#加筛选：姓名中包含字符k的员工名字、上级名字</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m</span><br><span class="line"><span class="keyword">ON</span> e.`manager_id`<span class="operator">=</span>m.`employee_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`last_name` <span class="keyword">LIKE</span> <span class="string">&#x27;%k%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#二）外连接</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">应用场景：用于查找一个表中有，另一个表中没有的记录</span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">1、外连接的查询结果为主表中所有的记录</span></span><br><span class="line"><span class="comment">   如果从表中有和它匹配的，则显示匹配的值</span></span><br><span class="line"><span class="comment">   如果从表中没有和它匹配的，则显示null</span></span><br><span class="line"><span class="comment">   外连接查询结果=内连接结果+主表中有而从表中没有的记录</span></span><br><span class="line"><span class="comment">2、左外连接：left jon左边的是主表</span></span><br><span class="line"><span class="comment">   右外连接：right join右边的是主表</span></span><br><span class="line"><span class="comment">3、左外和右外交换两个表的顺序，可以实现同样的效果</span></span><br><span class="line"><span class="comment">4、全外连接=内连接结果+表1有但表2没有+表2有但表1没有</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#引入：查询男朋友不在男生表的女生名</span><br><span class="line">#左外连接</span><br><span class="line"><span class="keyword">SELECT</span> be.name,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> beauty be</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> be.boyfriend_id<span class="operator">=</span>bo.id</span><br><span class="line"><span class="keyword">WHERE</span> bo.`id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#右外连接</span><br><span class="line"><span class="keyword">SELECT</span> be.name,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> be.boyfriend_id<span class="operator">=</span>bo.id</span><br><span class="line"><span class="keyword">WHERE</span> bo.`id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：查询哪个部门没有员工</span><br><span class="line">#左外</span><br><span class="line"><span class="keyword">SELECT</span> d.<span class="operator">*</span>,e.employee_id</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.`department_id`<span class="operator">=</span>e.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`employee_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#右外</span><br><span class="line"><span class="keyword">SELECT</span> d.<span class="operator">*</span>,e.employee_id</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> d.`department_id`<span class="operator">=</span>e.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`employee_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#三）交叉连接（笛卡尔乘积）</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> be.<span class="operator">*</span>,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> beauty be</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>
<p>练习</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、查询编号<span class="operator">&gt;</span><span class="number">3</span>的女神的男朋友信息，如果有则列出，没有用<span class="keyword">null</span>填充</span><br><span class="line"><span class="keyword">SELECT</span> be.id,be.name,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> beauty be</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">WHERE</span> be.id<span class="operator">&gt;</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、查询哪个城市没有部门</span><br><span class="line"><span class="keyword">SELECT</span> city,d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> locations l</span><br><span class="line"><span class="keyword">ON</span> d.`location_id`<span class="operator">=</span>l.`location_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、查询部门名为SAL或IT的员工信息</span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>,d.department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.`department_id`<span class="operator">=</span>e.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_name`<span class="keyword">IN</span> (<span class="string">&#x27;SAL&#x27;</span> , <span class="string">&#x27;IT&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="7-进阶七：子查询"><a href="#7-进阶七：子查询" class="headerlink" title="7. 进阶七：子查询"></a>7. 进阶七：子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">含义：出现在其他语句内部的<span class="keyword">select</span>语句，称为子查询或内查询</span><br><span class="line">外部的查询语句，称为主查询或外查询</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">按子查询出现的位置：</span><br><span class="line">	     <span class="keyword">select</span>后面：仅仅支持标量子查询</span><br><span class="line">	     <span class="keyword">from</span>后面：支持表子查询</span><br><span class="line">      ☆ <span class="keyword">where</span>或者<span class="keyword">having</span>后面：标量子查询，列子查询，行子查询</span><br><span class="line">	     <span class="keyword">exists</span>后面（相关子查询）：表子查询</span><br><span class="line">按结果集的行列数不同：</span><br><span class="line">	    标量子查询（结果集只有一行一列）</span><br><span class="line">		列子查询（结果集只有一列多行）</span><br><span class="line">		行子查询（结果集有一行多列）</span><br><span class="line">		表子查询（结果集一般为多行多列）</span><br></pre></td></tr></table></figure>
<p>（1）where或having后面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、标量子查询</span><br><span class="line">#<span class="number">2</span>、列子查询（多行子查询）</span><br><span class="line">#<span class="number">3</span>、行子查询（多行多列）</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">①子查询放在小括号内</span><br><span class="line">②子查询一般放在条件右侧</span><br><span class="line">③标量子查询，一般搭配单行操作符使用</span><br><span class="line"><span class="operator">&gt;</span> <span class="operator">&lt;</span> <span class="operator">&gt;=</span> <span class="operator">&lt;=</span> <span class="operator">=</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"></span><br><span class="line">列子查询一般搭配多行操作符使用</span><br><span class="line"><span class="keyword">IN</span><span class="operator">/</span><span class="keyword">NOT</span> <span class="keyword">IN</span>、<span class="keyword">ANY</span><span class="operator">/</span><span class="keyword">SOME</span>、<span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">④子查询的执行优先于主查询执行<span class="number">12345678910111213</span></span><br><span class="line">#<span class="number">1</span>、标量子查询</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：谁的工资比Abel高</span><br><span class="line"></span><br><span class="line">#①查询abel的工资</span><br><span class="line"><span class="keyword">SELECT</span> salary </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Abel&#x27;</span>;</span><br><span class="line">#②查询员工的信息，满足salary<span class="operator">&gt;</span>①的结果</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&gt;</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> salary </span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Abel&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：返回job_id与<span class="number">141</span>号员工相同，salary比<span class="number">143</span>号员工多的员工姓名，job_id和工资</span><br><span class="line"></span><br><span class="line">#①查询<span class="number">141</span>号员工的job_id</span><br><span class="line"><span class="keyword">SELECT</span> job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id<span class="operator">=</span><span class="number">141</span>;</span><br><span class="line"></span><br><span class="line">#②查询<span class="number">143</span>号员工的salary</span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id<span class="operator">=</span><span class="number">143</span>;</span><br><span class="line"></span><br><span class="line">#③员工的姓名，job_id,工资，要求job_id<span class="operator">=</span>①并且salary<span class="operator">&gt;</span>②</span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> job_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id<span class="operator">=</span><span class="number">141</span></span><br><span class="line">) <span class="keyword">AND</span> salary<span class="operator">&gt;</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id<span class="operator">=</span><span class="number">143</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例<span class="number">3</span>：返回公司工资最少的员工的last_name,job_id,salary</span><br><span class="line">#①查询公司的最低工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#②查询last_name,job_id</span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) </span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例<span class="number">4</span>：查询最低工资大于<span class="number">50</span>号部门的最低工资的部门id和其最低工资</span><br><span class="line">#①查询<span class="number">50</span>号部门的最低工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id<span class="operator">=</span><span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">#②查询每个部门的最低工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line">#③筛选②</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary)<span class="operator">&gt;</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> department_id<span class="operator">=</span><span class="number">50</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、列子查询（多行子查询）</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：返回location_id是<span class="number">1400</span>或<span class="number">1700</span>的部门中所有员工姓名</span><br><span class="line"></span><br><span class="line">#①查询location_id是<span class="number">1400</span>或<span class="number">1700</span>的部门编号</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span> location_id <span class="keyword">IN</span>(<span class="number">1400</span>,<span class="number">1700</span>);</span><br><span class="line"></span><br><span class="line">#②查询员工姓名要求部门号是①中的某个</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> location_id <span class="keyword">IN</span>(<span class="number">1400</span>,<span class="number">1700</span>)</span><br><span class="line">);#<span class="keyword">in</span>可以换成 <span class="operator">=</span><span class="keyword">ANY</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：返回其他工种中比job_id为‘IT_PROG<span class="string">&#x27;部门任一工资低的员工信息</span></span><br><span class="line"><span class="string">#用any相当于小于max工资</span></span><br><span class="line"><span class="string">SELECT employee_id,last_name,job_id,salary</span></span><br><span class="line"><span class="string">FROM employees</span></span><br><span class="line"><span class="string">WHERE salary&lt;ANY(</span></span><br><span class="line"><span class="string">	SELECT DISTINCT salary</span></span><br><span class="line"><span class="string">	FROM employees </span></span><br><span class="line"><span class="string">	WHERE job_id=&#x27;</span>IT_PROG<span class="string">&#x27;</span></span><br><span class="line"><span class="string">) AND job_id &lt;&gt; &#x27;</span>IT_PROG<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#案例3：返回其他工种中比job_id为‘IT_PROG&#x27;</span>部门所有工资低的员工信息</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&lt;</span><span class="keyword">ALL</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees </span><br><span class="line">	<span class="keyword">WHERE</span> job_id<span class="operator">=</span><span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> job_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;IT_PROG&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、行子查询（结果集是一行多列或多行多列）</span><br><span class="line"></span><br><span class="line">#案例：查询员工编号最小并且工资最高的员工信息</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(employee_id)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> salary<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (employee_id,salary)<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(employee_id),<span class="built_in">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（2）select后面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">仅支持标量子查询</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例<span class="number">1</span>：查询每个部门的员工个数</span><br><span class="line"><span class="keyword">SELECT</span> d.<span class="operator">*</span>,(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line">	<span class="keyword">FROM</span> employees e</span><br><span class="line">	<span class="keyword">WHERE</span> e.department_id<span class="operator">=</span>d.`department_id`</span><br><span class="line">)个数</span><br><span class="line"><span class="keyword">FROM</span> departments d;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询员工号<span class="operator">=</span><span class="number">102</span>的部门名</span><br><span class="line"><span class="keyword">SELECT</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> department_name</span><br><span class="line">	<span class="keyword">FROM</span> departments d</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line">	<span class="keyword">ON</span> d.department_id<span class="operator">=</span>e.department_id</span><br><span class="line">	<span class="keyword">WHERE</span> e.employee_id<span class="operator">=</span><span class="number">102</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（3）from后面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：查询每个部门的平均工资的工资等级</span><br><span class="line"></span><br><span class="line">#①查询每个部门的平均工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id；</span><br><span class="line"></span><br><span class="line">#②连接①的结果集和等级表，筛选条件 平均工资<span class="keyword">between</span>最低和最高</span><br><span class="line"><span class="keyword">SELECT</span> ag_dep.<span class="operator">*</span>,g.grade_level</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) ag_dep</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> ag_dep.ag <span class="keyword">BETWEEN</span> g.lowest_sal <span class="keyword">AND</span> g.highest_sal;</span><br></pre></td></tr></table></figure>
<p>（4）exists后面（相关子查询）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">exists完整的查询语句</span></span><br><span class="line"><span class="comment">结果：1或0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> employee_id <span class="keyword">FROM</span> employees);#结果为<span class="number">1</span>，表示存在</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：查询有员工的部门名</span><br><span class="line"><span class="keyword">SELECT</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">	<span class="keyword">FROM</span> employees e</span><br><span class="line">	<span class="keyword">WHERE</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询没有女朋友的男生信息</span><br><span class="line">#<span class="keyword">in</span></span><br><span class="line"><span class="keyword">SELECT</span> bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">WHERE</span> bo.id <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> boyfriend_id</span><br><span class="line">	<span class="keyword">FROM</span> beauty</span><br><span class="line">);</span><br><span class="line">#<span class="keyword">exists</span></span><br><span class="line"><span class="keyword">SELECT</span> bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> boyfriend_id</span><br><span class="line">	<span class="keyword">FROM</span> beauty be</span><br><span class="line">	<span class="keyword">WHERE</span> bo.`id`<span class="operator">=</span>be.`boyfriend_id`</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>相关练习</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span>查询和Zlotkey相同部门的员工姓名和工资</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Zlotkey&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、查询工资比公司平均工资高的员工的员工号，姓名，工资</span><br><span class="line"><span class="keyword">SELECT</span> last_name,employee_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&gt;</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、查询各部门中工资比本部门平均工资高的员工号，姓名，工资</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary,e.`department_id`</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">)avg_dep</span><br><span class="line"><span class="keyword">ON</span> e.`department_id`<span class="operator">=</span>avg_dep.department_id</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&gt;</span>avg_dep.ag;</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、查询，和姓名中包含字母u的员工在相同部门的员工，的员工号和姓名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,employees_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%u%&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#<span class="number">5</span>、查询在部门的location id为<span class="number">1700</span>的部门工作的员工的员工号</span><br><span class="line"><span class="keyword">SELECT</span> employee_id</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id<span class="operator">=</span><span class="keyword">ANY</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> location_id<span class="operator">=</span><span class="number">1700</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#<span class="number">6</span>、查询管理者是king的员工姓名和工资</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> employee_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;K_ing&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#<span class="number">7</span>、查询工资最高的员工的姓名，要求<span class="keyword">first</span>和last_name显示为一列，列名为姓名</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(first_name,last_name) &quot;姓名&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="8-进阶八：分页查询"><a href="#8-进阶八：分页查询" class="headerlink" title="8. 进阶八：分页查询"></a>8. 进阶八：分页查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">应用场景：当要显示的数据一页显示不全，需要分页提交<span class="keyword">sql</span>请求</span><br><span class="line">语法：</span><br><span class="line">		<span class="keyword">select</span> 查询列表</span><br><span class="line">		<span class="keyword">from</span> 表</span><br><span class="line">		【<span class="keyword">join</span> type <span class="keyword">join</span> 表<span class="number">2</span></span><br><span class="line">		<span class="keyword">where</span> 筛选条件</span><br><span class="line">		<span class="keyword">group</span> <span class="keyword">by</span> 分组字段</span><br><span class="line">		<span class="keyword">having</span> 分组后的筛选</span><br><span class="line">		<span class="keyword">order</span> <span class="keyword">by</span> 排序的字段】</span><br><span class="line">		limit <span class="keyword">offset</span>，size;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">offset</span>:要显示条目的起始索引，起始索引从<span class="number">0</span>开始</span><br><span class="line">		size：要显示的条目数</span><br><span class="line">特点：</span><br><span class="line">		①limit语句放在查询语句的最后</span><br><span class="line">		②公式</span><br><span class="line">		要显示的页数 page，每页的条目数size</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">select</span> 查询列表</span><br><span class="line">		<span class="keyword">from</span> 表</span><br><span class="line">		limit (page<span class="number">-1</span>)<span class="operator">*</span>size,size;<span class="number">1234567891011121314151617181920</span></span><br><span class="line">#案例<span class="number">1</span>：查询前五条员工信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询第<span class="number">11</span>条——第<span class="number">25</span>条</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">10</span>,<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">3</span>：有奖金的员工信息，并且工资较高的前<span class="number">10</span>名显示</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h1 id="DML数据操作语言"><a href="#DML数据操作语言" class="headerlink" title="DML数据操作语言"></a>DML数据操作语言</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#DML语言</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数据操作语言</span></span><br><span class="line"><span class="comment">插入：insert</span></span><br><span class="line"><span class="comment">修改：update</span></span><br><span class="line"><span class="comment">删除：delete</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="1、插入语句"><a href="#1、插入语句" class="headerlink" title="1、插入语句"></a>1、插入语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方式一：</span></span><br><span class="line"><span class="comment">insert into 表名(列名,...) values(值1，...);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#<span class="number">1</span>、插入的值的类型要与列的类型一致或兼容</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> beauty;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;1898888888&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、不可以为<span class="keyword">null</span>的列必须插入值，可以为<span class="keyword">null</span>的列如何插入值？</span><br><span class="line">#方式一：列名写上，值为<span class="keyword">null</span></span><br><span class="line">#方式二：列名省略，值省略</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,boyfriend_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">15</span>,<span class="string">&#x27;杨幂&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1986-9-12&#x27;</span>,<span class="string">&#x27;1898888888&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、列的顺序可以调换</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(NAME,sex,id,phone)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;蒋欣&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">16</span>,<span class="string">&#x27;110&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、列数和值的个数必须一致（以下错误）</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(NAME,sex,id,phone,boyfriend_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;蒋欣&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">16</span>,<span class="string">&#x27;110&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#<span class="number">5</span>、可以省略列名，默认是所有列，且顺序是表中列的顺序</span><br><span class="line"></span><br><span class="line">#方式二</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insert into 表名</span></span><br><span class="line"><span class="comment">set 列名=值，列名=值...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">SET</span> id<span class="operator">=</span><span class="number">17</span>,NAME<span class="operator">=</span><span class="string">&#x27;刘涛&#x27;</span>,phone<span class="operator">=</span><span class="string">&#x27;999&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>两种方式比较</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#两种方式比较</span><br><span class="line">#<span class="number">1</span>、方式一支持插入多行</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">&#x27;唐艺昕1&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;1898888888&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">18</span>,<span class="string">&#x27;唐艺昕2&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;1898888888&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">19</span>,<span class="string">&#x27;唐艺昕3&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;1898888888&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、方式一支持子查询，二不支持</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,phone)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">26</span>,<span class="string">&#x27;宋茜&#x27;</span>,<span class="string">&#x27;11809866&#x27;</span>;#把这个查询语句的结果集插入到beauty</span><br></pre></td></tr></table></figure>
<h2 id="2、修改语句"><a href="#2、修改语句" class="headerlink" title="2、修改语句"></a>2、修改语句</h2><h3 id="（1）修改单表的记录（主要）"><a href="#（1）修改单表的记录（主要）" class="headerlink" title="（1）修改单表的记录（主要）"></a>（1）修改单表的记录（主要）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>修改单表的记录☆</span><br><span class="line">语法：</span><br><span class="line"><span class="keyword">update</span> 表名</span><br><span class="line"><span class="keyword">set</span> 列<span class="operator">=</span>新值,列<span class="operator">=</span>新值,...</span><br><span class="line"><span class="keyword">where</span> 筛选条件;<span class="number">1234</span></span><br><span class="line">#案例<span class="number">1</span>、修改beauty表中姓唐的女生电话为<span class="number">138277777</span></span><br><span class="line"><span class="keyword">UPDATE</span> beauty <span class="keyword">SET</span> phone<span class="operator">=</span><span class="string">&#x27;138277777&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;唐%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：修改boys表中id号为<span class="number">2</span>的名称为张飞，魅力值为<span class="number">10</span></span><br><span class="line"><span class="keyword">UPDATE</span> boys <span class="keyword">SET</span> boyname<span class="operator">=</span><span class="string">&#x27;张飞&#x27;</span>,usercp<span class="operator">=</span><span class="number">10</span></span><br><span class="line"><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="（2）修改多表的记录"><a href="#（2）修改多表的记录" class="headerlink" title="（2）修改多表的记录"></a>（2）修改多表的记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、修改多表的记录【补充】</span><br><span class="line"><span class="keyword">update</span> 表<span class="number">1</span> 别名</span><br><span class="line"><span class="keyword">inner</span><span class="operator">/</span><span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">set</span> 列<span class="operator">=</span>值...</span><br><span class="line"><span class="keyword">where</span> 筛选条件;<span class="number">12345</span></span><br><span class="line">#案例<span class="number">1</span>：修改张无忌的女朋友的手机号为<span class="number">1123</span></span><br><span class="line"><span class="keyword">UPDATE</span> boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty be <span class="keyword">ON</span> bo.id<span class="operator">=</span>be.`boyfriend_id`</span><br><span class="line"><span class="keyword">SET</span> be.phone<span class="operator">=</span><span class="string">&#x27;1123&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.`boyName`<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：修改 没有男朋友的女神 的男朋友编号 都为张飞的编号</span><br><span class="line"><span class="keyword">UPDATE</span> boys bo</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty be <span class="keyword">ON</span> bo.id<span class="operator">=</span>be.`boyfriend_id`</span><br><span class="line"><span class="keyword">SET</span> be.boyfriend_id<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3、删除语句"><a href="#3、删除语句" class="headerlink" title="3、删除语句"></a>3、删除语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">方式一:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>单表的删除☆</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 筛选条件</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、多表的删除</span><br><span class="line"><span class="keyword">delete</span> 表<span class="number">1</span>的别名，表<span class="number">2</span>的别名</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名</span><br><span class="line"><span class="keyword">inner</span><span class="operator">/</span><span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> 别名 <span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">where</span> 筛选条件;</span><br><span class="line"></span><br><span class="line">方式二：<span class="keyword">truncate</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名<span class="number">123456789101112</span></span><br><span class="line">#方式一：<span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>、单表的删除</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：删除手机号以<span class="number">9</span>结尾的女生信息</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> beauty <span class="keyword">WHERE</span> phone <span class="keyword">LIKE</span> <span class="string">&#x27;%9&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、多表的删除</span><br><span class="line"></span><br><span class="line">#案例：删除张无忌的女朋友的信息</span><br><span class="line"><span class="keyword">DELETE</span> be</span><br><span class="line"><span class="keyword">FROM</span> beauty be</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> boys bo <span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">WHERE</span> bo.`boyName`<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#案例：删除黄晓明的信息，以及他女朋友的信息</span><br><span class="line"><span class="keyword">DELETE</span> be,bo</span><br><span class="line"><span class="keyword">FROM</span> beauty be</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> boys bo <span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">WHERE</span> bo.`boyName`<span class="operator">=</span><span class="string">&#x27;黄晓明&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#方式二：<span class="keyword">truncate</span>语句</span><br><span class="line">#案例：将魅力值<span class="operator">&gt;</span><span class="number">100</span>的男生信息删除</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> boys;</span><br></pre></td></tr></table></figure>
<p>delete和truncate区别【面试题】</p>
<p>1、delete可以加where条件，truncate不可以。<br>2、truncate删除，效率高一些。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br>3、假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始。<br>而truncate删除后，再插入数据，自增长列的值从1开始<br>4、truncate删除没有返回值，delete删除有返回值。<br>5、truncate删除不能回滚，delete删除可以回滚。</p>
<h1 id="DDL数据定义语言"><a href="#DDL数据定义语言" class="headerlink" title="DDL数据定义语言"></a>DDL数据定义语言</h1><h2 id="1、-库的管理"><a href="#1、-库的管理" class="headerlink" title="1、 库的管理"></a>1、 库的管理</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、库的创建</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">create database (if not exists) 库名; #如果不存在则创建</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#案例：创建库books</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> books;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、库的修改</span><br><span class="line">#不安全，基本不修改，要么删了重建</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE 库名；</span><br><span class="line">#修改库名直接去C盘的MySQL下的data文件夹改名</span><br><span class="line"></span><br><span class="line">#更改库的字符集</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE books <span class="type">CHARACTER</span> <span class="keyword">SET</span> gbk;</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、库的删除</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> books;</span><br></pre></td></tr></table></figure>
<h2 id="2、表的管理"><a href="#2、表的管理" class="headerlink" title="2、表的管理"></a>2、表的管理</h2><p>（1）表的创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">creat <span class="keyword">table</span> 表名(</span><br><span class="line">	列名 列的类型【（长度）约束】，</span><br><span class="line">	列名 列的类型【（长度）约束】，</span><br><span class="line">	列名 列的类型【（长度）约束】，</span><br><span class="line">	...</span><br><span class="line">	列名 列的类型【（长度）约束】，</span><br><span class="line">)<span class="number">123456</span></span><br><span class="line">#案例：创建表book</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">	id <span class="type">INT</span>,#编号</span><br><span class="line">	bName <span class="type">VARCHAR</span>(<span class="number">20</span>),#书名，最多<span class="number">20</span>个字符</span><br><span class="line">	price <span class="keyword">DOUBLE</span>,#价格</span><br><span class="line">	authorId <span class="type">INT</span>,#作者编号</span><br><span class="line">	publishDate DATETIME#出版日期</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line"><span class="keyword">DESC</span> book;#查看</span><br><span class="line"></span><br><span class="line">#案例：创建表author</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> author(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	au_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	nation <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">DESC</span> author;</span><br></pre></td></tr></table></figure>
<p>（2）表的修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">alter table 表名 add/drop/modify/change column 列名 【列类型 约束】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#①修改列名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book CHANGE <span class="keyword">COLUMN</span> publishDate pubDate DATETIME;</span><br><span class="line"></span><br><span class="line">#②修改列的类型或约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book MODIFY <span class="keyword">COLUMN</span> pubDate <span class="type">TIMESTAMP</span>;</span><br><span class="line"></span><br><span class="line">#③添加新列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> annual <span class="keyword">DOUBLE</span>;</span><br><span class="line"></span><br><span class="line">#④删除列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> annual;</span><br><span class="line"></span><br><span class="line">#⑤修改表名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author RENAME <span class="keyword">TO</span> book_author;</span><br></pre></td></tr></table></figure>
<p>（3）表的删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> book_author;</span><br><span class="line">#通用的写法</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> 旧表名;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名();<span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>（4）表的复制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> author <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;村上春树&#x27;</span>,<span class="string">&#x27;日本&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;莫言&#x27;</span>,<span class="string">&#x27;中国&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;冯唐&#x27;</span>,<span class="string">&#x27;中国&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">&#x27;金庸&#x27;</span>,<span class="string">&#x27;中国&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>、仅仅复制表的结构</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">copy</span> <span class="keyword">LIKE</span> author;#复制的表命名<span class="keyword">copy</span></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、复制表的结构<span class="operator">+</span>数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> author;</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、只复制部分数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy3</span><br><span class="line"><span class="keyword">SELECT</span> id,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> nation<span class="operator">=</span><span class="string">&#x27;中国&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、仅仅复制某些字段</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy4</span><br><span class="line"><span class="keyword">SELECT</span> id,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">0</span>;#只想要结构，不要数据，所以复制数据的条件恒不成立</span><br></pre></td></tr></table></figure>
<h2 id="3、常见的数据类型"><a href="#3、常见的数据类型" class="headerlink" title="3、常见的数据类型"></a>3、常见的数据类型</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#常见的数据类型</span><br><span class="line"></span><br><span class="line">数值型：</span><br><span class="line">			整型</span><br><span class="line">			小数（定点数，浮点数）</span><br><span class="line">字符型：</span><br><span class="line">			较短的文本：<span class="type">char</span>、<span class="type">varchar</span></span><br><span class="line">			较长的文本：text、<span class="type">blob</span>（较长的二进制数据）</span><br><span class="line">日期型</span><br></pre></td></tr></table></figure>
<h3 id="1-数值型"><a href="#1-数值型" class="headerlink" title="(1) 数值型"></a>(1) 数值型</h3><p>———-整数———-</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、整型</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">tinyint、smallint、mediumint、int/interger、bigint</span></span><br><span class="line"><span class="comment">   1         2          3           4          8</span></span><br><span class="line"><span class="comment"> 特点：</span></span><br><span class="line"><span class="comment"> ①如果不设置有符号还是无符号，默认是有符号，若想设置无符号，要加unsigned</span></span><br><span class="line"><span class="comment"> ②如果插入的数值超出整型范围，会报out of range异常，并插入临界值</span></span><br><span class="line"><span class="comment"> ③如果不设置长度，会有默认长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#如何设置有符号和无符号</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_int(</span><br><span class="line">	t1 <span class="type">INT</span>,  #有符号</span><br><span class="line">	t2 <span class="type">INT</span> UNSIGNED  #无符号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 长度</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_int(</span><br><span class="line">	t1 <span class="type">INT</span>(<span class="number">7</span>) ZEROFILL,  #有符号</span><br><span class="line">	t2 <span class="type">INT</span> UNSIGNED  #无符号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_int <span class="keyword">VALUES</span>(<span class="number">123</span>,<span class="number">123</span>);</span><br><span class="line">#第一个<span class="number">123</span>会在前面填充四个<span class="number">0</span>，并且加上填充是默认无符号</span><br></pre></td></tr></table></figure>
<p>———-小数———-</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">2</span>、小数</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">①浮点型</span></span><br><span class="line"><span class="comment">float(M,D)</span></span><br><span class="line"><span class="comment">double(M,D)</span></span><br><span class="line"><span class="comment">②定点型</span></span><br><span class="line"><span class="comment">dec(M,D)</span></span><br><span class="line"><span class="comment">decimal(M,D)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">①M：整数部位+小数部位 的长度</span></span><br><span class="line"><span class="comment"> D： 小数部位</span></span><br><span class="line"><span class="comment"> M和D都可以省略</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> ②M和D都可以省略</span></span><br><span class="line"><span class="comment"> 如果是decimal，默认M为10，D为0</span></span><br><span class="line"><span class="comment"> 而float和double会根据插入的数值的精度来决定精度</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> ③定点型的精确度较高，如果要求插入数值的精度较高，如货币运算等，则考虑使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#测试M和D</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tab_float;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_float(</span><br><span class="line">	f1 <span class="type">FLOAT</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">	f2 <span class="keyword">DOUBLE</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">	f3 <span class="type">DECIMAL</span>(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab_float;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_float <span class="keyword">VALUES</span>(<span class="number">123.45</span>,<span class="number">123.45</span>,<span class="number">123.45</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_float <span class="keyword">VALUES</span>(<span class="number">123.456</span>,<span class="number">123.456</span>,<span class="number">123.456</span>);#插入<span class="number">123.46</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_float <span class="keyword">VALUES</span>(<span class="number">1523.4</span>,<span class="number">1523.4</span>,<span class="number">1523.4</span>);#报错</span><br><span class="line"></span><br><span class="line">#原则：所选择的类型越简单越好，能保存数值的类型越小越好</span><br></pre></td></tr></table></figure>
<h3 id="2-字符型"><a href="#2-字符型" class="headerlink" title="(2) 字符型"></a>(2) 字符型</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">较短的文本：</span></span><br><span class="line"><span class="comment">char</span></span><br><span class="line"><span class="comment">varchar</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">较长的文本：</span></span><br><span class="line"><span class="comment">text</span></span><br><span class="line"><span class="comment">blob（较大的二进制）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特点:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	写法              M的意思	        特点	   空间的耗费    效率</span></span><br><span class="line"><span class="comment">char     char(M)	最大的字符数	  固定长度的字符    比较节省	     高</span></span><br><span class="line"><span class="comment">			   （char的M可以省略，默认为1）</span></span><br><span class="line"><span class="comment">varchar	  varchar(M)   最大的字符数       可变长度的字符     比较浪费	     低</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#enum：要求插入的值必须属于列表中指定的值之一，不区分大小写</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_char(</span><br><span class="line">	c1 ENUM(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;m&#x27;</span>);#插入失败</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab_char;#表中只有四项，abca</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="keyword">set</span>：和enum类似，和enum最大的区别是，<span class="keyword">set</span>类型一次可以选取多个成员，而enum只能选一个</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_set(</span><br><span class="line">	s1 <span class="keyword">SET</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;a,b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;a,b,c&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3）日期型"><a href="#3）日期型" class="headerlink" title="(3）日期型"></a>(3）日期型</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">date只保存日期</span></span><br><span class="line"><span class="comment">time只保存时间</span></span><br><span class="line"><span class="comment">year只保存年</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">datetime保存日期+时间</span></span><br><span class="line"><span class="comment">timestamp保存日期+时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">①datetime：字节8个，范围1000-9999年，不受时区影响</span></span><br><span class="line"><span class="comment">②timestamp：字节4个，范围1970-2038年，受时区影响</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 <span class="type">TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_date <span class="keyword">VALUES</span>(NOW(),NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab_date;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;time_zone&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="4、常见约束"><a href="#4、常见约束" class="headerlink" title="4、常见约束"></a>4、常见约束</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#常见约束</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段名 字段类型 列级约束</span><br><span class="line">	字段名 字段类型，</span><br><span class="line">	表级约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">含义：一种限制，用于限制表中的数据，为了保证表中数据的准确性和可靠性</span><br><span class="line"></span><br><span class="line">分类：六大约束</span><br><span class="line">	<span class="keyword">not</span> <span class="keyword">null</span>:非空，用于保证该字段的值不能为空。比如姓名、学号等</span><br><span class="line">	<span class="keyword">default</span>：默认，用于保证该字段有默认值。比如性别</span><br><span class="line">	<span class="keyword">primary</span> <span class="keyword">key</span>：主键，用于保证该字段的值有唯一性，并且非空。比如学号</span><br><span class="line">	<span class="keyword">unique</span>：唯一，保证该字段的值有唯一性，可以为空。比如座位号</span><br><span class="line">	<span class="keyword">check</span>：检查约束【mysql不支持】，比如年龄性别</span><br><span class="line">	<span class="keyword">foreign</span> <span class="keyword">key</span>：外键，用于限制两个表的关系，保证该字段值必须来自于主表关联列的值</span><br><span class="line">		    在从表添加外键约束，用于引用主表中某列的值</span><br><span class="line">		    比如：员工表的部门编号、工种号</span><br><span class="line"></span><br><span class="line">添加约束的时间：</span><br><span class="line">	<span class="number">1</span>、创建表时</span><br><span class="line">	<span class="number">2</span>、修改表时</span><br><span class="line">约束的添加分类：</span><br><span class="line">	<span class="number">1</span>、列级约束：六大约束语法上都支持，但外键约束没有效果</span><br><span class="line">	<span class="number">2</span>、表级约束：除了非空、默认约束，其他都支持</span><br></pre></td></tr></table></figure>
<h3 id="（1）创建表时添加约束"><a href="#（1）创建表时添加约束" class="headerlink" title="（1）创建表时添加约束"></a>（1）创建表时添加约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、添加列级约束</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法：直接在字段名和字段类型后面追加约束类型即可</span></span><br><span class="line"><span class="comment">只支持：默认、非空、主键、唯一</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一个列可以添加多个列级约束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE students;</span><br><span class="line">USE students;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,#主键</span><br><span class="line">	stuName <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,#非空</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">OR</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),#检查，不过mysql没用</span><br><span class="line">	seat <span class="type">INT</span> <span class="keyword">UNIQUE</span>,#唯一</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>, #默认约束</span><br><span class="line">	majorId <span class="type">INT</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> major(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">	majorName <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">DESC</span> stuinfo;</span><br><span class="line">#查看表中所有的索引，包括主键，外键，唯一</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> stuinfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、添加表级约束</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法：在各个字段的最下面</span></span><br><span class="line"><span class="comment">【constraint 约束名】 约束类型(字段名)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> stuinfo;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	stuname <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	seat <span class="type">INT</span>,</span><br><span class="line">	age <span class="type">INT</span>,</span><br><span class="line">	majorid <span class="type">INT</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> pk <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>(id),#主键</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> uq <span class="keyword">UNIQUE</span>(seat),#唯一</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> ck <span class="keyword">CHECK</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">OR</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),#检查</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(id)	</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> stuinfo;</span><br><span class="line"></span><br><span class="line">#通用的写法：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuinfo(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">	stuname <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>,</span><br><span class="line">	seat <span class="type">INT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">	majorid <span class="type">INT</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> major <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;java&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> major <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;h5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;john&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">19</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;lily&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">19</span>,<span class="number">2</span>);#错误，重复了</span><br></pre></td></tr></table></figure>

<p>主键和唯一的对比<br>1、主键和唯一都能保证唯一性。但主键不允许为空，唯一允许。<br>2、一个表中最多只能有一个主键，而唯一键可以有多个。如果写成primary key(id,stuname)是联合主键的效果，要两个同时重复才会报错。<br>3、主键和唯一都允许组合使用，但不推荐。</p>
<p>外键<br>1、要求从表设置成外键关系<br>2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>3、主表的关联列必须是一个key（一般是主键、唯一）<br>4、插入数据时，必须先插入主表，再插入从表；删除时先删除从表，再删除主表（例子中，主表是major）</p>
<p>列级约束和表级约束<br>1、列级约束：位置—列的后面。支持的约束类型：语法都支持，但外键没有效果<br>2、表级约束：位置—所有列的下面。支持的约束类型：默认和为空除外<br>3、是否可以起约束名：列级约束不可以，表级约束可以（但是对主键起名无效）</p>
<h3 id="（2）修改表时添加约束"><a href="#（2）修改表时添加约束" class="headerlink" title="（2）修改表时添加约束"></a>（2）修改表时添加约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、添加列级约束</span></span><br><span class="line"><span class="comment">alter table 表名 modify column 字段名 字段类型 新约束;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、添加表级约束</span></span><br><span class="line"><span class="comment">alter table 表名 add 【constraint 约束名】 约束类型（字段名）;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> stuinfo;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	stuname <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	seat <span class="type">INT</span>,</span><br><span class="line">	age <span class="type">INT</span>,</span><br><span class="line">	majorid <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">DESC</span> stuinfo;</span><br><span class="line">#<span class="number">1</span>、添加非空约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> stuname <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、添加默认约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、添加主键（记一种就行）</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> id <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>;#列级约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>(id);#表级约束</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、添加唯一</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> seat <span class="type">INT</span> <span class="keyword">UNIQUE</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">5</span>、添加外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(id);</span><br></pre></td></tr></table></figure>
<h3 id="（3）修改表时删除约束"><a href="#（3）修改表时删除约束" class="headerlink" title="（3）修改表时删除约束"></a>（3）修改表时删除约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、删除非空约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> stuname <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、删除默认约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> age <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、删除主键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、删除唯一</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> INDEX seat;</span><br><span class="line"></span><br><span class="line">#<span class="number">5</span>、删除外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span>  KEY fk_stuinfo_major;</span><br></pre></td></tr></table></figure>
<h2 id="5、-标识列"><a href="#5、-标识列" class="headerlink" title="5、 标识列"></a>5、 标识列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">又称为自增长列</span></span><br><span class="line"><span class="comment">含义：可以不用手动插入值，系统提供默认的序列值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特点：</span></span><br><span class="line"><span class="comment">1、标识列必须和主键搭配吗？不一定，但要求是一个key（主键外键唯一）</span></span><br><span class="line"><span class="comment">2、一个表中只可以有至多一个标识列</span></span><br><span class="line"><span class="comment">3、标识列的类型只能是数值型</span></span><br><span class="line"><span class="comment">4、标识列可以通过SET auto_increment_increment设置步长，也可以通过手动插入值设置起始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>、创建表时设置标识列</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tab_identity;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_identity(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> AUTO_INCREMENT,#自动增长</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> tab_identity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_identity <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;john&#x27;</span>);#执行几次就会插入几次，会自动编号<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>..</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab_identity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%auto_increment%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> auto_increment_increment<span class="operator">=</span><span class="number">3</span>;#把自增长的步长改为<span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、修改表时设置标识列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_identity MODIFY <span class="keyword">COLUMN</span> id <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> AUTO_INCREMENT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、修改表时删除标识列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_identity MODIFY <span class="keyword">COLUMN</span> id <span class="type">INT</span>;</span><br></pre></td></tr></table></figure>
<h1 id="TCL事务控制语言"><a href="#TCL事务控制语言" class="headerlink" title="TCL事务控制语言"></a>TCL事务控制语言</h1><p>Transaction Control Language 事务控制语言</p>
<p>事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。如果单元中某条sql语句一旦执行失败或产生错误，整个单元将会回滚。<br>（回滚：把操作撤销，回到最初状态）</p>
<p>存储引擎：在mysql中的数据用各种不同的技术存储在文件（或内存）中，通过show engines查看。（如，InnoDB，MyISAM，MEMORY）不是所有的存储引擎都支持事务，其中Innodb支持事务，MyISAM,MEMORY不支持。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">事务的创建</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、隐式事务：事务没有明显的开启和结束的标记</span></span><br><span class="line"><span class="comment">比如insert、update、delete语句</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">delete from 表 where id=1；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、显式事务：事务具有明显的开启和结束的标记</span></span><br><span class="line"><span class="comment">前提：必须先设置自动提交功能为禁用</span></span><br><span class="line"><span class="comment">SHOW VARIABLES LIKE &#x27;%autocommit%&#x27;;</span></span><br><span class="line"><span class="comment">set autocommit=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">步骤1：开启事务</span></span><br><span class="line"><span class="comment">set autocommit=0;</span></span><br><span class="line"><span class="comment">start transaction;#可选的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">步骤2：编写事务中的sql语句(select,insert,update,delete增删改查，不包括create，drop这些)</span></span><br><span class="line"><span class="comment">语句1;</span></span><br><span class="line"><span class="comment">语句2;</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">步骤3：结束事务</span></span><br><span class="line"><span class="comment">commit;提交事务</span></span><br><span class="line"><span class="comment">rollback;回滚事务</span></span><br><span class="line"><span class="comment">save point 节点名;#设置保存点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">	username <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	balance <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(username,balance)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;张无忌&#x27;</span>,<span class="number">1000</span>),(<span class="string">&#x27;赵敏&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">#演示事务的使用步骤</span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">#编写一组事务的语句</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span><span class="number">500</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span><span class="number">1500</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;赵敏&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#结束事务</span><br><span class="line">#<span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;#把<span class="number">500</span>,<span class="number">1500</span>改成<span class="number">1000</span>,<span class="number">1000</span>，执行回滚，发现还是<span class="number">500</span>,<span class="number">1500</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"></span><br><span class="line">#演示<span class="keyword">savepoint</span>的使用</span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> a;#设置保存点</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> a;#回滚到保存点</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;#<span class="number">1</span>号删了，<span class="number">2</span>号没删</span><br></pre></td></tr></table></figure>
<h2 id="1、-事务的ACID属性"><a href="#1、-事务的ACID属性" class="headerlink" title="1、 事务的ACID属性"></a>1、 事务的ACID属性</h2><p>（1）原子性 (A)</p>
<p>事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>（2）一致性（C）</p>
<p>事务必须使数据库从一个一致性状态变换到另一个一致性状态</p>
<p>（3）隔离性（I）</p>
<p>一个事务的执行不能被其他事物干扰，即一个事务内部的操作以及使用的数据对并发的其他事物是隔离的，并发执行的各个事务之间不能互相干扰</p>
<p>（4）持久性（D）</p>
<p>一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p>
<p>事务的并发问题：<br>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取有必要的隔离机制，会导致各种并发问题。</p>
<ul>
<li>脏读：对于两个事务T1,T2，T1读取了已经被T2更新但还没有被提交的字段，之后，若T2回滚，T1读取的内容就是临时且无效的</li>
<li>不可重复读：对于两个事物t1，t2，t1读取了一个字段，然后t2更新了该字段，之后，t1再次读取同一个字段，值就不同了</li>
<li>幻读：对于两个事务t1，t2，t1从一个表中读取了一个字段，然后t2在该表中插入了一些新的行。之后，如果t1再次读取同一个表，就会多出几行（和脏读有点相似，但脏读一般是针对更新，幻读针对插入、删除）</li>
</ul>
<p>通过设置事务的隔离级别来避免这些现象<br>四种事务隔离级别</p>
<ul>
<li>READ UNCOMMITTED（读未提交数据）：允许事务读取未被其他事物提交的变更，脏读、不可重复读和幻读的问题都会出现</li>
<li>READ COMMITED（读已提交数据）:只允许事务读取已经被其他事务提交的变更。可以避免脏读，但不可避免不可重复读和幻读。</li>
<li>REPEATABLE READ（可重复读）：确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事物对这个字段进行更新。可以避免脏读和不可重复读，但存在幻读。</li>
<li>SERIALIZABLE（串行化）：确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表进行插入、更新和删除，所有并发问题都可以避免，但性能低下。</li>
</ul>
<p>mysql中默认第三个隔离级别 repeatable read；<br>oracle中默认第二个隔离级别 read committed；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看当前隔离级别</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"></span><br><span class="line">#设置当前连接的隔离级别</span><br><span class="line"><span class="keyword">set</span> transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">#设置数据库系统全局的隔离级别</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br></pre></td></tr></table></figure>
<h2 id="2、delete和truncate在事务使用时的区别"><a href="#2、delete和truncate在事务使用时的区别" class="headerlink" title="2、delete和truncate在事务使用时的区别"></a>2、delete和truncate在事务使用时的区别</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#演示<span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;#回滚成功</span><br><span class="line"></span><br><span class="line">#演示<span class="keyword">truncate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> account;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;#没有回滚，实际删除了</span><br></pre></td></tr></table></figure>


<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ul>
<li>重用sql语句</li>
<li>简化复杂的sql操作，不必知道他的查询细节</li>
<li>保护数据，提高安全性</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">含义：虚拟表，和普通表一样使用</span></span><br><span class="line"><span class="comment">是通过表动态生成的数据，只保存sql逻辑，不保存查询结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">视图：create view，只是保存了sql逻辑，语法允许增删改查（一般不能增删改，只用来查）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">表：create table，保存了数据，增删改查</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例：查询姓张的学生名和专业名</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> stuname,majorName</span><br><span class="line"><span class="keyword">FROM</span> stuinfo s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> major m <span class="keyword">ON</span> s.`majorid`<span class="operator">=</span>m.`id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v1 <span class="keyword">WHERE</span> stuname <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="1、创建视图"><a href="#1、创建视图" class="headerlink" title="1、创建视图"></a>1、创建视图</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#一、创建视图</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法：</span></span><br><span class="line"><span class="comment">creat view 视图名</span></span><br><span class="line"><span class="comment">as</span></span><br><span class="line"><span class="comment">查询语句;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>、查询姓名中包含a字符的员工名、部门名、工种信息</span><br><span class="line">#创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id<span class="operator">=</span>d.department_id</span><br><span class="line"><span class="keyword">JOIN</span> jobs j <span class="keyword">ON</span> j.job_id<span class="operator">=</span>e.job_id;</span><br><span class="line">#使用</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv1 <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、查询各部门的平均工资级别</span><br><span class="line"></span><br><span class="line">#创建视图查看每个部门平均工资</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) ag,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> myv2;</span><br><span class="line"></span><br><span class="line">#使用</span><br><span class="line"><span class="keyword">SELECT</span> myv2.`ag`,g.grade_level</span><br><span class="line"><span class="keyword">FROM</span> myv2</span><br><span class="line"><span class="keyword">JOIN</span> job_grades g <span class="keyword">ON</span> myv2.`ag` <span class="keyword">BETWEEN</span> g.`lowest_sal` <span class="keyword">AND</span> g.`highest_sal`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、查询平均最低的工资信息</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> ag LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、查询平均工资最低的部门名和工资</span><br><span class="line"><span class="keyword">CREATE</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> ag LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2、修改视图"><a href="#2、修改视图" class="headerlink" title="2、修改视图"></a>2、修改视图</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式一</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">create or replace view 视图名</span></span><br><span class="line"><span class="comment">as</span></span><br><span class="line"><span class="comment">查询语句; #存在则修改，不存在则创建</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id;</span><br><span class="line"></span><br><span class="line">#方式二</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">alter view 视图名</span></span><br><span class="line"><span class="comment">as</span></span><br><span class="line"><span class="comment">查询语句;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<h2 id="3、删除和查看视图"><a href="#3、删除和查看视图" class="headerlink" title="3、删除和查看视图"></a>3、删除和查看视图</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#删除</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> myv1,myv2,myv3;</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line"><span class="keyword">DESC</span> myv3;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv3;</span><br></pre></td></tr></table></figure>
<h2 id="4、视图的更新"><a href="#4、视图的更新" class="headerlink" title="4、视图的更新"></a>4、视图的更新</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE  <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,email</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv1;</span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>、插入</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> myv1 <span class="keyword">VALUES</span>(<span class="string">&#x27;张飞&#x27;</span>,<span class="string">&#x27;zf@qq.com&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees;#也插入了张飞</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、修改</span><br><span class="line"><span class="keyword">UPDATE</span> myv1 <span class="keyword">SET</span> last_name<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span> <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、删除</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> myv1 <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>具备以下特点的视图不能更新</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、包含以下关键字的<span class="keyword">sql</span>语句：分组函数、<span class="keyword">distinct</span>、<span class="keyword">group</span> <span class="keyword">by</span>、<span class="keyword">having</span>、<span class="keyword">union</span>或者<span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) m,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv1;</span><br><span class="line"></span><br><span class="line">#更新(错误)</span><br><span class="line"><span class="keyword">UPDATE</span> myv1 <span class="keyword">SET</span> m<span class="operator">=</span><span class="number">9000</span> <span class="keyword">WHERE</span> department_id<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、常量视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> myv2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;john&#x27;</span> NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv2;</span><br><span class="line"></span><br><span class="line">#更新（错误）</span><br><span class="line"><span class="keyword">UPDATE</span> myv2 <span class="keyword">SET</span> NAME<span class="operator">=</span><span class="string">&#x27;lucy&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、<span class="keyword">select</span>中包含子查询</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees) 最高工资</span><br><span class="line">#更新，错误</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv3;</span><br><span class="line"><span class="keyword">UPDATE</span> myv3 <span class="keyword">SET</span> 最高工资<span class="operator">=</span><span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、<span class="keyword">join</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> myv4</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.department_id<span class="operator">=</span>d.department_id;</span><br><span class="line"></span><br><span class="line">#更新（可以）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv4;</span><br><span class="line"><span class="keyword">UPDATE</span> myv4 <span class="keyword">SET</span> last_name<span class="operator">=</span><span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;whalen&#x27;</span>;</span><br><span class="line">#插入（报错）</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> myv4 <span class="keyword">VALUES</span>(<span class="string">&#x27;陈真&#x27;</span>,<span class="string">&#x27;xxxx&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">5</span>、<span class="keyword">from</span>一个不能更新的视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> myv5</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv3;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> myv5 <span class="keyword">SET</span> 最高工资<span class="operator">=</span><span class="number">10000</span> <span class="keyword">WHERE</span> department_id<span class="operator">=</span><span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">6</span>、<span class="keyword">where</span>子句的子查询引用了<span class="keyword">from</span>子句中的表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> myv6</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,email,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> manager_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myv6;</span><br><span class="line"></span><br><span class="line">#更新（错误）</span><br><span class="line"><span class="keyword">UPDATE</span> myv6 <span class="keyword">SET</span> salary<span class="operator">=</span><span class="number">10000</span> <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;K_ing&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>总结：基本上复杂的语句都不允许更新</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>系统变量：全局变量，会话变量</p>
<p>自定义变量：用户变量，局部变量</p>
<h2 id="1、系统变量"><a href="#1、系统变量" class="headerlink" title="1、系统变量"></a>1、系统变量</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#一、系统变量:</span><br><span class="line"><span class="comment">/*变量由系统提供，不是用户定义，属于服务器层面</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用的语法：</span></span><br><span class="line"><span class="comment">1、查看所有的系统变量</span></span><br><span class="line"><span class="comment">show global variables;</span></span><br><span class="line"><span class="comment">show 【session】 variables;#会话变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、查看满足条件的部分系统变量</span></span><br><span class="line"><span class="comment">show global variables like %character%&#x27;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、查看指定的某个系统变量</span></span><br><span class="line"><span class="comment">select @@global.系统变量名;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、为某个系统变量赋值</span></span><br><span class="line"><span class="comment">方式一：</span></span><br><span class="line"><span class="comment">set global 系统变量名=值;</span></span><br><span class="line"><span class="comment">方式二：</span></span><br><span class="line"><span class="comment">set @@global.系统变量名=值;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#会话变量可以将global替换成session，如果是全局级别要加global，不写默认session</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="（1）全局变量"><a href="#（1）全局变量" class="headerlink" title="（1）全局变量"></a>（1）全局变量</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用域：服务器每次启动将为所有全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启</span></span><br><span class="line"><span class="comment">(服务器重启后修改后的就没用)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"># ①查看所有的全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line"></span><br><span class="line"># ②查看部分的全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%char%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># ③查看指定全局变量</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.autocommit;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"></span><br><span class="line"># ④为某个指定的全局变量赋值</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.autocommit<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="（2）会话变量"><a href="#（2）会话变量" class="headerlink" title="（2）会话变量"></a>（2）会话变量</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用域：仅仅针对于当前会话（连接）有效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#①查看所有的会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line">#②查看部分的会话变量</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%char%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#③查看指定的会话变量</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.transaction_isolation;</span><br><span class="line"></span><br><span class="line">#④为某个会话变量赋值</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.transaction_isolation<span class="operator">=</span><span class="string">&#x27;read-uncommitted&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> SESSION transaction_isolation<span class="operator">=</span><span class="string">&#x27;read-committed&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2、自定义变量"><a href="#2、自定义变量" class="headerlink" title="2、自定义变量"></a>2、自定义变量</h2><h3 id="（1）用户变量"><a href="#（1）用户变量" class="headerlink" title="（1）用户变量"></a>（1）用户变量</h3><p>作用域：针对当前会话有效，和会话变量的作用域相同<br>赋值操作符：=或:=</p>
<p>必须加@</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、声明并初始化</span><br><span class="line"><span class="keyword">SET</span> @用户变量名<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量名:<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量名:<span class="operator">=</span>值;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、赋值（更新）</span><br><span class="line">#方式一：<span class="keyword">set</span>或<span class="keyword">select</span>（和初始化一样）</span><br><span class="line">	<span class="keyword">SET</span> @用户变量名<span class="operator">=</span>值;</span><br><span class="line">	<span class="keyword">SET</span> @用户变量名:<span class="operator">=</span>值;</span><br><span class="line">	<span class="keyword">SELECT</span> @用户变量名:<span class="operator">=</span>值;</span><br><span class="line">#方式二：<span class="keyword">select</span> <span class="keyword">into</span></span><br><span class="line">	<span class="keyword">SELECT</span> 字段 <span class="keyword">INTO</span> @变量名</span><br><span class="line">	<span class="keyword">FROM</span> 表</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> <span class="variable">@count</span> </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、使用（查看用户变量）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@count</span>;</span><br></pre></td></tr></table></figure>
<h3 id="（2）局部变量"><a href="#（2）局部变量" class="headerlink" title="（2）局部变量"></a>（2）局部变量</h3><p>仅仅在定义它的begin end中有效，应用在begin end中的第一句话</p>
<p>需要限定类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、声明</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> 变量名 类型;</span><br><span class="line"><span class="keyword">DECLARE</span> 变量名 类型 <span class="keyword">DEFAULT</span> 值;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、赋值</span><br><span class="line"></span><br><span class="line">#方式一：<span class="keyword">set</span>或<span class="keyword">select</span>（和初始化一样）</span><br><span class="line">	<span class="keyword">SET</span> 局部变量名<span class="operator">=</span>值;</span><br><span class="line">	<span class="keyword">SET</span> 局部变量名:<span class="operator">=</span>值;</span><br><span class="line">	<span class="keyword">SELECT</span> @局部变量名:<span class="operator">=</span>值;</span><br><span class="line">#方式二：<span class="keyword">select</span> <span class="keyword">into</span>局部</span><br><span class="line">	<span class="keyword">SELECT</span> 字段 <span class="keyword">INTO</span> 变量名</span><br><span class="line">	<span class="keyword">FROM</span> 表;</span><br><span class="line">	</span><br><span class="line">#<span class="number">3</span>、使用</span><br><span class="line"><span class="keyword">SELECT</span> 局部变量名;</span><br></pre></td></tr></table></figure>
<p>用户变量和局部变量案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：申明两个变量并赋值，求和，并打印</span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>、用户变量</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@m</span><span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@n</span><span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@sum</span><span class="operator">=</span><span class="variable">@m</span><span class="operator">+</span><span class="variable">@n</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@sum</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、局部变量</span><br><span class="line"><span class="keyword">DECLARE</span> m <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> n <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> SUM <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> SUM<span class="operator">=</span>m<span class="operator">+</span>n;</span><br><span class="line"><span class="keyword">SELECT</span> SUM;</span><br><span class="line">#报错</span><br></pre></td></tr></table></figure>
<h1 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h1><h2 id="1、存储过程"><a href="#1、存储过程" class="headerlink" title="1、存储过程"></a>1、存储过程</h2><p>含义：<br>一组预先编译好的sql语句的集合，理解成批处理语句</p>
<p>好处：<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数，并且减少了和数据库服务器的连接次数，提高了效率</p>
<h3 id="（1）存储过程的创建"><a href="#（1）存储过程的创建" class="headerlink" title="（1）存储过程的创建"></a>（1）存储过程的创建</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#一、创建语法</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(参数列表)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	存储过程体（一组合法的<span class="keyword">SQL</span>语句）</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"><span class="number">1</span>、参数列表包含三部分</span><br><span class="line">参数模式 参数名 参数类型</span><br><span class="line">举例：</span><br><span class="line"><span class="keyword">IN</span> stuname <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">参数模式：</span><br><span class="line"><span class="keyword">IN</span>:该参数可以作为输入，即需要调用方传入值</span><br><span class="line"><span class="keyword">OUT</span>:参数可以作为输出，即可以作为返回值</span><br><span class="line"><span class="keyword">INOUT</span>:该参数既可以作为输入又可以作为输出，也就是既需要传入值，又可以返回值</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果存储过程体只有一句话, <span class="keyword">BEGIN</span> <span class="keyword">END</span> 可以省略</span><br><span class="line">存储过程体中每条<span class="keyword">sql</span>语句结尾必须加分号</span><br><span class="line">存储过程的结尾可以使用 DELIMITER 重新设置</span><br><span class="line">语法：</span><br><span class="line">DELIMITER 结束标记</span><br><span class="line">例如：</span><br><span class="line">DELIMITER $</span><br><span class="line">#二、调用语法</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> 存储过程名(实参列表);</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、空参列表(要在窗口中运行，sqlyog没用)</span><br><span class="line">#案例：插入到admin表中<span class="number">5</span>条记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> admin;</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp1()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> admin(username,PASSWORD) </span><br><span class="line">	<span class="keyword">VALUES</span>(<span class="string">&#x27;john1&#x27;</span>,<span class="string">&#x27;000&#x27;</span>),(<span class="string">&#x27;lily&#x27;</span>,<span class="string">&#x27;000&#x27;</span>),(<span class="string">&#x27;rose&#x27;</span>,<span class="string">&#x27;000&#x27;</span>),(<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;000&#x27;</span>),(<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;000&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line"><span class="keyword">CALL</span> myp1() $</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> admin$</span><br><span class="line">#<span class="number">2</span>、创建带<span class="keyword">in</span>模式参数的存储过程</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：创建存储过程实现 根据女生名查询对应的男生信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp2(<span class="keyword">IN</span> beautyName <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> bo.<span class="operator">*</span></span><br><span class="line">	<span class="keyword">FROM</span> boys bo</span><br><span class="line">	<span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty be <span class="keyword">ON</span> bo.id<span class="operator">=</span>be.boyfriend_id</span><br><span class="line">	<span class="keyword">WHERE</span> be.name<span class="operator">=</span>beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> NAMES gbk$</span><br><span class="line"><span class="keyword">CALL</span> myp2(<span class="string">&#x27;周芷若&#x27;</span>) $</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：创建存储过程，实现用户是否登陆成功</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp4(<span class="keyword">IN</span> username <span class="type">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">IN</span> PASSWORD <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> res <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;#声明并初始化</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> res #赋值</span><br><span class="line">	<span class="keyword">FROM</span> admin</span><br><span class="line">	<span class="keyword">WHERE</span> admin.username<span class="operator">=</span>username</span><br><span class="line">	<span class="keyword">AND</span> admin.password<span class="operator">=</span>PASSWORD;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">SELECT</span> IF(res<span class="operator">&gt;</span><span class="number">0</span>,<span class="string">&#x27;成功&#x27;</span>,<span class="string">&#x27;失败&#x27;</span>);#使用</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line"><span class="keyword">CALL</span> myp4(<span class="string">&#x27;张飞&#x27;</span>,<span class="string">&#x27;888&#x27;</span>)$</span><br><span class="line">#<span class="number">3</span>、创建带<span class="keyword">out</span>模式的存储过程</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：根据女生名返回对应的男生名</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp5(<span class="keyword">IN</span> beautyName <span class="type">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> boyName <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> bo.boyName <span class="keyword">INTO</span> boyName</span><br><span class="line">	<span class="keyword">FROM</span> boys bo</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty be <span class="keyword">ON</span> be.boyfriend_id<span class="operator">=</span>bo.id</span><br><span class="line">	<span class="keyword">WHERE</span> be.name<span class="operator">=</span>beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">#调用</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@bName</span>$</span><br><span class="line"><span class="keyword">CALL</span> myp5(<span class="string">&#x27;小昭&#x27;</span>,<span class="variable">@bName</span>)$</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@bName</span>$</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：根据女生名，返回对应的男生名和魅力值</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp6(<span class="keyword">IN</span> beautyName <span class="type">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> boyName <span class="type">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> userCP <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> bo.boyName,bo.userCP <span class="keyword">INTO</span> boyName,userCP</span><br><span class="line">	<span class="keyword">FROM</span> boys bo</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty be <span class="keyword">ON</span> be.boyfriend_id<span class="operator">=</span>bo.id</span><br><span class="line">	<span class="keyword">WHERE</span> be.name<span class="operator">=</span>beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">#调用</span><br><span class="line"><span class="keyword">CALL</span> myp6(<span class="string">&#x27;小昭&#x27;</span>,<span class="variable">@bName</span>,<span class="variable">@usercp</span>)$</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@bName</span>,<span class="variable">@usercp</span>$</span><br><span class="line">#<span class="number">4</span>、创建带<span class="keyword">in</span>，<span class="keyword">out</span>模式参数的存储过程</span><br><span class="line">#案例<span class="number">1</span>：传入a和b两个值，最终a和b都翻倍并返回</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp7(<span class="keyword">INOUT</span> a <span class="type">INT</span>,<span class="keyword">INOUT</span> b <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SET</span> a<span class="operator">=</span>a<span class="operator">*</span><span class="number">2</span>;</span><br><span class="line">	<span class="keyword">SET</span> b<span class="operator">=</span>b<span class="operator">*</span><span class="number">2</span>;	</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@m</span><span class="operator">=</span><span class="number">10</span>$</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@n</span><span class="operator">=</span><span class="number">20</span>$</span><br><span class="line"><span class="keyword">CALL</span> myp7(<span class="variable">@m</span>,<span class="variable">@n</span>)$</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@m</span>,<span class="variable">@n</span>$</span><br></pre></td></tr></table></figure>
<h3 id="（2）存储过程的删除、查看"><a href="#（2）存储过程的删除、查看" class="headerlink" title="（2）存储过程的删除、查看"></a>（2）存储过程的删除、查看</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#删除存储过程</span><br><span class="line">#语法 <span class="keyword">drop</span> <span class="keyword">procedure</span> 存储过程名</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> myp1;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> myp1,myp2;#错误</span><br><span class="line"></span><br><span class="line">#查看存储过程的信息</span><br><span class="line"><span class="keyword">DESC</span> myp2;#错误</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp2;</span><br></pre></td></tr></table></figure>
<h2 id="2、函数"><a href="#2、函数" class="headerlink" title="2、函数"></a>2、函数</h2><ul>
<li>与存储过程的区别<br>  （1）存储过程可以有0个返回，也可以有多个，函数只能有1个返回（0个也不行，多个也不行）<br>  （2）存储过程适合做批量插入、批量更新；函数适合做处理数据后返回一个结果</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#一、创建语法</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数列表) <span class="keyword">RETURNS</span> 返回类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	函数体</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">1、参数列表包含两部分-----参数名 参数类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、函数体：肯定会有return语句，如果没有会报错</span></span><br><span class="line"><span class="comment">如果return语句没有放在函数体最后也不报错，但不建议</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return 值;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、当函数体只有一句话可以省略begin，end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、使用delimiter语句设置结束标记</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#二、调用语法</span><br><span class="line"><span class="keyword">SELECT</span> 函数名(参数列表)</span><br></pre></td></tr></table></figure>
<p>案例演示—————————————–</p>
<h2 id="（1）创建、调用函数"><a href="#（1）创建、调用函数" class="headerlink" title="（1）创建、调用函数"></a>（1）创建、调用函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、无参有返回</span><br><span class="line">#案例：返回公司员工的个数</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;#不加这句下面的可能会报错</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf1() <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> c <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;#定义变量</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> c #赋值</span><br><span class="line">	<span class="keyword">FROM</span> employees;</span><br><span class="line">	<span class="keyword">RETURN</span> c;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf1()$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、有参有返回</span><br><span class="line">#案例<span class="number">1</span>：根据员工名返回它的工资</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf2(empName <span class="type">VARCHAR</span>(<span class="number">20</span>)) <span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SET</span> <span class="variable">@sal</span><span class="operator">=</span><span class="number">0</span>;#定义用户变量</span><br><span class="line">	<span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> <span class="variable">@sal</span>  #赋值</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name<span class="operator">=</span>empName;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">RETURN</span> <span class="variable">@sal</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf2(<span class="string">&#x27;kochhar&#x27;</span>) $</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：根据部门名，返回该部门平均工资</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf3(deptName <span class="type">VARCHAR</span>(<span class="number">20</span>)) <span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> sal <span class="keyword">DOUBLE</span>; #局部变量</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> sal</span><br><span class="line">	<span class="keyword">FROM</span> employees e</span><br><span class="line">	<span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id<span class="operator">=</span>d.department_id</span><br><span class="line">	<span class="keyword">WHERE</span> d.department_name<span class="operator">=</span>deptName;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">RETURN</span> sal;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf3(<span class="string">&#x27;IT&#x27;</span>) </span><br></pre></td></tr></table></figure>
<h2 id="（2）查看和删除"><a href="#（2）查看和删除" class="headerlink" title="（2）查看和删除"></a>（2）查看和删除</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看函数</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf3;</span><br><span class="line">#删除</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> myf3;</span><br><span class="line"></span><br><span class="line">#创建函数，实现传入两个<span class="type">float</span>，返回二者之和</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> test_fun1(num1 <span class="type">FLOAT</span>,num2 <span class="type">FLOAT</span>) <span class="keyword">RETURNS</span> <span class="type">FLOAT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> SUM <span class="type">FLOAT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> SUM<span class="operator">=</span>num1<span class="operator">+</span>num2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">RETURN</span> SUM;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> test_fun1(<span class="number">1</span>,<span class="number">2</span>) </span><br></pre></td></tr></table></figure>
<h1 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h1><ul>
<li>顺序结构：程序从上往下依次执行</li>
<li>分支结构：程序从两条或多条路径中选择一条去执行</li>
<li>循环结构：程序在满足一定条件的基础上重复执行一段代码</li>
</ul>
<h2 id="1、分支结构"><a href="#1、分支结构" class="headerlink" title="1、分支结构"></a>1、分支结构</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、if函数</span><br><span class="line">功能：实现简单的双分支</span><br><span class="line"><span class="keyword">SELECT</span> IF(表达式<span class="number">1</span>,表达式<span class="number">2</span>,表达式<span class="number">3</span>)</span><br><span class="line">执行顺序：</span><br><span class="line">如果表达式成立，则if函数返回表达式<span class="number">2</span>的值，否则返回表达式<span class="number">3</span>的值</span><br><span class="line"></span><br><span class="line">应用：任何地方</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、<span class="keyword">case</span>结构</span><br><span class="line"></span><br><span class="line">情况<span class="number">1</span>：类似于java中的switch语句，一般用于实现的等值判断</span><br><span class="line">语法：</span><br><span class="line">	<span class="keyword">CASE</span> 变量<span class="operator">|</span>表达式<span class="operator">|</span>字段</span><br><span class="line">	<span class="keyword">WHEN</span> 要判断的值 <span class="keyword">THEN</span> 返回的值<span class="number">1</span>或语句<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">WHEN</span> 要判断的值 <span class="keyword">THEN</span> 返回的值<span class="number">2</span>或语句<span class="number">2</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">ELSE</span> 要返回的值n或语句n;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">情况<span class="number">2</span>：类似于就java中的多重if，一般用于实现区间判断</span><br><span class="line">语法：</span><br><span class="line">	<span class="keyword">CASE</span> </span><br><span class="line">	<span class="keyword">WHEN</span> 要判断的值 <span class="keyword">THEN</span> 返回的值<span class="number">1</span>或语句<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">WHEN</span> 要判断的值 <span class="keyword">THEN</span> 返回的值<span class="number">2</span>或语句<span class="number">2</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">ELSE</span> 要返回的值n或语句n;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"><span class="number">1</span>、既可以作为表达式，嵌套在其他语句中使用，可以放在任何地方</span><br><span class="line">也可以作为独立的语句使用，只能放在 <span class="keyword">BEGIN</span> <span class="keyword">END</span> 中</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果 <span class="keyword">WHEN</span> 中的值或条件成立，则执行对应的 <span class="keyword">THEN</span> 后面的语句，并且结束 <span class="keyword">CASE</span></span><br><span class="line">如果都不满足，则执行 <span class="keyword">ELSE</span> 中的语句或值</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、 <span class="keyword">ELSE</span> 可以省略，如果省略了，并且所有的 <span class="keyword">WHEN</span> 都不满足，则返回 <span class="keyword">NULL</span></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637</span></span><br><span class="line">#案例</span><br><span class="line">#创建存储过程，根据传入的成绩，来显示等级，比如传入<span class="number">90</span><span class="number">-100</span>分显示A</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_case(<span class="keyword">IN</span> score <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">CASE</span> </span><br><span class="line">	<span class="keyword">WHEN</span> score<span class="operator">&gt;=</span><span class="number">90</span> <span class="keyword">AND</span> score<span class="operator">&lt;=</span><span class="number">100</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	<span class="keyword">WHEN</span> score<span class="operator">&gt;=</span><span class="number">80</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	<span class="keyword">WHEN</span> score<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">	<span class="keyword">ELSE</span> <span class="keyword">SELECT</span> <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_case(<span class="number">95</span>)$<span class="number">12345678910111213</span></span><br><span class="line">#<span class="number">3</span>、if结构</span><br><span class="line">功能：实现多重分支</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">IF 条件<span class="number">1</span> <span class="keyword">THEN</span> 语句<span class="number">1</span>;</span><br><span class="line">ELSEIF 条件<span class="number">2</span> <span class="keyword">THEN</span> 语句<span class="number">2</span>;</span><br><span class="line">...</span><br><span class="line">【<span class="keyword">else</span> 语句n;】</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"> </span><br><span class="line">应用场合：只能用在 <span class="keyword">BEGIN</span> <span class="keyword">END</span> 中</span><br><span class="line"></span><br><span class="line">#案例<span class="number">1</span>：根据传入的成绩，来返回等级，比如传入<span class="number">90</span><span class="number">-100</span>分返回A</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> test_if(score <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">CHAR</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	IF score<span class="operator">&gt;=</span><span class="number">90</span> <span class="keyword">AND</span> score<span class="operator">&lt;=</span><span class="number">100</span> <span class="keyword">THEN</span> <span class="keyword">RETURN</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	ELSEIF score<span class="operator">&gt;=</span><span class="number">80</span> <span class="keyword">THEN</span> <span class="keyword">RETURN</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	ELSEIF score<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">THEN</span> <span class="keyword">RETURN</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	<span class="keyword">ELSE</span> <span class="keyword">RETURN</span> <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> test_if(<span class="number">86</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2、循环结构"><a href="#2、循环结构" class="headerlink" title="2、循环结构"></a>2、循环结构</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">while、loop、repeat</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">循环控制：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">iterate类似于continue，结束本次循环</span></span><br><span class="line"><span class="comment">leave类似于break，跳出循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>、while</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">【标签:】while 循环条件 do</span><br><span class="line">	循环体;</span><br><span class="line"><span class="keyword">end</span> while 【标签】;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、loop</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">【标签：】loop</span><br><span class="line">	循环体</span><br><span class="line"><span class="keyword">end</span> loop 【标签】;</span><br><span class="line"></span><br><span class="line">可以用来模拟简单的死循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、repeat</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">【标签:】 repeat</span><br><span class="line">	循环体;</span><br><span class="line">until 结束循环的条件</span><br><span class="line"><span class="keyword">end</span> repeat【标签】;</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、没有添加循环控制语句</span><br><span class="line"></span><br><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_while1(<span class="keyword">IN</span> insertCount <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">	WHILE i<span class="operator">&lt;=</span>insertCount DO</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> admin(username,PASSWORD) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;rose&#x27;</span>,i),<span class="string">&#x27;666&#x27;</span>);</span><br><span class="line">		<span class="keyword">SET</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> pro_while1(<span class="number">10</span>)$</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、添加leave语句</span><br><span class="line"></span><br><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，如果次数<span class="operator">&gt;</span><span class="number">20</span>则停止</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> admin$</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> test_while1$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_while1(<span class="keyword">IN</span> insertCount <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">	a:WHILE i<span class="operator">&lt;=</span>insertCount DO</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> admin(username,PASSWORD) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;xiaohua&#x27;</span>,i),<span class="string">&#x27;000&#x27;</span>);</span><br><span class="line">		IF i<span class="operator">&gt;=</span><span class="number">20</span> <span class="keyword">THEN</span> LEAVE a;</span><br><span class="line">		<span class="keyword">END</span> IF;</span><br><span class="line">		<span class="keyword">SET</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE a; </span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_while1(<span class="number">21</span>)$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、添加iterate语句</span><br><span class="line"></span><br><span class="line">#案例：批量插入，根据次数插入admin中多条记录，只插入偶数次</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> admin$</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> test_while1$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_while1(<span class="keyword">IN</span> insertCount <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	a:WHILE i<span class="operator">&lt;=</span>insertCount DO</span><br><span class="line">		<span class="keyword">SET</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">		IF <span class="built_in">MOD</span>(i,<span class="number">2</span>)<span class="operator">!=</span><span class="number">0</span> <span class="keyword">THEN</span> ITERATE a;</span><br><span class="line">		<span class="keyword">END</span> IF;</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> admin(username,PASSWORD) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;xiaohua&#x27;</span>,i),<span class="string">&#x27;000&#x27;</span>);	</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">END</span> WHILE a; </span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_while1(<span class="number">21</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3、经典案例"><a href="#3、经典案例" class="headerlink" title="3、经典案例"></a>3、经典案例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">已知表stringcontent</span></span><br><span class="line"><span class="comment">其中字段：</span></span><br><span class="line"><span class="comment">id：自增长</span></span><br><span class="line"><span class="comment">content varchar(20)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">向该表插入指定个数的，随机的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stringcontent(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">	content <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_randstr_insert(<span class="keyword">IN</span> insertCount <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>; #定义一个循环变量来表示插入的次数</span><br><span class="line">	<span class="keyword">DECLARE</span> str <span class="type">VARCHAR</span>(<span class="number">26</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> startIndex <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;#代表起始索引</span><br><span class="line">	<span class="keyword">DECLARE</span> len <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;#代表截取字符串的长度</span><br><span class="line">	WHILE i<span class="operator">&lt;=</span>insertCount DO		</span><br><span class="line">		<span class="keyword">SET</span> len<span class="operator">=</span><span class="built_in">FLOOR</span>(RAND()<span class="operator">*</span>(<span class="number">20</span><span class="operator">-</span>startIndex<span class="operator">+</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>);</span><br><span class="line">		<span class="keyword">SET</span> startIndex<span class="operator">=</span><span class="built_in">FLOOR</span>(RAND()<span class="operator">*</span><span class="number">26</span><span class="operator">+</span><span class="number">1</span>);#产生一个随机整数<span class="number">1</span><span class="number">-26</span></span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> stringcontent(content) <span class="keyword">VALUES</span>(SUBSTR(str,startIndex,len));</span><br><span class="line">		<span class="keyword">SET</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>; #循环变量更新</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_randstr_insert(<span class="number">6</span>)$</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
</search>
